#########################
Running start QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:26:08.089816
##########################

Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Let c_1, c_2, ¡­, c_n be a permutation of integers 1, 2, ¡­, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments.

Cirno is studying mathematics, and the teacher asks her to count the number of permutations of length n with exactly k good numbers.

Unfortunately, Cirno isn't good at mathematics, and she can't answer this question. Therefore, she asks you for help.

Since the answer may be very big, you only need to tell her the number of permutations modulo p.

A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains four integers n, m, k, p (1 ¡Ü n ¡Ü 100, 1 ¡Ü m ¡Ü n, 1 ¡Ü k ¡Ü n, 1 ¡Ü p ¡Ü 10^9).

Output

Output the number of permutations modulo p.

Examples

Input


4 3 2 10007


Output


4


Input


6 4 1 769626776


Output


472


Input


66 11 9 786747482


Output


206331312


Input


99 30 18 650457567


Output


77365367

Note

In the first test case, there are four permutations: [1, 3, 2, 4], [2, 3, 1, 4], [4, 1, 3, 2] and [4, 2, 3, 1].

Take permutation [1, 3, 2, 4] as an example:

For number 1, all subsegments containing it are: [1], [1, 3], [1, 3, 2] and [1, 3, 2, 4], and there're three different maxima 1, 3 and 4.

Similarly, for number 3, there're two different maxima 3 and 4. For number 2, there're three different maxima 2, 3 and 4. And for number 4, there're only one, that is 4 itself.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Core Concepts and Algorithms

The problem involves counting permutations of length \( n \) where exactly \( k \) numbers are "good". A number \( x \) is considered good if there are exactly \( m \) different maximum values among all subsegments containing \( x \). 

To solve this, we need to understand how to determine when a number \( x \) is good and then count the permutations accordingly. The key concept here is the **inversion** in combinatorics, which helps in understanding the relative positions of elements in a permutation.

### Tutorial on Inversions

An inversion in a sequence is a pair of indices \( i < j \) such that \( a_i > a_j \). Understanding inversions is crucial because they help in determining how a number contributes to being the maximum in subsegments.

#### Example:

Consider the sequence \( [1, 3, 2, 4] \):

- For \( x = 1 \):
  - Subsegments: `[1]`, `[1, 3]`, `[1, 3, 2]`, `[1, 3, 2, 4]`
  - Maximums: `1`, `3`, `3`, `4`
  - Unique maximums: `{1, 3, 4}`

Here, there are 3 unique maximums, so \( x = 1 \) is not good.

- For \( x = 3 \):
  - Subsegments: `[3]`, `[3, 2]`, `[3, 2, 4]`
  - Maximums: `3`, `3`, `4`
  - Unique maximums: `{3, 4}`
  
Here, there are 2 unique maximums, so \( x = 3 \) is good.

### Relevant Example Problems

1. **Problem:** [Number of Inversions]
   - **Description:** Count the number of inversions in an array.
   - **Solution:** Use merge sort to count inversions efficiently.

2. **Problem:** [Permutations with Exactly K Good Numbers]
   - **Description:** Similar to the original problem but simpler constraints.
   - **Solution:** Use dynamic programming and combinatorial techniques.

3. **Problem:** [Counting Permutations by Inversions]
   - **Description:** Given an array, count how many permutations have exactly \( k \) inversions.
   - **Solution:** Use dynamic programming and prefix sums.

### Python3 Code to Solve the Original Problem

```python
from math import factorial
from functools import reduce

def modinv(a, m):
    return pow(a, m - 2, m)

def binomial(n, k, p):
    num = reduce(lambda x, y: x * y % p, range(n - k + 1, n + 1), 1)
    den = reduce(lambda x, y: x * y % p, range(1, k + 1), 1)
    return num * modinv(den, p) % p

def count_good_permutations(n, m, k, p):
    def count_k_inversions(k, n, p):
        if k == 0:
            return 1
        return (factorial(n) * modinv(binomial(n, k, p), p)) % p

    good_count = 0
    for i in range(m, min(m + k, n + 1)):
        good_count += count_k_inversions(i, n, p)
        good_count %= p

    return good_count

# Read input
import sys
input = sys.stdin.read
data = input().split()

n = int(data[0])
m = int(data[1])
k = int(data[2])
p = int(data[3])

# Output result
print(count_good_permutations(n, m, k, p))
```

### Explanation of the Solution

1. **Modular Inverse (`modinv`)**: Computes the modular inverse using Fermat's Little Theorem.
2. **Binomial Coefficient (`binomial`)**: Computes the binomial coefficient modulo \( p \).
3. **Count Inversions (`count_k_inversions`)**: Counts the number of permutations with exactly \( k \) inversions.
4. **Main Function (`count_good_permutations`)**: Iterates over possible values of \( k \) to compute the total number of good permutations.

This code reads the input, computes the result using the defined functions, and prints the final answer. The constraints are handled efficiently using modular arithmetic and dynamic programming principles.
completed 1/21, Solved: False, number of success = 0/1, acc = 0.0
An error occurred: 'gbk' codec can't encode character '\u22c5' in position 1148: illegal multibyte sequence
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ¡Ü t ¡Ü 1000) ¡ª the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ¡Ü a, b, c ¡Ü 10^9) ¡ª the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Core Concepts and Algorithms

The problem requires us to distribute songs of different durations into two concerts such that the absolute difference in their total durations is minimized. This involves understanding basic arithmetic operations and greedy algorithms.

#### Key Points:
1. **Total Duration Calculation**: First, calculate the total duration of all songs.
2. **Target Duration**: The target for each concert should be half of the total duration if possible, as this minimizes the difference.
3. **Greedy Approach**: Use a greedy approach to distribute songs starting with the longest duration (three-minute songs), followed by the next longest (two-minute songs), and finally the shortest (one-minute songs).

### Tutorial on Greedy Algorithms

A **greedy algorithm** makes locally optimal choices at each step with the hope of finding a global optimum. In the context of this problem:

1. **Calculate Total Duration**: Sum up the total duration of all songs (`total_duration = a * 1 + b * 2 + c * 3`).
2. **Target Duration**: Set the target duration for each concert as `target_duration = total_duration // 2`.
3. **Distribute Songs**:
    - Start by assigning three-minute songs to the first concert until reaching or exceeding the target duration.
    - Assign two-minute songs similarly.
    - Assign one-minute songs until the target duration is reached or exceeded.

By distributing the longer songs first, we ensure that we balance the total duration more effectively.

### Example Problems

#### Problem 1: Minimize Difference Between Two Sets
Given an array of integers, partition it into two subsets such that the absolute difference between the sums of the subsets is minimized.

**Solution**:
1. Calculate the total sum of the array.
2. Use dynamic programming to find the closest subset sum to half of the total sum.

```python
def min_partition_difference(arr):
    total_sum = sum(arr)
    n = len(arr)
    dp = [False] * (total_sum // 2 + 1)
    dp[0] = True
    
    for num in arr:
        for j in range(total_sum // 2, num - 1, -1):
            dp[j] = dp[j] or dp[j - num]
    
    closest_sum = max([i for i in range(total_sum // 2 + 1) if dp[i]])
    return abs(total_sum - 2 * closest_sum)
```

#### Problem 2: Maximum Number of Non-overlapping Events
Given an array of events where each event is represented as a pair `[start_time, end_time]`, find the maximum number of non-overlapping events that can be attended.

**Solution**:
1. Sort events by their end times.
2. Use a greedy approach to select events that do not overlap with previously selected events.

```python
def max_non_overlapping_events(events):
    events.sort(key=lambda x: x[1])
    count = 0
    last_end = float('-inf')
    
    for start, end in events:
        if start >= last_end:
            count += 1
            last_end = end
    
    return count
```

#### Problem 3: Minimum Cost to Connect Cities
Given a list of cities and roads connecting them, where each road has a cost, determine the minimum cost to connect all cities using the minimum spanning tree (MST).

**Solution**:
1. Use Kruskal's algorithm to build the MST by sorting edges by cost and adding them to the MST while ensuring no cycles are formed.

```python
def find(parent, i):
    if parent[i] == i:
        return i
    parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent, rank, x, y):
    rootX = find(parent, x)
    rootY = find(parent, y)
    
    if rank[rootX] > rank[rootY]:
        parent[rootY] = rootX
    elif rank[rootX] < rank[rootY]:
        parent[rootX] = rootY
    else:
        parent[rootY] = rootX
        rank[rootX] += 1

def min_cost_to_connect_cities(n, roads):
    parent = list(range(n))
    rank = [0] * n
    roads.sort(key=lambda x: x[2])
    
    mst_cost = 0
    for u, v, weight in roads:
        if find(parent, u) != find(parent, v):
            union(parent, rank, u, v)
            mst_cost += weight
    
    return mst_cost
```

### Python3 Code to Solve the Original Problem

#### Solution Explanation:
1. Calculate the total duration of all songs.
2. Use a greedy approach to distribute songs starting with three-minute songs, then two-minute songs, and finally one-minute songs.
3. Track the durations of both concerts and compute the absolute difference.

```python
def min_concert_difference(a, b, c):
    total_duration = a * 1 + b * 2 + c * 3
    target_duration = total_duration // 2
    concert1_duration = 0
    concert2_duration = 0
    
    # Distribute three-minute songs
    while c > 0:
        concert1_duration += 3
        c -= 1
        if concert1_duration >= target_duration:
            break
    
    # Distribute remaining songs
    while b > 0:
        concert1_duration += 2
        b -= 1
        if concert1_duration >= target_duration:
            break
    
    while a > 0:
        concert1_duration += 1
        a -= 1
        if concert1_duration >= target_duration:
            break
    
    concert2_duration = total_duration - concert1_duration
    
    return abs(concert1_duration - concert2_duration)

# Read input
import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
results = []

index = 1
for _ in range(t):
    a = int(data[index])
    b = int(data[index + 1])
    c = int(data[index + 2])
    index += 3
    results.append(min_concert_difference(a, b, c))

# Output results
for result in results:
    print(result)
```

This code reads the number of test cases and processes each test case according to the described logic, ensuring the minimal possible difference in concert durations is calculated and printed for each case.
completed 8/21, Solved: False, number of success = 0/8, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
A bow adorned with nameless flowers that bears the earnest hopes of an equally nameless person.

You have obtained the elegant bow known as the Windblume Ode. Inscribed in the weapon is an array of n (n ¡Ý 3) positive distinct integers (i.e. different, no duplicates are allowed).

Find the largest subset (i.e. having the maximum number of elements) of this array such that its sum is a composite number. A positive integer x is called composite if there exists a positive integer y such that 1 < y < x and x is divisible by y.

If there are multiple subsets with this largest size with the composite sum, you can output any of them. It can be proven that under the constraints of the problem such a non-empty subset always exists.

Input

Each test consists of multiple test cases. The first line contains the number of test cases t (1 ¡Ü t ¡Ü 100). Description of the test cases follows.

The first line of each test case contains an integer n (3 ¡Ü n ¡Ü 100) ¡ª the length of the array.

The second line of each test case contains n distinct integers a_{1},a_{2},...,a_{n} (1 ¡Ü a_{i} ¡Ü 200) ¡ª the elements of the array.

Output

Each test case should have two lines of output.

The first line should contain a single integer x: the size of the largest subset with composite sum. The next line should contain x space separated integers representing the indices of the subset of the initial array.

Example

Input


4
3
8 1 2
4
6 9 4 2
9
1 2 3 4 5 6 7 8 9
3
200 199 198


Output


2
2 1
4
2 1 4 3
9
6 9 1 2 3 4 5 7 8
3
1 2 3 

Note

In the first test case, the subset \\{a_2, a_1\} has a sum of 9, which is a composite number. The only subset of size 3 has a prime sum equal to 11. Note that you could also have selected the subset \\{a_1, a_3\} with sum 8 + 2 = 10, which is composite as it's divisible by 2.

In the second test case, the sum of all elements equals to 21, which is a composite number. Here we simply take the whole array as our subset.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Core Concepts and Algorithms:
To solve this problem, we need to find the largest subset of an array whose sum is a composite number. Here are the key steps involved:

1. **Subset Generation**: We need to generate all possible subsets of the given array. Since the maximum size of the array \( n \) is 100, the total number of subsets is \( 2^n \), which is feasible for small values of \( n \).
   
2. **Sum Calculation**: For each subset, calculate the sum of its elements.
   
3. **Composite Number Check**: Determine if the sum of each subset is a composite number. A number is composite if it has at least one divisor other than 1 and itself.
   
4. **Finding the Largest Composite Sum Subset**: Track the subset with the maximum number of elements that has a composite sum.

### Tutorial on Generating Subsets and Finding Composites:
#### Generating Subsets:
We can use bit manipulation to generate all subsets. For an array of length \( n \), each element can either be included or excluded in a subset, represented by a binary number from 0 to \( 2^n - 1 \).

#### Checking for Composite Numbers:
A number \( x \) is composite if it has divisors between 2 and \( \sqrt{x} \). To check this efficiently, we can iterate from 2 up to \( \lfloor \sqrt{x} \rfloor \) and see if \( x \) is divisible by any of these numbers.

### Example Problems:
Here are three example problems involving similar concepts:

1. **Subarray Product Less Than K**:
   - **Problem**: Given an array and a number \( k \), find the size of the largest subarray where the product of all elements is less than \( k \).
   - **Solution**: Use sliding window technique to maintain a valid window and check the product condition.
   - **Code**:
     ```python
     def max_subarray_product(arr, k):
         left = right = product = result = 0
         while right < len(arr):
             product *= arr[right]
             while product >= k and left <= right:
                 product /= arr[left]
                 left += 1
             result = max(result, right - left + 1)
             right += 1
         return result
     ```

2. **Maximum Sum Subarray**:
   - **Problem**: Given an array, find the contiguous subarray with the largest sum.
   - **Solution**: Use Kadane's algorithm to keep track of the current sum and the maximum sum found so far.
   - **Code**:
     ```python
     def max_sum_subarray(arr):
         max_current = max_global = arr[0]
         for num in arr[1:]:
             max_current = max(num, max_current + num)
             if max_current > max_global:
                 max_global = max_current
         return max_global
     ```

3. **Counting Divisors**:
   - **Problem**: Given an array, count the number of elements that have exactly \( d \) divisors.
   - **Solution**: Iterate through each element and count its divisors using a nested loop or efficient factorization techniques.
   - **Code**:
     ```python
     def count_divisors(n):
         count = 0
         i = 1
         while i * i <= n:
             if n % i == 0:
                 if i * i == n:
                     count += 1
                 else:
                     count += 2
             i += 1
         return count
     ```

### Python3 Code to Solve the Original Problem:
```python
import sys
from math import sqrt

def is_composite(x):
    if x < 4:
        return False
    for i in range(2, int(sqrt(x)) + 1):
        if x % i == 0:
            return True
    return False

def largest_subset_with_composite_sum(n, arr):
    max_size = 0
    best_subset = []
    
    # Generate all subsets using bit manipulation
    for mask in range(1 << n):
        subset_sum = 0
        subset_indices = []
        for i in range(n):
            if mask & (1 << i):
                subset_sum += arr[i]
                subset_indices.append(i + 1)
        
        if is_composite(subset_sum):
            if len(subset_indices) > max_size:
                max_size = len(subset_indices)
                best_subset = subset_indices
    
    print(max_size)
    print(' '.join(map(str, best_subset)))

# Read input from stdin
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1

for _ in range(t):
    n = int(data[index])
    index += 1
    arr = list(map(int, data[index:index+n]))
    index += n
    
    largest_subset_with_composite_sum(n, arr)
```

### Explanation of the Solution:
1. **is_composite Function**: Checks if a number is composite by iterating up to its square root.
2. **largest_subset_with_composite_sum Function**: Generates all subsets using bit manipulation, calculates their sums, and checks if they are composite. Keeps track of the largest subset found.
3. **Reading Input**: Reads input from standard input and processes each test case accordingly.
completed 16/21, Solved: False, number of success = 0/16, acc = 0.0
#########################
Running end QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:27:40.766385
##########################

