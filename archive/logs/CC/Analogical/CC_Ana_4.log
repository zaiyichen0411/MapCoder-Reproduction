#########################
Running start QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:26:08.102957
##########################

An error occurred: 'gbk' codec can't encode character '\u22c5' in position 1378: illegal multibyte sequence
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
You are given an array A of length N weights of masses A_1, A_2...A_N. No two weights have the same mass. You can put every weight on one side of the balance (left or right). You don't have to put weights in order A_1,...,A_N. There is also a string S consisting of characters "L" and "R", meaning that after putting the i-th weight (not A_i, but i-th weight of your choice) left or right side of the balance should be heavier. Find the order of putting the weights on the balance such that rules of string S are satisfied. 

Input

The first line contains one integer N (1 ¡Ü N ¡Ü 2*10^5) - the length of the array A The second line contains N distinct integers: A_1, A_2,...,A_N (1 ¡Ü A_i ¡Ü 10^9) - the weights given The third line contains string S of length N consisting only of letters "L" and "R" - string determining which side of the balance should be heavier after putting the i-th weight of your choice

Output

The output contains N lines. In every line, you should print one integer and one letter - integer representing the weight you are putting on the balance in that move and the letter representing the side of the balance where you are putting the weight. If there is no solution, print -1.

Example

Input


5
3 8 2 13 7
LLRLL


Output


3 L
2 R
8 R
13 L
7 L

Note

Explanation for the test case: 

after the 1st weight: 3 L (left side is heavier)

after the 2nd weight: 2 R (left side is heavier)

after the 3rd weight: 8 R (right side is heavier)

after the 4th weight: 13 L (left side is heavier)

after the 5th weight: 7 L (left side is heavier)

So, the rules given by string S are fulfilled and our order of putting the weights is correct.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Algorithms:
To solve this problem, we need to ensure that the balance's state matches the sequence specified by the string `S`. We can achieve this using a greedy approach with two heaps (priority queues): one for weights on the left side (`left_heap`) and one for weights on the right side (`right_heap`). We maintain the sum of weights on both sides and update them as we place each weight according to the requirements of `S`.

### Tutorial:
#### Priority Queues:
Priority queues are data structures that allow efficient access to the smallest (or largest) element in the set. They are implemented using binary heaps, providing O(log n) time complexity for insertions and deletions.

#### Greedy Algorithm:
A greedy algorithm makes the locally optimal choice at each step with the hope that these choices will lead to a global optimum. Here, we make the choice that ensures the current state of the balance matches the requirement at each step.

### Example Problems:
1. **Median Maintenance**: Given a stream of numbers, find the median after each insertion.
   - **Solution**: Use two heaps (a max heap and a min heap) to keep track of the lower and upper halves of the data stream.
   
2. **Task Scheduler**: Schedule tasks based on their execution times and priorities.
   - **Solution**: Use a priority queue to always execute the task with the shortest remaining time next.
   
3. **Maximum Profit Job Scheduling**: Given jobs with start and end times and profits, schedule the maximum number of non-overlapping jobs.
   - **Solution**: Sort jobs by their end times and use a priority queue to select the most profitable job that does not conflict with previously selected jobs.

### Python3 Code to Solve the Original Problem:
```python
import heapq
import sys

def solve(N, A, S):
    # Heaps to store weights on the left and right sides of the balance
    left_heap = []
    right_heap = []
    
    # Sum of weights on the left and right sides
    left_sum = 0
    right_sum = 0
    
    # Process each weight according to the requirements of S
    for i in range(N):
        if S[i] == 'L':
            # Place the weight on the left side
            heapq.heappush(left_heap, -A[i])
            left_sum += A[i]
        else:
            # Place the weight on the right side
            heapq.heappush(right_heap, A[i])
            right_sum += A[i]
        
        # Ensure the balance is maintained
        while left_sum < right_sum:
            # Move the heaviest weight from right to left
            transfer_weight = heapq.heappop(right_heap)
            right_sum -= transfer_weight
            left_sum += transfer_weight
            heapq.heappush(left_heap, -transfer_weight)
        
        while left_sum > right_sum:
            # Move the lightest weight from left to right
            transfer_weight = -heapq.heappop(left_heap)
            left_sum -= transfer_weight
            right_sum += transfer_weight
            heapq.heappush(right_heap, transfer_weight)
        
        # Output the result for the current weight
        if S[i] == 'L':
            print(f"{A[i]} L")
        else:
            print(f"{A[i]} R")

# Read input from standard input
input = sys.stdin.read
data = input().split()
N = int(data[0])
A = list(map(int, data[1:N+1]))
S = data[N+1]

# Solve the problem
solve(N, A, S)
```

### Explanation of the Solution:
1. **Heaps Initialization**: Two heaps (`left_heap` and `right_heap`) are initialized to store weights on the left and right sides of the balance.
2. **Processing Each Weight**: For each weight, we determine whether to place it on the left or right side based on the character in `S`.
3. **Maintaining Balance**: After placing each weight, we check if the balance needs to be adjusted. If the left side is lighter than the right side, we move the heaviest weight from the right side to the left side. Conversely, if the left side is heavier, we move the lightest weight from the left side to the right side.
4. **Output Result**: For each weight, we print the weight and its corresponding side ('L' for left, 'R' for right).

This solution ensures that the balance's state matches the sequence specified by `S`, and it handles the constraints efficiently.
completed 3/21, Solved: False, number of success = 0/3, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Alice and Bob are playing a game. They are given an array A of length N. The array consists of integers. They are building a sequence together. In the beginning, the sequence is empty. In one turn a player can remove a number from the left or right side of the array and append it to the sequence. The rule is that the sequence they are building must be strictly increasing. The winner is the player that makes the last move. Alice is playing first. Given the starting array, under the assumption that they both play optimally, who wins the game?

Input

The first line contains one integer N (1 ¡Ü N ¡Ü 2*10^5) - the length of the array A.

The second line contains N integers A_1, A_2,...,A_N (0 ¡Ü A_i ¡Ü 10^9)

Output

The first and only line of output consists of one string, the name of the winner. If Alice won, print "Alice", otherwise, print "Bob".

Examples

Input


1
5


Output


Alice


Input


3
5 4 5


Output


Alice


Input


6
5 8 2 1 10 9


Output


Bob

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Core Concepts:

The problem involves a two-player game where players take turns removing elements from either end of a sequence to build a strictly increasing sequence. The key concept here is dynamic programming (DP), which helps us determine the optimal moves for each player based on the current state of the array.

### Tutorial:

**Dynamic Programming (DP):**
Dynamic Programming is an algorithmic technique for solving optimization problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations. It is particularly useful in problems involving sequences, graphs, and other combinatorial structures.

In this problem, we can use DP to keep track of the maximum length of a strictly increasing subsequence that can be formed from the left or right end of the array. This allows us to evaluate the best possible moves for both players.

### Example Problems:

**Problem 1: Longest Increasing Subsequence (LIS)**

**Description:** Given an array, find the length of the longest strictly increasing subsequence.

**Solution:** Use DP to store the length of the LIS ending at each index. Iterate through the array and update the DP table accordingly.

```python
def lis(arr):
    n = len(arr)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

print(lis([10, 9, 2, 5, 3, 7, 101, 18]))  # Output: 4
```

**Problem 2: Stone Game**

**Description:** Two players take turns picking stones from either end of a pile. The player with more stones wins. Both players play optimally.

**Solution:** Use DP to determine the maximum number of stones a player can collect. The state `dp[i][j]` represents the maximum number of stones a player can collect from indices `i` to `j`.

```python
def stoneGame(stones):
    n = len(stones)
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = stones[i]
    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])
    return dp[0][n - 1]

print(stoneGame([3, 7, 2, 3]))  # Output: 2
```

**Problem 3: Minimum Cost Climbing Stairs**

**Description:** Given an array representing the cost of climbing each step, find the minimum cost to reach the top of the floor. You can start from either step 0 or step 1.

**Solution:** Use DP to store the minimum cost to reach each step. The state `dp[i]` represents the minimum cost to reach step `i`.

```python
def minCostClimbingStairs(cost):
    n = len(cost)
    dp = [0] * n
    dp[0], dp[1] = cost[0], cost[1]
    for i in range(2, n):
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
    return min(dp[n - 1], dp[n - 2])

print(minCostClimbingStairs([10, 15, 20]))  # Output: 15
```

### Python3 Code to Solve the Original Problem:

**Explanation:**
We will use DP to determine the maximum length of a strictly increasing subsequence that can be built from the left or right end of the array. We then compare the lengths to decide the winner based on the parity of the length.

**Python3 Code:**

```python
def winnerOfGame(N, A):
    dp_left = [0] * N
    dp_right = [0] * N
    
    dp_left[0] = 1
    dp_right[-1] = 1
    
    for i in range(1, N):
        if A[i] > A[i - 1]:
            dp_left[i] = dp_left[i - 1] + 1
        else:
            dp_left[i] = 1
            
    for i in range(N - 2, -1, -1):
        if A[i] < A[i + 1]:
            dp_right[i] = dp_right[i + 1] + 1
        else:
            dp_right[i] = 1
    
    total_length = sum(max(x, y) for x, y in zip(dp_left, dp_right))
    
    if total_length % 2 == 0:
        return "Bob"
    else:
        return "Alice"

# Read input
N = int(input())
A = list(map(int, input().split()))

# Print the result
print(winnerOfGame(N, A))
```

This code reads the input, computes the lengths of the longest increasing subsequences from both ends using DP, sums them up, and determines the winner based on whether the total length is even or odd.
completed 13/21, Solved: False, number of success = 0/13, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
You are given array a_1, a_2, ¡­, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ¡Ü k ¡Ü n) as follows:

  * Choose k distinct array indices 1 ¡Ü i_1 < i_2 < ¡­ < i_k ¡Ü n. 
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ ¡­ ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND) (notes section contains formal definition). 
  * Subtract x from each of a_{i_1}, a_{i_2}, ¡­, a_{i_k}; all other elements remain untouched. 



Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ¡Ü t ¡Ü 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ¡Ü n ¡Ü 200 000) ¡ª the length of array a.

The second line of each test case contains n integers a_1, a_2, ¡­, a_n (0 ¡Ü a_i < 2^{30}) ¡ª array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation ¡ª a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Algorithms:
To solve this problem, we need to understand how the bitwise AND operation works and how it affects the elements of the array when performing elimination operations. The key insight is that for an element `a_i` to eventually become zero through repeated elimination operations, it must be able to contribute to making other elements zero. This means that `a_i` must share common bits with other elements in such a way that their AND results can be used to reduce those elements to zero.

### Tutorial:
#### Bitwise AND Operation:
The bitwise AND operation between two numbers results in a new number where each bit is set to 1 only if both corresponding bits of the operands are 1. For example:
```
  1010 (10 in decimal)
& 1100 (12 in decimal)
------
  1000 (8 in decimal)
```

#### Elimination Operation:
Given an array `a` and an integer `k`, we select `k` distinct indices and compute the bitwise AND of the selected elements. We then subtract this result from each of the selected elements. The goal is to determine which values of `k` allow us to make all elements of the array zero through a series of such operations.

### Example Problems:
#### Problem 1: [Minimum XOR Sum]
**Problem:** Given an array of integers, find the minimum sum of pairwise XORs.
**Solution:** Pair up elements such that the XOR of pairs is minimized.
```python
def min_xor_sum(nums):
    nums.sort()
    return sum(nums[i] ^ nums[i+1] for i in range(0, len(nums), 2))
```

#### Problem 2: [Bitwise OR Queries]
**Problem:** Given an array and a list of queries asking for the bitwise OR of subarrays.
**Solution:** Use a segment tree to efficiently handle range updates and queries.
```python
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self.build_tree(arr, 0, 0, self.n-1)

    def build_tree(self, arr, node, start, end):
        if start == end:
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            self.build_tree(arr, 2*node + 1, start, mid)
            self.build_tree(arr, 2*node + 2, mid+1, end)
            self.tree[node] = self.tree[2*node + 1] | self.tree[2*node + 2]

    def query(self, node, start, end, l, r):
        if r < start or end < l:
            return 0
        if l <= start and end <= r:
            return self.tree[node]
        mid = (start + end) // 2
        return self.query(2*node + 1, start, mid, l, r) | self.query(2*node + 2, mid+1, end, l, r)
```

#### Problem 3: [Binary Indexed Tree (BIT)]
**Problem:** Given an array and supporting operations to update elements and calculate prefix sums.
**Solution:** Implement a Binary Indexed Tree to efficiently manage point updates and range queries.
```python
class BIT:
    def __init__(self, size):
        self.size = size
        self.tree = [0] * (size + 1)

    def update(self, idx, val):
        while idx <= self.size:
            self.tree[idx] += val
            idx += idx & -idx

    def prefix_sum(self, idx):
        total = 0
        while idx > 0:
            total += self.tree[idx]
            idx -= idx & -idx
        return total
```

### Python3 Code to Solve the Original Problem:
#### Explanation:
We need to identify which values of `k` allow us to make all elements zero. We observe that if `a_i` has a bit set that no other element has, it cannot be reduced to zero. Therefore, we count the frequency of each bit position being set across all elements. A valid `k` must not include any bit positions that do not appear in at least `k` elements.

#### Python3 Code:
```python
def possible_values_of_k(n, a):
    # Count the frequency of each bit position being set
    bit_count = [0] * 30
    for num in a:
        for i in range(30):
            if (num >> i) & 1:
                bit_count[i] += 1
    
    # Determine the valid k values
    valid_k = []
    for k in range(1, n + 1):
        if all(bit_count[i] >= k for i in range(30)):
            valid_k.append(k)
    
    return valid_k

import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1
results = []

for _ in range(t):
    n = int(data[index])
    index += 1
    a = list(map(int, data[index:index+n]))
    index += n
    results.append(possible_values_of_k(n, a))

for result in results:
    print(" ".join(map(str, result)))
```

This code reads the input, processes each test case, determines the valid values of `k`, and prints the results. The `possible_values_of_k` function counts the frequency of each bit position being set and checks which values of `k` satisfy the condition of having at least `k` elements with that bit set.
completed 16/21, Solved: False, number of success = 0/16, acc = 0.0
#########################
Running end QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:27:39.766860
##########################

