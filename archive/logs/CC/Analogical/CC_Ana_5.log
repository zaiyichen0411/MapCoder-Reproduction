#########################
Running start QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:26:08.090202
##########################

An error occurred: 'gbk' codec can't encode character '\u22c5' in position 797: illegal multibyte sequence
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Shohag has an integer sequence a_1, a_2, ¡­, a_n. He can perform the following operation any number of times (possibly, zero):

  * Select any positive integer k (it can be different in different operations). 
  * Choose any position in the sequence (possibly the beginning or end of the sequence, or in between any two elements) and insert k into the sequence at this position. 
  * This way, the sequence a changes, and the next operation is performed on this changed sequence. 



For example, if a=[3,3,4] and he selects k = 2, then after the operation he can obtain one of the sequences [\underline{2},3,3,4], [3,\underline{2},3,4], [3,3,\underline{2},4], or [3,3,4,\underline{2}].

Shohag wants this sequence to satisfy the following condition: for each 1 ¡Ü i ¡Ü |a|, a_i ¡Ü i. Here, |a| denotes the size of a.

Help him to find the minimum number of operations that he has to perform to achieve this goal. We can show that under the constraints of the problem it's always possible to achieve this goal in a finite number of operations.

Input

The first line contains a single integer t (1 ¡Ü t ¡Ü 200) ¡ª the number of test cases.

The first line of each test case contains a single integer n (1 ¡Ü n ¡Ü 100) ¡ª the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, ¡­, a_n (1 ¡Ü a_i ¡Ü 10^9) ¡ª the elements of the sequence.

Output

For each test case, print a single integer ¡ª the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] ¡ú [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] ¡ú [1, 2, \underline{3}, 5, 7, 4] ¡ú [1, 2, 3, \underline{4}, 5, 7, 4] ¡ú [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Core Concepts/Algorithms:

To solve this problem, we need to understand how to minimize the number of operations required to transform a given sequence such that each element \( a_i \leq i \).

**Algorithm:**
1. **Initialize the count of operations**: Start with a counter initialized to zero.
2. **Iterate through the sequence**: For each element \( a_i \), check if it violates the condition \( a_i \leq i \).
   - If \( a_i > i \), determine how many elements less than \( a_i \) are needed to fill the gap up to index \( i \).
   - Add the necessary number of operations to the counter.
3. **Return the total number of operations**: After iterating through the entire sequence, return the counter value.

### Tutorial:
#### Understanding the Algorithm:
The key idea here is to ensure that each element in the sequence does not exceed its index. If an element exceeds its index, we need to insert smaller elements to make it fit within the allowed range.

#### Steps to Solve:
1. **Initialization**: Start with a counter set to zero.
2. **Loop Through Sequence**: For each element in the sequence, compare it with its index.
   - If the element is greater than its index, calculate the number of elements needed to replace it.
   - Increment the counter accordingly.
3. **Return Result**: Finally, return the total count of operations required.

### Example Problems:

1. **Problem:** Minimum Insertions to Form a Sorted Array
   - **Description:** Given an array, determine the minimum number of insertions required to make the array sorted.
   - **Solution:** Sort the array and use a stack to keep track of the smallest suffix of the sorted array that is already sorted. Count the number of insertions needed to merge the unsorted part into the sorted part.
   
2. **Problem:** Minimize Maximum Element in an Array
   - **Description:** Given an array, determine the minimum number of operations required to make the maximum element in the array equal to or less than a given threshold.
   - **Solution:** Use binary search to find the minimum threshold. For each threshold, simulate the operations required to reduce the maximum element.
   
3. **Problem:** Transform Array to Satisfy Condition
   - **Description:** Given an array, determine the minimum number of operations required to make each element less than or equal to its index.
   - **Solution:** Iterate through the array and for each element greater than its index, calculate and add the required number of operations to the counter.

### Python3 Code to Solve the Original Problem:

```python
def min_operations_to_transform(sequence):
    n = len(sequence)
    operations = 0
    
    for i in range(n):
        if sequence[i] > i + 1:
            # Calculate the number of elements needed to replace the current element
            operations += sequence[i] - (i + 1)
    
    return operations

# Read input
t = int(input())
results = []

for _ in range(t):
    n = int(input())
    sequence = list(map(int, input().split()))
    results.append(min_operations_to_transform(sequence))

# Print results
for result in results:
    print(result)
```

### Explanation of the Solution:
- **Function Definition:** `min_operations_to_transform` takes a sequence as input and returns the minimum number of operations required.
- **Initialization:** Initialize `operations` to zero.
- **Loop Through Sequence:** Iterate through the sequence using a for loop.
  - For each element, check if it violates the condition \( a_i \leq i \).
  - If it does, calculate the number of elements needed to replace it and increment the `operations` counter.
- **Return Result:** After processing all elements, return the total number of operations.
- **Reading Input:** Read the number of test cases and process each test case individually.
- **Printing Results:** Print the result for each test case.
completed 4/21, Solved: False, number of success = 0/4, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ¡Ü i ¡Ü |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ¡Ü t ¡Ü 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ¡Ü |s| ¡Ü 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
## Core Concepts / Algorithms:

The core concept for solving this problem involves counting the occurrences of "ab" and "ba" substrings within a given string `s`. We also need to determine how many changes (either replacing 'a' with 'b' or vice versa) are required to make the counts of these substrings equal. To achieve this efficiently, we should count the differences between the occurrences of "ab" and "ba". By understanding how many more instances of "ab" or "ba" we have, we can decide on the optimal replacements to balance the counts.

### Steps to Solve:
1. **Count Occurrences**: Count the number of "ab" and "ba" substrings.
2. **Difference Calculation**: Compute the absolute difference between the counts of "ab" and "ba".
3. **Optimal Replacements**: Replace either 'a' or 'b' to reduce this difference.
4. **Construct Result String**: Output the modified string.

## Tutorial:

### Understanding Substring Counting:
To count occurrences of a substring within another string, you can iterate through the main string and check if the current substring matches the target substring. This approach works well for small strings but can become inefficient for larger ones.

### Calculating Differences:
Once you know how many times each substring occurs, calculating their difference gives insight into what adjustments need to be made. If the difference is even, the counts can always be balanced by swapping pairs. If odd, one more replacement might be needed.

### Optimal Replacement Strategy:
Deciding whether to replace 'a' or 'b' depends on which swap brings the counts closer to being equal. Since every replacement affects two positions, strategically choosing the right position can minimize the number of swaps needed.

## Example Problems:

### Problem 1: Equalize Substrings
**Problem Statement:** You are given a string `s` containing 'a's and 'b's. Your task is to find the minimum number of operations required to make the count of "ab" and "ba" equal.

**Solution:**
- Count "ab" and "ba".
- Calculate the absolute difference.
- Perform minimal replacements to balance.

**Python3 Code:**
```python
def min_operations(s):
    ab_count = sum(1 for i in range(len(s) - 1) if s[i:i+2] == "ab")
    ba_count = sum(1 for i in range(len(s) - 1) if s[i:i+2] == "ba")
    diff = abs(ab_count - ba_count)
    
    # Return half of the difference, rounded up if odd
    return (diff + 1) // 2

# Test case
print(min_operations("aabbbabaa"))  # Output: 2
```

### Problem 2: Minimum Swaps to Balance Parentheses
**Problem Statement:** Given a string with parentheses '(', ')', find the minimum number of swaps to balance the parentheses.

**Solution:**
- Track unmatched '(' and ')' using counters.
- Use a stack to manage unmatched parentheses.
- Calculate the swaps based on the counter values.

**Python3 Code:**
```python
def min_swaps_to_balance(parentheses):
    open_count = close_count = swaps = imbalance = 0
    
    for p in parentheses:
        if p == '(':
            open_count += 1
            if imbalance > 0:
                swaps += imbalance
                imbalance -= 1
        else:
            close_count += 1
            imbalance = close_count - open_count
    
    return swaps

# Test case
print(min_swaps_to_balance("))(()"))  # Output: 1
```

### Problem 3: Minimize Insertions/Deletions to Form Palindrome
**Problem Statement:** Given a string `s`, find the minimum number of insertions/deletions to convert it into a palindrome.

**Solution:**
- Find the longest palindromic subsequence (LPS).
- The result is the length of the string minus LPS length.

**Python3 Code:**
```python
def min_insertions_deletions(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for gap in range(n):
        for i in range(n - gap):
            j = i + gap
            if gap == 0:
                dp[i][j] = 1
            elif gap == 1:
                dp[i][j] = 2 if s[i] == s[j] else 1
            else:
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    
    return n - dp[0][n - 1]

# Test case
print(min_insertions_deletions("radar"))  # Output: 0
```

## Python3 Code to Solve the Original Problem:

### Explanation of the Solution:
- Count the occurrences of "ab" and "ba" in the string.
- Calculate the absolute difference between these counts.
- Perform minimal replacements to balance the counts by deciding whether to change an 'a' to 'b' or vice versa at strategic positions.

### Python3 Code:

```python
def min_steps_to_equal_ab_ba(s):
    ab_count = sum(1 for i in range(len(s) - 1) if s[i:i+2] == "ab")
    ba_count = sum(1 for i in range(len(s) - 1) if s[i:i+2] == "ba")
    diff = abs(ab_count - ba_count)
    
    # Create a list of positions to modify
    positions = []
    if ab_count < ba_count:
        for i in range(len(s) - 1):
            if s[i:i+2] == "ab":
                positions.append(i)
            elif s[i:i+2] != "ba":
                positions.append(i)
    else:
        for i in range(len(s) - 1):
            if s[i:i+2] == "ba":
                positions.append(i)
            elif s[i:i+2] != "ab":
                positions.append(i)
    
    # Perform replacements
    result = list(s)
    for pos in positions[:diff]:
        if s[pos] == 'a':
            result[pos] = 'b'
        else:
            result[pos] = 'a'
    
    return ''.join(result)

# Read input from standard input
import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
results = []

for i in range(t):
    s = data[i + 1]
    results.append(min_steps_to_equal_ab_ba(s))

# Print results to standard output
for res in results:
    print(res)
```

This code reads input from standard input, processes each test case, and outputs the modified string for each case.
completed 9/21, Solved: False, number of success = 0/9, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from left to right). No time is spent on pressing the keys and on placing your hand over the first letter of the word.

For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l' and 'o' then are on the positions 8, 5, 12 and 15, respectively. Therefore, it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". 

Determine how long it will take to print the word s.

Input

The first line contains an integer t (1 ¡Ü t ¡Ü 1000) ¡ª the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard ¡ª a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
## Algorithms:
To solve this problem, we need to calculate the total time required to type a given word on a custom keyboard. The time taken to move between two keys is determined by the absolute difference in their positions on the keyboard. Here are the steps involved:

1. **Mapping Key Positions**: Create a dictionary to map each character to its position on the keyboard.
2. **Calculating Time**: Iterate through the characters of the word and sum up the time taken to move from one character to the next.

## Tutorial:
### Step-by-Step Explanation:

1. **Mapping Key Positions**:
   - We create a dictionary where the keys are the characters ('a' to 'z') and the values are their respective positions (from 0 to 25).
   
2. **Calculating Time**:
   - Initialize a variable to keep track of the total time.
   - Iterate through the characters of the word.
   - For each pair of adjacent characters, calculate the absolute difference in their positions and add it to the total time.
   - Since no time is spent on the first character, start iterating from the second character.

### Example:

Let's consider the example where the keyboard layout is `abcdefghijklmnopqrstuvwxyz` and the word to type is `hello`.

1. **Mapping Key Positions**:
   ```
   {'a': 0, 'b': 1, 'c': 2, ..., 'y': 24, 'z': 25}
   ```

2. **Calculating Time**:
   - Starting with 'h' (position 7), move to 'e' (position 4): \(|7 - 4| = 3\)
   - Move to 'l' (position 11): \(|4 - 11| = 7\)
   - Move to 'l' (position 11): \(|11 - 11| = 0\)
   - Move to 'o' (position 14): \(|11 - 14| = 3\)
   - Total time: \(3 + 7 + 0 + 3 = 13\)

## Example Problems:

### Problem 1: Typing Distance on a Standard Keyboard
**Problem Description**: Given a word, calculate the typing distance using a standard alphabetically ordered keyboard.
**Solution**: Use the same approach as above but with a predefined keyboard layout (`abcdefghijklmnopqrstuvwxyz`).

```python
def typing_distance(word):
    keyboard = 'abcdefghijklmnopqrstuvwxyz'
    pos = {char: i for i, char in enumerate(keyboard)}
    time = 0
    for i in range(1, len(word)):
        time += abs(pos[word[i]] - pos[word[i - 1]])
    return time

word = "hello"
print(typing_distance(word))
```

### Problem 2: Minimum Steps to Type a Word
**Problem Description**: Given a keyboard layout and a word, calculate the minimum steps required to type the word.
**Solution**: Implement the algorithm described above using the provided keyboard layout.

```python
def min_steps_to_type(word, keyboard):
    pos = {char: i for i, char in enumerate(keyboard)}
    time = 0
    for i in range(1, len(word)):
        time += abs(pos[word[i]] - pos[word[i - 1]])
    return time

keyboard = "abcdefghijklmnopqrstuvwxyz"
word = "hello"
print(min_steps_to_type(word, keyboard))
```

### Problem 3: Typing Time on a Custom Keyboard
**Problem Description**: Given a custom keyboard layout and a word, calculate the typing time.
**Solution**: Use the mapping and calculation logic as described above.

```python
def typing_time(word, keyboard):
    pos = {char: i for i, char in enumerate(keyboard)}
    time = 0
    for i in range(1, len(word)):
        time += abs(pos[word[i]] - pos[word[i - 1]])
    return time

keyboard = "qwertyuiopasdfghjklzxcvbnm"
word = "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"
print(typing_time(word, keyboard))
```

## Python3 Code to Solve the Original Problem:

### Explanation of the Solution:
- Read the number of test cases.
- For each test case, read the keyboard layout and the word to type.
- Create a dictionary to map each character to its position on the keyboard.
- Calculate the total time required to type the word by iterating through the characters and summing up the distances.
- Print the result for each test case.

### Python3 Code:
```python
def typing_time(word, keyboard):
    pos = {char: i for i, char in enumerate(keyboard)}
    time = 0
    for i in range(1, len(word)):
        time += abs(pos[word[i]] - pos[word[i - 1]])
    return time

import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1
results = []

for _ in range(t):
    keyboard = data[index]
    word = data[index + 1]
    index += 2
    results.append(str(typing_time(word, keyboard)))

print('\n'.join(results))
```

This code reads the input from standard input, processes each test case, and prints the results for each test case.
completed 15/21, Solved: True, number of success = 1/15, acc = 6.67
#########################
Running end QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:27:50.790725
##########################

