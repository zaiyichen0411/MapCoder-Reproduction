#########################
Running start QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:26:08.093741
##########################

An error occurred: 'gbk' codec can't encode character '\u22c5' in position 1314: illegal multibyte sequence
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Given n, find any array a_1, a_2, ¡­, a_n of integers such that all of the following conditions hold: 

  * 1 ¡Ü a_i ¡Ü 10^9 for every i from 1 to n.

  * a_1 < a_2 < ¡­ <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}




It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ¡Ü t ¡Ü 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ¡Ü n ¡Ü 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, ¡­, a_n ¡ª the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Algorithms:

The core concepts involved in solving this problem are:
1. **Sequence Generation**: We need to generate a sequence of numbers.
2. **Prime Numbers**: To ensure that no number in the sequence is divisible by the previous one, we can use prime numbers. Prime numbers have no divisors other than 1 and themselves, making them ideal for this condition.
3. **Incremental Construction**: The sequence should be strictly increasing, so we start with the smallest prime and keep adding the next prime number until the required length is reached.

### Tutorial:

#### Sequence Generation:
Generating sequences involves creating a series of values that follow a specific pattern. In this problem, the sequence needs to be strictly increasing and composed of numbers that are not divisible by their preceding elements.

#### Prime Numbers:
Prime numbers are numbers greater than 1 that have no positive divisors other than 1 and themselves. They are fundamental in many areas of mathematics and computer science, including cryptography and number theory.

#### Incremental Construction:
To construct the sequence incrementally, we start with the smallest prime number and add the next prime number to the sequence at each step. This ensures that the sequence remains strictly increasing and that no number is divisible by its predecessor.

### Example Problems:

#### Problem 1: Generate First N Prime Numbers
**Problem**: Write a function to generate the first `n` prime numbers.

**Solution**:
1. Use a helper function to check if a number is prime.
2. Iterate through natural numbers and collect primes until `n` primes are found.

```python
def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def generate_primes(n):
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes

# Example usage
print(generate_primes(5))  # Output: [2, 3, 5, 7, 11]
```

#### Problem 2: Find the Next Prime Number
**Problem**: Write a function to find the next prime number after a given number.

**Solution**:
1. Start checking from the given number + 1.
2. Check each number for primality using the helper function.

```python
def next_prime(num):
    candidate = num + 1
    while not is_prime(candidate):
        candidate += 1
    return candidate

# Example usage
print(next_prime(10))  # Output: 11
```

#### Problem 3: Generate a Strictly Increasing Sequence Using Primes
**Problem**: Write a function to generate a strictly increasing sequence of length `n` using prime numbers.

**Solution**:
1. Generate prime numbers until we have enough for the sequence.
2. Select the first `n` primes to form the sequence.

```python
def generate_increasing_sequence(n):
    primes = generate_primes(n)
    return primes[:n]

# Example usage
print(generate_increasing_sequence(3))  # Output: [2, 3, 5]
```

### Python3 Code to Solve the Original Problem:

**Explanation**:
1. We generate prime numbers up to a sufficiently large limit using a sieve method.
2. We select the first `n` prime numbers to form the sequence.
3. Print the sequence for each test case.

```python
def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    p = 2
    while (p * p <= limit):
        if (is_prime[p] == True):
            for i in range(p * p, limit + 1, p):
                is_prime[i] = False
        p += 1
    prime_numbers = []
    for p in range(2, limit + 1):
        if is_prime[p]:
            prime_numbers.append(p)
    return prime_numbers

def generate_sequence(n):
    limit = 10**6  # Adjusted limit based on constraint
    primes = sieve_of_eratosthenes(limit)
    return primes[:n]

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    
    results = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        sequence = generate_sequence(n)
        results.append(sequence)
    
    for sequence in results:
        print(' '.join(map(str, sequence)))

if __name__ == "__main__":
    main()
```

This code reads input from standard input, generates the required sequences using prime numbers, and prints the results. The sieve of Eratosthenes algorithm efficiently finds all prime numbers up to a specified limit.
completed 2/21, Solved: False, number of success = 0/2, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ¡Ü t ¡Ü 10^4) ¡ª the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ¡Ü x_1 ¡Ü 10^6; 0 ¡Ü p_1 ¡Ü 10^6) ¡ª the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ¡Ü x_2 ¡Ü 10^6; 0 ¡Ü p_2 ¡Ü 10^6) ¡ª the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
### Algorithms:

To solve this problem, we need to compare two numbers where each number is represented as a positive integer `x` followed by `p` zeros. 

Core Concepts:
1. **String Representation**: Convert the numbers into string representations to easily append zeros.
2. **Comparison**: Compare the resulting strings lexicographically to determine which number is larger.

### Tutorial:

**String Representation**:
- In Python, converting an integer to a string can be done using the `str()` function.
- Appending zeros to a number can be achieved by multiplying the number by 10 raised to the power of `p`.

**Lexicographical Comparison**:
- String comparison in Python uses lexicographical order, similar to alphabetical order for alphabets.
- For example, "10" is less than "2" because "1" comes before "2".

### Example Problems:

**Problem 1: Compare Two Numbers**
- **Problem Description**: Given two numbers `x1` and `p1`, and another number `x2` and `p2`, compare the two numbers formed by appending `p1` zeros to `x1` and `p2` zeros to `x2`.
- **Solution**: Convert both numbers to their string representations and compare them.
- **Python Code**:
    ```python
    def compare_numbers(x1, p1, x2, p2):
        num1 = str(x1) + '0' * p1
        num2 = str(x2) + '0' * p2
        if num1 < num2:
            return "<"
        elif num1 > num2:
            return ">"
        else:
            return "="
    ```

**Problem 2: Sort an Array of Numbers**
- **Problem Description**: Given an array of numbers where each number is a positive integer followed by a certain number of zeros, sort the array in ascending order.
- **Solution**: Convert each number to its string representation, append zeros, and then use regular sorting methods.
- **Python Code**:
    ```python
    def sort_numbers(arr):
        arr.sort(key=lambda x: int(str(x[0]) + '0' * x[1]))
        return arr
    ```

**Problem 3: Find Maximum Number After Operations**
- **Problem Description**: Given a list of numbers, append any number of zeros to each number and find the maximum possible number after these operations.
- **Solution**: Append as many zeros as possible (i.e., the maximum allowed value of `p`) to each number and find the maximum value.
- **Python Code**:
    ```python
    def max_number_after_operations(nums):
        max_num = float('-inf')
        for num in nums:
            max_num = max(max_num, int(str(num[0]) + '0' * 10**6))
        return max_num
    ```

### Python3 code to solve the original problem:

**Explanation**:
- Read the number of test cases.
- For each test case, read the values of `x1`, `p1`, `x2`, and `p2`.
- Convert these values to their string representations and append the appropriate number of zeros.
- Compare the two resulting strings lexicographically and print the result.

**Python Code**:
```python
def compare_numbers(x1, p1, x2, p2):
    num1 = str(x1) + '0' * p1
    num2 = str(x2) + '0' * p2
    if num1 < num2:
        return "<"
    elif num1 > num2:
        return ">"
    else:
        return "="

# Main function to handle input and output
import sys
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1
results = []

for _ in range(t):
    x1 = int(data[index])
    p1 = int(data[index + 1])
    x2 = int(data[index + 2])
    p2 = int(data[index + 3])
    index += 4
    results.append(compare_numbers(x1, p1, x2, p2))

# Print all results
for result in results:
    print(result)
```

This code reads the input, processes each test case, compares the numbers, and prints the results according to the specified format.
completed 9/21, Solved: False, number of success = 0/9, acc = 0.0
Your goal is to write Python3 code to solve competitive programming problems. Given a problem , explain the core concepts in it and provide other relevant problems. Then solve the original problem.

# Problem:
There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:

  * Choose two indices i and j (1 ¡Ü i, j ¡Ü n; i ¡Ù j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. 



You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). 

What's the minimum possible ugliness you can achieve, after any number of days?

Input

The first line contains one integer t (1 ¡Ü t ¡Ü 1000) ¡ª the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ¡Ü n ¡Ü 100) ¡ª the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, ¡­, a_n (1 ¡Ü a_i ¡Ü 10^7) ¡ª the heights of the buildings.

Output

For each test case, output a single integer ¡ª the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.

-------
Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.

# Instruction: (Your response must include the following points sequentially)

## Algorithms:
Identify the core concepts or algorithms used to solve the problem.

## Tutorial:
Write a useful tutorial about these algorithms.

## Example Problems: 
Provide three examples of relevant competitive programming problems that involve these algorithms. For each problem , describe the problem , explain the solution in detail , and then write the correct Python3 code.

## Python3 code to solve the original problem: 
Include the following points in your response: 
- Explanation of the solution: 
- Python3 code to solve the problem (inside ```  ``` block):
## Algorithms:
### Core Concepts:
To minimize the ugliness of the buildings, we need to reduce the height difference between the tallest and shortest buildings. This involves redistributing blocks among the towers such that the maximum height is minimized relative to the minimum height. The key observation here is that to minimize the ugliness, we should aim to balance the heights of the towers as much as possible.

### Algorithm Steps:
1. **Sort the Heights**: Sorting the list of building heights helps in easily identifying the smallest and largest heights.
2. **Balance the Heights**: By distributing blocks from taller towers to shorter ones, we can try to bring the heights closer together.
3. **Calculate Ugliness**: After balancing, the minimum possible ugliness will be the difference between the highest and lowest heights in the sorted list.

## Tutorial:
### Sorting Basics:
Sorting is a fundamental algorithm that arranges elements in a specific order. Common sorting algorithms include Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, and Quick Sort. For this problem, Python¡¯s built-in `sort()` method is efficient enough due to its Timsort implementation, which has a worst-case time complexity of O(n log n).

### Finding Min and Max:
After sorting, the smallest element will be at the beginning of the list (`a[0]`), and the largest element will be at the end of the list (`a[n-1]`). The difference between these two values gives us the current ugliness.

### Balancing Heights:
Balancing the heights isn't explicitly necessary because sorting inherently makes the problem simpler. However, understanding how to distribute elements can help in more complex scenarios where direct redistribution is required.

## Example Problems:
### Problem 1: Equalize Array
**Problem Statement**: Given an array `A`, find the minimum number of operations required to make all elements equal by incrementing or decrementing an element by 1 in one operation.

**Solution**: Increment/decrement operations don¡¯t directly apply here, but the concept of minimizing differences is similar. We sort the array and calculate the median, then sum the absolute differences between each element and the median.

```python
def min_operations_to_equalize(arr):
    arr.sort()
    median = arr[len(arr) // 2]
    return sum(abs(x - median) for x in arr)
```

### Problem 2: Minimum Cost to Make All Elements Zero
**Problem Statement**: Given an array `A`, find the minimum cost to make all elements zero. Each operation costs |A[i]| units.

**Solution**: Similar to finding the median, the optimal strategy involves sorting and using the middle value to minimize total cost. The total cost is the sum of absolute values of deviations from the median.

```python
def min_cost_to_zero(arr):
    arr.sort()
    median = arr[len(arr) // 2]
    return sum(abs(x - median) for x in arr)
```

### Problem 3: Minimum Operations to Get K Pairs With Smallest Sums
**Problem Statement**: Given two arrays `A` and `B`, find k pairs with the smallest sums. Each pair consists of one element from `A` and one from `B`.

**Solution**: Use a priority queue to efficiently find pairs with the smallest sums. Sort both arrays and start pairing from the smallest elements.

```python
import heapq

def k_smallest_pairs(A, B, k):
    result = []
    heap = [(A[0] + B[0], 0, 0)]
    
    while heap and len(result) < k:
        _, i, j = heapq.heappop(heap)
        result.append((A[i], B[j]))
        
        if j + 1 < len(B):
            heapq.heappush(heap, (A[i] + B[j+1], i, j+1))
    
    return result
```

## Python3 code to solve the original problem:
### Explanation of the Solution:
1. **Read Input**: Take the number of test cases and for each case, read the number of buildings and their heights.
2. **Process Each Case**: For each test case, sort the list of heights.
3. **Calculate Ugliness**: Compute the difference between the maximum and minimum heights in the sorted list.
4. **Print Result**: Output the calculated ugliness for each test case.

### Python3 Code:
```python
# Read input from standard input
import sys
input = sys.stdin.read
data = input().split()

# Initialize index for reading data
index = 0

# Function to process each test case
def process_test_case():
    global index
    n = int(data[index])
    index += 1
    heights = list(map(int, data[index:index+n]))
    index += n
    heights.sort()
    return max(heights) - min(heights)

# Number of test cases
t = int(data[index])
index += 1

# Process each test case and print the result
results = [process_test_case() for _ in range(t)]

# Print all results
for result in results:
    print(result)
```

This solution reads the input, processes each test case by sorting the heights and calculating the ugliness, and outputs the results accordingly.
completed 15/21, Solved: False, number of success = 0/15, acc = 0.0
#########################
Running end QwenCoderTurbo-Analogical-CC-Python3-0.0-1, Time: 2025-11-11 20:27:32.241288
##########################

