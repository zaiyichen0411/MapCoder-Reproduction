{"task_id": "HumanEval/126", "prompt": "\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n", "entry_point": "is_sorted", "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "sample_io": ["assert is_sorted([5]) == True", "assert is_sorted([1, 2, 3, 4, 5]) == True", "assert is_sorted([1, 3, 2, 4, 5]) == False", "assert is_sorted([1, 2, 3, 4, 5, 6]) == True", "assert is_sorted([1, 2, 3, 4, 5, 6, 7]) == True", "assert is_sorted([1, 3, 2, 4, 5, 6, 7]) == False", "assert is_sorted([1, 2, 2, 3, 3, 4]) == True", "assert is_sorted([1, 2, 2, 2, 3, 4]) == False"], "source_codes": ["\ndef is_sorted(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    for i in range(len(lst)):\n        count = lst.count(lst[i])\n        if count > 1 and lst[i] != lst[i - 1]:\n            return False\n    return True\n\n# Test cases\nprint(is_sorted([5]))  # Output: True\nprint(is_sorted([1, 2, 3, 4, 5]))  # Output: True\nprint(is_sorted([1, 3, 2, 4, 5]))  # Output: False\nprint(is_sorted([1, 2, 3, 4, 5, 6]))  # Output: True\nprint(is_sorted([1, 2, 3, 4, 5, 6, 7]))  # Output: True\nprint(is_sorted([1, 3, 2, 4, 5, 6, 7]))  # Output: False\nprint(is_sorted([1, 2, 2, 3, 3, 4]))  # Output: True\nprint(is_sorted([1, 2, 2, 2, 3, 4]))  # Output: False\n\n\n"], "responses": ["```python\ndef is_sorted(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    for i in range(len(lst)):\n        count = lst.count(lst[i])\n        if count > 1 and lst[i] != lst[i - 1]:\n            return False\n    return True\n\n# Test cases\nprint(is_sorted([5]))  # Output: True\nprint(is_sorted([1, 2, 3, 4, 5]))  # Output: True\nprint(is_sorted([1, 3, 2, 4, 5]))  # Output: False\nprint(is_sorted([1, 2, 3, 4, 5, 6]))  # Output: True\nprint(is_sorted([1, 2, 3, 4, 5, 6, 7]))  # Output: True\nprint(is_sorted([1, 3, 2, 4, 5, 6, 7]))  # Output: False\nprint(is_sorted([1, 2, 2, 3, 3, 4]))  # Output: True\nprint(is_sorted([1, 2, 2, 2, 3, 4]))  # Output: False\n```"], "prompt_tokens": [3898], "completion_tokens": [2029], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/127", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "sample_io": ["assert intersection((1, 2), (2, 3)) == \"NO\"", "assert intersection((-1, 1), (0, 4)) == \"NO\"", "assert intersection((-3, -1), (-5, 5)) == \"YES\""], "source_codes": ["\nfrom sympy import isprime\n\ndef intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    if start1 > end2 or start2 > end1:\n        return \"NO\"\n    \n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    intersection_length = intersection_end - intersection_start + 1\n    \n    if isprime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\n"], "responses": ["```python\nfrom sympy import isprime\n\ndef intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    if start1 > end2 or start2 > end1:\n        return \"NO\"\n    \n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    intersection_length = intersection_end - intersection_start + 1\n    \n    if isprime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n```"], "prompt_tokens": [4181], "completion_tokens": [2135], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/128", "prompt": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n", "entry_point": "prod_signs", "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert prod_signs([1, 2, 2, -4]) == -9", "assert prod_signs([0, 1]) == 0", "assert prod_signs([]) == None"], "source_codes": ["\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    \n    for char in s:\n        if char.isalpha():\n            idx = alphabet.index(char.lower())\n            rotated_idx = (idx + 4) % 26\n            encrypted += alphabet[rotated_idx].upper() if char.isupper() else alphabet[rotated_idx]\n        else:\n            encrypted += char\n    \n    return encrypted\n\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt or not txt[-1].isalpha():\n        return False\n    \n    words = txt.split()\n    \n    if len(words[-1]) == 1:\n        return True\n    \n    return False\n\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}\\.[txt|exe|dll]{3}$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\n\ndef fruit_distribution(s, n):\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    mangoes = n - apples - oranges\n    return mangoes\n\n\nfrom sympy import isprime\n\n\ndef prime_fib(n: int):\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n    \n    count = 0\n    for num in fib_generator():\n        if num > 1 and isprime(num):\n            count += 1\n            if count == n:\n                return num\n\n\ndef compare_one(a, b):\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    \n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None\n\n\ndef sort_even(l: list):\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even_elements.sort()\n    \n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result\n\n\ndef search(lst):\n    from collections import Counter\n    \n    freq = Counter(lst)\n    result = -1\n    \n    for num, freq_num in freq.items():\n        if num <= freq_num and num > result:\n            result = num\n    \n    return result\n\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    \n    product_of_signs = 1\n    magnitude_sum = 0\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        product_of_signs *= -1 if num < 0 else 1\n    \n    return magnitude_sum * product_of_signs\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    \n    for char in s:\n        if char.isalpha():\n            idx = alphabet.index(char.lower())\n            rotated_idx = (idx + 4) % 26\n            encrypted += alphabet[rotated_idx].upper() if char.isupper() else alphabet[rotated_idx]\n        else:\n            encrypted += char\n    \n    return encrypted\n\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt or not txt[-1].isalpha():\n        return False\n    \n    words = txt.split()\n    \n    if len(words[-1]) == 1:\n        return True\n    \n    return False\n\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}\\.[txt|exe|dll]{3}$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\n\ndef fruit_distribution(s, n):\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    mangoes = n - apples - oranges\n    return mangoes\n\n\nfrom sympy import isprime\n\n\ndef prime_fib(n: int):\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n    \n    count = 0\n    for num in fib_generator():\n        if num > 1 and isprime(num):\n            count += 1\n            if count == n:\n                return num\n\n\ndef compare_one(a, b):\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    \n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None\n\n\ndef sort_even(l: list):\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even_elements.sort()\n    \n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result\n\n\ndef search(lst):\n    from collections import Counter\n    \n    freq = Counter(lst)\n    result = -1\n    \n    for num, freq_num in freq.items():\n        if num <= freq_num and num > result:\n            result = num\n    \n    return result\n\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    \n    product_of_signs = 1\n    magnitude_sum = 0\n    \n    for num in arr:\n        magnitude_sum += abs(num)\n        product_of_signs *= -1 if num < 0 else 1\n    \n    return magnitude_sum * product_of_signs\n```"], "prompt_tokens": [2988], "completion_tokens": [1707], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/129", "prompt": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n", "entry_point": "minPath", "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "sample_io": ["assert minPath([ [1,2,3], [4,5,6], [7,8,9] ], 3) == [1, 2, 1]", "assert minPath([ [5,9,3], [4,1,6], [7,8,2] ], 1) == [1]"], "source_codes": ["\ndef encrypt(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotated_alphabet = alphabet[2*2:] + alphabet[:2*2]\n    \n    def rotate_char(c):\n        if c in alphabet:\n            return rotated_alphabet[alphabet.index(c)]\n        else:\n            return c\n        \n    return ''.join(rotate_char(c) for c in s)\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    if not txt[-1].isalpha():\n        return False\n    words = txt.split()\n    if len(words[-1]) != 1:\n        return False\n    return True\n\ndef file_name_check(file_name):\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    if not name or not name[0].isalpha() or not extension in {'txt', 'exe', 'dll'}:\n        return 'No'\n    digit_count = sum(c.isdigit() for c in name)\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    words = s.split()\n    num_oranges = int(words[1])\n    num_apples = int(words[4])\n    num_mangoes = n - num_oranges - num_apples\n    return num_mangoes\n\nfrom sympy import isprime\n\ndef prime_fib(n):\n    a, b = 0, 1\n    count = 0\n    while True:\n        a, b = b, a + b\n        if isprime(b):\n            count += 1\n            if count == n:\n                return b\n\ndef compare_one(a, b):\n    a_float = float(str(a).replace(',', '.'))\n    b_float = float(str(b).replace(',', '.'))\n    if a_float == b_float:\n        return None\n    elif a_float > b_float:\n        return a\n    else:\n        return b\n\ndef sort_even(l):\n    even_indices = [i for i, x in enumerate(l) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    \n    result = l[:]\n    for i, value in zip(even_indices, even_values):\n        result[i] = value\n    \n    return result\n\ndef search(lst):\n    freq_dict = {}\n    for num in lst:\n        freq_dict[num] = freq_dict.get(num, 0) + 1\n    \n    sorted_lst = sorted(lst)\n    for num in sorted_lst[::-1]:\n        if freq_dict[num] >= num:\n            return num\n    return -1\n\nimport heapq\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    pq = [(grid[0][0], 0, 0, [grid[0][0]])]\n    \n    while pq:\n        val, row, col, path = heapq.heappop(pq)\n        \n        if len(path) == k:\n            return path\n        \n        if row == n-1 and col == n-1:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < n and 0 <= nc < n:\n                heapq.heappush(pq, (val + grid[nr][nc], nr, nc, path + [grid[nr][nc]]))\n                \n    return []\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotated_alphabet = alphabet[2*2:] + alphabet[:2*2]\n    \n    def rotate_char(c):\n        if c in alphabet:\n            return rotated_alphabet[alphabet.index(c)]\n        else:\n            return c\n        \n    return ''.join(rotate_char(c) for c in s)\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    if not txt[-1].isalpha():\n        return False\n    words = txt.split()\n    if len(words[-1]) != 1:\n        return False\n    return True\n\ndef file_name_check(file_name):\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    name, extension = parts\n    if not name or not name[0].isalpha() or not extension in {'txt', 'exe', 'dll'}:\n        return 'No'\n    digit_count = sum(c.isdigit() for c in name)\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    words = s.split()\n    num_oranges = int(words[1])\n    num_apples = int(words[4])\n    num_mangoes = n - num_oranges - num_apples\n    return num_mangoes\n\nfrom sympy import isprime\n\ndef prime_fib(n):\n    a, b = 0, 1\n    count = 0\n    while True:\n        a, b = b, a + b\n        if isprime(b):\n            count += 1\n            if count == n:\n                return b\n\ndef compare_one(a, b):\n    a_float = float(str(a).replace(',', '.'))\n    b_float = float(str(b).replace(',', '.'))\n    if a_float == b_float:\n        return None\n    elif a_float > b_float:\n        return a\n    else:\n        return b\n\ndef sort_even(l):\n    even_indices = [i for i, x in enumerate(l) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    \n    result = l[:]\n    for i, value in zip(even_indices, even_values):\n        result[i] = value\n    \n    return result\n\ndef search(lst):\n    freq_dict = {}\n    for num in lst:\n        freq_dict[num] = freq_dict.get(num, 0) + 1\n    \n    sorted_lst = sorted(lst)\n    for num in sorted_lst[::-1]:\n        if freq_dict[num] >= num:\n            return num\n    return -1\n\nimport heapq\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    pq = [(grid[0][0], 0, 0, [grid[0][0]])]\n    \n    while pq:\n        val, row, col, path = heapq.heappop(pq)\n        \n        if len(path) == k:\n            return path\n        \n        if row == n-1 and col == n-1:\n            continue\n        \n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < n and 0 <= nc < n:\n                heapq.heappush(pq, (val + grid[nr][nc], nr, nc, path + [grid[nr][nc]]))\n                \n    return []\n```"], "prompt_tokens": [3977], "completion_tokens": [2298], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/130", "prompt": "\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n", "entry_point": "tri", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "sample_io": ["assert tri(3) == [1, 3, 2, 8]"], "source_codes": ["\ndef tri(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_fib(n: int):\n        fib1, fib2 = 0, 1\n        count = 0\n        \n        while True:\n            fib_next = fib1 + fib2\n            if is_prime(fib_next):\n                count += 1\n                if count == n:\n                    return fib_next\n            fib1, fib2 = fib2, fib_next\n\n    def encrypt(s):\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        result = []\n        \n        for char in s:\n            if char.isalpha():\n                idx = alphabet.index(char.lower())\n                new_idx = (idx + 4) % 26\n                result.append(alphabet[new_idx].upper() if char.isupper() else alphabet[new_idx]))\n            else:\n                result.append(char)\n        \n        return ''.join(result)\n\n    def check_if_last_char_is_a_letter(txt):\n        if not txt.strip():\n            return False\n        \n        stripped_txt = txt.strip()\n        if not stripped_txt[-1].isalpha():\n            return False\n        \n        if len(stripped_txt) > 1 and stripped_txt[-2] != ' ':\n            return False\n        \n        return True\n\n    def file_name_check(file_name):\n        pattern = r'^[a-zA-Z][^0-9]*\\d{0,3}[^0-9]*\\.(txt|exe|dll)$'\n        return 'Yes' if re.match(pattern, file_name) else 'No'\n\n    def fruit_distribution(s, n):\n        import re\n        apple_count = int(re.search(r'\\d+', s).group())\n        orange_count = int(re.search(r'\\d+', s, re.IGNORECASE).group())\n        mango_count = n - apple_count - orange_count\n        return mango_count\n\n    def compare_one(a, b):\n        if isinstance(a, str):\n            a = float(a.replace(',', '.'))\n        if isinstance(b, str):\n            b = float(b.replace(',', '.'))\n        \n        if a == b:\n            return None\n        elif a > b:\n            return a\n        else:\n            return b\n\n    def sort_even(l: list):\n        even_indices = [i for i in range(len(l)) if i % 2 == 0]\n        even_values = [l[i] for i in even_indices]\n        even_values.sort()\n        \n        for i, val in zip(even_indices, even_values):\n            l[i] = val\n        \n        return l\n\n    def search(lst):\n        from collections import Counter\n        freq_dict = Counter(lst)\n        lst_sorted = sorted(freq_dict.keys(), reverse=True)\n        \n        for num in lst_sorted:\n            if freq_dict[num] >= num:\n                return num\n        \n        return -1\n\n    if n == 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    \n    sequence = [1, 3]\n    for i in range(2, n):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            next_val = sequence[i - 1] + sequence[i - 2] + sequence[i + 1]\n            sequence.append(next_val)\n    \n    return sequence\n\n\n"], "responses": ["```python\ndef tri(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_fib(n: int):\n        fib1, fib2 = 0, 1\n        count = 0\n        \n        while True:\n            fib_next = fib1 + fib2\n            if is_prime(fib_next):\n                count += 1\n                if count == n:\n                    return fib_next\n            fib1, fib2 = fib2, fib_next\n\n    def encrypt(s):\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        result = []\n        \n        for char in s:\n            if char.isalpha():\n                idx = alphabet.index(char.lower())\n                new_idx = (idx + 4) % 26\n                result.append(alphabet[new_idx].upper() if char.isupper() else alphabet[new_idx]))\n            else:\n                result.append(char)\n        \n        return ''.join(result)\n\n    def check_if_last_char_is_a_letter(txt):\n        if not txt.strip():\n            return False\n        \n        stripped_txt = txt.strip()\n        if not stripped_txt[-1].isalpha():\n            return False\n        \n        if len(stripped_txt) > 1 and stripped_txt[-2] != ' ':\n            return False\n        \n        return True\n\n    def file_name_check(file_name):\n        pattern = r'^[a-zA-Z][^0-9]*\\d{0,3}[^0-9]*\\.(txt|exe|dll)$'\n        return 'Yes' if re.match(pattern, file_name) else 'No'\n\n    def fruit_distribution(s, n):\n        import re\n        apple_count = int(re.search(r'\\d+', s).group())\n        orange_count = int(re.search(r'\\d+', s, re.IGNORECASE).group())\n        mango_count = n - apple_count - orange_count\n        return mango_count\n\n    def compare_one(a, b):\n        if isinstance(a, str):\n            a = float(a.replace(',', '.'))\n        if isinstance(b, str):\n            b = float(b.replace(',', '.'))\n        \n        if a == b:\n            return None\n        elif a > b:\n            return a\n        else:\n            return b\n\n    def sort_even(l: list):\n        even_indices = [i for i in range(len(l)) if i % 2 == 0]\n        even_values = [l[i] for i in even_indices]\n        even_values.sort()\n        \n        for i, val in zip(even_indices, even_values):\n            l[i] = val\n        \n        return l\n\n    def search(lst):\n        from collections import Counter\n        freq_dict = Counter(lst)\n        lst_sorted = sorted(freq_dict.keys(), reverse=True)\n        \n        for num in lst_sorted:\n            if freq_dict[num] >= num:\n                return num\n        \n        return -1\n\n    if n == 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    \n    sequence = [1, 3]\n    for i in range(2, n):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            next_val = sequence[i - 1] + sequence[i - 2] + sequence[i + 1]\n            sequence.append(next_val)\n    \n    return sequence\n```"], "prompt_tokens": [3713], "completion_tokens": [2327], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/131", "prompt": "\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "sample_io": ["assert digits(1)  == 1", "assert digits(4)  == 0", "assert digits(235) == 15"], "source_codes": ["\ndef digits(n):\n    odd_digits = [int(d) for d in str(n) if int(d) % 2 != 0]\n    return prod(odd_digits) if odd_digits else 0\n\nfrom functools import reduce\nprod = lambda lst: reduce(lambda x, y: x * y, lst, 1)\n\n\n"], "responses": ["```python\ndef digits(n):\n    odd_digits = [int(d) for d in str(n) if int(d) % 2 != 0]\n    return prod(odd_digits) if odd_digits else 0\n\nfrom functools import reduce\nprod = lambda lst: reduce(lambda x, y: x * y, lst, 1)\n```"], "prompt_tokens": [4084], "completion_tokens": [2354], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/132", "prompt": "\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][]') \u279e True\n    '''\n", "entry_point": "is_nested", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][]') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "sample_io": ["assert is_nested('[[]]') == True", "assert is_nested('[]]]]]]][[[[[]') == False", "assert is_nested('[][]') == False", "assert is_nested('[]') == False", "assert is_nested('[[][]]') == True", "assert is_nested('[[]][]') == True"], "source_codes": ["\ndef is_nested(string):\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                nested = True\n    return nested and not stack\n\n\n"], "responses": ["```python\ndef is_nested(string):\n    stack = []\n    nested = False\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                nested = True\n    return nested and not stack\n```"], "prompt_tokens": [3258], "completion_tokens": [1410], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/133", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert sum_squares([1,2,3])==14", "assert sum_squares([1,4,9])==98", "assert sum_squares([1,3,5,7])==84", "assert sum_squares([1.4,4.2,0])==29", "assert sum_squares([-2.4,1,1])==6"], "source_codes": ["\nimport math\n\ndef sum_squares(lst):\n    return sum(math.ceil(x)**2 for x in lst)\n\n\n"], "responses": ["```python\nimport math\n\ndef sum_squares(lst):\n    return sum(math.ceil(x)**2 for x in lst)\n```"], "prompt_tokens": [3316], "completion_tokens": [1366], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/134", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "sample_io": ["assert check_if_last_char_is_a_letter(\"apple pie\") == False", "assert check_if_last_char_is_a_letter(\"apple pi e\") == True", "assert check_if_last_char_is_a_letter(\"apple pi e \") == False", "assert check_if_last_char_is_a_letter(\"\") == False"], "source_codes": ["\ndef check_if_last_char_is_a_letter(txt):\n    if txt == \"\":\n        return False\n    if txt[-1].isalpha():\n        words = txt.split()\n        last_word = words[-1]\n        if len(last_word) == 1:\n            return True\n    return False\n\n\n"], "responses": ["```python\ndef check_if_last_char_is_a_letter(txt):\n    if txt == \"\":\n        return False\n    if txt[-1].isalpha():\n        words = txt.split()\n        last_word = words[-1]\n        if len(last_word) == 1:\n            return True\n    return False\n```"], "prompt_tokens": [2493], "completion_tokens": [629], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/135", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "sample_io": ["assert can_arrange([1,2,4,3,5]) == 3", "assert can_arrange([1,2,3]) == -1"], "source_codes": ["\ndef can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1\n\n\n"], "responses": ["```python\ndef can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1\n```"], "prompt_tokens": [3312], "completion_tokens": [1494], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/136", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "sample_io": ["assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)", "assert largest_smallest_integers([]) == (None, None)", "assert largest_smallest_integers([0]) == (None, None)"], "source_codes": ["\ndef largest_smallest_integers(lst):\n    negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    largest_negative = max(negatives) if negatives else None\n    smallest_positive = min(positives) if positives else None\n    \n    return (largest_negative, smallest_positive)\n\n\n"], "responses": ["```python\ndef largest_smallest_integers(lst):\n    negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    largest_negative = max(negatives) if negatives else None\n    smallest_positive = min(positives) if positives else None\n    \n    return (largest_negative, smallest_positive)\n```"], "prompt_tokens": [3382], "completion_tokens": [1533], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/137", "prompt": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n", "entry_point": "compare_one", "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "sample_io": ["assert compare_one(1, 2.5) == 2.5", "assert compare_one(1, \"2,3\") == \"2,3\"", "assert compare_one(\"5,1\", \"6\") == \"6\"", "assert compare_one(\"1\", 1) == None"], "source_codes": ["\ndef encrypt(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    char_map = {original: rotated for original, rotated in zip(alphabet, rotated_alphabet)}\n    encrypted_s = ''.join(char_map.get(c, c) for c in s)\n    return encrypted_s\n\ndef check_if_last_char_is_a_letter(txt):\n    txt = txt.rstrip()\n    if not txt or not txt[-1].isalpha():\n        return False\n    words = txt.split()\n    return len(words[-1]) == 1\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}\\.[txt|exe|dll]{3}$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\ndef fruit_distribution(s, n):\n    numbers = re.findall(r'\\d+', s)\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    mangoes = n - apples - oranges\n    return mangoes\n\ndef prime_fib(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def generate_fibonacci():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = generate_fibonacci()\n    count = 0\n    for fib_num in fib_gen:\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\ndef compare_one(a, b):\n    def to_float(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return value\n    \n    a_float = to_float(a)\n    b_float = to_float(b)\n    \n    if a_float > b_float:\n        return a\n    elif b_float > a_float:\n        return b\n    else:\n        return None\n\ndef sort_even(l):\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    even_elements.sort()\n    sorted_list = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            sorted_list.append(even_elements[even_index])\n            even_index += 1\n        else:\n            sorted_list.append(l[i])\n    return sorted_list\n\ndef search(lst):\n    freq_dict = Counter(lst)\n    lst.sort()\n    for num in lst:\n        if freq_dict[num] >= num:\n            return num\n    return -1\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    char_map = {original: rotated for original, rotated in zip(alphabet, rotated_alphabet)}\n    encrypted_s = ''.join(char_map.get(c, c) for c in s)\n    return encrypted_s\n\ndef check_if_last_char_is_a_letter(txt):\n    txt = txt.rstrip()\n    if not txt or not txt[-1].isalpha():\n        return False\n    words = txt.split()\n    return len(words[-1]) == 1\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}\\.[txt|exe|dll]{3}$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\ndef fruit_distribution(s, n):\n    numbers = re.findall(r'\\d+', s)\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    mangoes = n - apples - oranges\n    return mangoes\n\ndef prime_fib(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def generate_fibonacci():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = generate_fibonacci()\n    count = 0\n    for fib_num in fib_gen:\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\ndef compare_one(a, b):\n    def to_float(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return value\n    \n    a_float = to_float(a)\n    b_float = to_float(b)\n    \n    if a_float > b_float:\n        return a\n    elif b_float > a_float:\n        return b\n    else:\n        return None\n\ndef sort_even(l):\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    even_elements.sort()\n    sorted_list = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            sorted_list.append(even_elements[even_index])\n            even_index += 1\n        else:\n            sorted_list.append(l[i])\n    return sorted_list\n\ndef search(lst):\n    freq_dict = Counter(lst)\n    lst.sort()\n    for num in lst:\n        if freq_dict[num] >= num:\n            return num\n    return -1\n```"], "prompt_tokens": [4348], "completion_tokens": [2993], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/138", "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n", "entry_point": "is_equal_to_sum_even", "canonical_solution": "    return n%2 == 0 and n >= 8\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "sample_io": ["assert is_equal_to_sum_even(4) == False", "assert is_equal_to_sum_even(6) == False", "assert is_equal_to_sum_even(8) == True"], "source_codes": ["\ndef is_equal_to_sum_even(n):\n    if n < 8 or n % 2 != 0:\n        return False\n    return True\n\n\n"], "responses": ["```python\ndef is_equal_to_sum_even(n):\n    if n < 8 or n % 2 != 0:\n        return False\n    return True\n```"], "prompt_tokens": [3377], "completion_tokens": [1604], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/139", "prompt": "\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "sample_io": ["assert special_factorial(4) == 288"], "source_codes": ["\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result\n\n\n"], "responses": ["```python\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result\n```"], "prompt_tokens": [3318], "completion_tokens": [1514], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/140", "prompt": "\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n", "entry_point": "fix_spaces", "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "sample_io": ["assert fix_spaces(\"Example\") == \"Example\"", "assert fix_spaces(\"Example 1\") == \"Example_1\"", "assert fix_spaces(\" Example 2\") == \"_Example_2\"", "assert fix_spaces(\" Example   3\") == \"_Example-3\""], "source_codes": ["\ndef fix_spaces(text):\n    text = text.replace(' ', '_')\n    if '_' in text:\n        parts = text.split('_')\n        fixed_parts = []\n        for part in parts:\n            if len(part) > 2:\n                fixed_parts.append('-')\n            else:\n                fixed_parts.append(part)\n        return ''.join(fixed_parts)\n    return text\n\n\n"], "responses": ["```python\ndef fix_spaces(text):\n    text = text.replace(' ', '_')\n    if '_' in text:\n        parts = text.split('_')\n        fixed_parts = []\n        for part in parts:\n            if len(part) > 2:\n                fixed_parts.append('-')\n            else:\n                fixed_parts.append(part)\n        return ''.join(fixed_parts)\n    return text\n```"], "prompt_tokens": [2869], "completion_tokens": [1081], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/141", "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n", "entry_point": "file_name_check", "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "sample_io": ["assert file_name_check(\"example.txt\") == 'Yes'", "asssert file_name_check(\"1example.dll\") == 'No'"], "source_codes": ["\ndef file_name_check(file_name):\n    if not file_name:\n        return 'No'\n    \n    parts = file_name.split('.')\n    \n    if len(parts) != 2:\n        return 'No'\n    \n    if not parts[0]:\n        return 'No'\n    \n    if not parts[0][0].isalpha():\n        return 'No'\n    \n    allowed_extensions = ['txt', 'exe', 'dll']\n    if parts[1] not in allowed_extensions:\n        return 'No'\n    \n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n    \n    return 'Yes'\n\n\n"], "responses": ["```python\ndef file_name_check(file_name):\n    if not file_name:\n        return 'No'\n    \n    parts = file_name.split('.')\n    \n    if len(parts) != 2:\n        return 'No'\n    \n    if not parts[0]:\n        return 'No'\n    \n    if not parts[0][0].isalpha():\n        return 'No'\n    \n    allowed_extensions = ['txt', 'exe', 'dll']\n    if parts[1] not in allowed_extensions:\n        return 'No'\n    \n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n    \n    return 'Yes'\n```"], "prompt_tokens": [2708], "completion_tokens": [760], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/142", "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "sample_io": ["assert sum_squares([1,2,3]) == 6", "assert sum_squares([]) == 0", "assert sum_squares([-1,-5,2,-1,-5]) == -126"], "source_codes": ["\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    mapping = {original: encrypted for original, encrypted in zip(alphabet, shifted_alphabet)}\n    \n    encrypted_str = ''.join(mapping.get(char, char) for char in s)\n    return encrypted_str\n\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    txt = txt.rstrip()\n    if not txt[-1].isalpha():\n        return False\n    \n    if len(txt) > 1 and txt[-2].isalpha():\n        return False\n    \n    return True\n\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.(txt|exe|dll)$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\n\ndef fruit_distribution(s, n):\n    counts = re.findall(r'\\d+', s)\n    apple_count = int(counts[0])\n    orange_count = int(counts[1])\n    return n - apple_count - orange_count\n\n\ndef prime_fib(n: int):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield b\n            a, b = b, a + b\n\n    fib_gen = fib_generator()\n    count = 0\n    while True:\n        fib_num = next(fib_gen)\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\n\ndef compare_one(a, b):\n    types = (int, float, str)\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    \n    if a == b:\n        return None\n    elif a > b:\n        return a\n    else:\n        return b\n\n\ndef sort_even(l: list):\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices])\n    \n    result = l[:]\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n    \n    return result\n\n\ndef search(lst):\n    freq = Counter(lst)\n    for num in sorted(lst, reverse=True):\n        if freq[num] >= num:\n            return num\n    return -1\n\n\ndef sum_squares(lst):\n    total_sum = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            total_sum += num ** 2\n        elif i % 4 == 0:\n            total_sum += num ** 3\n        else:\n            total_sum += num\n    return total_sum\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    mapping = {original: encrypted for original, encrypted in zip(alphabet, shifted_alphabet)}\n    \n    encrypted_str = ''.join(mapping.get(char, char) for char in s)\n    return encrypted_str\n\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    txt = txt.rstrip()\n    if not txt[-1].isalpha():\n        return False\n    \n    if len(txt) > 1 and txt[-2].isalpha():\n        return False\n    \n    return True\n\n\ndef file_name_check(file_name):\n    pattern = r'^[a-zA-Z][^\\d]*\\d{0,3}[^\\d]*\\.(txt|exe|dll)$'\n    return 'Yes' if re.match(pattern, file_name) else 'No'\n\n\ndef fruit_distribution(s, n):\n    counts = re.findall(r'\\d+', s)\n    apple_count = int(counts[0])\n    orange_count = int(counts[1])\n    return n - apple_count - orange_count\n\n\ndef prime_fib(n: int):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield b\n            a, b = b, a + b\n\n    fib_gen = fib_generator()\n    count = 0\n    while True:\n        fib_num = next(fib_gen)\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\n\ndef compare_one(a, b):\n    types = (int, float, str)\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    \n    if a == b:\n        return None\n    elif a > b:\n        return a\n    else:\n        return b\n\n\ndef sort_even(l: list):\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices])\n    \n    result = l[:]\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n    \n    return result\n\n\ndef search(lst):\n    freq = Counter(lst)\n    for num in sorted(lst, reverse=True):\n        if freq[num] >= num:\n            return num\n    return -1\n\n\ndef sum_squares(lst):\n    total_sum = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            total_sum += num ** 2\n        elif i % 4 == 0:\n            total_sum += num ** 3\n        else:\n            total_sum += num\n    return total_sum\n```"], "prompt_tokens": [3439], "completion_tokens": [2088], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/143", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n", "entry_point": "words_in_sentence", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "sample_io": ["assert words_in_sentence(\"This is a test\") == \"is\"", "assert words_in_sentence(\"lets go for swimming\") == \"go for\""], "source_codes": ["\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef extract_words(sentence):\n    return sentence.split()\n\ndef filter_prime_length_words(words):\n    return [word for word in words if is_prime(len(word))]\n\ndef words_in_sentence(sentence):\n    words = extract_words(sentence)\n    prime_length_words = filter_prime_length_words(words)\n    return ' '.join(prime_length_words)\n\n# Test cases\nprint(words_in_sentence(\"This is a test\"))  # Output: \"is\"\nprint(words_in_sentence(\"lets go for swimming\"))  # Output: \"go for\"\n\n\n"], "responses": ["```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef extract_words(sentence):\n    return sentence.split()\n\ndef filter_prime_length_words(words):\n    return [word for word in words if is_prime(len(word))]\n\ndef words_in_sentence(sentence):\n    words = extract_words(sentence)\n    prime_length_words = filter_prime_length_words(words)\n    return ' '.join(prime_length_words)\n\n# Test cases\nprint(words_in_sentence(\"This is a test\"))  # Output: \"is\"\nprint(words_in_sentence(\"lets go for swimming\"))  # Output: \"go for\"\n```"], "prompt_tokens": [2635], "completion_tokens": [890], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/144", "prompt": "\ndef simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "sample_io": ["assert simplify(\"1/5\", \"5/1\") == True", "assert simplify(\"1/6\", \"2/1\") == False", "assert simplify(\"7/10\", \"10/2\") == False"], "source_codes": ["\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    table = str.maketrans(alphabet, shifted_alphabet)\n    return s.translate(table)\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    words = txt.split()\n    last_word = words[-1]\n    if len(last_word) != 1 or not last_word.isalpha():\n        return False\n    return True\n\ndef file_name_check(file_name):\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    \n    prefix, suffix = parts\n    if not prefix or not prefix[0].isalpha() or not suffix in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    match = re.match(r'(\\d+) apples and (\\d+) oranges', s)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    \n    apples, oranges = map(int, match.groups())\n    mangoes = n - (apples + oranges)\n    return mangoes\n\ndef prime_fib(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    count = 0\n    for fib_num in fib_generator():\n        if fib_num > 0 and is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\ndef compare_one(a, b):\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n        return float(value)\n    \n    a_float = to_float(a)\n    b_float = to_float(b)\n    \n    if a_float == b_float:\n        return None\n    elif a_float > b_float:\n        return a\n    else:\n        return b\n\ndef sort_even(l):\n    even_indices_values = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n    return result\n\ndef search(lst):\n    freq = Counter(lst)\n    max_val = -1\n    for key, val in freq.items():\n        if key <= val and key > max_val:\n            max_val = key\n    return max_val\n\ndef simplify(x, n):\n    x_parts = x.split('/')\n    n_parts = n.split('/')\n    x_num, x_denom = int(x_parts[0]), int(x_parts[1])\n    n_num, n_denom = int(n_parts[0]), int(n_parts[1])\n    \n    gcd = lambda a, b: a if b == 0 else gcd(b, a % b)\n    lcm = lambda a, b: abs(a*b) // gcd(a, b)\n    \n    combined_numerator = x_num * n_num\n    combined_denominator = x_denom * n_denom\n    \n    simplified_numerator = combined_numerator // gcd(combined_numerator, combined_denominator)\n    simplified_denominator = combined_denominator // gcd(combined_numerator, combined_denominator)\n    \n    return simplified_denominator == 1\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    table = str.maketrans(alphabet, shifted_alphabet)\n    return s.translate(table)\n\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    words = txt.split()\n    last_word = words[-1]\n    if len(last_word) != 1 or not last_word.isalpha():\n        return False\n    return True\n\ndef file_name_check(file_name):\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    \n    prefix, suffix = parts\n    if not prefix or not prefix[0].isalpha() or not suffix in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'\n\ndef fruit_distribution(s, n):\n    match = re.match(r'(\\d+) apples and (\\d+) oranges', s)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    \n    apples, oranges = map(int, match.groups())\n    mangoes = n - (apples + oranges)\n    return mangoes\n\ndef prime_fib(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def fib_generator():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    count = 0\n    for fib_num in fib_generator():\n        if fib_num > 0 and is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\ndef compare_one(a, b):\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n        return float(value)\n    \n    a_float = to_float(a)\n    b_float = to_float(b)\n    \n    if a_float == b_float:\n        return None\n    elif a_float > b_float:\n        return a\n    else:\n        return b\n\ndef sort_even(l):\n    even_indices_values = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n    return result\n\ndef search(lst):\n    freq = Counter(lst)\n    max_val = -1\n    for key, val in freq.items():\n        if key <= val and key > max_val:\n            max_val = key\n    return max_val\n\ndef simplify(x, n):\n    x_parts = x.split('/')\n    n_parts = n.split('/')\n    x_num, x_denom = int(x_parts[0]), int(x_parts[1])\n    n_num, n_denom = int(n_parts[0]), int(n_parts[1])\n    \n    gcd = lambda a, b: a if b == 0 else gcd(b, a % b)\n    lcm = lambda a, b: abs(a*b) // gcd(a, b)\n    \n    combined_numerator = x_num * n_num\n    combined_denominator = x_denom * n_denom\n    \n    simplified_numerator = combined_numerator // gcd(combined_numerator, combined_denominator)\n    simplified_denominator = combined_denominator // gcd(combined_numerator, combined_denominator)\n    \n    return simplified_denominator == 1\n```"], "prompt_tokens": [3887], "completion_tokens": [2774], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/145", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]", "assert order_by_points([]) == []"], "source_codes": ["\ndef order_by_points(nums):\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n\n\n"], "responses": ["```python\ndef order_by_points(nums):\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n```"], "prompt_tokens": [2921], "completion_tokens": [1076], "no_of_try": 1, "is_solved": false, "language": "Python3"}
{"task_id": "HumanEval/146", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "sample_io": ["assert specialFilter([15, -73, 14, -15]) == 1", "assert specialFilter([33, -2, -3, 45, 21, 109]) == 2"], "source_codes": ["\ndef specialFilter(nums):\n    return len([num for num in nums if num > 10 and str(num)[0] in '13579' and str(num)[-1] in '13579'])\n\n\n"], "responses": ["```python\ndef specialFilter(nums):\n    return len([num for num in nums if num > 10 and str(num)[0] in '13579' and str(num)[-1] in '13579'])\n```"], "prompt_tokens": [4109], "completion_tokens": [2249], "no_of_try": 1, "is_solved": true, "language": "Python3"}
