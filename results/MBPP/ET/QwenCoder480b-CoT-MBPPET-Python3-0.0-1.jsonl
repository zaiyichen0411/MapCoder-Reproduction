{"name": "mbpp_3_is_not_prime", "language": "Python3", "prompt": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to identify non-prime numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_not_prime", "test": "def check(candidate):\n    assert candidate(2) == False\n    assert candidate(10) == True\n    assert candidate(35) == True\n    assert candidate(37) == False\n\ndef test_check():\n    check(is_not_prime)\n\ntest_check()\n", "sample_io": ["assert is_not_prime(2) == False"], "source_codes": ["\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n```"], "prompt_tokens": [75], "completion_tokens": [80], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_3_is_not_prime"}
{"name": "mbpp_4_heap_queue_largest", "language": "Python3", "prompt": "from typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_queue_largest", "test": "def check(candidate):\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n\ndef test_check():\n    check(heap_queue_largest)\n\ntest_check()\n", "sample_io": ["assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"], "source_codes": ["\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to get n largest elements in descending order\n    return heapq.nlargest(n, nums)\n\n\n"], "responses": ["```python\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to get n largest elements in descending order\n    return heapq.nlargest(n, nums)\n```"], "prompt_tokens": [97], "completion_tokens": [106], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_4_heap_queue_largest"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has only one bit set)\n    # A number is power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n\n\n"], "responses": ["```python\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has only one bit set)\n    # A number is power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n```"], "prompt_tokens": [90], "completion_tokens": [166], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_8_square_nums", "language": "Python3", "prompt": "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find squares of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30]) == [100, 400, 900]\n    assert candidate([12, 15]) == [144, 225]\n\ndef test_check():\n    check(square_nums)\n\ntest_check()\n", "sample_io": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]\n\n\n"], "responses": ["```python\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_8_square_nums"}
{"name": "mbpp_9_find_Rotations", "language": "Python3", "prompt": "def find_Rotations(str: str) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Rotations", "test": "def check(candidate):\n    assert candidate('aaaa') == 1\n    assert candidate('ab') == 2\n    assert candidate('abc') == 3\n\ndef test_check():\n    check(find_Rotations)\n\ntest_check()\n", "sample_io": ["assert find_Rotations('aaaa') == 1"], "source_codes": ["\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Try all possible rotations from 1 to n-1\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        # Check if rotated string is same as original\n        if rotated == str:\n            return i\n    \n    # If no rotation found (should not happen for valid input), return length\n    return n\n\n\n"], "responses": ["```python\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Try all possible rotations from 1 to n-1\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        # Check if rotated string is same as original\n        if rotated == str:\n            return i\n    \n    # If no rotation found (should not happen for valid input), return length\n    return n\n```"], "prompt_tokens": [89], "completion_tokens": [137], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_9_find_Rotations"}
{"name": "mbpp_11_remove_Occ", "language": "Python3", "prompt": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n\tWrite a python function to remove first and last occurrence of a given character from the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_Occ", "test": "def check(candidate):\n    assert candidate('hello', 'l') == 'heo'\n    assert candidate('abcda', 'a') == 'bcd'\n    assert candidate('PHP', 'P') == 'H'\n\ndef test_check():\n    check(remove_Occ)\n\ntest_check()\n", "sample_io": ["assert remove_Occ('hello', 'l') == 'heo'"], "source_codes": ["\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n\n\n"], "responses": ["```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [197], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_11_remove_Occ"}
{"name": "mbpp_12_sort_matrix", "language": "Python3", "prompt": "from typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_matrix", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    assert candidate([[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n    assert candidate([[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\n\ndef test_check():\n    check(sort_matrix)\n\ntest_check()\n", "sample_io": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"], "source_codes": ["\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(M, key=lambda row: sum(row))\n\n\n"], "responses": ["```python\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(M, key=lambda row: sum(row))\n```"], "prompt_tokens": [91], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_12_sort_matrix"}
{"name": "mbpp_14_find_Volume", "language": "Python3", "prompt": "def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n\tWrite a python function to find the volume of a triangular prism.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Volume", "test": "def check(candidate):\n    assert candidate(10, 8, 6) == 240\n    assert candidate(3, 2, 2) == 6\n    assert candidate(1, 2, 1) == 1\n\ndef test_check():\n    check(find_Volume)\n\ntest_check()\n", "sample_io": ["assert find_Volume(10, 8, 6) == 240"], "source_codes": ["\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: length of the triangular base\n        b: base of the triangular base\n        h: height of the prism\n    \n    Returns:\n        Volume of the triangular prism\n    \"\"\"\n    # Volume of triangular prism = (1/2 * base_area) * height_of_prism\n    # Assuming the base is a right triangle with legs l and b\n    base_area = 0.5 * l * b\n    volume = base_area * h\n    return int(volume)\n\n\n"], "responses": ["```python\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: length of the triangular base\n        b: base of the triangular base\n        h: height of the prism\n    \n    Returns:\n        Volume of the triangular prism\n    \"\"\"\n    # Volume of triangular prism = (1/2 * base_area) * height_of_prism\n    # Assuming the base is a right triangle with legs l and b\n    base_area = 0.5 * l * b\n    volume = base_area * h\n    return int(volume)\n```"], "prompt_tokens": [85], "completion_tokens": [139], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_14_find_Volume"}
{"name": "mbpp_16_text_lowercase_underscore", "language": "Python3", "prompt": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n\tWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_lowercase_underscore", "test": "def check(candidate):\n    assert candidate('aab_cbbbc') == True\n    assert candidate('aab_Abbbc') == False\n    assert candidate('Aaab_abbbc') == False\n\ndef test_check():\n    check(text_lowercase_underscore)\n\ntest_check()\n", "sample_io": ["assert text_lowercase_underscore('aab_cbbbc') == True"], "source_codes": ["\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))\n```"], "prompt_tokens": [89], "completion_tokens": [70], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_16_text_lowercase_underscore"}
{"name": "mbpp_17_square_perimeter", "language": "Python3", "prompt": "def square_perimeter(a: int) -> int:\n    \"\"\"\n\tWrite a function that returns the perimeter of a square given its side length as input.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_perimeter", "test": "def check(candidate):\n    assert candidate(10) == 40\n    assert candidate(5) == 20\n    assert candidate(4) == 16\n\ndef test_check():\n    check(square_perimeter)\n\ntest_check()\n", "sample_io": ["assert square_perimeter(10) == 40"], "source_codes": ["\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n\n\n"], "responses": ["```python\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n```"], "prompt_tokens": [81], "completion_tokens": [44], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_17_square_perimeter"}
{"name": "mbpp_18_remove_dirty_chars", "language": "Python3", "prompt": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n\tWrite a function to remove characters from the first string which are present in the second string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_dirty_chars", "test": "def check(candidate):\n    assert candidate('probasscurve', 'pros') == 'bacuve'\n    assert candidate('digitalindia', 'talent') == 'digiidi'\n    assert candidate('exoticmiles', 'toxic') == 'emles'\n\ndef test_check():\n    check(remove_dirty_chars)\n\ntest_check()\n", "sample_io": ["assert remove_dirty_chars('probasscurve', 'pros') == 'bacuve'"], "source_codes": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n    \"\"\"\n    # Create a set of characters from the second string for efficient lookup\n    dirty_chars = set(second_string)\n    \n    # Build result string by including only characters not in the dirty set\n    result = ''.join(char for char in string if char not in dirty_chars)\n    \n    return result\n\n\n"], "responses": ["```python\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n    \"\"\"\n    # Create a set of characters from the second string for efficient lookup\n    dirty_chars = set(second_string)\n    \n    # Build result string by including only characters not in the dirty set\n    result = ''.join(char for char in string if char not in dirty_chars)\n    \n    return result\n```"], "prompt_tokens": [87], "completion_tokens": [105], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_18_remove_dirty_chars"}
{"name": "mbpp_19_test_duplicate", "language": "Python3", "prompt": "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to find whether a given array of integers contains any duplicate element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_duplicate", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 4]) == True\n    assert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True\n\ndef test_check():\n    check(test_duplicate)\n\ntest_check()\n", "sample_io": ["assert test_duplicate([1, 2, 3, 4, 5]) == False"], "source_codes": ["\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n\n"], "responses": ["```python\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n```"], "prompt_tokens": [86], "completion_tokens": [69], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_19_test_duplicate"}
{"name": "mbpp_20_is_woodall", "language": "Python3", "prompt": "def is_woodall(x: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given number is woodball or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_woodall", "test": "def check(candidate):\n    assert candidate(383) == True\n    assert candidate(254) == False\n    assert candidate(200) == False\n\ndef test_check():\n    check(is_woodall)\n\ntest_check()\n", "sample_io": ["assert is_woodall(383) == True"], "source_codes": ["\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Check if the given number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \"\"\"\n    if x < 1:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n\n\n"], "responses": ["Looking at this problem, I need to determine if a given number is a Woodall number.\n\nA Woodall number is a number of the form n \u00d7 2^n - 1, where n is a positive integer.\n\nLet me think through the approach:\n1. For a given number x, I need to check if there exists a positive integer n such that x = n \u00d7 2^n - 1\n2. This can be rewritten as x + 1 = n \u00d7 2^n\n3. I can iterate through possible values of n and check if the equation holds\n4. Since 2^n grows very quickly, I don't need to check many values\n\nLet me trace through a few examples:\n- For n=1: 1 \u00d7 2^1 - 1 = 2 - 1 = 1\n- For n=2: 2 \u00d7 2^2 - 1 = 8 - 1 = 7\n- For n=3: 3 \u00d7 2^3 - 1 = 24 - 1 = 23\n- For n=4: 4 \u00d7 2^4 - 1 = 64 - 1 = 63\n\n```python\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Check if the given number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \"\"\"\n    if x < 1:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n```"], "prompt_tokens": [80], "completion_tokens": [377], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_20_is_woodall"}
{"name": "mbpp_56_checks", "language": "Python3", "prompt": "def checks(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check if a given number is one less than twice its reverse.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "checks", "test": "def check(candidate):\n    assert candidate(70) == False\n    assert candidate(23) == False\n    assert candidate(73) == True\n\ndef test_check():\n    check(checks)\n\ntest_check()\n", "sample_io": ["assert checks(70) == False"], "source_codes": ["\ndef checks(n: int) -> bool:\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    # Convert number to string to easily reverse it\n    str_n = str(n)\n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    # Check if n equals twice its reverse minus 1\n    return n == 2 * reversed_n - 1\n\n\n"], "responses": ["```python\ndef checks(n: int) -> bool:\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    # Convert number to string to easily reverse it\n    str_n = str(n)\n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    # Check if n equals twice its reverse minus 1\n    return n == 2 * reversed_n - 1\n```"], "prompt_tokens": [80], "completion_tokens": [97], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_56_checks"}
{"name": "mbpp_57_find_Max_Num", "language": "Python3", "prompt": "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest number that can be formed with the given list of digits.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Max_Num", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 321\n    assert candidate([4, 5, 6, 1]) == 6541\n    assert candidate([1, 2, 3, 9]) == 9321\n\ndef test_check():\n    check(find_Max_Num)\n\ntest_check()\n", "sample_io": ["assert find_Max_Num([1, 2, 3]) == 321"], "source_codes": ["\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest number that can be formed with the given list of digits.\n    \"\"\"\n    # Convert all digits to strings for easy comparison\n    str_arr = [str(digit) for digit in arr]\n    \n    # Sort the array in descending order based on string comparison\n    # We compare 'a' + 'b' vs 'b' + 'a' to determine which combination is larger\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all digits are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all digits to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n\n\n"], "responses": ["```python\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest number that can be formed with the given list of digits.\n    \"\"\"\n    # Convert all digits to strings for easy comparison\n    str_arr = [str(digit) for digit in arr]\n    \n    # Sort the array in descending order based on string comparison\n    # We compare 'a' + 'b' vs 'b' + 'a' to determine which combination is larger\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all digits are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all digits to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n```"], "prompt_tokens": [90], "completion_tokens": [184], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_57_find_Max_Num"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n\n\n"], "responses": ["```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n```"], "prompt_tokens": [86], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": ["\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n\u00b2 - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n\n\n"], "responses": ["```python\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n\u00b2 - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n```"], "prompt_tokens": [75], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_59_is_octagonal"}
{"name": "mbpp_61_count_Substrings", "language": "Python3", "prompt": "def count_Substrings(s: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Substrings", "test": "def check(candidate):\n    assert candidate('112112') == 6\n    assert candidate('111') == 6\n    assert candidate('1101112') == 12\n\ndef test_check():\n    check(count_Substrings)\n\ntest_check()\n", "sample_io": ["assert count_Substrings('112112') == 6"], "source_codes": ["\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    \n    # For each starting position\n    for i in range(n):\n        digit_sum = 0\n        # For each ending position from current start\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            length = j - i + 1\n            # Check if sum of digits equals length\n            if digit_sum == length:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["Looking at this problem, I need to count substrings where the sum of digits equals the length of the substring.\n\nLet me think through the approach:\n1. For each possible substring, calculate the sum of its digits\n2. Check if this sum equals the length of the substring\n3. Count all such substrings\n\nI can optimize this using a prefix sum approach:\n- For each position, I'll track the cumulative difference between digit sum and length\n- When two positions have the same difference, the substring between them satisfies our condition\n\n```python\ndef count_Substrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    \n    # For each starting position\n    for i in range(n):\n        digit_sum = 0\n        # For each ending position from current start\n        for j in range(i, n):\n            digit_sum += int(s[j])\n            length = j - i + 1\n            # Check if sum of digits equals length\n            if digit_sum == length:\n                count += 1\n    \n    return count\n```"], "prompt_tokens": [85], "completion_tokens": [222], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_61_count_Substrings"}
{"name": "mbpp_62_smallest_num", "language": "Python3", "prompt": "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "smallest_num", "test": "def check(candidate):\n    assert candidate([10, 20, 1, 45, 99]) == 1\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([45, 46, 50, 60]) == 45\n\ndef test_check():\n    check(smallest_num)\n\ntest_check()\n", "sample_io": ["assert smallest_num([10, 20, 1, 45, 99]) == 1"], "source_codes": ["\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    return min(xs)\n\n\n"], "responses": ["```python\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    return min(xs)\n```"], "prompt_tokens": [81], "completion_tokens": [84], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_62_smallest_num"}
{"name": "mbpp_63_max_difference", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between available pairs in the given tuple list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_difference", "test": "def check(candidate):\n    assert candidate([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    assert candidate([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    assert candidate([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n\ndef test_check():\n    check(max_difference)\n\ntest_check()\n", "sample_io": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"], "source_codes": ["\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[1] - pair[0])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum difference between available pairs in a list of tuples.\n\nLet me think step by step:\n1. Each tuple contains two integers\n2. I need to calculate the difference for each pair\n3. Return the maximum difference found\n\nThe difference could be interpreted as the absolute difference between the two elements in each tuple, or it could be the difference (second - first) for each tuple. Given the phrasing \"maximum difference between available pairs\", I'll interpret this as finding the maximum absolute difference among all tuples.\n\n```python\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[1] - pair[0])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n```"], "prompt_tokens": [93], "completion_tokens": [206], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_63_max_difference"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "responses": ["```python\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n```"], "prompt_tokens": [98], "completion_tokens": [62], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total\n\n\n"], "responses": ["```python\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total\n```"], "prompt_tokens": [93], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_66_pos_count", "language": "Python3", "prompt": "from typing import List\n\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of positive numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pos_count", "test": "def check(candidate):\n    assert candidate([1, -2, 3, -4]) == 2\n    assert candidate([3, 4, 5, -1]) == 3\n    assert candidate([1, 2, 3, 4]) == 4\n\ndef test_check():\n    check(pos_count)\n\ntest_check()\n", "sample_io": ["assert pos_count([1, -2, 3, -4]) == 2"], "source_codes": ["\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n```"], "prompt_tokens": [84], "completion_tokens": [65], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_66_pos_count"}
{"name": "mbpp_67_bell_number", "language": "Python3", "prompt": "def bell_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the number of ways to partition a set of Bell numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(10) == 115975\n    assert candidate(56) == 6775685320645824322581483068371419745979053216268760300\n\ndef test_check():\n    check(bell_number)\n\ntest_check()\n", "sample_io": ["assert bell_number(2) == 2"], "source_codes": ["\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Args:\n        n: Non-negative integer representing the size of the set\n        \n    Returns:\n        The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Initialize Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle using the recurrence relation\n    for i in range(1, n + 1):\n        # First element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]\n\n\n"], "responses": ["```python\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Args:\n        n: Non-negative integer representing the size of the set\n        \n    Returns:\n        The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Initialize Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle using the recurrence relation\n    for i in range(1, n + 1):\n        # First element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]\n```"], "prompt_tokens": [80], "completion_tokens": [244], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_67_bell_number"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Check whether the given array is monotonic or not.\n    An array is monotonic if it is either entirely non-increasing or non-decreasing.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    increasing = True\n    for i in range(1, len(A)):\n        if A[i] < A[i-1]:\n            increasing = False\n            break\n    \n    # If it's increasing, return True\n    if increasing:\n        return True\n    \n    # Check if array is monotonic decreasing\n    decreasing = True\n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            decreasing = False\n            break\n    \n    return decreasing\n\n\n"], "responses": ["```python\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Check whether the given array is monotonic or not.\n    An array is monotonic if it is either entirely non-increasing or non-decreasing.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    increasing = True\n    for i in range(1, len(A)):\n        if A[i] < A[i-1]:\n            increasing = False\n            break\n    \n    # If it's increasing, return True\n    if increasing:\n        return True\n    \n    # Check if array is monotonic decreasing\n    decreasing = True\n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            decreasing = False\n            break\n    \n    return decreasing\n```"], "prompt_tokens": [88], "completion_tokens": [179], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n    \"\"\"\n    if not s:  # Empty list is a sublist of any list\n        return True\n    \n    if len(s) > len(l):  # Sublist cannot be longer than the main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if the sublist matches at this position\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n    \"\"\"\n    if not s:  # Empty list is a sublist of any list\n        return True\n    \n    if len(s) > len(l):  # Sublist cannot be longer than the main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if the sublist matches at this position\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n```"], "prompt_tokens": [90], "completion_tokens": [142], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_70_get_equal", "language": "Python3", "prompt": "from typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to find whether all the given lists have equal length or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_equal", "test": "def check(candidate):\n    assert candidate([[11, 22, 33], [44, 55, 66]]) == True\n    assert candidate([[1, 2, 3], [4, 5, 6, 7]]) == False\n    assert candidate([[1, 2], [3, 4]]) == True\n\ndef test_check():\n    check(get_equal)\n\ntest_check()\n", "sample_io": ["assert get_equal([[11, 22, 33], [44, 55, 66]]) == True"], "source_codes": ["\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to find whether all the given lists have equal length or not.\n    \"\"\"\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    \n    for lst in Input:\n        if len(lst) != first_length:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to find whether all the given lists have equal length or not.\n    \"\"\"\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    \n    for lst in Input:\n        if len(lst) != first_length:\n            return False\n    \n    return True\n```"], "prompt_tokens": [86], "completion_tokens": [80], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_70_get_equal"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": ["\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using comb sort algorithm.\n    \"\"\"\n    if not nums:\n        return nums\n    \n    n = len(nums)\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Calculate next gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n            \n        swapped = False\n        \n        # Compare elements with current gap\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                # Swap elements\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    \n    return nums\n\n\n"], "responses": ["```python\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using comb sort algorithm.\n    \"\"\"\n    if not nums:\n        return nums\n    \n    n = len(nums)\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Calculate next gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n            \n        swapped = False\n        \n        # Compare elements with current gap\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                # Swap elements\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    \n    return nums\n```"], "prompt_tokens": [80], "completion_tokens": [169], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_72_dif_Square", "language": "Python3", "prompt": "def dif_Square(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dif_Square", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(10) == False\n    assert candidate(15) == True\n\ndef test_check():\n    check(dif_Square)\n\ntest_check()\n", "sample_io": ["assert dif_Square(5) == True"], "source_codes": ["\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n \u2262 2 (mod 4)).\n    \n    This is because:\n    - If n = a\u00b2 - b\u00b2 = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even: n is divisible by 4\n    - If both are odd: n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n\n\n"], "responses": ["```python\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n \u2262 2 (mod 4)).\n    \n    This is because:\n    - If n = a\u00b2 - b\u00b2 = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even: n is divisible by 4\n    - If both are odd: n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n```"], "prompt_tokens": [86], "completion_tokens": [177], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_72_dif_Square"}
{"name": "mbpp_74_is_samepatterns", "language": "Python3", "prompt": "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n\tWrite a function to check whether it follows the sequence given in the patterns array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_samepatterns", "test": "def check(candidate):\n    assert candidate(['red', 'green', 'green'], ['a', 'b', 'b']) == True\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b', 'b']) == False\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b']) == False\n\ndef test_check():\n    check(is_samepatterns)\n\ntest_check()\n", "sample_io": ["assert is_samepatterns(['red', 'green', 'green'], ['a', 'b', 'b']) == True"], "source_codes": ["\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Check whether the colors follow the same sequence pattern as the patterns array.\n    \n    Args:\n        colors: List of color strings\n        patterns: List of pattern strings\n    \n    Returns:\n        bool: True if colors follow the same pattern as patterns, False otherwise\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from pattern to color and color to pattern\n    pattern_to_color = {}\n    color_to_pattern = {}\n    \n    for i in range(len(patterns)):\n        pattern = patterns[i]\n        color = colors[i]\n        \n        # Check if pattern already mapped to a different color\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n        \n        # Check if color already mapped to a different pattern\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n    \n    return True\n\n\n"], "responses": ["```python\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Check whether the colors follow the same sequence pattern as the patterns array.\n    \n    Args:\n        colors: List of color strings\n        patterns: List of pattern strings\n    \n    Returns:\n        bool: True if colors follow the same pattern as patterns, False otherwise\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from pattern to color and color to pattern\n    pattern_to_color = {}\n    color_to_pattern = {}\n    \n    for i in range(len(patterns)):\n        pattern = patterns[i]\n        color = colors[i]\n        \n        # Check if pattern already mapped to a different color\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n        \n        # Check if color already mapped to a different pattern\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n    \n    return True\n```"], "prompt_tokens": [91], "completion_tokens": [240], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_74_is_samepatterns"}
{"name": "mbpp_75_find_tuples", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n\tWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_tuples", "test": "def check(candidate):\n    assert candidate([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    assert candidate([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]\n    assert candidate([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]\n\ndef test_check():\n    check(find_tuples)\n\ntest_check()\n", "sample_io": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"], "source_codes": ["\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        if all(element % K == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return result\n\n\n"], "responses": ["```python\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        if all(element % K == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return result\n```"], "prompt_tokens": [109], "completion_tokens": [96], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_75_find_tuples"}
{"name": "mbpp_77_is_Diff", "language": "Python3", "prompt": "def is_Diff(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether a number is divisible by 11.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Diff", "test": "def check(candidate):\n    assert candidate(12345) == False\n    assert candidate(1212112) == True\n    assert candidate(1212) == False\n\ndef test_check():\n    check(is_Diff)\n\ntest_check()\n", "sample_io": ["assert is_Diff(12345) == False"], "source_codes": ["\ndef is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n    \"\"\"\n    # Convert number to string to easily access digits\n    n_str = str(abs(n))  # Use absolute value to handle negative numbers\n    \n    # Calculate sum of digits at odd positions (1-indexed)\n    odd_sum = sum(int(n_str[i]) for i in range(0, len(n_str), 2))\n    \n    # Calculate sum of digits at even positions (1-indexed)\n    even_sum = sum(int(n_str[i]) for i in range(1, len(n_str), 2))\n    \n    # Check if the difference is divisible by 11\n    return (odd_sum - even_sum) % 11 == 0\n\n\n"], "responses": ["```python\ndef is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n    \"\"\"\n    # Convert number to string to easily access digits\n    n_str = str(abs(n))  # Use absolute value to handle negative numbers\n    \n    # Calculate sum of digits at odd positions (1-indexed)\n    odd_sum = sum(int(n_str[i]) for i in range(0, len(n_str), 2))\n    \n    # Calculate sum of digits at even positions (1-indexed)\n    even_sum = sum(int(n_str[i]) for i in range(1, len(n_str), 2))\n    \n    # Check if the difference is divisible by 11\n    return (odd_sum - even_sum) % 11 == 0\n```"], "prompt_tokens": [80], "completion_tokens": [174], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_77_is_Diff"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "responses": ["```python\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n```"], "prompt_tokens": [80], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    The nth tetrahedral number is the sum of the first n triangular numbers,\n    or equivalently, it can be calculated using the formula:\n    T(n) = n * (n + 1) * (n + 2) / 6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "responses": ["```python\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    The nth tetrahedral number is the sum of the first n triangular numbers,\n    or equivalently, it can be calculated using the formula:\n    T(n) = n * (n + 1) * (n + 2) / 6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n```"], "prompt_tokens": [77], "completion_tokens": [126], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_83_get_Char", "language": "Python3", "prompt": "def get_Char(strr: str) -> str:\n    \"\"\"\n\tWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Char", "test": "def check(candidate):\n    assert candidate('abc') == 'f'\n    assert candidate('gfg') == 't'\n    assert candidate('ab') == 'c'\n\ndef test_check():\n    check(get_Char)\n\ntest_check()\n", "sample_io": ["assert get_Char('abc') == 'f'"], "source_codes": ["\ndef get_Char(strr: str) -> str:\n    \"\"\"\n    Find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n    \"\"\"\n    # Calculate sum of ASCII values of all characters\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Take modulo 26\n    mod_result = ascii_sum % 26\n    \n    # Convert to character (0->'a', 1->'b', ..., 25->'z')\n    return chr(ord('a') + mod_result)\n\n\n"], "responses": ["```python\ndef get_Char(strr: str) -> str:\n    \"\"\"\n    Find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n    \"\"\"\n    # Calculate sum of ASCII values of all characters\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Take modulo 26\n    mod_result = ascii_sum % 26\n    \n    # Convert to character (0->'a', 1->'b', ..., 25->'z')\n    return chr(ord('a') + mod_result)\n```"], "prompt_tokens": [91], "completion_tokens": [122], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_83_get_Char"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to store computed values\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n\n\n"], "responses": ["Looking at the Newman-Conway sequence, I need to understand its definition first.\n\nThe Newman-Conway sequence is defined as:\n- P(1) = 1\n- P(2) = 1\n- P(n) = P(P(n-1)) + P(n - P(n-1)) for n > 2\n\nLet me trace through a few values:\n- P(1) = 1\n- P(2) = 1\n- P(3) = P(P(2)) + P(3 - P(2)) = P(1) + P(2) = 1 + 1 = 2\n- P(4) = P(P(3)) + P(4 - P(3)) = P(2) + P(2) = 1 + 1 = 2\n\nI'll implement this using dynamic programming to avoid recalculating values.\n\n```python\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to store computed values\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n```"], "prompt_tokens": [78], "completion_tokens": [345], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_86_centered_hexagonal_number", "language": "Python3", "prompt": "def centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth centered hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "centered_hexagonal_number", "test": "def check(candidate):\n    assert candidate(10) == 271\n    assert candidate(2) == 7\n    assert candidate(9) == 217\n\ndef test_check():\n    check(centered_hexagonal_number)\n\ntest_check()\n", "sample_io": ["assert centered_hexagonal_number(10) == 271"], "source_codes": ["\ndef centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n    Find the nth centered hexagonal number.\n    \n    A centered hexagonal number is given by the formula: 3n(n-1) + 1\n    \"\"\"\n    return 3 * n * (n - 1) + 1\n\n\n"], "responses": ["```python\ndef centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n    Find the nth centered hexagonal number.\n    \n    A centered hexagonal number is given by the formula: 3n(n-1) + 1\n    \"\"\"\n    return 3 * n * (n - 1) + 1\n```"], "prompt_tokens": [76], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_86_centered_hexagonal_number"}
{"name": "mbpp_87_merge_dictionaries_three", "language": "Python3", "prompt": "from typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to merge three dictionaries into a single dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_dictionaries_three", "test": "def check(candidate):\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'L': 'lavender', 'B': 'Blue' }) == { 'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'L': 'lavender', 'B': 'Blue' }, { 'G': 'Green', 'W': 'White' }) == { 'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White' }\n\ndef test_check():\n    check(merge_dictionaries_three)\n\ntest_check()\n", "sample_io": ["assert merge_dictionaries_three({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }"], "source_codes": ["\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n\n\n"], "responses": ["```python\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n```"], "prompt_tokens": [105], "completion_tokens": [83], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_87_merge_dictionaries_three"}
{"name": "mbpp_88_freq_count", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_88_freq_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "freq_count", "test": "def check(candidate):\n    assert candidate([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }\n    assert candidate([1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4]) == { 1: 3, 2: 2, 3: 3, 4: 3 }\n    assert candidate([5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5]) == { 10: 1, 5: 3, 6: 2, 7: 2, 4: 2, 9: 2 }\n\ndef test_check():\n    check(freq_count)\n\ntest_check()\n", "sample_io": ["assert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }"], "source_codes": ["\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    for element in list1:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict\n\n\n"], "responses": ["```python\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    for element in list1:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict\n```"], "prompt_tokens": [95], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_88_freq_count"}
{"name": "mbpp_89_closest_num", "language": "Python3", "prompt": "def closest_num(N: int) -> int:\n    \"\"\"\n\tWrite a function to find the closest smaller number than n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "closest_num", "test": "def check(candidate):\n    assert candidate(11) == 10\n    assert candidate(7) == 6\n    assert candidate(12) == 11\n\ndef test_check():\n    check(closest_num)\n\ntest_check()\n", "sample_io": ["assert closest_num(11) == 10"], "source_codes": ["\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n\n\n"], "responses": ["```python\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n```"], "prompt_tokens": [75], "completion_tokens": [35], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_89_closest_num"}
{"name": "mbpp_90_len_log", "language": "Python3", "prompt": "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "len_log", "test": "def check(candidate):\n    assert candidate(['python', 'PHP', 'bigdata']) == 7\n    assert candidate(['a', 'ab', 'abc']) == 3\n    assert candidate(['small', 'big', 'tall']) == 5\n\ndef test_check():\n    check(len_log)\n\ntest_check()\n", "sample_io": ["assert len_log(['python', 'PHP', 'bigdata']) == 7"], "source_codes": ["\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n```"], "prompt_tokens": [83], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_90_len_log"}
{"name": "mbpp_91_find_substring", "language": "Python3", "prompt": "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string is present as a substring in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_substring", "test": "def check(candidate):\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ack') == True\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'abc') == False\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ange') == True\n\ndef test_check():\n    check(find_substring)\n\ntest_check()\n", "sample_io": ["assert find_substring(['red', 'black', 'white', 'green', 'orange'], 'ack') == True"], "source_codes": ["\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False\n\n\n"], "responses": ["```python\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False\n```"], "prompt_tokens": [97], "completion_tokens": [71], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_91_find_substring"}
{"name": "mbpp_92_is_undulating", "language": "Python3", "prompt": "def is_undulating(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is undulating or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_undulating", "test": "def check(candidate):\n    assert candidate(1212121) == True\n    assert candidate(1991) == False\n    assert candidate(121) == True\n\ndef test_check():\n    check(is_undulating)\n\ntest_check()\n", "sample_io": ["assert is_undulating(1212121) == True"], "source_codes": ["\ndef is_undulating(n: int) -> bool:\n    # Convert number to string to work with individual digits\n    s = str(n)\n    \n    # Numbers with less than 3 digits cannot be undulating\n    if len(s) < 3:\n        return False\n    \n    # First two digits must be different for undulation\n    if s[0] == s[1]:\n        return False\n    \n    # Check if the pattern alternates consistently\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n\n\n"], "responses": ["Looking at this problem, I need to understand what an \"undulating\" number is. Based on the function name and typical mathematical definitions, an undulating number has digits that alternate between two values in a wave-like pattern (like 121212 or 47474).\n\nLet me think through the approach:\n1. Convert the number to a string to easily access individual digits\n2. For a number to be undulating, it should alternate between exactly two different digits\n3. The pattern should be consistent throughout (e.g., ababab... where a and b are different digits)\n\nHere's my solution:\n\n```python\ndef is_undulating(n: int) -> bool:\n    # Convert number to string to work with individual digits\n    s = str(n)\n    \n    # Numbers with less than 3 digits cannot be undulating\n    if len(s) < 3:\n        return False\n    \n    # First two digits must be different for undulation\n    if s[0] == s[1]:\n        return False\n    \n    # Check if the pattern alternates consistently\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n```"], "prompt_tokens": [80], "completion_tokens": [326], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_92_is_undulating"}
{"name": "mbpp_93_power", "language": "Python3", "prompt": "def power(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the value of 'a' to the power 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power", "test": "def check(candidate):\n    assert candidate(3, 4) == 81\n    assert candidate(2, 3) == 8\n    assert candidate(5, 5) == 3125\n\ndef test_check():\n    check(power)\n\ntest_check()\n", "sample_io": ["assert power(3, 4) == 81"], "source_codes": ["\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    return a ** b\n\n\n"], "responses": ["```python\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    return a ** b\n```"], "prompt_tokens": [83], "completion_tokens": [45], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_93_power"}
{"name": "mbpp_94_index_minimum", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n\tGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_minimum", "test": "def check(candidate):\n    assert candidate([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    assert candidate([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'\n    assert candidate([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'\n\ndef test_check():\n    check(index_minimum)\n\ntest_check()\n", "sample_io": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"], "source_codes": ["\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_tuple = min(test_list, key=lambda x: x[1])\n    return min_tuple[0]\n\n\n"], "responses": ["```python\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_tuple = min(test_list, key=lambda x: x[1])\n    return min_tuple[0]\n```"], "prompt_tokens": [100], "completion_tokens": [87], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_94_index_minimum"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n\n\n"], "responses": ["```python\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n```"], "prompt_tokens": [89], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_96_divisor", "language": "Python3", "prompt": "def divisor(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of divisors of a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisor", "test": "def check(candidate):\n    assert candidate(15) == 4\n    assert candidate(12) == 6\n    assert candidate(9) == 3\n\ndef test_check():\n    check(divisor)\n\ntest_check()\n", "sample_io": ["assert divisor(15) == 4"], "source_codes": ["\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n (int): The integer to find divisors for\n        \n    Returns:\n        int: The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n\n\n"], "responses": ["```python\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n (int): The integer to find divisors for\n        \n    Returns:\n        int: The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n```"], "prompt_tokens": [78], "completion_tokens": [160], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_96_divisor"}
{"name": "mbpp_97_frequency_lists", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_97_frequency_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1 }\n    assert candidate([[20, 30, 40, 17], [18, 16, 14, 13], [10, 20, 30, 40]]) == { 20: 2, 30: 2, 40: 2, 17: 1, 18: 1, 16: 1, 14: 1, 13: 1, 10: 1 }\n\ndef test_check():\n    check(frequency_lists)\n\ntest_check()\n", "sample_io": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }"], "source_codes": ["\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = []\n    for sublist in list1:\n        for item in sublist:\n            flattened.append(item)\n    \n    # Count frequency of each element\n    frequency_dict = {}\n    for item in flattened:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict\n\n\n"], "responses": ["```python\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = []\n    for sublist in list1:\n        for item in sublist:\n            flattened.append(item)\n    \n    # Count frequency of each element\n    frequency_dict = {}\n    for item in flattened:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict\n```"], "prompt_tokens": [97], "completion_tokens": [126], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_97_frequency_lists"}
{"name": "mbpp_99_decimal_to_binary", "language": "Python3", "prompt": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n\tWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(8) == '1000'\n    assert candidate(18) == '10010'\n    assert candidate(7) == '111'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "sample_io": ["assert decimal_to_binary(8) == '1000'"], "source_codes": ["\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n\n\n"], "responses": ["```python\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n```"], "prompt_tokens": [87], "completion_tokens": [88], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_99_decimal_to_binary"}
{"name": "mbpp_100_next_smallest_palindrome", "language": "Python3", "prompt": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_smallest_palindrome", "test": "def check(candidate):\n    assert candidate(99) == 101\n    assert candidate(1221) == 1331\n    assert candidate(120) == 121\n\ndef test_check():\n    check(next_smallest_palindrome)\n\ntest_check()\n", "sample_io": ["assert next_smallest_palindrome(99) == 101"], "source_codes": ["\ndef next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n    \n    Args:\n        num: An integer\n        \n    Returns:\n        The next smallest palindrome as an integer\n    \"\"\"\n    num += 1\n    \n    while True:\n        # Convert number to string to check if it's palindrome\n        str_num = str(num)\n        \n        # Check if the number is palindrome\n        if str_num == str_num[::-1]:\n            return num\n        \n        num += 1\n\n\n"], "responses": ["```python\ndef next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n    \n    Args:\n        num: An integer\n        \n    Returns:\n        The next smallest palindrome as an integer\n    \"\"\"\n    num += 1\n    \n    while True:\n        # Convert number to string to check if it's palindrome\n        str_num = str(num)\n        \n        # Check if the number is palindrome\n        if str_num == str_num[::-1]:\n            return num\n        \n        num += 1\n```"], "prompt_tokens": [85], "completion_tokens": [115], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_100_next_smallest_palindrome"}
{"name": "mbpp_101_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find the kth element in the given array using 1-based indexing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "kth_element", "test": "def check(candidate):\n    assert candidate([12, 3, 5, 7, 19], 2) == 3\n    assert candidate([17, 24, 8, 23], 3) == 8\n    assert candidate([16, 21, 25, 36, 4], 4) == 36\n\ndef test_check():\n    check(kth_element)\n\ntest_check()\n", "sample_io": ["assert kth_element([12, 3, 5, 7, 19], 2) == 3"], "source_codes": ["\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr: List of integers\n        k: Position (1-based indexing)\n        \n    Returns:\n        The kth element in the array\n        \n    Raises:\n        IndexError: If k is out of bounds\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    # Convert 1-based indexing to 0-based indexing\n    return arr[k - 1]\n\n\n"], "responses": ["```python\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr: List of integers\n        k: Position (1-based indexing)\n        \n    Returns:\n        The kth element in the array\n        \n    Raises:\n        IndexError: If k is out of bounds\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    # Convert 1-based indexing to 0-based indexing\n    return arr[k - 1]\n```"], "prompt_tokens": [93], "completion_tokens": [130], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_101_kth_element"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert a snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join all words together\n    return ''.join(result)\n\n\n"], "responses": ["```python\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert a snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join all words together\n    return ''.join(result)\n```"], "prompt_tokens": [79], "completion_tokens": [103], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_103_eulerian_num", "language": "Python3", "prompt": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a function to find the Eulerian number a(n, m).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "eulerian_num", "test": "def check(candidate):\n    assert candidate(3, 1) == 4\n    assert candidate(4, 1) == 11\n    assert candidate(5, 3) == 26\n\ndef test_check():\n    check(eulerian_num)\n\ntest_check()\n", "sample_io": ["assert eulerian_num(3, 1) == 4"], "source_codes": ["\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Find the Eulerian number A(n, m).\n    \"\"\"\n    # Handle edge cases\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 0\n    \n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(1, min(i, m + 1)):\n            if j < i:\n                dp[i][j] = (i - j) * dp[i-1][j-1] + (j + 1) * dp[i-1][j]\n    \n    return dp[n][m]\n\n\n"], "responses": ["Looking at this problem, I need to implement a function to calculate Eulerian numbers A(n,m), which count the number of permutations of 1 to n with exactly m ascents.\n\nThe Eulerian numbers follow this recurrence relation:\n- A(n,m) = (n-m) \u00d7 A(n-1,m-1) + (m+1) \u00d7 A(n-1,m)\n- Base cases: A(0,0) = 1, A(n,0) = 1 for n \u2265 1, A(n,m) = 0 if m < 0 or m \u2265 n\n\nLet me implement this using dynamic programming:\n\n```python\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Find the Eulerian number A(n, m).\n    \"\"\"\n    # Handle edge cases\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 0\n    \n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(1, min(i, m + 1)):\n            if j < i:\n                dp[i][j] = (i - j) * dp[i-1][j-1] + (j + 1) * dp[i-1][j]\n    \n    return dp[n][m]\n```"], "prompt_tokens": [82], "completion_tokens": [367], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_103_eulerian_num"}
{"name": "mbpp_104_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([[' red ', 'green'], ['blue ', ' black'], [' orange', 'brown']]) == [[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]\n    assert candidate([['zilver', 'gold'], ['magnesium', 'aluminium'], ['steel', 'bronze']]) == [['gold', 'zilver'], ['aluminium', 'magnesium'], ['bronze', 'steel']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n\n\n"], "responses": ["```python\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n```"], "prompt_tokens": [90], "completion_tokens": [54], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_104_sort_sublists"}
{"name": "mbpp_105_count", "language": "Python3", "prompt": "from typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n\tWrite a python function to count true booleans in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count", "test": "def check(candidate):\n    assert candidate([True, False, True]) == 2\n    assert candidate([False, False]) == 0\n    assert candidate([True, True, True]) == 3\n\ndef test_check():\n    check(count)\n\ntest_check()\n", "sample_io": ["assert count([True, False, True]) == 2"], "source_codes": ["\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n\n\n"], "responses": ["```python\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n```"], "prompt_tokens": [83], "completion_tokens": [40], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_105_count"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, extend with the given list, then convert back to tuple\n    result = list(test_tup)\n    result.extend(test_list)\n    return tuple(result)\n\n\n"], "responses": ["```python\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, extend with the given list, then convert back to tuple\n    result = list(test_tup)\n    result.extend(test_list)\n    return tuple(result)\n```"], "prompt_tokens": [103], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged = num1 + num2 + num3\n    \n    # Sort the merged list\n    merged.sort()\n    \n    return merged\n\n\n"], "responses": ["```python\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged = num1 + num2 + num3\n    \n    # Sort the merged list\n    merged.sort()\n    \n    return merged\n```"], "prompt_tokens": [97], "completion_tokens": [84], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # Check the original string\n    if s[-1] == '1':\n        count += 1\n    \n    # Check each rotation\n    for i in range(1, min(n, length)):\n        # After i left rotations, the character at position i (0-indexed) becomes the last character\n        if s[i] == '1':\n            count += 1\n    \n    return count\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Understand what \"rotating a binary string\" means - it typically means shifting characters left or right\n2. For each rotation, convert the binary string to a decimal number and check if it's odd\n3. Count how many rotations result in odd numbers\n\nLet me think about this step by step:\n- A binary number is odd if its last digit is '1'\n- When we rotate left, the first character moves to the end\n- When we rotate right, the last character moves to the front\n- I'll assume left rotation based on common interpretation\n\nFor each rotation position, I'll check if the last digit is '1' (making the number odd).\n\n```python\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # Check the original string\n    if s[-1] == '1':\n        count += 1\n    \n    # Check each rotation\n    for i in range(1, min(n, length)):\n        # After i left rotations, the character at position i (0-indexed) becomes the last character\n        if s[i] == '1':\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [304], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check if the first character is a sign\n    start_index = 0\n    if text[0] in '+-':\n        # If string has only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n        start_index = 1\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check if the first character is a sign\n    start_index = 0\n    if text[0] in '+-':\n        # If string has only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n        start_index = 1\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n```"], "prompt_tokens": [77], "completion_tokens": [181], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n    \n    Args:\n        nums: A tuple containing exactly 3 positive integers\n        \n    Returns:\n        int: A single integer formed by concatenating the numbers\n        \n    Example:\n        >>> tuple_to_int((1, 2, 3))\n        123\n        >>> tuple_to_int((10, 20, 30))\n        102030\n    \"\"\"\n    # Convert each number to string, join them together, then convert back to int\n    return int(''.join(str(num) for num in nums))\n\n\n"], "responses": ["```python\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n    \n    Args:\n        nums: A tuple containing exactly 3 positive integers\n        \n    Returns:\n        int: A single integer formed by concatenating the numbers\n        \n    Example:\n        >>> tuple_to_int((1, 2, 3))\n        123\n        >>> tuple_to_int((10, 20, 30))\n        102030\n    \"\"\"\n    # Convert each number to string, join them together, then convert back to int\n    return int(''.join(str(num) for num in nums))\n```"], "prompt_tokens": [90], "completion_tokens": [151], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_117_list_to_float", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n\tWrite a function to convert all possible convertible elements in a list of lists to floats.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_to_float", "test": "def check(candidate):\n    assert candidate([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\n    assert candidate([('4', '4'), ('2', '27'), ('4.12', '9'), ('7', '11')]) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\n    assert candidate([('6', '78'), ('5', '26.45'), ('1.33', '4'), ('82', '13')]) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\n\ndef test_check():\n    check(list_to_float)\n\ntest_check()\n", "sample_io": ["assert list_to_float([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]"], "source_codes": ["\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        converted_tuple = []\n        for element in tuple_item:\n            try:\n                converted_tuple.append(float(element))\n            except ValueError:\n                # If conversion fails, keep the original element\n                converted_tuple.append(element)\n        result.append(tuple(converted_tuple))\n    return result\n\n\n"], "responses": ["```python\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        converted_tuple = []\n        for element in tuple_item:\n            try:\n                converted_tuple.append(float(element))\n            except ValueError:\n                # If conversion fails, keep the original element\n                converted_tuple.append(element)\n        result.append(tuple(converted_tuple))\n    return result\n```"], "prompt_tokens": [99], "completion_tokens": [112], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_117_list_to_float"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n\n\n"], "responses": ["```python\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n```"], "prompt_tokens": [88], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_119_search", "language": "Python3", "prompt": "from typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the element that appears only once in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "search", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8\n    assert candidate([1, 2, 2, 3, 3, 4, 4]) == 1\n\ndef test_check():\n    check(search)\n\ntest_check()\n", "sample_io": ["assert search([1, 1, 2, 2, 3]) == 3"], "source_codes": ["\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If the pair is maintained, the single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If the pair is broken, the single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n\n\n"], "responses": ["```python\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If the pair is maintained, the single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If the pair is broken, the single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n```"], "prompt_tokens": [85], "completion_tokens": [170], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_119_search"}
{"name": "mbpp_120_max_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 200\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 484\n\ndef test_check():\n    check(max_product_tuple)\n\ntest_check()\n", "sample_io": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"], "source_codes": ["\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tuple_pair in list1:\n        # Calculate the product of the two numbers in the tuple\n        product = tuple_pair[0] * tuple_pair[1]\n        # Take the absolute value and compare with current maximum\n        abs_product = abs(product)\n        if abs_product > max_product:\n            max_product = abs_product\n    \n    return max_product\n\n\n"], "responses": ["```python\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tuple_pair in list1:\n        # Calculate the product of the two numbers in the tuple\n        product = tuple_pair[0] * tuple_pair[1]\n        # Take the absolute value and compare with current maximum\n        abs_product = abs(product)\n        if abs_product > max_product:\n            max_product = abs_product\n    \n    return max_product\n```"], "prompt_tokens": [97], "completion_tokens": [137], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_120_max_product_tuple"}
{"name": "mbpp_123_amicable_numbers_sum", "language": "Python3", "prompt": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n\tWrite a function to sum all amicable numbers from 1 to a specified number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "amicable_numbers_sum", "test": "def check(candidate):\n    assert candidate(999) == 504\n    assert candidate(9999) == 31626\n    assert candidate(99) == 0\n\ndef test_check():\n    check(amicable_numbers_sum)\n\ntest_check()\n", "sample_io": ["assert amicable_numbers_sum(999) == 504"], "source_codes": ["\ndef amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n\"\"\"\n        if n <= 1:\n            return 0\n        divisors_sum = 1  # 1 is always a proper divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        # Check if b is within range and forms an amicable pair\n        if b > a and b <= limit and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    \n    return amicable_sum\n\n\n"], "responses": ["```python\ndef amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n\"\"\"\n        if n <= 1:\n            return 0\n        divisors_sum = 1  # 1 is always a proper divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        # Check if b is within range and forms an amicable pair\n        if b > a and b <= limit and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    \n    return amicable_sum\n```"], "prompt_tokens": [82], "completion_tokens": [234], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_123_amicable_numbers_sum"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["\ndef find_length(string: str) -> int:\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        # Treat '0' as +1 and '1' as -1\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        \n        # Reset to 0 if current_diff becomes negative\n        # (we can always choose empty substring with diff = 0)\n        current_diff = max(current_diff, 0)\n        \n        # Update maximum difference\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum difference between the number of 0s and 1s in any substring of a binary string.\n\nThis is equivalent to finding the maximum sum of a subarray where:\n- Each '0' contributes +1 to the sum\n- Each '1' contributes -1 to the sum\n\nI can use Kadane's algorithm to find the maximum subarray sum:\n\n```python\ndef find_length(string: str) -> int:\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        # Treat '0' as +1 and '1' as -1\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        \n        # Reset to 0 if current_diff becomes negative\n        # (we can always choose empty substring with diff = 0)\n        current_diff = max(current_diff, 0)\n        \n        # Update maximum difference\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n```"], "prompt_tokens": [94], "completion_tokens": [222], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_126_sum", "language": "Python3", "prompt": "def sum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of common divisors of two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum", "test": "def check(candidate):\n    assert candidate(10, 15) == 6\n    assert candidate(100, 150) == 93\n    assert candidate(4, 6) == 3\n\ndef test_check():\n    check(sum)\n\ntest_check()\n", "sample_io": ["assert sum(10, 15) == 6"], "source_codes": ["\ndef sum(a: int, b: int) -> int:\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n    \"\"\"\n    # Find the greatest common divisor (GCD) of a and b\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Get the GCD of a and b\n    g = gcd(a, b)\n    \n    # Find all divisors of the GCD and sum them up\n    divisor_sum = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            divisor_sum += i\n            if i != g // i:  # Avoid counting the same divisor twice for perfect squares\n                divisor_sum += g // i\n    \n    return divisor_sum\n\n\n"], "responses": ["```python\ndef sum(a: int, b: int) -> int:\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n    \"\"\"\n    # Find the greatest common divisor (GCD) of a and b\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Get the GCD of a and b\n    g = gcd(a, b)\n    \n    # Find all divisors of the GCD and sum them up\n    divisor_sum = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            divisor_sum += i\n            if i != g // i:  # Avoid counting the same divisor twice for perfect squares\n                divisor_sum += g // i\n    \n    return divisor_sum\n```"], "prompt_tokens": [83], "completion_tokens": [186], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_126_sum"}
{"name": "mbpp_127_multiply_int", "language": "Python3", "prompt": "def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n\tWrite a function to multiply two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_int", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(5, 10) == 50\n    assert candidate(4, 8) == 32\n\ndef test_check():\n    check(multiply_int)\n\ntest_check()\n", "sample_io": ["assert multiply_int(10, 20) == 200"], "source_codes": ["\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n\n\n"], "responses": ["```python\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n```"], "prompt_tokens": [75], "completion_tokens": [38], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_127_multiply_int"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string of words.\n    \"\"\"\n    words = str.split()\n    result = []\n    for word in words:\n        if len(word) > n:\n            result.append(word)\n    return result\n\n\n"], "responses": ["```python\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string of words.\n    \"\"\"\n    words = str.split()\n    result = []\n    for word in words:\n        if len(word) > n:\n            result.append(word)\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_129_magic_square_test", "language": "Python3", "prompt": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to calculate whether the matrix is a magic square.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "magic_square_test", "test": "def check(candidate):\n    assert candidate([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n\ndef test_check():\n    check(magic_square_test)\n\ntest_check()\n", "sample_io": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True"], "source_codes": ["\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    \"\"\"\n    if not my_matrix or not my_matrix[0]:\n        return False\n    \n    n = len(my_matrix)\n    \n    # Check if matrix is square\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as reference\n    target_sum = sum(my_matrix[0])\n    \n    # Check all rows\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum:\n            return False\n    \n    # Check all columns\n    for j in range(n):\n        col_sum = sum(my_matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    diag_sum = sum(my_matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(my_matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    \"\"\"\n    if not my_matrix or not my_matrix[0]:\n        return False\n    \n    n = len(my_matrix)\n    \n    # Check if matrix is square\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as reference\n    target_sum = sum(my_matrix[0])\n    \n    # Check all rows\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum:\n            return False\n    \n    # Check all columns\n    for j in range(n):\n        col_sum = sum(my_matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    diag_sum = sum(my_matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(my_matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n```"], "prompt_tokens": [85], "completion_tokens": [272], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_129_magic_square_test"}
{"name": "mbpp_130_max_occurrences", "language": "Python3", "prompt": "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_occurrences", "test": "def check(candidate):\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]) == 8\n    assert candidate([10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]) == 20\n\ndef test_check():\n    check(max_occurrences)\n\ntest_check()\n", "sample_io": ["assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2"], "source_codes": ["\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Count frequency of each number\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    return max_freq\n\n\n"], "responses": ["```python\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Count frequency of each number\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    return max_freq\n```"], "prompt_tokens": [85], "completion_tokens": [105], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_130_max_occurrences"}
{"name": "mbpp_131_reverse_vowels", "language": "Python3", "prompt": "def reverse_vowels(str1: str) -> str:\n    \"\"\"\n\tWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_vowels", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('USA') == 'ASU'\n    assert candidate('ab') == 'ab'\n\ndef test_check():\n    check(reverse_vowels)\n\ntest_check()\n", "sample_io": ["assert reverse_vowels('Python') == 'Python'"], "source_codes": ["\ndef reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)\n\n\n"], "responses": ["```python\ndef reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)\n```"], "prompt_tokens": [87], "completion_tokens": [165], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_131_reverse_vowels"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n\n\n"], "responses": ["```python\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n```"], "prompt_tokens": [82], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_133_sum_negativenum", "language": "Python3", "prompt": "from typing import List\n\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of the negative numbers of a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_negativenum", "test": "def check(candidate):\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32\n    assert candidate([10, 15, -14, 13, -18, 12, -20]) == -52\n    assert candidate([19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894\n\ndef test_check():\n    check(sum_negativenum)\n\ntest_check()\n", "sample_io": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"], "source_codes": ["\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n\n\n"], "responses": ["```python\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n```"], "prompt_tokens": [90], "completion_tokens": [56], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_133_sum_negativenum"}
{"name": "mbpp_135_hexagonal_num", "language": "Python3", "prompt": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "hexagonal_num", "test": "def check(candidate):\n    assert candidate(10) == 190\n    assert candidate(5) == 45\n    assert candidate(7) == 91\n\ndef test_check():\n    check(hexagonal_num)\n\ntest_check()\n", "sample_io": ["assert hexagonal_num(10) == 190"], "source_codes": ["\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    A hexagonal number is a figurate number that represents a hexagon.\n    The nth hexagonal number is given by the formula: H(n) = n(2n-1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n\n\n"], "responses": ["```python\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    A hexagonal number is a figurate number that represents a hexagon.\n    The nth hexagonal number is given by the formula: H(n) = n(2n-1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n```"], "prompt_tokens": [75], "completion_tokens": [167], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_135_hexagonal_num"}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "Python3", "prompt": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sum_Of_Powers_Of_Two", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(7) == False\n    assert candidate(14) == True\n\ndef test_check():\n    check(is_Sum_Of_Powers_Of_Two)\n\ntest_check()\n", "sample_io": ["assert is_Sum_Of_Powers_Of_Two(10) == True"], "source_codes": ["\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \"\"\"\n    # A number can be represented as sum of non-zero powers of 2 if and only if it's positive\n    # because any positive integer can be expressed as a sum of distinct powers of 2 (binary representation)\n    # and 0 cannot be represented as sum of non-zero powers of 2\n    return n > 0\n\n\n"], "responses": ["```python\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \"\"\"\n    # A number can be represented as sum of non-zero powers of 2 if and only if it's positive\n    # because any positive integer can be expressed as a sum of distinct powers of 2 (binary representation)\n    # and 0 cannot be represented as sum of non-zero powers of 2\n    return n > 0\n```"], "prompt_tokens": [94], "completion_tokens": [116], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_138_is_Sum_Of_Powers_Of_Two"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": ["\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using pancake sorting algorithm.\n    Returns the list of k-values representing the sequence of pancake flips.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    result = []\n    n = len(arr)\n    \n    # Start from the largest element and work down\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        \n        # If the maximum is already at the end, skip\n        if max_index == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip it to the beginning\n        if max_index != 0:\n            # Flip from 0 to max_index (inclusive)\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            result.append(max_index + 1)\n        \n        # Flip from 0 to size-1 (inclusive) to move max to its final position\n        arr[:size] = reversed(arr[:size])\n        result.append(size)\n    \n    return result\n\n\n"], "responses": ["```python\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using pancake sorting algorithm.\n    Returns the list of k-values representing the sequence of pancake flips.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    result = []\n    n = len(arr)\n    \n    # Start from the largest element and work down\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        \n        # If the maximum is already at the end, skip\n        if max_index == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip it to the beginning\n        if max_index != 0:\n            # Flip from 0 to max_index (inclusive)\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            result.append(max_index + 1)\n        \n        # Flip from 0 to size-1 (inclusive) to move max to its final position\n        arr[:size] = reversed(arr[:size])\n        result.append(size)\n    \n    return result\n```"], "prompt_tokens": [81], "completion_tokens": [293], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_142_count_samepair", "language": "Python3", "prompt": "from typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n\tWrite a function to count number items that are identical in the same position of three given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_samepair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 4\n    assert candidate([1, 2, 3, 4, 2, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 5\n\ndef test_check():\n    check(count_samepair)\n\ntest_check()\n", "sample_io": ["assert count_samepair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3"], "source_codes": ["\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    count = 0\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    count = 0\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [102], "completion_tokens": [109], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_142_count_samepair"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n```"], "prompt_tokens": [85], "completion_tokens": [63], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_143_find_lists"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val\n\n\n"], "responses": ["```python\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val\n```"], "prompt_tokens": [90], "completion_tokens": [73], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_160_find_solution", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_solution", "test": "def check(candidate):\n    assert candidate(2, 3, 7) == (2, 1)\n    assert candidate(4, 2, 7) == None\n    assert candidate(1, 13, 17) == (4, 1)\n\ndef test_check():\n    check(find_solution)\n\ntest_check()\n", "sample_io": ["assert find_solution(2, 3, 7) == (2, 1)"], "source_codes": ["\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    \"\"\"\n    # Handle special cases\n    if a == 0 and b == 0:\n        if n == 0:\n            return (0, 0)  # Any solution works, return (0,0)\n        else:\n            return None    # No solution exists\n    \n    if a == 0:\n        if n % b == 0:\n            return (0, n // b)\n        else:\n            return None\n    \n    if b == 0:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    \n    # Use Extended Euclidean Algorithm to find gcd and coefficients\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return x, 1, 0\n        gcd, s, t = extended_gcd(y, x % y)\n        return gcd, t, s - (x // y) * t\n    \n    gcd, s, t = extended_gcd(a, b)\n    \n    # Check if solution exists\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution\n    factor = n // gcd\n    x = s * factor\n    y = t * factor\n    \n    return (x, y)\n\n\n"], "responses": ["```python\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    \"\"\"\n    # Handle special cases\n    if a == 0 and b == 0:\n        if n == 0:\n            return (0, 0)  # Any solution works, return (0,0)\n        else:\n            return None    # No solution exists\n    \n    if a == 0:\n        if n % b == 0:\n            return (0, n // b)\n        else:\n            return None\n    \n    if b == 0:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    \n    # Use Extended Euclidean Algorithm to find gcd and coefficients\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return x, 1, 0\n        gcd, s, t = extended_gcd(y, x % y)\n        return gcd, t, s - (x // y) * t\n    \n    gcd, s, t = extended_gcd(a, b)\n    \n    # Check if solution exists\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution\n    factor = n // gcd\n    x = s * factor\n    y = t * factor\n    \n    return (x, y)\n```"], "prompt_tokens": [111], "completion_tokens": [331], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_160_find_solution"}
{"name": "mbpp_161_remove_elements", "language": "Python3", "prompt": "from typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to remove all elements from a given list present in another list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_elements", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]\n\ndef test_check():\n    check(remove_elements)\n\ntest_check()\n", "sample_io": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"], "source_codes": ["\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Return elements from list1 that are not in list2\n    return [element for element in list1 if element not in set2]\n\n\n"], "responses": ["```python\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Return elements from list1 that are not in list2\n    return [element for element in list1 if element not in set2]\n```"], "prompt_tokens": [93], "completion_tokens": [100], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_161_remove_elements"}
{"name": "mbpp_162_sum_series", "language": "Python3", "prompt": "def sum_series(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_series", "test": "def check(candidate):\n    assert candidate(6) == 12\n    assert candidate(10) == 30\n    assert candidate(9) == 25\n\ndef test_check():\n    check(sum_series)\n\ntest_check()\n", "sample_io": ["assert sum_series(6) == 12"], "source_codes": ["\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4) + ... (until n-x <= 0).\n    \"\"\"\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n\n\n"], "responses": ["```python\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4) + ... (until n-x <= 0).\n    \"\"\"\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n```"], "prompt_tokens": [111], "completion_tokens": [100], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_162_sum_series"}
{"name": "mbpp_164_are_equivalent", "language": "Python3", "prompt": "def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n\tWrite a function to determine if the sum of the divisors of two integers are the same.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "are_equivalent", "test": "def check(candidate):\n    assert candidate(36, 57) == False\n    assert candidate(2, 4) == False\n    assert candidate(23, 47) == True\n\ndef test_check():\n    check(are_equivalent)\n\ntest_check()\n", "sample_io": ["assert are_equivalent(36, 57) == False"], "source_codes": ["\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        \"\"\"Calculate the sum of all divisors of n (including 1 and n itself)\"\"\"\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisor_sum += n // i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n\n\n"], "responses": ["```python\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        \"\"\"Calculate the sum of all divisors of n (including 1 and n itself)\"\"\"\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisor_sum += n // i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n```"], "prompt_tokens": [89], "completion_tokens": [180], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_164_are_equivalent"}
{"name": "mbpp_165_count_char_position", "language": "Python3", "prompt": "def count_char_position(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_char_position", "test": "def check(candidate):\n    assert candidate('xbcefg') == 2\n    assert candidate('ABcED') == 3\n    assert candidate('AbgdeF') == 5\n\ndef test_check():\n    check(count_char_position)\n\ntest_check()\n", "sample_io": ["assert count_char_position('xbcefg') == 2"], "source_codes": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i in range(len(str1)):\n        char = str1[i]\n        # Check if character is a letter\n        if 'a' <= char <= 'z':\n            # Get the position of the character in alphabet (a=1, b=2, ..., z=26)\n            alphabet_position = ord(char) - ord('a') + 1\n            # Check if the position matches the string index (1-based indexing for alphabet)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i in range(len(str1)):\n        char = str1[i]\n        # Check if character is a letter\n        if 'a' <= char <= 'z':\n            # Get the position of the character in alphabet (a=1, b=2, ..., z=26)\n            alphabet_position = ord(char) - ord('a') + 1\n            # Check if the position matches the string index (1-based indexing for alphabet)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n```"], "prompt_tokens": [95], "completion_tokens": [179], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_165_count_char_position"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n\n"], "responses": ["```python\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n```"], "prompt_tokens": [91], "completion_tokens": [184], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_167_next_power_of_2", "language": "Python3", "prompt": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest power of 2 greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_power_of_2", "test": "def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 8\n    assert candidate(17) == 32\n\ndef test_check():\n    check(next_power_of_2)\n\ntest_check()\n", "sample_io": ["assert next_power_of_2(0) == 1"], "source_codes": ["\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    n += 1\n    \n    return n\n\n\n"], "responses": ["```python\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    n += 1\n    \n    return n\n```"], "prompt_tokens": [85], "completion_tokens": [181], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_167_next_power_of_2"}
{"name": "mbpp_168_frequency", "language": "Python3", "prompt": "from typing import List\n\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurrences of a number in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 4) == 0\n    assert candidate([1, 2, 2, 3, 3, 3, 4], 3) == 3\n    assert candidate([0, 1, 2, 3, 1, 2], 1) == 2\n\ndef test_check():\n    check(frequency)\n\ntest_check()\n", "sample_io": ["assert frequency([1, 2, 3], 4) == 0"], "source_codes": ["\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers\n        x: Integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    return a.count(x)\n\n\n"], "responses": ["```python\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers\n        x: Integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    return a.count(x)\n```"], "prompt_tokens": [89], "completion_tokens": [76], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_168_frequency"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n    \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    return sum(list1[m:n+1])\n\n\n"], "responses": ["```python\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n    \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    return sum(list1[m:n+1])\n```"], "prompt_tokens": [99], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_171_perimeter_pentagon", "language": "Python3", "prompt": "def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n\tWrite a function to find the perimeter of a regular pentagon from the length of its sides.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perimeter_pentagon", "test": "def check(candidate):\n    assert candidate(5) == 25\n    assert candidate(10) == 50\n    assert candidate(15) == 75\n\ndef test_check():\n    check(perimeter_pentagon)\n\ntest_check()\n", "sample_io": ["assert perimeter_pentagon(5) == 25"], "source_codes": ["\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a\n\n\n"], "responses": ["```python\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a\n```"], "prompt_tokens": [84], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_171_perimeter_pentagon"}
{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n\n\n"], "responses": ["```python\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n```"], "prompt_tokens": [86], "completion_tokens": [50], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_222_check_type", "language": "Python3", "prompt": "from typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if all the elements in tuple have same data type or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_type", "test": "def check(candidate):\n    assert candidate((5, 6, 7, 3, 5, 6)) == True\n    assert candidate((1, 2, '4')) == False\n    assert candidate((3, 2, 1, 4, 5)) == True\n\ndef test_check():\n    check(check_type)\n\ntest_check()\n", "sample_io": ["assert check_type((5, 6, 7, 3, 5, 6)) == True"], "source_codes": ["\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    if not test_tuple:  # Empty tuple\n        return True\n    \n    first_type = type(test_tuple[0])\n    return all(type(element) == first_type for element in test_tuple)\n\n\n"], "responses": ["```python\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    if not test_tuple:  # Empty tuple\n        return True\n    \n    first_type = type(test_tuple[0])\n    return all(type(element) == first_type for element in test_tuple)\n```"], "prompt_tokens": [87], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_222_check_type"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    # Since the array is sorted, we can use binary search to find the first and last occurrence\n    # of the element x, then calculate its frequency\n    \n    # Find the first occurrence of x\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find the last occurrence of x\n    def find_last_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find first and last positions of x\n    first_pos = find_first_occurrence(arr, x)\n    if first_pos == -1:\n        return False  # Element not found\n    \n    last_pos = find_last_occurrence(arr, x)\n    \n    # Calculate frequency\n    count = last_pos - first_pos + 1\n    \n    # Check if count is greater than n/2\n    return count > n // 2\n\n\n"], "responses": ["```python\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    # Since the array is sorted, we can use binary search to find the first and last occurrence\n    # of the element x, then calculate its frequency\n    \n    # Find the first occurrence of x\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find the last occurrence of x\n    def find_last_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find first and last positions of x\n    first_pos = find_first_occurrence(arr, x)\n    if first_pos == -1:\n        return False  # Element not found\n    \n    last_pos = find_last_occurrence(arr, x)\n    \n    # Calculate frequency\n    count = last_pos - first_pos + 1\n    \n    # Check if count is greater than n/2\n    return count > n // 2\n```"], "prompt_tokens": [127], "completion_tokens": [441], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_224_count_Set_Bits", "language": "Python3", "prompt": "def count_Set_Bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of set bits (binary digits with value 1) in a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Set_Bits", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(4) == 1\n    assert candidate(6) == 2\n\ndef test_check():\n    check(count_Set_Bits)\n\ntest_check()\n", "sample_io": ["assert count_Set_Bits(2) == 1"], "source_codes": ["\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n\n"], "responses": ["```python\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n```"], "prompt_tokens": [89], "completion_tokens": [74], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_224_count_Set_Bits"}
{"name": "mbpp_226_odd_values_string", "language": "Python3", "prompt": "def odd_values_string(str: str) -> str:\n    \"\"\"\n\tWrite a python function to remove the characters which have odd index values of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_values_string", "test": "def check(candidate):\n    assert candidate('abcdef') == 'ace'\n    assert candidate('python') == 'pto'\n    assert candidate('data') == 'dt'\n    assert candidate('lambs') == 'lms'\n\ndef test_check():\n    check(odd_values_string)\n\ntest_check()\n", "sample_io": ["assert odd_values_string('abcdef') == 'ace'"], "source_codes": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result\n\n\n"], "responses": ["```python\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result\n```"], "prompt_tokens": [82], "completion_tokens": [71], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_226_odd_values_string"}
{"name": "mbpp_227_min_of_three", "language": "Python3", "prompt": "def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find minimum of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_of_three", "test": "def check(candidate):\n    assert candidate(10, 20, 0) == 0\n    assert candidate(19, 15, 18) == 15\n    assert candidate(-10, -20, -30) == -30\n\ndef test_check():\n    check(min_of_three)\n\ntest_check()\n", "sample_io": ["assert min_of_three(10, 20, 0) == 0"], "source_codes": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n\n"], "responses": ["```python\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n```"], "prompt_tokens": [82], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_227_min_of_three"}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "Python3", "prompt": "def all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the bits are unset in the given range or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Bits_Set_In_The_Given_Range", "test": "def check(candidate):\n    assert candidate(4, 1, 2) == True\n    assert candidate(17, 2, 4) == True\n    assert candidate(39, 4, 6) == False\n\ndef test_check():\n    check(all_Bits_Set_In_The_Given_Range)\n\ntest_check()\n", "sample_io": ["assert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"], "source_codes": ["\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1\n    \n    # Shift the mask to align with positions [l, r]\n    mask = mask << (l - 1)\n    \n    # Check if any bit in the range is set\n    # If (n & mask) == 0, then all bits in range are unset\n    return (n & mask) == 0\n\n\n"], "responses": ["Looking at this problem, I need to check whether all bits are unset (0) in a given range [l, r] of an integer n.\n\nLet me think step by step:\n1. I need to examine bits from position l to position r (inclusive)\n2. If any bit in this range is set (1), return False\n3. If all bits in this range are unset (0), return True\n\nTo check this efficiently, I can:\n- Create a mask that has 1s only in the range [l, r]\n- Apply this mask to n using AND operation\n- If the result is 0, then all bits in that range are unset\n\nThe mask can be created by:\n- Creating a number with (r-l+1) consecutive 1s\n- Left shifting it by (l-1) positions\n\n```python\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1\n    \n    # Shift the mask to align with positions [l, r]\n    mask = mask << (l - 1)\n    \n    # Check if any bit in the range is set\n    # If (n & mask) == 0, then all bits in range are unset\n    return (n & mask) == 0\n```"], "prompt_tokens": [99], "completion_tokens": [334], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_228_all_Bits_Set_In_The_Given_Range"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n\n\n"], "responses": ["```python\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n```"], "prompt_tokens": [125], "completion_tokens": [125], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_230_replace_blank", "language": "Python3", "prompt": "def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n\tWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_blank", "test": "def check(candidate):\n    assert candidate('hello people', '@') == 'hello@people'\n    assert candidate('python program language', '$') == 'python$program$language'\n    assert candidate('blank space', '-') == 'blank-space'\n\ndef test_check():\n    check(replace_blank)\n\ntest_check()\n", "sample_io": ["assert replace_blank('hello people', '@') == 'hello@people'"], "source_codes": ["\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n\n\n"], "responses": ["```python\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n```"], "prompt_tokens": [94], "completion_tokens": [60], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_230_replace_blank"}
{"name": "mbpp_234_volume_cube", "language": "Python3", "prompt": "def volume_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the volume of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "volume_cube", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(2) == 8\n    assert candidate(5) == 125\n\ndef test_check():\n    check(volume_cube)\n\ntest_check()\n", "sample_io": ["assert volume_cube(3) == 27"], "source_codes": ["\ndef volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    return l ** 3\n\n\n"], "responses": ["```python\ndef volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    return l ** 3\n```"], "prompt_tokens": [78], "completion_tokens": [42], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_234_volume_cube"}
{"name": "mbpp_237_check_occurences", "language": "Python3", "prompt": "from typing import List, Tuple, Dict\n\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_occurences", "test": "def check(candidate):\n    assert candidate([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }\n    assert candidate([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]) == { (2, 4): 2, (3, 6): 2, (4, 7): 1 }\n    assert candidate([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]) == { (2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1 }\n\ndef test_check():\n    check(check_occurences)\n\ntest_check()\n", "sample_io": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }"], "source_codes": ["\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        if item in result:\n            result[item] += 1\n        else:\n            result[item] = 1\n    return result\n\n\n"], "responses": ["```python\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        if item in result:\n            result[item] += 1\n        else:\n            result[item] = 1\n    return result\n```"], "prompt_tokens": [116], "completion_tokens": [104], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_237_check_occurences"}
{"name": "mbpp_238_number_of_substrings", "language": "Python3", "prompt": "def number_of_substrings(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_of_substrings", "test": "def check(candidate):\n    assert candidate('abc') == 6\n    assert candidate('abcd') == 10\n    assert candidate('abcde') == 15\n\ndef test_check():\n    check(number_of_substrings)\n\ntest_check()\n", "sample_io": ["assert number_of_substrings('abc') == 6"], "source_codes": ["\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n    \n    For a string of length n, the number of non-empty substrings is n * (n + 1) / 2\n    This is because:\n    - Substrings of length 1: n\n    - Substrings of length 2: n-1\n    - Substrings of length 3: n-2\n    - ...\n    - Substrings of length n: 1\n    \n    Total = n + (n-1) + (n-2) + ... + 1 = n * (n + 1) / 2\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n\n\n"], "responses": ["```python\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n    \n    For a string of length n, the number of non-empty substrings is n * (n + 1) / 2\n    This is because:\n    - Substrings of length 1: n\n    - Substrings of length 2: n-1\n    - Substrings of length 3: n-2\n    - ...\n    - Substrings of length n: 1\n    \n    Total = n + (n-1) + (n-2) + ... + 1 = n * (n + 1) / 2\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n```"], "prompt_tokens": [83], "completion_tokens": [173], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_238_number_of_substrings"}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "Python3", "prompt": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_total_number_of_sequences", "test": "def check(candidate):\n    assert candidate(10, 4) == 4\n    assert candidate(5, 2) == 6\n    assert candidate(16, 3) == 84\n\ndef test_check():\n    check(get_total_number_of_sequences)\n\ntest_check()\n", "sample_io": ["assert get_total_number_of_sequences(10, 4) == 4"], "source_codes": ["\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    # dp[i][j] = number of sequences of length i ending with value j\n    # We only need current and previous row\n    prev_dp = [0] * (m + 1)\n    \n    # Base case: sequences of length 1\n    for j in range(1, m + 1):\n        prev_dp[j] = 1\n    \n    # Fill for sequences of length 2 to n\n    for length in range(2, n + 1):\n        curr_dp = [0] * (m + 1)\n        \n        # For each possible ending value j\n        for j in range(1, m + 1):\n            # Sum up all valid previous sequences where prev_val * 2 <= j\n            # This means prev_val <= j // 2\n            for prev_val in range(1, min(j // 2, m) + 1):\n                curr_dp[j] += prev_dp[prev_val]\n        \n        prev_dp = curr_dp\n    \n    # Sum all possible ending values for sequences of length n\n    return sum(prev_dp)\n\n\n"], "responses": ["Looking at this problem, I need to count sequences of length n where each element is a positive integer, bounded by m, and each element is at least twice the previous element.\n\nLet me think about this step by step:\n1. This is a dynamic programming problem where I need to track valid sequences\n2. For each position in the sequence, I need to consider what values can be placed there\n3. The constraint is that each element \u2265 2 \u00d7 (previous element)\n4. Each element must be \u2264 m\n\nI'll use dynamic programming where dp[i][j] represents the number of valid sequences of length i ending with value j.\n\n```python\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    # dp[i][j] = number of sequences of length i ending with value j\n    # We only need current and previous row\n    prev_dp = [0] * (m + 1)\n    \n    # Base case: sequences of length 1\n    for j in range(1, m + 1):\n        prev_dp[j] = 1\n    \n    # Fill for sequences of length 2 to n\n    for length in range(2, n + 1):\n        curr_dp = [0] * (m + 1)\n        \n        # For each possible ending value j\n        for j in range(1, m + 1):\n            # Sum up all valid previous sequences where prev_val * 2 <= j\n            # This means prev_val <= j // 2\n            for prev_val in range(1, min(j // 2, m) + 1):\n                curr_dp[j] += prev_dp[prev_val]\n        \n        prev_dp = curr_dp\n    \n    # Sum all possible ending values for sequences of length n\n    return sum(prev_dp)\n```"], "prompt_tokens": [119], "completion_tokens": [405], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_239_get_total_number_of_sequences"}
{"name": "mbpp_240_replace_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_240_replace_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_list", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate(['red', 'blue', 'green'], ['yellow']) == ['red', 'blue', 'yellow']\n\ndef test_check():\n    check(replace_list)\n\ntest_check()\n", "sample_io": ["assert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"], "source_codes": ["\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if not list1:\n        return list2.copy()\n    \n    result = list1[:-1] + list2\n    return result\n\n\n"], "responses": ["```python\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if not list1:\n        return list2.copy()\n    \n    result = list1[:-1] + list2\n    return result\n```"], "prompt_tokens": [104], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_240_replace_list"}
{"name": "mbpp_242_count_charac", "language": "Python3", "prompt": "def count_charac(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the total number of characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_charac", "test": "def check(candidate):\n    assert candidate('python programming') == 18\n    assert candidate('language') == 8\n    assert candidate('words') == 5\n\ndef test_check():\n    check(count_charac)\n\ntest_check()\n", "sample_io": ["assert count_charac('python programming') == 18"], "source_codes": ["\ndef count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)\n\n\n"], "responses": ["```python\ndef count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)\n```"], "prompt_tokens": [79], "completion_tokens": [42], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_242_count_charac"}
{"name": "mbpp_244_next_Perfect_Square", "language": "Python3", "prompt": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n\tWrite a python function to find the next perfect square greater than a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_Perfect_Square", "test": "def check(candidate):\n    assert candidate(35) == 36\n    assert candidate(6) == 9\n    assert candidate(9) == 16\n\ndef test_check():\n    check(next_Perfect_Square)\n\ntest_check()\n", "sample_io": ["assert next_Perfect_Square(35) == 36"], "source_codes": ["\nimport math\n\ndef next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Find the next perfect square greater than a given number.\n    \n    Args:\n        N (int): The input number\n        \n    Returns:\n        int: The next perfect square greater than N\n    \"\"\"\n    # Find the square root of N and round it up to the next integer\n    sqrt_N = math.ceil(math.sqrt(N))\n    \n    # If N is already a perfect square, we need the next one\n    if sqrt_N * sqrt_N == N:\n        sqrt_N += 1\n    \n    # Return the square of the next integer\n    return sqrt_N * sqrt_N\n\n\n"], "responses": ["```python\nimport math\n\ndef next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Find the next perfect square greater than a given number.\n    \n    Args:\n        N (int): The input number\n        \n    Returns:\n        int: The next perfect square greater than N\n    \"\"\"\n    # Find the square root of N and round it up to the next integer\n    sqrt_N = math.ceil(math.sqrt(N))\n    \n    # If N is already a perfect square, we need the next one\n    if sqrt_N * sqrt_N == N:\n        sqrt_N += 1\n    \n    # Return the square of the next integer\n    return sqrt_N * sqrt_N\n```"], "prompt_tokens": [82], "completion_tokens": [143], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_244_next_Perfect_Square"}
{"name": "mbpp_245_max_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum", "test": "def check(candidate):\n    assert candidate([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert candidate([80, 60, 30, 40, 20, 10]) == 210\n    assert candidate([2, 3, 14, 16, 21, 23, 29, 30]) == 138\n\ndef test_check():\n    check(max_sum)\n\ntest_check()\n", "sample_io": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"], "source_codes": ["\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Initialize arrays to store maximum sum of increasing and decreasing subsequences\n    # inc[i] stores maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] such that inc[i] stores the maximum sum of increasing subsequence ending at i\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] such that dec[i] stores the maximum sum of decreasing subsequence starting at i\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # inc[i] + dec[i] - arr[i] because arr[i] is counted twice\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum\n\n\n"], "responses": ["```python\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Initialize arrays to store maximum sum of increasing and decreasing subsequences\n    # inc[i] stores maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] such that inc[i] stores the maximum sum of increasing subsequence ending at i\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] such that dec[i] stores the maximum sum of decreasing subsequence starting at i\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # inc[i] + dec[i] - arr[i] because arr[i] is counted twice\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum\n```"], "prompt_tokens": [107], "completion_tokens": [333], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_245_max_sum"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": ["\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D array to store results of subproblems\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for substrings of length 3 and more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n\n\n"], "responses": ["```python\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D array to store results of subproblems\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for substrings of length 3 and more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n```"], "prompt_tokens": [84], "completion_tokens": [266], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_247_lps"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets to remove duplicates and enable set intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Find intersection and convert back to list\n    return list(set1 & set2)\n\n\n"], "responses": ["```python\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets to remove duplicates and enable set intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Find intersection and convert back to list\n    return list(set1 & set2)\n```"], "prompt_tokens": [90], "completion_tokens": [131], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occurrences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n\n\n"], "responses": ["```python\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occurrences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n```"], "prompt_tokens": [100], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_251_insert_element", "language": "Python3", "prompt": "from typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n\tWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "insert_element", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    assert candidate(['python', 'java'], 'program') == ['program', 'python', 'program', 'java']\n    assert candidate(['happy', 'sad'], 'laugh') == ['laugh', 'happy', 'laugh', 'sad']\n\ndef test_check():\n    check(insert_element)\n\ntest_check()\n", "sample_io": ["assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"], "source_codes": ["\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n\n\n"], "responses": ["```python\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_251_insert_element"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": ["\nimport cmath\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number (int is not correct for complex numbers,\n                 but we'll interpret this as a complex number input)\n    \n    Returns:\n        Tuple containing (magnitude, phase) where:\n        - magnitude is the distance from origin\n        - phase is the angle in radians\n    \"\"\"\n    # Convert to complex number if it's not already\n    complex_num = complex(numbers)\n    \n    # Get polar coordinates using cmath.polar()\n    magnitude, phase = cmath.polar(complex_num)\n    \n    return (magnitude, phase)\n\n\n"], "responses": ["```python\nimport cmath\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number (int is not correct for complex numbers,\n                 but we'll interpret this as a complex number input)\n    \n    Returns:\n        Tuple containing (magnitude, phase) where:\n        - magnitude is the distance from origin\n        - phase is the angle in radians\n    \"\"\"\n    # Convert to complex number if it's not already\n    complex_num = complex(numbers)\n    \n    # Get polar coordinates using cmath.polar()\n    magnitude, phase = cmath.polar(complex_num)\n    \n    return (magnitude, phase)\n```"], "prompt_tokens": [82], "completion_tokens": [147], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_252_convert"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    result = []\n    \n    # For each element in the list\n    for i in range(len(l)):\n        # Get all combinations of length n-1\n        smaller_combinations = combinations_colors(l[i:], n-1)\n        \n        # Prepend current element to each smaller combination\n        for combo in smaller_combinations:\n            result.append([l[i]] + combo)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    result = []\n    \n    # For each element in the list\n    for i in range(len(l)):\n        # Get all combinations of length n-1\n        smaller_combinations = combinations_colors(l[i:], n-1)\n        \n        # Prepend current element to each smaller combination\n        for combo in smaller_combinations:\n            result.append([l[i]] + combo)\n    \n    return result\n```"], "prompt_tokens": [112], "completion_tokens": [174], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes algorithm\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    count = 0\n    for i in range(2, n):\n        if is_prime[i]:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes algorithm\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    count = 0\n    for i in range(2, n):\n        if is_prime[i]:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [91], "completion_tokens": [195], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": ["\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "responses": ["```python\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n```"], "prompt_tokens": [95], "completion_tokens": [53], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_259_maximize_elements", "language": "Python3", "prompt": "from typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to maximize the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximize_elements", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[7, 8], [5, 10], [3, 10], [8, 11]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[8, 9], [6, 11], [4, 11], [9, 12]]\n\ndef test_check():\n    check(maximize_elements)\n\ntest_check()\n", "sample_io": ["assert maximize_elements([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]"], "source_codes": ["\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through corresponding sublists\n    for i in range(len(test_tup1)):\n        sublist = []\n        # Compare elements in corresponding positions\n        for j in range(len(test_tup1[i])):\n            max_element = max(test_tup1[i][j], test_tup2[i][j])\n            sublist.append(max_element)\n        result.append(sublist)\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to create a function that maximizes elements from two lists of lists. Based on the function signature and typical interpretation of \"maximize\" with two inputs, I'll assume we want to take the element-wise maximum between corresponding positions in the two input lists.\n\nLet me think through the approach:\n1. Compare corresponding sublists from both input lists\n2. For each pair of sublists, compare corresponding elements\n3. Take the maximum of each element pair\n4. Return the resulting list of lists\n\n```python\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through corresponding sublists\n    for i in range(len(test_tup1)):\n        sublist = []\n        # Compare elements in corresponding positions\n        for j in range(len(test_tup1[i])):\n            max_element = max(test_tup1[i][j], test_tup2[i][j])\n            sublist.append(max_element)\n        result.append(sublist)\n    \n    return result\n```"], "prompt_tokens": [94], "completion_tokens": [240], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_259_maximize_elements"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": ["\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Find the nth newman\u2013shanks\u2013williams prime number.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate NSW sequence and check for primes\n    nsw_prev2 = 1  # NSW(0)\n    nsw_prev1 = 1  # NSW(1)\n    \n    count = 0\n    \n    # Check if first two terms are prime\n    if is_prime(nsw_prev2):\n        count += 1\n        if count == n:\n            return nsw_prev2\n    \n    if is_prime(nsw_prev1):\n        count += 1\n        if count == n:\n            return nsw_prev1\n    \n    # Generate subsequent NSW numbers\n    i = 2\n    while True:\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        \n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        \n        # Update for next iteration\n        nsw_prev2 = nsw_prev1\n        nsw_prev1 = nsw_current\n        i += 1\n\n\n"], "responses": ["Looking at this problem, I need to find the nth Newman-Shanks-Williams prime number.\n\nNewman-Shanks-Williams (NSW) primes are primes that appear in the NSW sequence, which is defined by the recurrence relation:\n- NSW(0) = 1\n- NSW(1) = 1  \n- NSW(n) = 2 * NSW(n-1) + NSW(n-2) for n \u2265 2\n\nThe sequence starts: 1, 1, 3, 7, 17, 41, 99, 239, 577, 1393, ...\n\nNSW primes are the terms in this sequence that are actually prime numbers.\n\nLet me generate the code:\n\n```python\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Find the nth newman\u2013shanks\u2013williams prime number.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate NSW sequence and check for primes\n    nsw_prev2 = 1  # NSW(0)\n    nsw_prev1 = 1  # NSW(1)\n    \n    count = 0\n    \n    # Check if first two terms are prime\n    if is_prime(nsw_prev2):\n        count += 1\n        if count == n:\n            return nsw_prev2\n    \n    if is_prime(nsw_prev1):\n        count += 1\n        if count == n:\n            return nsw_prev1\n    \n    # Generate subsequent NSW numbers\n    i = 2\n    while True:\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        \n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        \n        # Update for next iteration\n        nsw_prev2 = nsw_prev1\n        nsw_prev1 = nsw_current\n        i += 1\n```"], "prompt_tokens": [82], "completion_tokens": [478], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
{"name": "mbpp_261_division_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "division_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)\n    assert candidate((12, 6, 8, 16), (6, 3, 4, 4)) == (2, 2, 2, 4)\n    assert candidate((20, 14, 36, 18), (5, 7, 6, 9)) == (4, 2, 6, 2)\n\ndef test_check():\n    check(division_elements)\n\ntest_check()\n", "sample_io": ["assert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)"], "source_codes": ["\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    return tuple(a // b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    return tuple(a // b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [119], "completion_tokens": [93], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_261_division_elements"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n\n\n"], "responses": ["```python\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n```"], "prompt_tokens": [119], "completion_tokens": [97], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_264_dog_age", "language": "Python3", "prompt": "def dog_age(h_age: int) -> int:\n    \"\"\"\n\tWrite a function to calculate a dog's age in dog's years.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dog_age", "test": "def check(candidate):\n    assert candidate(12) == 61\n    assert candidate(15) == 73\n    assert candidate(24) == 109\n\ndef test_check():\n    check(dog_age)\n\ntest_check()\n", "sample_io": ["assert dog_age(12) == 61"], "source_codes": ["\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + (h_age - 2) * 4\n\n\n"], "responses": ["```python\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + (h_age - 2) * 4\n```"], "prompt_tokens": [78], "completion_tokens": [95], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_264_dog_age"}
{"name": "mbpp_265_list_split", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_split", "test": "def check(candidate):\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]]\n    assert candidate(['python', 'java', 'C', 'C++', 'DBMS', 'SQL'], 2) == [['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]\n\ndef test_check():\n    check(list_split)\n\ntest_check()\n", "sample_io": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"], "source_codes": ["\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Takes in a list and an integer n and splits a list for every nth element,\n    returning a list of the resulting lists.\n    \"\"\"\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer\")\n    \n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i + step])\n    \n    return result\n\n\n"], "responses": ["```python\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Takes in a list and an integer n and splits a list for every nth element,\n    returning a list of the resulting lists.\n    \"\"\"\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer\")\n    \n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i + step])\n    \n    return result\n```"], "prompt_tokens": [106], "completion_tokens": [102], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_265_list_split"}
{"name": "mbpp_266_lateralsurface_cube", "language": "Python3", "prompt": "def lateralsurface_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cube", "test": "def check(candidate):\n    assert candidate(5) == 100\n    assert candidate(9) == 324\n    assert candidate(10) == 400\n\ndef test_check():\n    check(lateralsurface_cube)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cube(5) == 100"], "source_codes": ["\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    # Lateral surface area of a cube = 4 * side^2\n    # This includes all 4 vertical faces, excluding top and bottom\n    return 4 * l * l\n\n\n"], "responses": ["```python\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    # Lateral surface area of a cube = 4 * side^2\n    # This includes all 4 vertical faces, excluding top and bottom\n    return 4 * l * l\n```"], "prompt_tokens": [82], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_266_lateralsurface_cube"}
{"name": "mbpp_267_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 10\n    assert candidate(3) == 35\n    assert candidate(4) == 84\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 10"], "source_codes": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 2\n    return total\n\n\n"], "responses": ["```python\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 2\n    return total\n```"], "prompt_tokens": [89], "completion_tokens": [85], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_267_square_Sum"}
{"name": "mbpp_268_find_star_num", "language": "Python3", "prompt": "def find_star_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th star number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_star_num", "test": "def check(candidate):\n    assert candidate(3) == 37\n    assert candidate(4) == 73\n    assert candidate(5) == 121\n\ndef test_check():\n    check(find_star_num)\n\ntest_check()\n", "sample_io": ["assert find_star_num(3) == 37"], "source_codes": ["\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Find the n'th star number.\n    \"\"\"\n    return 6 * n * (n - 1) + 1\n\n\n"], "responses": ["Looking at this problem, I need to find the n-th star number.\n\nStar numbers are a sequence of numbers that represent centered hexagrams (six-pointed stars). The formula for the n-th star number is:\n\nStar(n) = 6n(n-1) + 1\n\nLet me verify this with the first few star numbers:\n- Star(1) = 6\u00d71\u00d70 + 1 = 1\n- Star(2) = 6\u00d72\u00d71 + 1 = 13\n- Star(3) = 6\u00d73\u00d72 + 1 = 37\n\nThis matches the known sequence of star numbers.\n\n```python\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Find the n'th star number.\n    \"\"\"\n    return 6 * n * (n - 1) + 1\n```"], "prompt_tokens": [76], "completion_tokens": [183], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_268_find_star_num"}
{"name": "mbpp_269_ascii_value", "language": "Python3", "prompt": "def ascii_value(k: str) -> int:\n    \"\"\"\n\tWrite a function to find the ascii value of a character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "ascii_value", "test": "def check(candidate):\n    assert candidate('A') == 65\n    assert candidate('R') == 82\n    assert candidate('S') == 83\n\ndef test_check():\n    check(ascii_value)\n\ntest_check()\n", "sample_io": ["assert ascii_value('A') == 65"], "source_codes": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    return ord(k)\n\n\n"], "responses": ["```python\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    return ord(k)\n```"], "prompt_tokens": [75], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_269_ascii_value"}
{"name": "mbpp_270_sum_even_and_even_index", "language": "Python3", "prompt": "from typing import List\n\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even numbers at even positions of a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_even_and_even_index", "test": "def check(candidate):\n    assert candidate([5, 6, 12, 1, 18, 8]) == 30\n    assert candidate([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26\n    assert candidate([5, 6, 12, 1]) == 12\n\ndef test_check():\n    check(sum_even_and_even_index)\n\ntest_check()\n", "sample_io": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"], "source_codes": ["\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of even numbers at even indices\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # Iterate through even indices only\n        if arr[i] % 2 == 0:  # Check if the number at even index is even\n            total += arr[i]\n    return total\n\n\n"], "responses": ["```python\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of even numbers at even indices\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # Iterate through even indices only\n        if arr[i] % 2 == 0:  # Check if the number at even index is even\n            total += arr[i]\n    return total\n```"], "prompt_tokens": [90], "completion_tokens": [122], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_270_sum_even_and_even_index"}
{"name": "mbpp_271_even_Power_Sum", "language": "Python3", "prompt": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_Power_Sum", "test": "def check(candidate):\n    assert candidate(2) == 1056\n    assert candidate(3) == 8832\n    assert candidate(1) == 32\n\ndef test_check():\n    check(even_Power_Sum)\n\ntest_check()\n", "sample_io": ["assert even_Power_Sum(2) == 1056"], "source_codes": ["\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 5\n    return total\n\n\n"], "responses": ["```python\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 5\n    return total\n```"], "prompt_tokens": [95], "completion_tokens": [87], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_271_even_Power_Sum"}
{"name": "mbpp_272_rear_extract", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rear_extract", "test": "def check(candidate):\n    assert candidate([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n    assert candidate([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\n    assert candidate([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\n\ndef test_check():\n    check(rear_extract)\n\ntest_check()\n", "sample_io": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"], "source_codes": ["\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n\n\n"], "responses": ["```python\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n```"], "prompt_tokens": [101], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_272_rear_extract"}
{"name": "mbpp_273_substract_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "substract_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    assert candidate((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    assert candidate((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n\ndef test_check():\n    check(substract_elements)\n\ntest_check()\n", "sample_io": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"], "source_codes": ["\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (test_tup1[0] - test_tup2[0], test_tup1[1] - test_tup2[1], test_tup1[2] - test_tup2[2])\n\n\n"], "responses": ["```python\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (test_tup1[0] - test_tup2[0], test_tup1[1] - test_tup2[1], test_tup1[2] - test_tup2[2])\n```"], "prompt_tokens": [123], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_273_substract_elements"}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "Python3", "prompt": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_binomial_Coeff_Sum", "test": "def check(candidate):\n    assert candidate(4) == 8\n    assert candidate(6) == 32\n    assert candidate(2) == 2\n\ndef test_check():\n    check(even_binomial_Coeff_Sum)\n\ntest_check()\n", "sample_io": ["assert even_binomial_Coeff_Sum(4) == 8"], "source_codes": ["\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Find the sum of even index binomial coefficients for (1 + x)^n\n    This is equivalent to finding the sum of C(n,0) + C(n,2) + C(n,4) + ...\n    \"\"\"\n    # The sum of even index binomial coefficients equals 2^(n-1)\n    # This can be derived from the fact that:\n    # (1 + 1)^n = sum of all binomial coefficients = 2^n\n    # (1 - 1)^n = alternating sum of binomial coefficients = 0\n    # Adding these: 2 * (sum of even index coefficients) = 2^n\n    # Therefore: sum of even index coefficients = 2^(n-1)\n    \n    if n == 0:\n        return 1  # C(0,0) = 1\n    \n    return 2 ** (n - 1)\n\n\n"], "responses": ["```python\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Find the sum of even index binomial coefficients for (1 + x)^n\n    This is equivalent to finding the sum of C(n,0) + C(n,2) + C(n,4) + ...\n    \"\"\"\n    # The sum of even index binomial coefficients equals 2^(n-1)\n    # This can be derived from the fact that:\n    # (1 + 1)^n = sum of all binomial coefficients = 2^n\n    # (1 - 1)^n = alternating sum of binomial coefficients = 0\n    # Adding these: 2 * (sum of even index coefficients) = 2^n\n    # Therefore: sum of even index coefficients = 2^(n-1)\n    \n    if n == 0:\n        return 1  # C(0,0) = 1\n    \n    return 2 ** (n - 1)\n```"], "prompt_tokens": [90], "completion_tokens": [212], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_274_even_binomial_Coeff_Sum"}
{"name": "mbpp_277_dict_filter", "language": "Python3", "prompt": "from typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n\tWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dict_filter", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 170) == { 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 180) == { 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 190) == { 'Pierre Cox': 190 }\n\ndef test_check():\n    check(dict_filter)\n\ntest_check()\n", "sample_io": ["assert dict_filter(3) == 27"], "source_codes": ["\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n\n\n"], "responses": ["```python\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n```"], "prompt_tokens": [106], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_277_dict_filter"}
{"name": "mbpp_278_count_first_elements", "language": "Python3", "prompt": "from typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n\tWrite a function to find the number of elements that occurs before the list element in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_first_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, (4, 6), 10]) == 3\n    assert candidate([2, 9, (5, 7), 11]) == 2\n    assert candidate([11, 15, 5, 8, (2, 3), 8]) == 4\n\ndef test_check():\n    check(count_first_elements)\n\ntest_check()\n", "sample_io": ["assert count_first_elements([1, 5, 7, (4, 6), 10]) == 3"], "source_codes": ["\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return len(test_tup)\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Iterate through the given list/tuple\n2. Count elements until I encounter a list element (which would be represented as a Tuple in the type hint)\n3. Return the count of elements before the first list element\n\nLet me analyze the type hint: `List[Union[int, Tuple[int, int]]]` suggests we have a list containing either integers or tuples of two integers. The problem asks for counting elements before a \"list element\", which in this context would be the Tuple.\n\n```python\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return len(test_tup)\n```"], "prompt_tokens": [104], "completion_tokens": [191], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_278_count_first_elements"}
{"name": "mbpp_279_is_num_decagonal", "language": "Python3", "prompt": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth decagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_num_decagonal", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(7) == 175\n    assert candidate(10) == 370\n\ndef test_check():\n    check(is_num_decagonal)\n\ntest_check()\n", "sample_io": ["assert is_num_decagonal(3) == 27"], "source_codes": ["\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Find the nth decagonal number.\n    \n    A decagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the decagon (a ten-sided polygon).\n    \n    The formula for the nth decagonal number is: 4n\u00b2 - 3n\n    \n    Args:\n        n (int): The position of the decagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth decagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 4 * n * n - 3 * n\n\n\n"], "responses": ["```python\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Find the nth decagonal number.\n    \n    A decagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the decagon (a ten-sided polygon).\n    \n    The formula for the nth decagonal number is: 4n\u00b2 - 3n\n    \n    Args:\n        n (int): The position of the decagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth decagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 4 * n * n - 3 * n\n```"], "prompt_tokens": [76], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_279_is_num_decagonal"}
{"name": "mbpp_280_sequential_search", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n\tWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequential_search", "test": "def check(candidate):\n    assert candidate([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)\n    assert candidate([12, 32, 45, 62, 35, 47, 44, 61], 61) == (True, 7)\n    assert candidate([9, 10, 17, 19, 22, 39, 48, 56], 48) == (True, 6)\n\ndef test_check():\n    check(sequential_search)\n\ntest_check()\n", "sample_io": ["assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"], "source_codes": ["\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing \n    a boolean that indicates if the element is in the array and the index position \n    of the element (or -1 if the element is not found).\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return (True, i)\n    \n    return (False, -1)\n\n\n"], "responses": ["```python\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing \n    a boolean that indicates if the element is in the array and the index position \n    of the element (or -1 if the element is not found).\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return (True, i)\n    \n    return (False, -1)\n```"], "prompt_tokens": [124], "completion_tokens": [112], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_280_sequential_search"}
{"name": "mbpp_281_all_unique", "language": "Python3", "prompt": "from typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check if the elements of a given list are unique or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_unique", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == True\n\ndef test_check():\n    check(all_unique)\n\ntest_check()\n", "sample_io": ["assert all_unique([1, 2, 3]) == True"], "source_codes": ["\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n\n\n"], "responses": ["```python\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n```"], "prompt_tokens": [88], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_281_all_unique"}
{"name": "mbpp_282_sub_list", "language": "Python3", "prompt": "from typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to subtract two lists element-wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sub_list", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\n    assert candidate([1, 2], [3, 4]) == [-2, -2]\n    assert candidate([90, 120], [50, 70]) == [40, 50]\n\ndef test_check():\n    check(sub_list)\n\ntest_check()\n", "sample_io": ["assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"], "source_codes": ["\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    return [a - b for a, b in zip(nums1, nums2)]\n\n\n"], "responses": ["```python\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    return [a - b for a, b in zip(nums1, nums2)]\n```"], "prompt_tokens": [87], "completion_tokens": [57], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_282_sub_list"}
{"name": "mbpp_283_validate", "language": "Python3", "prompt": "def validate(n: int) -> bool:\n    \"\"\"\n\tWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "validate", "test": "def check(candidate):\n    assert candidate(1234) == True\n    assert candidate(51241) == False\n    assert candidate(321) == True\n\ndef test_check():\n    check(validate)\n\ntest_check()\n", "sample_io": ["assert validate(1234) == True"], "source_codes": ["\ndef validate(n: int) -> bool:\n    \"\"\"\n    Takes in an integer and checks whether the frequency of each digit in the integer \n    is less than or equal to the digit itself.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        bool: True if frequency of each digit <= digit value, False otherwise\n    \"\"\"\n    # Convert to string to easily iterate through digits\n    # Handle negative numbers by taking absolute value\n    digits_str = str(abs(n))\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit value\n    for digit, frequency in digit_count.items():\n        if frequency > digit:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef validate(n: int) -> bool:\n    \"\"\"\n    Takes in an integer and checks whether the frequency of each digit in the integer \n    is less than or equal to the digit itself.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        bool: True if frequency of each digit <= digit value, False otherwise\n    \"\"\"\n    # Convert to string to easily iterate through digits\n    # Handle negative numbers by taking absolute value\n    digits_str = str(abs(n))\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit value\n    for digit, frequency in digit_count.items():\n        if frequency > digit:\n            return False\n    \n    return True\n```"], "prompt_tokens": [91], "completion_tokens": [191], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_283_validate"}
{"name": "mbpp_284_check_element", "language": "Python3", "prompt": "from typing import List, Any\n\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n\tWrite a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_284_check_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_element", "test": "def check(candidate):\n    assert candidate(['green', 'orange', 'black', 'white'], 'blue') == False\n    assert candidate([1, 2, 3, 4], 7) == False\n    assert candidate(['green', 'green', 'green', 'green'], 'green') == True\n\ndef test_check():\n    check(check_element)\n\ntest_check()\n", "sample_io": ["assert check_element(['green', 'orange', 'black', 'white'], 'blue') == False"], "source_codes": ["\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n```"], "prompt_tokens": [100], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_284_check_element"}
{"name": "mbpp_285_text_match_two_three", "language": "Python3", "prompt": "def text_match_two_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_two_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n\ndef test_check():\n    check(text_match_two_three)\n\ntest_check()\n", "sample_io": ["assert text_match_two_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [89], "completion_tokens": [69], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_285_text_match_two_three"}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum_repeated", "test": "def check(candidate):\n    assert candidate([10, 20, -30, -1], 4, 3) == 30\n    assert candidate([-1, 10, 20], 3, 2) == 59\n    assert candidate([-1, -2, -3], 3, 3) == -1\n\ndef test_check():\n    check(max_sub_array_sum_repeated)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"], "source_codes": ["\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    # Kadane's algorithm for maximum subarray sum\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm on the original array\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate total sum of the array\n    total_sum = sum(a)\n    \n    # Create array of size 2*n by concatenating a with itself\n    extended_array = a + a\n    \n    # Find maximum subarray sum in the extended array\n    max_kadane = kadane(extended_array)\n    \n    # If total sum is negative, the best subarray won't span multiple copies\n    if total_sum < 0:\n        return max_kadane\n    \n    # If total sum is positive, we can include (k-2) full arrays in between\n    # The maximum sum would be: max_kadane + (k-2) * total_sum\n    return max_kadane + (k - 2) * total_sum\n\n\n"], "responses": ["```python\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    # Kadane's algorithm for maximum subarray sum\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm on the original array\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate total sum of the array\n    total_sum = sum(a)\n    \n    # Create array of size 2*n by concatenating a with itself\n    extended_array = a + a\n    \n    # Find maximum subarray sum in the extended array\n    max_kadane = kadane(extended_array)\n    \n    # If total sum is negative, the best subarray won't span multiple copies\n    if total_sum < 0:\n        return max_kadane\n    \n    # If total sum is positive, we can include (k-2) full arrays in between\n    # The maximum sum would be: max_kadane + (k-2) * total_sum\n    return max_kadane + (k - 2) * total_sum\n```"], "prompt_tokens": [108], "completion_tokens": [302], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_286_max_sub_array_sum_repeated"}
{"name": "mbpp_287_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 20\n    assert candidate(3) == 56\n    assert candidate(4) == 120\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 20"], "source_codes": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n    \"\"\"\n    # First n even natural numbers are: 2, 4, 6, ..., 2n\n    # We need to calculate: 2^2 + 4^2 + 6^2 + ... + (2n)^2\n    # This can be written as: 4(1^2 + 2^2 + 3^2 + ... + n^2)\n    # Using the formula for sum of squares: 1^2 + 2^2 + ... + n^2 = n(n+1)(2n+1)/6\n    \n    return 4 * n * (n + 1) * (2 * n + 1) // 6\n\n\n"], "responses": ["```python\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n    \"\"\"\n    # First n even natural numbers are: 2, 4, 6, ..., 2n\n    # We need to calculate: 2^2 + 4^2 + 6^2 + ... + (2n)^2\n    # This can be written as: 4(1^2 + 2^2 + 3^2 + ... + n^2)\n    # Using the formula for sum of squares: 1^2 + 2^2 + ... + n^2 = n(n+1)(2n+1)/6\n    \n    return 4 * n * (n + 1) * (2 * n + 1) // 6\n```"], "prompt_tokens": [86], "completion_tokens": [190], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_287_square_Sum"}
{"name": "mbpp_290_max_length", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list of maximum length in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1], [5, 7], [10, 12, 14, 15]]) == (4, [10, 12, 14, 15])\n    assert candidate([[5], [15, 20, 25]]) == (3, [15, 20, 25])\n\ndef test_check():\n    check(max_length)\n\ntest_check()\n", "sample_io": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    \"\"\"\n    if not list1:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)\n\n\n"], "responses": ["```python\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n    \"\"\"\n    if not list1:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)\n```"], "prompt_tokens": [93], "completion_tokens": [107], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_290_max_length"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # For n >= 3\n    same = k  # ways where last two posts are same (positions 1 and 2)\n    diff = k * (k - 1)  # ways where last two posts are different (positions 1 and 2)\n    \n    for i in range(3, n + 1):\n        new_same = diff\n        new_diff = (same + diff) * (k - 1)\n        same = new_same\n        diff = new_diff\n    \n    return same + diff\n\n\n"], "responses": ["Looking at this problem, I need to count the number of ways to paint a fence with n posts using k colors, where at most 2 adjacent posts can have the same color.\n\nLet me think about this step by step:\n\n1. For n=1: We can paint it in k ways\n2. For n=2: We can paint it in k*k ways (each post can be any of k colors)\n3. For n\u22653: I need to ensure no more than 2 consecutive posts have the same color\n\nI'll use dynamic programming:\n- Let `same[i]` = number of ways where the last two posts (i-1 and i) have the same color\n- Let `diff[i]` = number of ways where the last two posts (i-1 and i) have different colors\n\nThe recurrence relations are:\n- `same[i] = diff[i-1]` (to have same color at position i, position i-1 must be different from i-2)\n- `diff[i] = (same[i-1] + diff[i-1]) * (k-1)` (we can choose any of the remaining k-1 colors)\n\nBase cases:\n- `same[2] = k` (first two posts same color)\n- `diff[2] = k * (k-1)` (first two posts different colors)\n\n```python\ndef count_no_of_ways(n: int, k: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # For n >= 3\n    same = k  # ways where last two posts are same (positions 1 and 2)\n    diff = k * (k - 1)  # ways where last two posts are different (positions 1 and 2)\n    \n    for i in range(3, n + 1):\n        new_same = diff\n        new_diff = (same + diff) * (k - 1)\n        same = new_same\n        diff = new_diff\n    \n    return same + diff\n```"], "prompt_tokens": [107], "completion_tokens": [454], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n\n\n"], "responses": ["```python\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n```"], "prompt_tokens": [84], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": ["\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Find the third side of a right angled triangle given two sides.\n    Uses Pythagorean theorem: c\u00b2 = a\u00b2 + b\u00b2\n    \"\"\"\n    import math\n    \n    # Calculate the hypotenuse (third side) using Pythagorean theorem\n    third_side = math.sqrt(w**2 + h**2)\n    \n    return third_side\n\n\n"], "responses": ["```python\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Find the third side of a right angled triangle given two sides.\n    Uses Pythagorean theorem: c\u00b2 = a\u00b2 + b\u00b2\n    \"\"\"\n    import math\n    \n    # Calculate the hypotenuse (third side) using Pythagorean theorem\n    third_side = math.sqrt(w**2 + h**2)\n    \n    return third_side\n```"], "prompt_tokens": [83], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_294_max_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 5\n    assert candidate(['Python', 15, 20, 25]) == 25\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 50\n\ndef test_check():\n    check(max_val)\n\ntest_check()\n", "sample_io": ["assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"], "source_codes": ["\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Find the maximum value in a given heterogeneous list.\n    Only considers integer values in the list.\n    \"\"\"\n    # Filter out only integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the maximum integer value\n    if int_values:\n        return max(int_values)\n    else:\n        # If no integers in list, raise an exception or handle as needed\n        raise ValueError(\"No integer values found in the list\")\n\n\n"], "responses": ["```python\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Find the maximum value in a given heterogeneous list.\n    Only considers integer values in the list.\n    \"\"\"\n    # Filter out only integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the maximum integer value\n    if int_values:\n        return max(int_values)\n    else:\n        # If no integers in list, raise an exception or handle as needed\n        raise ValueError(\"No integer values found in the list\")\n```"], "prompt_tokens": [90], "completion_tokens": [121], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_294_max_val"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n\n\n"], "responses": ["```python\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n```"], "prompt_tokens": [78], "completion_tokens": [87], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_296_get_Inv_Count", "language": "Python3", "prompt": "from typing import List\n\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count inversions in an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Inv_Count", "test": "def check(candidate):\n    assert candidate([1, 20, 6, 4, 5]) == 5\n    assert candidate([1, 2, 1]) == 1\n    assert candidate([1, 2, 5, 6, 1]) == 3\n\ndef test_check():\n    check(get_Inv_Count)\n\ntest_check()\n", "sample_io": ["assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"], "source_codes": ["\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n\n\n"], "responses": ["```python\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n```"], "prompt_tokens": [83], "completion_tokens": [427], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_296_get_Inv_Count"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flatten a given nested list structure.\n    \"\"\"\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n\n\n"], "responses": ["```python\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flatten a given nested list structure.\n    \"\"\"\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n```"], "prompt_tokens": [90], "completion_tokens": [74], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_299_max_aggregate", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n\tWrite a function to calculate the maximum aggregate from the list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_aggregate", "test": "def check(candidate):\n    assert candidate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)\n    assert candidate([('Juan Whelan', 50), ('Sabah Colley', 48), ('Peter Nichols', 37), ('Juan Whelan', 22), ('Sabah Colley', 14)]) == ('Juan Whelan', 72)\n    assert candidate([('Juan Whelan', 10), ('Sabah Colley', 20), ('Peter Nichols', 30), ('Juan Whelan', 40), ('Sabah Colley', 50)]) == ('Sabah Colley', 70)\n\ndef test_check():\n    check(max_aggregate)\n\ntest_check()\n", "sample_io": ["assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"], "source_codes": ["\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return (\"\", 0)\n    \n    max_name, max_value = stdata[0]\n    \n    for name, value in stdata:\n        if value > max_value:\n            max_name, max_value = name, value\n    \n    return (max_name, max_value)\n\n\n"], "responses": ["```python\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return (\"\", 0)\n    \n    max_name, max_value = stdata[0]\n    \n    for name, value in stdata:\n        if value > max_value:\n            max_name, max_value = name, value\n    \n    return (max_name, max_value)\n```"], "prompt_tokens": [94], "completion_tokens": [106], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_299_max_aggregate"}
{"name": "mbpp_304_find_Element", "language": "Python3", "prompt": "from typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    \"\"\"\n\tWrite a python function to find element at a given index after number of rotations.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3\n    assert candidate([1, 2, 3, 4], [[0, 1], [0, 2]], 1, 2) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [[0, 1], [0, 2]], 1, 1) == 1\n\ndef test_check():\n    check(find_Element)\n\ntest_check()\n", "sample_io": ["assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3"], "source_codes": ["\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Make a copy of the array to avoid modifying the original\n    result_arr = arr.copy()\n    \n    # Perform the specified number of rotations\n    for _ in range(rotations):\n        # Apply each range rotation\n        for start, end in ranges:\n            if start <= end and 0 <= start < len(result_arr) and 0 <= end < len(result_arr):\n                # Right rotation: move last element to first position\n                if start != end:  # Only rotate if range has more than one element\n                    temp = result_arr[end]\n                    for i in range(end, start, -1):\n                        result_arr[i] = result_arr[i-1]\n                    result_arr[start] = temp\n    \n    # Return the element at the specified index\n    return result_arr[index]\n\n\n"], "responses": ["Looking at this problem, I need to find the element at a given index after performing a certain number of rotations on an array within specified ranges.\n\nLet me break down the approach:\n1. For each rotation, I need to rotate the elements in the specified ranges\n2. After all rotations, return the element at the given index\n\nHowever, looking at the function signature more carefully, it seems like \"ranges\" might represent multiple range operations, and \"rotations\" is the number of times to perform rotations.\n\nLet me implement a solution that handles right rotations within specified ranges:\n\n```python\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Make a copy of the array to avoid modifying the original\n    result_arr = arr.copy()\n    \n    # Perform the specified number of rotations\n    for _ in range(rotations):\n        # Apply each range rotation\n        for start, end in ranges:\n            if start <= end and 0 <= start < len(result_arr) and 0 <= end < len(result_arr):\n                # Right rotation: move last element to first position\n                if start != end:  # Only rotate if range has more than one element\n                    temp = result_arr[end]\n                    for i in range(end, start, -1):\n                        result_arr[i] = result_arr[i-1]\n                    result_arr[start] = temp\n    \n    # Return the element at the specified index\n    return result_arr[index]\n```"], "prompt_tokens": [99], "completion_tokens": [310], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_304_find_Element"}
{"name": "mbpp_305_start_withp", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n\tWrite a function to return two words from a list of words starting with letter 'p'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "start_withp", "test": "def check(candidate):\n    assert candidate(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')\n    assert candidate(['Python Programming', 'Java Programming']) == ('Python', 'Programming')\n    assert candidate(['Pqrst Pqr', 'qrstuv']) == ('Pqrst', 'Pqr')\n\ndef test_check():\n    check(start_withp)\n\ntest_check()\n", "sample_io": ["assert start_withp(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')"], "source_codes": ["\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = [word for word in words if word.lower().startswith('p')]\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    else:\n        raise ValueError(\"Not enough words starting with 'p' in the list\")\n\n\n"], "responses": ["```python\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = [word for word in words if word.lower().startswith('p')]\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    else:\n        raise ValueError(\"Not enough words starting with 'p' in the list\")\n```"], "prompt_tokens": [93], "completion_tokens": [104], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_305_start_withp"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": ["\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of increasing subsequence from prefix until ith index \n    and also including a given kth element which is after i, i.e., k > i.\n    \"\"\"\n    if k <= index:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize dp array\n    for i in range(index + 1):\n        dp[i] = a[i]\n    \n    # Fill dp array for indices 0 to index\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find maximum sum subsequence that ends before or at index and can be extended to k\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:  # Can extend this subsequence to include a[k]\n            max_sum = max(max_sum, dp[i])\n    \n    # Return the maximum sum including a[k]\n    return max_sum + a[k] if max_sum > 0 else a[k]\n\n\n"], "responses": ["```python\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of increasing subsequence from prefix until ith index \n    and also including a given kth element which is after i, i.e., k > i.\n    \"\"\"\n    if k <= index:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize dp array\n    for i in range(index + 1):\n        dp[i] = a[i]\n    \n    # Fill dp array for indices 0 to index\n    for i in range(1, index + 1):\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find maximum sum subsequence that ends before or at index and can be extended to k\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:  # Can extend this subsequence to include a[k]\n            max_sum = max(max_sum, dp[i])\n    \n    # Return the maximum sum including a[k]\n    return max_sum + a[k] if max_sum > 0 else a[k]\n```"], "prompt_tokens": [122], "completion_tokens": [290], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return the first N elements\n    products.sort(reverse=True)\n    return products[:N]\n\n\n"], "responses": ["```python\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return the first N elements\n    products.sort(reverse=True)\n    return products[:N]\n```"], "prompt_tokens": [104], "completion_tokens": [116], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_309_maximum", "language": "Python3", "prompt": "def maximum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximum", "test": "def check(candidate):\n    assert candidate(5, 10) == 10\n    assert candidate(-1, -2) == -1\n    assert candidate(9, 7) == 9\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n", "sample_io": ["assert maximum(5, 10) == 10"], "source_codes": ["\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n\n\n"], "responses": ["```python\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n```"], "prompt_tokens": [78], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_309_maximum"}
{"name": "mbpp_310_string_to_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_tuple", "test": "def check(candidate):\n    assert candidate('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n    assert candidate('item1') == ['i', 't', 'e', 'm', '1']\n    assert candidate('15.10') == ['1', '5', '.', '1', '0']\n\ndef test_check():\n    check(string_to_tuple)\n\ntest_check()\n", "sample_io": ["assert string_to_tuple('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']"], "source_codes": ["\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n\n\n"], "responses": ["```python\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n```"], "prompt_tokens": [85], "completion_tokens": [43], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_310_string_to_tuple"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    \n    return 1 << power\n\n\n"], "responses": ["```python\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    \n    return 1 << power\n```"], "prompt_tokens": [88], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    The Lucas sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use iterative approach to avoid recursion overhead\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["```python\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    The Lucas sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use iterative approach to avoid recursion overhead\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n```"], "prompt_tokens": [77], "completion_tokens": [210], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n\n\n"], "responses": ["```python\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n```"], "prompt_tokens": [94], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_391_convert_list_dictionary", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    \"\"\"\n\tWrite a function to convert more than one list to nested dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_391_convert_list_dictionary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert_list_dictionary", "test": "def check(candidate):\n    assert candidate(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }, { 'S002': { 'Leyton Marsh': 98 } }, { 'S003': { 'Duncan Boyle': 89 } }, { 'S004': { 'Saim Richards': 92 } }]\n    assert candidate(['abc', 'def', 'ghi', 'jkl'], ['python', 'program', 'language', 'programs'], [100, 200, 300, 400]) == [{ 'abc': { 'python': 100 } }, { 'def': { 'program': 200 } }, { 'ghi': { 'language': 300 } }, { 'jkl': { 'programs': 400 } }]\n    assert candidate(['A1', 'A2', 'A3', 'A4'], ['java', 'C', 'C++', 'DBMS'], [10, 20, 30, 40]) == [{ 'A1': { 'java': 10 } }, { 'A2': { 'C': 20 } }, { 'A3': { 'C++': 30 } }, { 'A4': { 'DBMS': 40 } }]\n\ndef test_check():\n    check(convert_list_dictionary)\n\ntest_check()\n", "sample_io": ["assert convert_list_dictionary(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }]"], "source_codes": ["\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    if not l1 or not l2 or not l3:\n        return []\n    \n    result = []\n    \n    # Process elements in parallel\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        # Create a dictionary with l1[i] as key and {l2[i]: l3[i]} as value\n        item = {l1[i]: {l2[i]: l3[i]}}\n        result.append(item)\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to convert three lists into a nested dictionary structure where:\n- The first list (l1) contains keys for the outer dictionary\n- The second list (l2) contains keys for the inner dictionary  \n- The third list (l3) contains values for the inner dictionary\n\nThe expected return type is `List[Dict[str, Dict[str, int]]]`, which suggests a list containing dictionaries.\n\nLet me think about the structure:\n- Each element from l1 becomes a key in a dictionary\n- Each element from l2 becomes a key in a nested dictionary\n- Each element from l3 becomes a value in that nested dictionary\n\nSince we have three lists, I'll assume they should be processed in parallel (same indices), and we might want to group them in some way.\n\n```python\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    if not l1 or not l2 or not l3:\n        return []\n    \n    result = []\n    \n    # Process elements in parallel\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        # Create a dictionary with l1[i] as key and {l2[i]: l3[i]} as value\n        item = {l1[i]: {l2[i]: l3[i]}}\n        result.append(item)\n    \n    return result\n```"], "prompt_tokens": [107], "completion_tokens": [314], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_391_convert_list_dictionary"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 1:\n            memo[num] = num\n            return num\n        \n        # Calculate the sum of breaking down into parts\n        breakdown_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum between keeping the number or breaking it down\n        result = max(num, breakdown_sum)\n        memo[num] = result\n        return result\n    \n    return f(n)\n\n\n"], "responses": ["Looking at this problem, I need to implement a recursive function with memoization to find the maximum sum using the given equation.\n\nThe function f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n) means:\n- Either take n as is\n- Or break it down into parts and sum up their maximum values\n\nI'll use dynamic programming with memoization to avoid recalculating values.\n\n```python\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 1:\n            memo[num] = num\n            return num\n        \n        # Calculate the sum of breaking down into parts\n        breakdown_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum between keeping the number or breaking it down\n        result = max(num, breakdown_sum)\n        memo[num] = result\n        return result\n    \n    return f(n)\n```"], "prompt_tokens": [110], "completion_tokens": [233], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_393_max_length_list", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list with maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length_list", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5])\n    assert candidate([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9])\n\ndef test_check():\n    check(max_length_list)\n\ntest_check()\n", "sample_io": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = max(input_list, key=len)\n    return (len(max_list), max_list)\n\n\n"], "responses": ["```python\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = max(input_list, key=len)\n    return (len(max_list), max_list)\n```"], "prompt_tokens": [89], "completion_tokens": [107], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_393_max_length_list"}
{"name": "mbpp_394_check_distinct", "language": "Python3", "prompt": "from typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if given list contains no duplicates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_distinct", "test": "def check(candidate):\n    assert candidate([1, 4, 5, 6, 1, 4]) == False\n    assert candidate([1, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 6]) == True\n\ndef test_check():\n    check(check_distinct)\n\ntest_check()\n", "sample_io": ["assert check_distinct([1, 4, 5, 6, 1, 4]) == False"], "source_codes": ["\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))\n\n\n"], "responses": ["```python\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))\n```"], "prompt_tokens": [84], "completion_tokens": [50], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_394_check_distinct"}
{"name": "mbpp_395_first_non_repeating_character", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first non-repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_non_repeating_character", "test": "def check(candidate):\n    assert candidate('abcabc') == None\n    assert candidate('abc') == 'a'\n    assert candidate('ababc') == 'c'\n\ndef test_check():\n    check(first_non_repeating_character)\n\ntest_check()\n", "sample_io": ["assert first_non_repeating_character('abcabc') == None"], "source_codes": ["\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n        str1: Input string\n        \n    Returns:\n        The first non-repeating character, or None if all characters repeat\n    \"\"\"\n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n\n\n"], "responses": ["```python\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n        str1: Input string\n        \n    Returns:\n        The first non-repeating character, or None if all characters repeat\n    \"\"\"\n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n```"], "prompt_tokens": [90], "completion_tokens": [141], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_395_first_non_repeating_character"}
{"name": "mbpp_396_check_char", "language": "Python3", "prompt": "def check_char(string: str) -> str:\n    \"\"\"\n\tWrite a function to check whether the given string starts and ends with the same character or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_char", "test": "def check(candidate):\n    assert candidate('abba') == 'Valid'\n    assert candidate('a') == 'Valid'\n    assert candidate('abcd') == 'Invalid'\n\ndef test_check():\n    check(check_char)\n\ntest_check()\n", "sample_io": ["assert check_char('abba') == 'Valid'"], "source_codes": ["\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"No\"\n    \n    # Handle single character string\n    if len(string) == 1:\n        return \"Yes\"\n    \n    # Check if first and last characters are the same\n    if string[0] == string[-1]:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n\n"], "responses": ["```python\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"No\"\n    \n    # Handle single character string\n    if len(string) == 1:\n        return \"Yes\"\n    \n    # Check if first and last characters are the same\n    if string[0] == string[-1]:\n        return \"Yes\"\n    else:\n        return \"No\"\n```"], "prompt_tokens": [82], "completion_tokens": [119], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_396_check_char"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \"\"\"\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n\n\n"], "responses": ["```python\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \"\"\"\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n```"], "prompt_tokens": [82], "completion_tokens": [56], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total += int(char)\n    \n    return total\n\n\n"], "responses": ["```python\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total += int(char)\n    \n    return total\n```"], "prompt_tokens": [89], "completion_tokens": [109], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n\n\n"], "responses": ["```python\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n```"], "prompt_tokens": [114], "completion_tokens": [135], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_400_extract_freq", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to extract the number of unique tuples in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_freq", "test": "def check(candidate):\n    assert candidate([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    assert candidate([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    assert candidate([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n\ndef test_check():\n    check(extract_freq)\n\ntest_check()\n", "sample_io": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"], "source_codes": ["\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n\n\n"], "responses": ["```python\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n```"], "prompt_tokens": [91], "completion_tokens": [48], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_400_extract_freq"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through the outer lists\n    for i in range(len(test_tup1)):\n        inner_result = []\n        # Iterate through the inner lists\n        for j in range(len(test_tup1[i])):\n            inner_result.append(test_tup1[i][j] + test_tup2[i][j])\n        result.append(inner_result)\n    \n    return result\n\n\n"], "responses": ["```python\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through the outer lists\n    for i in range(len(test_tup1)):\n        inner_result = []\n        # Iterate through the inner lists\n        for j in range(len(test_tup1[i])):\n            inner_result.append(test_tup1[i][j] + test_tup2[i][j])\n        result.append(inner_result)\n    \n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [132], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_401_add_nested_tuples"}
{"name": "mbpp_404_minimum", "language": "Python3", "prompt": "def minimum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "minimum", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(-5, -4) == -5\n    assert candidate(0, 0) == 0\n\ndef test_check():\n    check(minimum)\n\ntest_check()\n", "sample_io": ["assert minimum(1, 2) == 1"], "source_codes": ["\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n\n\n"], "responses": ["```python\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n```"], "prompt_tokens": [78], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_404_minimum"}
{"name": "mbpp_405_check_tuplex", "language": "Python3", "prompt": "from typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n\tWrite a function to check whether an element exists within a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_405_check_tuplex.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_tuplex", "test": "def check(candidate):\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], '5') == False\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 3) == True\n\ndef test_check():\n    check(check_tuplex)\n\ntest_check()\n", "sample_io": ["assert check_tuplex(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True"], "source_codes": ["\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex\n\n\n"], "responses": ["```python\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex\n```"], "prompt_tokens": [99], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_405_check_tuplex"}
{"name": "mbpp_406_find_Parity", "language": "Python3", "prompt": "def find_Parity(x: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether the parity of a given number is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Parity", "test": "def check(candidate):\n    assert candidate(12) == False\n    assert candidate(7) == True\n    assert candidate(10) == False\n\ndef test_check():\n    check(find_Parity)\n\ntest_check()\n", "sample_io": ["assert find_Parity(12) == False"], "source_codes": ["\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the parity is odd, False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if even\n    return count % 2 == 1\n\n\n"], "responses": ["```python\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the parity is odd, False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if even\n    return count % 2 == 1\n```"], "prompt_tokens": [80], "completion_tokens": [172], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_406_find_Parity"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n    Create the next bigger number by rearranging the digits of a given number.\n    If no such number exists, return None.\n    \"\"\"\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit found, no bigger permutation exists\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n\n\n"], "responses": ["```python\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n    Create the next bigger number by rearranging the digits of a given number.\n    If no such number exists, return None.\n    \"\"\"\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit found, no bigger permutation exists\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n```"], "prompt_tokens": [89], "completion_tokens": [244], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["\nimport heapq\nfrom typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Use a min heap to keep track of the smallest pairs\n    heap = []\n    visited = set()\n    \n    # Initialize with the pair (0,0) - indices from both arrays\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n    visited.add((0, 0))\n    \n    result = []\n    \n    while heap and len(result) < k:\n        # Get the smallest sum pair\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        # Move to next index in nums1 (i+1, j)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Move to next index in nums2 (i, j+1)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "responses": ["```python\nimport heapq\nfrom typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Use a min heap to keep track of the smallest pairs\n    heap = []\n    visited = set()\n    \n    # Initialize with the pair (0,0) - indices from both arrays\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n    visited.add((0, 0))\n    \n    result = []\n    \n    while heap and len(result) < k:\n        # Get the smallest sum pair\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        # Move to next index in nums1 (i+1, j)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Move to next index in nums2 (i, j+1)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n```"], "prompt_tokens": [111], "completion_tokens": [351], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n        list1: A list of tuples containing two integers each\n        \n    Returns:\n        The minimum product value among all tuple pairs\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Calculate products of each tuple pair and find the minimum\n    products = [a * b for a, b in list1]\n    return min(products)\n\n\n"], "responses": ["```python\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n        list1: A list of tuples containing two integers each\n        \n    Returns:\n        The minimum product value among all tuple pairs\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Calculate products of each tuple pair and find the minimum\n    products = [a * b for a, b in list1]\n    return min(products)\n```"], "prompt_tokens": [95], "completion_tokens": [120], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_410_min_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 2\n    assert candidate(['Python', 15, 20, 25]) == 15\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 20\n\ndef test_check():\n    check(min_val)\n\ntest_check()\n", "sample_io": ["assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"], "source_codes": ["\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of the integer values\n    return min(int_values)\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of the integer values\n    return min(int_values)\n```"], "prompt_tokens": [90], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_410_min_val"}
{"name": "mbpp_411_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert the given snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('android_tv') == 'AndroidTv'\n    assert candidate('google_pixel') == 'GooglePixel'\n    assert candidate('apple_watch') == 'AppleWatch'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('android_tv') == 'AndroidTv'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert the given snake case string to camel case string.\n    \n    Args:\n        word (str): A snake case string\n        \n    Returns:\n        str: The camel case equivalent\n        \n    Examples:\n        >>> snake_to_camel('hello_world')\n        'helloWorld'\n        >>> snake_to_camel('snake_case_to_camel_case')\n        'snakeCaseToCamelCase'\n        >>> snake_to_camel('single')\n        'single'\n    \"\"\"\n    if not word:\n        return word\n    \n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = words[0] + ''.join(word.capitalize() for word in words[1:])\n    \n    return result\n\n\n"], "responses": ["```python\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert the given snake case string to camel case string.\n    \n    Args:\n        word (str): A snake case string\n        \n    Returns:\n        str: The camel case equivalent\n        \n    Examples:\n        >>> snake_to_camel('hello_world')\n        'helloWorld'\n        >>> snake_to_camel('snake_case_to_camel_case')\n        'snakeCaseToCamelCase'\n        >>> snake_to_camel('single')\n        'single'\n    \"\"\"\n    if not word:\n        return word\n    \n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = words[0] + ''.join(word.capitalize() for word in words[1:])\n    \n    return result\n```"], "prompt_tokens": [80], "completion_tokens": [179], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_411_snake_to_camel"}
{"name": "mbpp_412_remove_odd", "language": "Python3", "prompt": "from typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove odd numbers from a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [2]\n    assert candidate([2, 4, 6]) == [2, 4, 6]\n    assert candidate([10, 20, 3]) == [10, 20]\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd([1, 2, 3]) == [2]"], "source_codes": ["\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [x for x in l if x % 2 == 0]\n\n\n"], "responses": ["```python\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [x for x in l if x % 2 == 0]\n```"], "prompt_tokens": [83], "completion_tokens": [51], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_412_remove_odd"}
{"name": "mbpp_413_extract_nth_element", "language": "Python3", "prompt": "from typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract the nth element from a given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_nth_element", "test": "def check(candidate):\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2) == [99, 96, 94, 98]\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1) == [98, 97, 91, 94]\n\ndef test_check():\n    check(extract_nth_element)\n\ntest_check()\n", "sample_io": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"], "source_codes": ["\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    return [tuple_item[n] for tuple_item in list1]\n\n\n"], "responses": ["```python\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    return [tuple_item[n] for tuple_item in list1]\n```"], "prompt_tokens": [101], "completion_tokens": [62], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_413_extract_nth_element"}
{"name": "mbpp_414_overlapping", "language": "Python3", "prompt": "from typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "overlapping", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False\n    assert candidate([1, 2, 3], [4, 5, 6]) == False\n    assert candidate([1, 4, 5], [1, 4, 5]) == True\n\ndef test_check():\n    check(overlapping)\n\ntest_check()\n", "sample_io": ["assert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"], "source_codes": ["\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence or not.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n\n\n"], "responses": ["```python\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence or not.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n```"], "prompt_tokens": [94], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_414_overlapping"}
{"name": "mbpp_415_max_Product", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n\tWrite a python function to find a pair with highest product from a given array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    assert candidate([0, -1, -2, -4, 5, 0, -6]) == (-4, -6)\n    assert candidate([1, 2, 3]) == (2, 3)\n\ndef test_check():\n    check(max_Product)\n\ntest_check()\n", "sample_io": ["assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"], "source_codes": ["\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily find candidates for maximum product\n    sorted_arr = sorted(arr)\n    n = len(sorted_arr)\n    \n    # The maximum product will be either:\n    # 1. Product of two largest numbers (if both positive)\n    # 2. Product of two smallest numbers (if both negative)\n    product1 = sorted_arr[0] * sorted_arr[1]  # Two smallest\n    product2 = sorted_arr[n-1] * sorted_arr[n-2]  # Two largest\n    \n    if product1 > product2:\n        # Find the actual elements in original array\n        first, second = sorted_arr[0], sorted_arr[1]\n    else:\n        # Find the actual elements in original array\n        first, second = sorted_arr[n-1], sorted_arr[n-2]\n    \n    # Return the pair in the same order as they appear in the original array\n    first_index = arr.index(first)\n    if first == second:\n        # If both elements are same, find the second occurrence\n        second_index = arr.index(second, first_index + 1)\n    else:\n        second_index = arr.index(second)\n    \n    # Return in the order that maintains the original sequence\n    if first_index < second_index:\n        return (first, second)\n    else:\n        return (second, first)\n\n\n"], "responses": ["```python\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily find candidates for maximum product\n    sorted_arr = sorted(arr)\n    n = len(sorted_arr)\n    \n    # The maximum product will be either:\n    # 1. Product of two largest numbers (if both positive)\n    # 2. Product of two smallest numbers (if both negative)\n    product1 = sorted_arr[0] * sorted_arr[1]  # Two smallest\n    product2 = sorted_arr[n-1] * sorted_arr[n-2]  # Two largest\n    \n    if product1 > product2:\n        # Find the actual elements in original array\n        first, second = sorted_arr[0], sorted_arr[1]\n    else:\n        # Find the actual elements in original array\n        first, second = sorted_arr[n-1], sorted_arr[n-2]\n    \n    # Return the pair in the same order as they appear in the original array\n    first_index = arr.index(first)\n    if first == second:\n        # If both elements are same, find the second occurrence\n        second_index = arr.index(second, first_index + 1)\n    else:\n        second_index = arr.index(second)\n    \n    # Return in the order that maintains the original sequence\n    if first_index < second_index:\n        return (first, second)\n    else:\n        return (second, first)\n```"], "prompt_tokens": [92], "completion_tokens": [340], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_415_max_Product"}
{"name": "mbpp_417_group_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to find common first element in given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "group_tuples", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]\n    assert candidate([['a', 'b'], ['a', 'c'], ['d', 'e']]) == [['a', 'b', 'c'], ['d', 'e']]\n    assert candidate([['f', 'g'], ['f', 'g'], ['h', 'i']]) == [['f', 'g', 'g'], ['h', 'i']]\n\ndef test_check():\n    check(group_tuples)\n\ntest_check()\n", "sample_io": ["assert group_tuples([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]"], "source_codes": ["\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find common first element in given list of lists.\n    \"\"\"\n    if not Input:\n        return []\n    \n    # Group lists by their first element\n    groups = {}\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].extend(lst)\n    \n    # Convert groups to list of lists\n    result = list(groups.values())\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find lists that have the same first element and group them together.\n\nLet me think through the approach:\n1. Group lists by their first element\n2. Return the grouped lists\n\n```python\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find common first element in given list of lists.\n    \"\"\"\n    if not Input:\n        return []\n    \n    # Group lists by their first element\n    groups = {}\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].extend(lst)\n    \n    # Convert groups to list of lists\n    result = list(groups.values())\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [175], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_417_group_tuples"}
{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n\n\n"], "responses": ["```python\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n```"], "prompt_tokens": [88], "completion_tokens": [82], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    # Round each number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    return result\n\n\n"], "responses": ["```python\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    # Round each number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [123], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_420_cube_Sum", "language": "Python3", "prompt": "def cube_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the cube sum of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_Sum", "test": "def check(candidate):\n    assert candidate(2) == 72\n    assert candidate(3) == 288\n    assert candidate(4) == 800\n\ndef test_check():\n    check(cube_Sum)\n\ntest_check()\n", "sample_io": ["assert cube_Sum(2) == 72"], "source_codes": ["\ndef cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The first n even natural numbers are: 2, 4, 6, ..., 2n\n    We need to calculate: 2\u00b3 + 4\u00b3 + 6\u00b3 + ... + (2n)\u00b3\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total\n\n\n"], "responses": ["```python\ndef cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The first n even natural numbers are: 2, 4, 6, ..., 2n\n    We need to calculate: 2\u00b3 + 4\u00b3 + 6\u00b3 + ... + (2n)\u00b3\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 3\n    return total\n```"], "prompt_tokens": [80], "completion_tokens": [123], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_420_cube_Sum"}
{"name": "mbpp_421_concatenate_tuple", "language": "Python3", "prompt": "from typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n\tWrite a function to concatenate each element of tuple by the delimiter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "concatenate_tuple", "test": "def check(candidate):\n    assert candidate(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'\n    assert candidate(('QWE', 'is', 4, 'RTY')) == 'QWE-is-4-RTY'\n    assert candidate(('ZEN', 'is', 4, 'OP')) == 'ZEN-is-4-OP'\n\ndef test_check():\n    check(concatenate_tuple)\n\ntest_check()\n", "sample_io": ["assert concatenate_tuple(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'"], "source_codes": ["\nfrom typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str], delimiter: str = ',') -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(str(element) for element in test_tup)\n\n\n"], "responses": ["Looking at this problem, I need to create a function that concatenates each element of a tuple by a delimiter. However, the problem statement doesn't specify what delimiter to use. Based on common practices, I'll assume we want to join the elements with a default delimiter (like comma) or allow for a customizable delimiter.\n\nLet me analyze the function signature:\n- Input: `test_tup` which is a Tuple of type `[str, str, int, str]`\n- Output: A single string with all elements concatenated\n\nSince the tuple contains mixed types (strings and an integer), I'll need to convert all elements to strings before joining them.\n\n```python\nfrom typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str], delimiter: str = ',') -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(str(element) for element in test_tup)\n```"], "prompt_tokens": [90], "completion_tokens": [199], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_421_concatenate_tuple"}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "Python3", "prompt": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n\tWrite a python function to find the average of cubes of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Average_Of_Cube", "test": "def check(candidate):\n    assert candidate(2) == 4.5\n    assert candidate(3) == 12\n    assert candidate(1) == 1\n\ndef test_check():\n    check(find_Average_Of_Cube)\n\ntest_check()\n", "sample_io": ["assert find_Average_Of_Cube(2) == 4.5"], "source_codes": ["\ndef find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n    Find the average of cubes of first n natural numbers.\n    \n    Args:\n        n (int): Number of natural numbers to consider\n        \n    Returns:\n        float: Average of cubes of first n natural numbers\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # Sum of cubes of first n natural numbers = [n(n+1)/2]^2\n    sum_of_cubes = ((n * (n + 1)) // 2) ** 2\n    \n    # Average = Sum / Count\n    average = sum_of_cubes / n\n    \n    return float(average)\n\n\n"], "responses": ["```python\ndef find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n    Find the average of cubes of first n natural numbers.\n    \n    Args:\n        n (int): Number of natural numbers to consider\n        \n    Returns:\n        float: Average of cubes of first n natural numbers\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # Sum of cubes of first n natural numbers = [n(n+1)/2]^2\n    sum_of_cubes = ((n * (n + 1)) // 2) ** 2\n    \n    # Average = Sum / Count\n    average = sum_of_cubes / n\n    \n    return float(average)\n```"], "prompt_tokens": [83], "completion_tokens": [148], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_422_find_Average_Of_Cube"}
{"name": "mbpp_424_extract_rear", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n\tWrite a function to extract only the rear index element of each string in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_rear", "test": "def check(candidate):\n    assert candidate(('Mers', 'for', 'Vers')) == ['s', 'r', 's']\n    assert candidate(('Avenge', 'for', 'People')) == ['e', 'r', 'e']\n    assert candidate(('Gotta', 'get', 'go')) == ['a', 't', 'o']\n\ndef test_check():\n    check(extract_rear)\n\ntest_check()\n", "sample_io": ["assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"], "source_codes": ["\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [string[-1] for string in test_tuple]\n\n\n"], "responses": ["```python\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [string[-1] for string in test_tuple]\n```"], "prompt_tokens": [96], "completion_tokens": [59], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_424_extract_rear"}
{"name": "mbpp_425_count_element_in_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n\tWrite a function to count the number of sublists containing a particular element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_425_count_element_in_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_element_in_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'A') == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'E') == 1\n\ndef test_check():\n    check(count_element_in_list)\n\ntest_check()\n", "sample_io": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"], "source_codes": ["\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n        list1: A list of lists\n        x: The element to search for\n        \n    Returns:\n        The count of sublists that contain the element x\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n        list1: A list of lists\n        x: The element to search for\n        \n    Returns:\n        The count of sublists that contain the element x\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [106], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_425_count_element_in_list"}
{"name": "mbpp_426_filter_oddnumbers", "language": "Python3", "prompt": "from typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to filter odd numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_oddnumbers", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 20, 45, 67, 84, 93]) == [45, 67, 93]\n    assert candidate([5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3]\n\ndef test_check():\n    check(filter_oddnumbers)\n\ntest_check()\n", "sample_io": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"], "source_codes": ["\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\n\n"], "responses": ["```python\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n```"], "prompt_tokens": [79], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_426_filter_oddnumbers"}
{"name": "mbpp_427_change_date_format", "language": "Python3", "prompt": "def change_date_format(dt: str) -> str:\n    \"\"\"\n\tWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "change_date_format", "test": "def check(candidate):\n    assert candidate('2026-01-02') == '02-01-2026'\n    assert candidate('2020-11-13') == '13-11-2020'\n    assert candidate('2021-04-26') == '26-04-2021'\n\ndef test_check():\n    check(change_date_format)\n\ntest_check()\n", "sample_io": ["assert change_date_format('2026-01-02') == '02-01-2026'"], "source_codes": ["\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \"\"\"\n    # Split the input date string by '-'\n    parts = dt.split('-')\n    \n    # Rearrange the parts from [year, month, day] to [day, month, year]\n    return f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n\n\n"], "responses": ["```python\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \"\"\"\n    # Split the input date string by '-'\n    parts = dt.split('-')\n    \n    # Rearrange the parts from [year, month, day] to [day, month, year]\n    return f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n```"], "prompt_tokens": [82], "completion_tokens": [93], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_427_change_date_format"}
{"name": "mbpp_428_shell_sort", "language": "Python3", "prompt": "from typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given array by using shell sort.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "shell_sort", "test": "def check(candidate):\n    assert candidate([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    assert candidate([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]\n    assert candidate([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]\n\ndef test_check():\n    check(shell_sort)\n\ntest_check()\n", "sample_io": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"], "source_codes": ["\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given array by using shell sort.\n    \"\"\"\n    n = len(my_list)\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        # Perform insertion sort for elements at gap intervals\n        for i in range(gap, n):\n            # Save the current element\n            temp = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put temp (the original my_list[i]) in its correct location\n            my_list[j] = temp\n        \n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return my_list\n\n\n"], "responses": ["```python\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given array by using shell sort.\n    \"\"\"\n    n = len(my_list)\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size\n    while gap > 0:\n        # Perform insertion sort for elements at gap intervals\n        for i in range(gap, n):\n            # Save the current element\n            temp = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put temp (the original my_list[i]) in its correct location\n            my_list[j] = temp\n        \n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return my_list\n```"], "prompt_tokens": [84], "completion_tokens": [220], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_428_shell_sort"}
{"name": "mbpp_429_and_tuples", "language": "Python3", "prompt": "from typing import Tuple\n\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to extract the elementwise and tuples from the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_429_and_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "and_tuples", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)\n    assert candidate((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)\n    assert candidate((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)\n\ndef test_check():\n    check(and_tuples)\n\ntest_check()\n", "sample_io": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"], "source_codes": ["\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [115], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_429_and_tuples"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": ["\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Find the directrix of a parabola y = ax^2 + bx + c.\n    Returns the y-coordinate of the directrix.\n    \"\"\"\n    # For parabola y = ax^2 + bx + c\n    # Directrix is y = c - (b^2 + 1)/(4a)\n    \n    # Calculate vertex y-coordinate: k = c - b^2/(4a)\n    # Directrix: y = k - 1/(4a) = c - b^2/(4a) - 1/(4a) = c - (b^2 + 1)/(4a)\n    \n    return c - (b * b + 1) // (4 * a)\n\n\n"], "responses": ["Looking at this problem, I need to find the directrix of a parabola given in the standard form y = ax\u00b2 + bx + c.\n\nLet me recall the relationship between a parabola and its directrix:\n- For a parabola y = ax\u00b2 + bx + c, I first need to convert it to vertex form\n- The vertex form is y = a(x - h)\u00b2 + k, where (h, k) is the vertex\n- For a parabola with vertex (h, k) and coefficient a, the focus is at (h, k + 1/(4a))\n- The directrix is the horizontal line y = k - 1/(4a)\n\nLet me work through the steps:\n1. Find the vertex (h, k) of the parabola y = ax\u00b2 + bx + c\n2. Calculate the directrix using the formula\n\nFor a parabola y = ax\u00b2 + bx + c:\n- h = -b/(2a)\n- k = c - b\u00b2/(4a)\n- Directrix: y = k - 1/(4a) = c - b\u00b2/(4a) - 1/(4a) = c - (b\u00b2 + 1)/(4a)\n\n```python\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Find the directrix of a parabola y = ax^2 + bx + c.\n    Returns the y-coordinate of the directrix.\n    \"\"\"\n    # For parabola y = ax^2 + bx + c\n    # Directrix is y = c - (b^2 + 1)/(4a)\n    \n    # Calculate vertex y-coordinate: k = c - b^2/(4a)\n    # Directrix: y = k - 1/(4a) = c - b^2/(4a) - 1/(4a) = c - (b^2 + 1)/(4a)\n    \n    return c - (b * b + 1) // (4 * a)\n```"], "prompt_tokens": [88], "completion_tokens": [445], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": ["\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n\n\n"], "responses": ["```python\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n```"], "prompt_tokens": [101], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_432_median_trapezium", "language": "Python3", "prompt": "def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n\tWrite a function to find the median length of a trapezium.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_trapezium", "test": "def check(candidate):\n    assert candidate(15, 25, 35) == 20\n    assert candidate(10, 20, 30) == 15\n    assert candidate(6, 9, 4) == 7.5\n\ndef test_check():\n    check(median_trapezium)\n\ntest_check()\n", "sample_io": ["assert median_trapezium(15, 25, 35) == 20"], "source_codes": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints\n    of the non-parallel sides. Its length equals the average of the lengths\n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2.0\n\n\n"], "responses": ["```python\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints\n    of the non-parallel sides. Its length equals the average of the lengths\n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2.0\n```"], "prompt_tokens": [91], "completion_tokens": [161], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_432_median_trapezium"}
{"name": "mbpp_433_check_greater", "language": "Python3", "prompt": "from typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the entered number is greater than the elements of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_greater", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 4) == False\n    assert candidate([2, 3, 4, 5, 6], 8) == True\n    assert candidate([9, 7, 4, 8, 6, 1], 11) == True\n\ndef test_check():\n    check(check_greater)\n\ntest_check()\n", "sample_io": ["assert check_greater([1, 2, 3, 4, 5], 4) == False"], "source_codes": ["\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    for element in arr:\n        if number <= element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    for element in arr:\n        if number <= element:\n            return False\n    return True\n```"], "prompt_tokens": [92], "completion_tokens": [63], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_433_check_greater"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [83], "completion_tokens": [60], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_435_last_Digit", "language": "Python3", "prompt": "def last_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit", "test": "def check(candidate):\n    assert candidate(123) == 3\n    assert candidate(25) == 5\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit)\n\ntest_check()\n", "sample_io": ["assert last_Digit(123) == 3"], "source_codes": ["\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10\n\n\n"], "responses": ["```python\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10\n```"], "prompt_tokens": [78], "completion_tokens": [65], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_435_last_Digit"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n\n\n"], "responses": ["```python\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n```"], "prompt_tokens": [85], "completion_tokens": [52], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_437_remove_odd", "language": "Python3", "prompt": "def remove_odd(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove odd characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate('python') == 'yhn'\n    assert candidate('program') == 'rga'\n    assert candidate('language') == 'agae'\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd('python') == 'yhn'"], "source_codes": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join([char for i, char in enumerate(str1) if i % 2 == 0])\n\n\n"], "responses": ["```python\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join([char for i, char in enumerate(str1) if i % 2 == 0])\n```"], "prompt_tokens": [75], "completion_tokens": [56], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_437_remove_odd"}
{"name": "mbpp_438_count_bidirectional", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to count bidirectional tuple pairs.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_bidirectional", "test": "def check(candidate):\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3\n    assert candidate([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4\n\ndef test_check():\n    check(count_bidirectional)\n\ntest_check()\n", "sample_io": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3"], "source_codes": ["\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Count bidirectional tuple pairs in a list of tuples.\n    A bidirectional pair exists when both (a,b) and (b,a) are present in the list.\n    \"\"\"\n    # Convert list to set for O(1) lookup\n    tuple_set = set(test_list)\n    count = 0\n    \n    # For each tuple (a,b), check if (b,a) exists and a != b\n    for a, b in test_list:\n        if a != b and (b, a) in tuple_set:\n            count += 1\n    \n    # Since we count each pair twice ((a,b) and (b,a)), divide by 2\n    return count // 2\n\n\n"], "responses": ["```python\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Count bidirectional tuple pairs in a list of tuples.\n    A bidirectional pair exists when both (a,b) and (b,a) are present in the list.\n    \"\"\"\n    # Convert list to set for O(1) lookup\n    tuple_set = set(test_list)\n    count = 0\n    \n    # For each tuple (a,b), check if (b,a) exists and a != b\n    for a, b in test_list:\n        if a != b and (b, a) in tuple_set:\n            count += 1\n    \n    # Since we count each pair twice ((a,b) and (b,a)), divide by 2\n    return count // 2\n```"], "prompt_tokens": [87], "completion_tokens": [167], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_438_count_bidirectional"}
{"name": "mbpp_439_multiple_to_single", "language": "Python3", "prompt": "from typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n\tWrite a function to join a list of multiple integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiple_to_single", "test": "def check(candidate):\n    assert candidate([11, 33, 50]) == 113350\n    assert candidate([-1, 2, 3, 4, 5, 6]) == -123456\n    assert candidate([10, 15, 20, 25]) == 10152025\n\ndef test_check():\n    check(multiple_to_single)\n\ntest_check()\n", "sample_io": ["assert multiple_to_single([11, 33, 50]) == 113350"], "source_codes": ["\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n    \n    Args:\n        L: List of integers\n        \n    Returns:\n        Single integer formed by concatenating all integers in the list\n        \n    Examples:\n        >>> multiple_to_single([1, 2, 3])\n        123\n        >>> multiple_to_single([4, 5, 6, 7])\n        4567\n        >>> multiple_to_single([0, 1, 2])\n        12\n    \"\"\"\n    # Convert each integer to string, join them, then convert back to integer\n    return int(''.join(map(str, L)))\n\n\n"], "responses": ["```python\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n    \n    Args:\n        L: List of integers\n        \n    Returns:\n        Single integer formed by concatenating all integers in the list\n        \n    Examples:\n        >>> multiple_to_single([1, 2, 3])\n        123\n        >>> multiple_to_single([4, 5, 6, 7])\n        4567\n        >>> multiple_to_single([0, 1, 2])\n        12\n    \"\"\"\n    # Convert each integer to string, join them, then convert back to integer\n    return int(''.join(map(str, L)))\n```"], "prompt_tokens": [85], "completion_tokens": [153], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_439_multiple_to_single"}
{"name": "mbpp_440_find_adverb_position", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n\tWrite a function to find the first adverb and their positions in a given sentence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverb_position", "test": "def check(candidate):\n    assert candidate('clearly!! we can see the sky') == (0, 7, 'clearly')\n    assert candidate('seriously!! there are many roses') == (0, 9, 'seriously')\n    assert candidate('unfortunately!! sita is going to home') == (0, 13, 'unfortunately')\n\ndef test_check():\n    check(find_adverb_position)\n\ntest_check()\n", "sample_io": ["assert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')"], "source_codes": ["\nimport re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n    Returns a tuple of (start_position, end_position, adverb_text).\n    If no adverb is found, returns (-1, -1, '').\n    \"\"\"\n    # Common adverb patterns - words ending with 'ly'\n    # This is a simplified approach - a more comprehensive solution would use NLP libraries\n    pattern = r'\\b\\w+ly\\b'\n    \n    match = re.search(pattern, text)\n    \n    if match:\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    else:\n        return (-1, -1, '')\n\n\n"], "responses": ["```python\nimport re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n    Returns a tuple of (start_position, end_position, adverb_text).\n    If no adverb is found, returns (-1, -1, '').\n    \"\"\"\n    # Common adverb patterns - words ending with 'ly'\n    # This is a simplified approach - a more comprehensive solution would use NLP libraries\n    pattern = r'\\b\\w+ly\\b'\n    \n    match = re.search(pattern, text)\n    \n    if match:\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    else:\n        return (-1, -1, '')\n```"], "prompt_tokens": [92], "completion_tokens": [184], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_440_find_adverb_position"}
{"name": "mbpp_441_surfacearea_cube", "language": "Python3", "prompt": "def surfacearea_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the surface area of a cube of a given size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cube", "test": "def check(candidate):\n    assert candidate(5) == 150\n    assert candidate(3) == 54\n    assert candidate(10) == 600\n\ndef test_check():\n    check(surfacearea_cube)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cube(5) == 150"], "source_codes": ["\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n\n\n"], "responses": ["```python\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n```"], "prompt_tokens": [80], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_441_surfacearea_cube"}
{"name": "mbpp_442_positive_count", "language": "Python3", "prompt": "from typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n\tWrite a function to find the ration of positive numbers in an array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "positive_count", "test": "def check(candidate):\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54\n    assert candidate([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56\n\ndef test_check():\n    check(positive_count)\n\ntest_check()\n", "sample_io": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"], "source_codes": ["\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of positive numbers in an array of integers.\n    \"\"\"\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n\n\n"], "responses": ["```python\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of positive numbers in an array of integers.\n    \"\"\"\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n```"], "prompt_tokens": [85], "completion_tokens": [74], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_442_positive_count"}
{"name": "mbpp_443_largest_neg", "language": "Python3", "prompt": "from typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest negative number from the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "largest_neg", "test": "def check(candidate):\n    assert candidate([1, 2, 3, -4, -6]) == -6\n    assert candidate([1, 2, 3, -8, -9]) == -9\n    assert candidate([1, 2, 3, 4, -1]) == -1\n\ndef test_check():\n    check(largest_neg)\n\ntest_check()\n", "sample_io": ["assert largest_neg([1, 2, 3, -4, -6]) == -6"], "source_codes": ["\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_numbers = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_numbers:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_numbers)\n\n\n"], "responses": ["```python\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_numbers = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_numbers:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_numbers)\n```"], "prompt_tokens": [85], "completion_tokens": [108], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_443_largest_neg"}
{"name": "mbpp_444_trim_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to trim each list by k in the given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "trim_tuple", "test": "def check(candidate):\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 1) == [[3, 2, 1], [4, 9, 2], [1, 2, 3], [8, 2, 1]]\n    assert candidate([[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]], 1) == [[8, 4], [8, 12], [1, 7], [6, 9]]\n\ndef test_check():\n    check(trim_tuple)\n\ntest_check()\n", "sample_io": ["assert trim_tuple([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]"], "source_codes": ["\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    result = []\n    for inner_list in test_list:\n        if len(inner_list) <= 2 * K:\n            # If the list is too short to trim, return empty list\n            trimmed = []\n        else:\n            # Trim K elements from both ends\n            trimmed = inner_list[K:-K]\n        result.append(trimmed)\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to trim each inner list by removing K elements from both the beginning and end.\n\nLet me think through the steps:\n1. For each inner list in the input list\n2. Remove K elements from the start and K elements from the end\n3. Return the modified list of lists\n\nThis is essentially slicing each inner list from index K to -K (or K to length-K if we want to be more explicit).\n\n```python\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    result = []\n    for inner_list in test_list:\n        if len(inner_list) <= 2 * K:\n            # If the list is too short to trim, return empty list\n            trimmed = []\n        else:\n            # Trim K elements from both ends\n            trimmed = inner_list[K:-K]\n        result.append(trimmed)\n    return result\n```"], "prompt_tokens": [91], "completion_tokens": [209], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_444_trim_tuple"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        row = []\n        for j in range(len(test_tup1[i])):\n            row.append(test_tup1[i][j] * test_tup2[i][j])\n        result.append(row)\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to perform index-wise multiplication of corresponding elements from two lists of lists.\n\nLet me break down what's needed:\n1. Take two lists of lists as input\n2. Multiply corresponding elements at each position\n3. Return the result as a new list of lists\n\nFor example, if I have:\n- test_tup1 = [[1, 2], [3, 4]]\n- test_tup2 = [[5, 6], [7, 8]]\n\nThe result should be:\n- [[1*5, 2*6], [3*7, 4*8]] = [[5, 12], [21, 32]]\n\nHere's my solution:\n\n```python\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        row = []\n        for j in range(len(test_tup1[i])):\n            row.append(test_tup1[i][j] * test_tup2[i][j])\n        result.append(row)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [259], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_446_count_Occurrence", "language": "Python3", "prompt": "from typing import Any, List\n\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n\tWrite a python function to count the occurence of all elements of list in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Occurrence", "test": "def check(candidate):\n    assert candidate(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    assert candidate((1, 2, 3, 1, 4, 6, 7, 1, 4), [1, 4, 7]) == 6\n    assert candidate((1, 2, 3, 4, 5, 6), [1, 2]) == 2\n\ndef test_check():\n    check(count_Occurrence)\n\ntest_check()\n", "sample_io": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"], "source_codes": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count\n\n\n"], "responses": ["```python\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count\n```"], "prompt_tokens": [96], "completion_tokens": [69], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_446_count_Occurrence"}
{"name": "mbpp_447_cube_nums", "language": "Python3", "prompt": "from typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find cubes of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    assert candidate([10, 20, 30]) == [1000, 8000, 27000]\n    assert candidate([12, 15]) == [1728, 3375]\n\ndef test_check():\n    check(cube_nums)\n\ntest_check()\n", "sample_io": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"], "source_codes": ["\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n\n\n"], "responses": ["```python\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_447_cube_nums"}
{"name": "mbpp_448_cal_sum", "language": "Python3", "prompt": "def cal_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of perrin numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cal_sum", "test": "def check(candidate):\n    assert candidate(9) == 49\n    assert candidate(10) == 66\n    assert candidate(11) == 88\n\ndef test_check():\n    check(cal_sum)\n\ntest_check()\n", "sample_io": ["assert cal_sum(9) == 49"], "source_codes": ["\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of P(0) + P(1) + P(2)\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to calculate the sum of Perrin numbers. The Perrin sequence is defined as:\n- P(0) = 3\n- P(1) = 0  \n- P(2) = 2\n- P(n) = P(n-2) + P(n-3) for n > 2\n\nLet me write a function to calculate the sum of the first n+1 Perrin numbers (from P(0) to P(n)).\n\n```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of P(0) + P(1) + P(2)\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n```"], "prompt_tokens": [76], "completion_tokens": [401], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_448_cal_sum"}
{"name": "mbpp_450_extract_string", "language": "Python3", "prompt": "from typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n\tWrite a function to extract specified size of strings from a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_string", "test": "def check(candidate):\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 6) == ['Python']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 9) == ['exercises']\n\ndef test_check():\n    check(extract_string)\n\ntest_check()\n", "sample_io": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"], "source_codes": ["\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]\n\n\n"], "responses": ["```python\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]\n```"], "prompt_tokens": [91], "completion_tokens": [58], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_450_extract_string"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return text1.replace(\" \", \"\")\n\n\n"], "responses": ["```python\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return text1.replace(\" \", \"\")\n```"], "prompt_tokens": [79], "completion_tokens": [44], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_452_loss_amount", "language": "Python3", "prompt": "def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n\tWrite a function that gives loss amount on a sale if the given amount has loss else return 0.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "loss_amount", "test": "def check(candidate):\n    assert candidate(1500, 1200) == 0\n    assert candidate(100, 200) == 100\n    assert candidate(2000, 5000) == 3000\n\ndef test_check():\n    check(loss_amount)\n\ntest_check()\n", "sample_io": ["assert loss_amount(1500, 1200) == 0"], "source_codes": ["\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n```"], "prompt_tokens": [90], "completion_tokens": [70], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_452_loss_amount"}
{"name": "mbpp_453_sumofFactors", "language": "Python3", "prompt": "def sumofFactors(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even factors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sumofFactors", "test": "def check(candidate):\n    assert candidate(18) == 26\n    assert candidate(30) == 48\n    assert candidate(6) == 8\n\ndef test_check():\n    check(sumofFactors)\n\ntest_check()\n", "sample_io": ["assert sumofFactors(18) == 26"], "source_codes": ["\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Find the sum of even factors of a number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    \n    # Check all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a factor of n and i is even\n        if n % i == 0 and i % 2 == 0:\n            total_sum += i\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Find the sum of even factors of a number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    \n    # Check all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a factor of n and i is even\n        if n % i == 0 and i % 2 == 0:\n            total_sum += i\n    \n    return total_sum\n```"], "prompt_tokens": [79], "completion_tokens": [116], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_453_sumofFactors"}
{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    import re\n    \n    # Pattern to match a word containing 'z'\n    # \\b represents word boundary\n    # \\w* matches zero or more word characters\n    # z matches the letter 'z'\n    # \\w* matches zero or more word characters\n    # \\b represents word boundary\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    import re\n    \n    # Pattern to match a word containing 'z'\n    # \\b represents word boundary\n    # \\w* matches zero or more word characters\n    # z matches the letter 'z'\n    # \\w* matches zero or more word characters\n    # \\b represents word boundary\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [76], "completion_tokens": [131], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_455_check_monthnumb_number", "language": "Python3", "prompt": "def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 31 days or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumb_number", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(2) == False\n    assert candidate(6) == False\n\ndef test_check():\n    check(check_monthnumb_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumb_number(5) == True"], "source_codes": ["\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    return monthnum2 in months_with_31_days\n\n\n"], "responses": ["```python\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    return monthnum2 in months_with_31_days\n```"], "prompt_tokens": [86], "completion_tokens": [127], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_455_check_monthnumb_number"}
{"name": "mbpp_456_reverse_string_list", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n\tWrite a function to reverse each string in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_string_list", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    assert candidate(['john', 'amal', 'joel', 'george']) == ['nhoj', 'lama', 'leoj', 'egroeg']\n    assert candidate(['jack', 'john', 'mary']) == ['kcaj', 'nhoj', 'yram']\n\ndef test_check():\n    check(reverse_string_list)\n\ntest_check()\n", "sample_io": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"], "source_codes": ["\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n\n\n"], "responses": ["```python\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n```"], "prompt_tokens": [87], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_456_reverse_string_list"}
{"name": "mbpp_457_Find_Min", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min", "test": "def check(candidate):\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert candidate([[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1]\n    assert candidate([['x'], ['x', 'y'], ['x', 'y', 'z']]) == ['x']\n\ndef test_check():\n    check(Find_Min)\n\ntest_check()\n", "sample_io": ["assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"], "source_codes": ["\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the sublist having minimum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    min_length = float('inf')\n    min_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n\n\n"], "responses": ["```python\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the sublist having minimum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    min_length = float('inf')\n    min_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n```"], "prompt_tokens": [85], "completion_tokens": [96], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_457_Find_Min"}
{"name": "mbpp_458_rectangle_area", "language": "Python3", "prompt": "def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to find the area of a rectangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rectangle_area", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(10, 5) == 50\n    assert candidate(4, 2) == 8\n\ndef test_check():\n    check(rectangle_area)\n\ntest_check()\n", "sample_io": ["assert rectangle_area(10, 20) == 200"], "source_codes": ["\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n\n\n"], "responses": ["```python\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n```"], "prompt_tokens": [78], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_458_rectangle_area"}
{"name": "mbpp_459_remove_uppercase", "language": "Python3", "prompt": "def remove_uppercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove uppercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_uppercase", "test": "def check(candidate):\n    assert candidate('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\n    assert candidate('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'\n    assert candidate('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'\n\ndef test_check():\n    check(remove_uppercase)\n\ntest_check()\n", "sample_io": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"], "source_codes": ["\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.isupper():\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.isupper():\n            result += char\n    return result\n```"], "prompt_tokens": [78], "completion_tokens": [62], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_459_remove_uppercase"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n\n\n"], "responses": ["```python\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_461_upper_ctr", "language": "Python3", "prompt": "def upper_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the upper case characters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "upper_ctr", "test": "def check(candidate):\n    assert candidate('PYthon') == 1\n    assert candidate('BigData') == 1\n    assert candidate('program') == 0\n\ndef test_check():\n    check(upper_ctr)\n\ntest_check()\n", "sample_io": ["assert upper_ctr('PYthon') == 1"], "source_codes": ["\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n```"], "prompt_tokens": [78], "completion_tokens": [62], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_461_upper_ctr"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["\nfrom typing import List, Union\nfrom itertools import combinations\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    result = []\n    \n    # Add empty combination\n    result.append([])\n    \n    # Generate combinations of all lengths from 1 to len(list1)\n    for r in range(1, len(list1) + 1):\n        for combo in combinations(list1, r):\n            result.append(list(combo))\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List, Union\nfrom itertools import combinations\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    result = []\n    \n    # Add empty combination\n    result.append([])\n    \n    # Generate combinations of all lengths from 1 to len(list1)\n    for r in range(1, len(list1) + 1):\n        for combo in combinations(list1, r):\n            result.append(list(combo))\n    \n    return result\n```"], "prompt_tokens": [97], "completion_tokens": [128], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # Initialize variables to track maximum and minimum products ending at current position\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        \n        # Update max and min products ending at current position\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        \n        # Update global maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "responses": ["```python\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # Initialize variables to track maximum and minimum products ending at current position\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        \n        # Update max and min products ending at current position\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        \n        # Update global maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```"], "prompt_tokens": [86], "completion_tokens": [215], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_464_check_value", "language": "Python3", "prompt": "from typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n\tWrite a function to check if all values are same in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_value", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 12) == True\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 5) == False\n\ndef test_check():\n    check(check_value)\n\ntest_check()\n", "sample_io": ["assert check_value({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False"], "source_codes": ["\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n\n\n"], "responses": ["```python\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n```"], "prompt_tokens": [89], "completion_tokens": [98], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_464_check_value"}
{"name": "mbpp_465_drop_empty", "language": "Python3", "prompt": "from typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to drop empty items from a given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "drop_empty", "test": "def check(candidate):\n    assert candidate({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }\n    assert candidate({ 'c1': 'Red', 'c2': None, 'c3': None }) == { 'c1': 'Red' }\n    assert candidate({ 'c1': None, 'c2': 'Green', 'c3': None }) == { 'c2': 'Green' }\n\ndef test_check():\n    check(drop_empty)\n\ntest_check()\n", "sample_io": ["assert drop_empty({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }"], "source_codes": ["\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Drop empty items from a given dictionary.\n    \"\"\"\n    return {key: value for key, value in dict1.items() if value is not None and value != \"\"}\n\n\n"], "responses": ["```python\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Drop empty items from a given dictionary.\n    \"\"\"\n    return {key: value for key, value in dict1.items() if value is not None and value != \"\"}\n```"], "prompt_tokens": [90], "completion_tokens": [60], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_465_drop_empty"}
{"name": "mbpp_468_max_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product", "test": "def check(candidate):\n    assert candidate([3, 100, 4, 5, 150, 6]) == 3000\n    assert candidate([4, 42, 55, 68, 80]) == 50265600\n    assert candidate([10, 22, 9, 33, 21, 50, 41, 60]) == 2460\n\ndef test_check():\n    check(max_product)\n\ntest_check()\n", "sample_io": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000"], "source_codes": ["\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element (increasing condition)\n            # and both are positive (to maximize product)\n            if arr[i] > arr[j] and arr[i] > 0 and arr[j] > 0:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    return max(dp)\n\n\n"], "responses": ["```python\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element (increasing condition)\n            # and both are positive (to maximize product)\n            if arr[i] > arr[j] and arr[i] > 0 and arr[j] > 0:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    return max(dp)\n```"], "prompt_tokens": [90], "completion_tokens": [153], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_468_max_product"}
{"name": "mbpp_470_add_pairwise", "language": "Python3", "prompt": "from typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the pairwise addition of the neighboring elements of the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_pairwise", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n    assert candidate((2, 6, 8, 9, 11)) == (8, 14, 17, 20)\n    assert candidate((3, 7, 9, 10, 12)) == (10, 16, 19, 22)\n\ndef test_check():\n    check(add_pairwise)\n\ntest_check()\n", "sample_io": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)"], "source_codes": ["\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n\n\n"], "responses": ["```python\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n```"], "prompt_tokens": [104], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_470_add_pairwise"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \"\"\"\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product\n\n\n"], "responses": ["```python\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \"\"\"\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product\n```"], "prompt_tokens": [89], "completion_tokens": [62], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_472_check_Consecutive", "language": "Python3", "prompt": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given list contains consecutive numbers or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_Consecutive", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 2, 3, 5, 6]) == False\n    assert candidate([1, 2, 1]) == False\n\ndef test_check():\n    check(check_Consecutive)\n\ntest_check()\n", "sample_io": ["assert check_Consecutive([1, 2, 3, 4, 5]) == True"], "source_codes": ["\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to check for consecutive numbers\n    sorted_list = sorted(l)\n    \n    # Check if each adjacent pair differs by 1\n    for i in range(len(sorted_list) - 1):\n        if sorted_list[i + 1] - sorted_list[i] != 1:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to check for consecutive numbers\n    sorted_list = sorted(l)\n    \n    # Check if each adjacent pair differs by 1\n    for i in range(len(sorted_list) - 1):\n        if sorted_list[i + 1] - sorted_list[i] != 1:\n            return False\n    \n    return True\n```"], "prompt_tokens": [86], "completion_tokens": [120], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_472_check_Consecutive"}
{"name": "mbpp_474_replace_char", "language": "Python3", "prompt": "def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n\tWrite a function to replace characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_char", "test": "def check(candidate):\n    assert candidate('polygon', 'y', 'l') == 'pollgon'\n    assert candidate('character', 'c', 'a') == 'aharaater'\n    assert candidate('python', 'l', 'a') == 'python'\n\ndef test_check():\n    check(replace_char)\n\ntest_check()\n", "sample_io": ["assert replace_char('polygon', 'y', 'l') == 'pollgon'"], "source_codes": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    return str1.replace(ch, newch)\n\n\n"], "responses": ["```python\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    return str1.replace(ch, newch)\n```"], "prompt_tokens": [83], "completion_tokens": [49], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_474_replace_char"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n\n\n"], "responses": ["```python\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n```"], "prompt_tokens": [91], "completion_tokens": [54], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_476_big_sum", "language": "Python3", "prompt": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the largest and smallest value in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 4\n    assert candidate([-1, 2, 3, 4]) == 3\n    assert candidate([2, 3, 6]) == 8\n\ndef test_check():\n    check(big_sum)\n\ntest_check()\n", "sample_io": ["assert big_sum([1, 2, 3]) == 4"], "source_codes": ["\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) + min(nums)\n\n\n"], "responses": ["```python\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) + min(nums)\n```"], "prompt_tokens": [88], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_476_big_sum"}
{"name": "mbpp_477_is_lower", "language": "Python3", "prompt": "def is_lower(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert the given string to lower case.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_lower", "test": "def check(candidate):\n    assert candidate('InValid') == 'invalid'\n    assert candidate('TruE') == 'true'\n    assert candidate('SenTenCE') == 'sentence'\n\ndef test_check():\n    check(is_lower)\n\ntest_check()\n", "sample_io": ["assert is_lower('InValid') == 'invalid'"], "source_codes": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "responses": ["```python\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n```"], "prompt_tokens": [76], "completion_tokens": [38], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_477_is_lower"}
{"name": "mbpp_478_remove_lowercase", "language": "Python3", "prompt": "def remove_lowercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove lowercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_lowercase", "test": "def check(candidate):\n    assert candidate('PYTHon') == 'PYTH'\n    assert candidate('FInD') == 'FID'\n    assert candidate('STRinG') == 'STRG'\n\ndef test_check():\n    check(remove_lowercase)\n\ntest_check()\n", "sample_io": ["assert remove_lowercase('PYTHon') == 'PYTH'"], "source_codes": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.islower():\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.islower():\n            result += char\n    return result\n```"], "prompt_tokens": [77], "completion_tokens": [61], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_478_remove_lowercase"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (can be positive or negative)\n    \n    Returns:\n        The first (leftmost) digit of the number\n    \n    Examples:\n        >>> first_Digit(12345)\n        1\n        >>> first_Digit(-987)\n        9\n        >>> first_Digit(5)\n        5\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    n = abs(n)\n    \n    # Keep dividing by 10 until we get a single digit\n    while n >= 10:\n        n //= 10\n    \n    return n\n\n\n"], "responses": ["```python\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (can be positive or negative)\n    \n    Returns:\n        The first (leftmost) digit of the number\n    \n    Examples:\n        >>> first_Digit(12345)\n        1\n        >>> first_Digit(-987)\n        9\n        >>> first_Digit(5)\n        5\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    n = abs(n)\n    \n    # Keep dividing by 10 until we get a single digit\n    while n >= 10:\n        n //= 10\n    \n    return n\n```"], "prompt_tokens": [78], "completion_tokens": [158], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "responses": ["```python\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n```"], "prompt_tokens": [86], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_555_difference", "language": "Python3", "prompt": "def difference(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "difference", "test": "def check(candidate):\n    assert candidate(3) == 30\n    assert candidate(5) == 210\n    assert candidate(2) == 6\n\ndef test_check():\n    check(difference)\n\ntest_check()\n", "sample_io": ["assert difference(3) == 30"], "source_codes": ["\ndef difference(n: int) -> int:\n    \"\"\"\n    Find the difference between the sum of cubes of the first n natural numbers \n    and the sum of the first n natural numbers.\n    \n    Sum of cubes = 1\u00b3 + 2\u00b3 + 3\u00b3 + ... + n\u00b3 = [n(n+1)/2]\u00b2\n    Sum of first n natural numbers = 1 + 2 + 3 + ... + n = n(n+1)/2\n    \n    Difference = [n(n+1)/2]\u00b2 - n(n+1)/2 = n(n+1)/2 * (n(n+1)/2 - 1)\n    \"\"\"\n    sum_n = n * (n + 1) // 2\n    sum_cubes = sum_n * sum_n\n    return sum_cubes - sum_n\n\n\n"], "responses": ["```python\ndef difference(n: int) -> int:\n    \"\"\"\n    Find the difference between the sum of cubes of the first n natural numbers \n    and the sum of the first n natural numbers.\n    \n    Sum of cubes = 1\u00b3 + 2\u00b3 + 3\u00b3 + ... + n\u00b3 = [n(n+1)/2]\u00b2\n    Sum of first n natural numbers = 1 + 2 + 3 + ... + n = n(n+1)/2\n    \n    Difference = [n(n+1)/2]\u00b2 - n(n+1)/2 = n(n+1)/2 * (n(n+1)/2 - 1)\n    \"\"\"\n    sum_n = n * (n + 1) // 2\n    sum_cubes = sum_n * sum_n\n    return sum_cubes - sum_n\n```"], "prompt_tokens": [91], "completion_tokens": [180], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_555_difference"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, then multiply them to get the total pairs.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n\n\n"], "responses": ["```python\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, then multiply them to get the total pairs.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n```"], "prompt_tokens": [92], "completion_tokens": [137], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_557_toggle_string", "language": "Python3", "prompt": "def toggle_string(string: str) -> str:\n    \"\"\"\n\tWrite a function to toggle the case of all characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_string", "test": "def check(candidate):\n    assert candidate('Python') == 'pYTHON'\n    assert candidate('Pangram') == 'pANGRAM'\n    assert candidate('LIttLE') == 'liTTle'\n\ndef test_check():\n    check(toggle_string)\n\ntest_check()\n", "sample_io": ["assert toggle_string('Python') == 'pYTHON'"], "source_codes": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n```"], "prompt_tokens": [77], "completion_tokens": [80], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_557_toggle_string"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str1 = str(abs(n1))\n    str2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    distance = 0\n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        distance += abs(digit1 - digit2)\n    \n    return distance\n\n\n"], "responses": ["```python\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str1 = str(abs(n1))\n    str2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    distance = 0\n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        distance += abs(digit1 - digit2)\n    \n    return distance\n```"], "prompt_tokens": [87], "completion_tokens": [164], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_559_max_sub_array_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of the largest contiguous sublist in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum", "test": "def check(candidate):\n    assert candidate([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    assert candidate([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8\n    assert candidate([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10\n\ndef test_check():\n    check(max_sub_array_sum)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"], "source_codes": ["\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the sum of the largest contiguous sublist in the given list using Kadane's algorithm.\n    \"\"\"\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        # Either extend the existing subarray or start a new one\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        # Update the maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "responses": ["```python\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the sum of the largest contiguous sublist in the given list using Kadane's algorithm.\n    \"\"\"\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        # Either extend the existing subarray or start a new one\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        # Update the maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```"], "prompt_tokens": [92], "completion_tokens": [151], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_559_max_sub_array_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to get unique elements and find union\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "responses": ["```python\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to get unique elements and find union\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [128], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_562_Find_Max_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 4], [5, 6, 7, 8]]) == 4\n    assert candidate([[0, 1], [2, 2], [3, 2, 1]]) == 3\n    assert candidate([[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5\n\ndef test_check():\n    check(Find_Max_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"], "source_codes": ["\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        current_length = len(sublist)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        current_length = len(sublist)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n```"], "prompt_tokens": [85], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_562_Find_Max_Length"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Extract values between quotation marks from a string.\n    \n    Args:\n        text (str): Input string containing quoted values\n        \n    Returns:\n        List[str]: List of extracted values between quotation marks\n    \"\"\"\n    # Use regex to find all substrings between quotation marks\n    # This pattern matches both single and double quotes\n    pattern = r'\"([^\"]*)\"|\\'([^\\']*)\\''\n    matches = re.findall(pattern, text)\n    \n    # Extract the non-empty groups from the matches\n    result = []\n    for match in matches:\n        # match is a tuple where one element will be empty string\n        # we take the non-empty one\n        result.append(match[0] if match[0] else match[1])\n    \n    return result\n\n\n"], "responses": ["```python\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Extract values between quotation marks from a string.\n    \n    Args:\n        text (str): Input string containing quoted values\n        \n    Returns:\n        List[str]: List of extracted values between quotation marks\n    \"\"\"\n    # Use regex to find all substrings between quotation marks\n    # This pattern matches both single and double quotes\n    pattern = r'\"([^\"]*)\"|\\'([^\\']*)\\''\n    matches = re.findall(pattern, text)\n    \n    # Extract the non-empty groups from the matches\n    result = []\n    for match in matches:\n        # match is a tuple where one element will be empty string\n        # we take the non-empty one\n        result.append(match[0] if match[0] else match[1])\n    \n    return result\n```"], "prompt_tokens": [82], "completion_tokens": [184], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_564_count_Pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Pairs", "test": "def check(candidate):\n    assert candidate([1, 2, 1], 3) == 2\n    assert candidate([1, 1, 1, 1], 4) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 10\n\ndef test_check():\n    check(count_Pairs)\n\ntest_check()\n", "sample_io": ["assert count_Pairs([1, 2, 1], 3) == 2"], "source_codes": ["\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Total possible pairs = n * (n-1) / 2\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with same elements\n    same_element_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            same_element_pairs += count * (count - 1) // 2\n    \n    return total_pairs - same_element_pairs\n\n\n"], "responses": ["```python\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Total possible pairs = n * (n-1) / 2\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with same elements\n    same_element_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            same_element_pairs += count * (count - 1) // 2\n    \n    return total_pairs - same_element_pairs\n```"], "prompt_tokens": [98], "completion_tokens": [161], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_564_count_Pairs"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n\n\n"], "responses": ["```python\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n```"], "prompt_tokens": [79], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_566_sum_digits", "language": "Python3", "prompt": "def sum_digits(n: int) -> int:\n    \"\"\"\n\tWrite a function to get the sum of the digits of a non-negative integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_digits", "test": "def check(candidate):\n    assert candidate(345) == 12\n    assert candidate(12) == 3\n    assert candidate(97) == 16\n\ndef test_check():\n    check(sum_digits)\n\ntest_check()\n", "sample_io": ["assert sum_digits(345) == 12"], "source_codes": ["\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n\n\n"], "responses": ["```python\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n```"], "prompt_tokens": [79], "completion_tokens": [69], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_566_sum_digits"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": ["\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Check if the list is empty or has only one element, it's considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if the list is sorted in ascending order\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Check if the list is empty or has only one element, it's considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if the list is sorted in ascending order\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [85], "completion_tokens": [115], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_568_empty_list", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n\tWrite a function to create a list of N empty dictionaries.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "empty_list", "test": "def check(candidate):\n    assert candidate(5) == [{  }, {  }, {  }, {  }, {  }]\n    assert candidate(6) == [{  }, {  }, {  }, {  }, {  }, {  }]\n    assert candidate(7) == [{  }, {  }, {  }, {  }, {  }, {  }, {  }]\n\ndef test_check():\n    check(empty_list)\n\ntest_check()\n", "sample_io": ["assert empty_list(5) == [{  }, {  }, {  }, {  }, {  }]"], "source_codes": ["\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n\n\n"], "responses": ["```python\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n```"], "prompt_tokens": [88], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_568_empty_list"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n\n\n"], "responses": ["```python\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n```"], "prompt_tokens": [90], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    \"\"\"\n    # Remove duplicates by converting to set, then back to list\n    unique_nums = list(set(nums))\n    \n    # Return the first two unique numbers\n    return unique_nums[:2]\n\n\n"], "responses": ["Looking at this problem, I need to find two unique numbers from a list that contains duplicates. Based on the function name and description, it seems like I should return exactly two unique numbers from the list.\n\nLet me think through the approach:\n1. Remove duplicates from the list\n2. Return the first two unique numbers\n\n```python\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n    \"\"\"\n    # Remove duplicates by converting to set, then back to list\n    unique_nums = list(set(nums))\n    \n    # Return the first two unique numbers\n    return unique_nums[:2]\n```"], "prompt_tokens": [86], "completion_tokens": [141], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_573_unique_product", "language": "Python3", "prompt": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to calculate the product of the unique numbers in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_product", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    assert candidate([1, 2, 3, 1]) == 6\n    assert candidate([7, 8, 9, 0, 1, 1]) == 0\n\ndef test_check():\n    check(unique_product)\n\ntest_check()\n", "sample_io": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"], "source_codes": ["\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Get unique numbers by converting to set\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n\n\n"], "responses": ["```python\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Get unique numbers by converting to set\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n```"], "prompt_tokens": [87], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_573_unique_product"}
{"name": "mbpp_574_surfacearea_cylinder", "language": "Python3", "prompt": "def surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the surface area of a cylinder.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cylinder", "test": "def check(candidate):\n    assert candidate(10, 5) == 942.45\n    assert candidate(4, 5) == 226.18800000000002\n    assert candidate(4, 10) == 351.848\n\ndef test_check():\n    check(surfacearea_cylinder)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cylinder(10, 5) == 942.45"], "source_codes": ["\ndef surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n    Write a function to find the surface area of a cylinder.\n    \"\"\"\n    import math\n    return 2 * math.pi * r * (r + h)\n\n\n"], "responses": ["```python\ndef surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n    Write a function to find the surface area of a cylinder.\n    \"\"\"\n    import math\n    return 2 * math.pi * r * (r + h)\n```"], "prompt_tokens": [81], "completion_tokens": [56], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_574_surfacearea_cylinder"}
{"name": "mbpp_576_is_Sub_Array", "language": "Python3", "prompt": "from typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list is sublist of another or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sub_Array", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 5], [1, 2]) == False\n    assert candidate([1, 2, 1], [1, 2, 1]) == True\n    assert candidate([1, 0, 2, 2], [2, 2, 0]) == False\n\ndef test_check():\n    check(is_Sub_Array)\n\ntest_check()\n", "sample_io": ["assert is_Sub_Array([1, 4, 3, 5], [1, 2]) == False"], "source_codes": ["\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Check whether list A is a sublist of list B or not.\n    A sublist means all elements of A appear in B in the same order consecutively.\n    \"\"\"\n    if len(A) == 0:\n        return True\n    \n    if len(A) > len(B):\n        return False\n    \n    # Check each possible starting position in B\n    for i in range(len(B) - len(A) + 1):\n        # Check if A matches the subarray of B starting at position i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Check whether list A is a sublist of list B or not.\n    A sublist means all elements of A appear in B in the same order consecutively.\n    \"\"\"\n    if len(A) == 0:\n        return True\n    \n    if len(A) > len(B):\n        return False\n    \n    # Check each possible starting position in B\n    for i in range(len(B) - len(A) + 1):\n        # Check if A matches the subarray of B starting at position i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False\n```"], "prompt_tokens": [91], "completion_tokens": [146], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_576_is_Sub_Array"}
{"name": "mbpp_577_last_Digit_Factorial", "language": "Python3", "prompt": "def last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit in factorial of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit_Factorial", "test": "def check(candidate):\n    assert candidate(4) == 4\n    assert candidate(21) == 0\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit_Factorial)\n\ntest_check()\n", "sample_io": ["assert last_Digit_Factorial(4) == 4"], "source_codes": ["\ndef last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n    Find the last digit in factorial of a given number.\n    \n    The key insight is that for n >= 5, the factorial will always end in 0\n    because it will contain both factors 2 and 5, creating a factor of 10.\n    \n    For n < 5, we calculate the factorial directly and return the last digit.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    if n == 2:\n        return 2\n    \n    if n == 3:\n        return 6\n    \n    if n == 4:\n        return 4\n    \n    # For n >= 5, the last digit is always 0\n    # This is because n! will contain factors 2 and 5, making it divisible by 10\n    return 0\n\n\n"], "responses": ["```python\ndef last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n    Find the last digit in factorial of a given number.\n    \n    The key insight is that for n >= 5, the factorial will always end in 0\n    because it will contain both factors 2 and 5, creating a factor of 10.\n    \n    For n < 5, we calculate the factorial directly and return the last digit.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    if n == 2:\n        return 2\n    \n    if n == 3:\n        return 6\n    \n    if n == 4:\n        return 4\n    \n    # For n >= 5, the last digit is always 0\n    # This is because n! will contain factors 2 and 5, making it divisible by 10\n    return 0\n```"], "prompt_tokens": [83], "completion_tokens": [207], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_577_last_Digit_Factorial"}
{"name": "mbpp_578_interleave_lists", "language": "Python3", "prompt": "from typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to interleave 3 lists of the same length into a single flat list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "interleave_lists", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    assert candidate([10, 20], [15, 2], [5, 10]) == [10, 15, 5, 20, 2, 10]\n    assert candidate([11, 44], [10, 15], [20, 5]) == [11, 10, 20, 44, 15, 5]\n\ndef test_check():\n    check(interleave_lists)\n\ntest_check()\n", "sample_io": ["assert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"], "source_codes": ["\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n\n"], "responses": ["```python\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_578_interleave_lists"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n    Returns a tuple containing elements that are in either tuple but not in both.\n    \"\"\"\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple and return\n    return tuple(dissimilar)\n\n\n"], "responses": ["```python\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n    Returns a tuple containing elements that are in either tuple but not in both.\n    \"\"\"\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple and return\n    return tuple(dissimilar)\n```"], "prompt_tokens": [116], "completion_tokens": [144], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_580_extract_even", "language": "Python3", "prompt": "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n\tWrite a function to remove uneven elements in the nested mixed tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_even", "test": "def check(candidate):\n    assert candidate((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    assert candidate((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))\n    assert candidate((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)\n\ndef test_check():\n    check(extract_even)\n\ntest_check()\n", "sample_io": ["assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"], "source_codes": ["\ndef extract_even(test_tuple):\n    \"\"\"\n    Remove uneven elements from a nested mixed tuple, keeping only even numbers.\n    \n    Args:\n        test_tuple: A nested tuple containing integers\n        \n    Returns:\n        A new tuple with only even numbers, maintaining the nested structure\n    \"\"\"\n    result = []\n    \n    for element in test_tuple:\n        if isinstance(element, tuple):\n            # Recursively process nested tuples\n            nested_result = extract_even(element)\n            # Only add non-empty nested tuples\n            if nested_result:\n                result.append(nested_result)\n        elif isinstance(element, int) and element % 2 == 0:\n            # Keep even integers\n            result.append(element)\n    \n    return tuple(result)\n\n\n"], "responses": ["```python\ndef extract_even(test_tuple):\n    \"\"\"\n    Remove uneven elements from a nested mixed tuple, keeping only even numbers.\n    \n    Args:\n        test_tuple: A nested tuple containing integers\n        \n    Returns:\n        A new tuple with only even numbers, maintaining the nested structure\n    \"\"\"\n    result = []\n    \n    for element in test_tuple:\n        if isinstance(element, tuple):\n            # Recursively process nested tuples\n            nested_result = extract_even(element)\n            # Only add non-empty nested tuples\n            if nested_result:\n                result.append(nested_result)\n        elif isinstance(element, int) and element % 2 == 0:\n            # Keep even integers\n            result.append(element)\n    \n    return tuple(result)\n```"], "prompt_tokens": [101], "completion_tokens": [149], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_580_extract_even"}
{"name": "mbpp_581_surface_Area", "language": "Python3", "prompt": "def surface_Area(b: int, s: int) -> int:\n    \"\"\"\n\tWrite a python function to find the surface area of a square pyramid with a given base edge and height.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surface_Area", "test": "def check(candidate):\n    assert candidate(3, 4) == 33\n    assert candidate(4, 5) == 56\n    assert candidate(1, 2) == 5\n\ndef test_check():\n    check(surface_Area)\n\ntest_check()\n", "sample_io": ["assert surface_Area(3, 4) == 33"], "source_codes": ["\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and slant height.\n    \n    Args:\n        b: base edge length\n        s: slant height\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area (square base)\n    base_area = b * b\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n\n\n"], "responses": ["```python\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and slant height.\n    \n    Args:\n        b: base edge length\n        s: slant height\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area (square base)\n    base_area = b * b\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n```"], "prompt_tokens": [89], "completion_tokens": [140], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_581_surface_Area"}
{"name": "mbpp_583_catalan_number", "language": "Python3", "prompt": "def catalan_number(num: int) -> int:\n    \"\"\"\n\tWrite a function which returns nth catalan number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "catalan_number", "test": "def check(candidate):\n    assert candidate(10) == 16796\n    assert candidate(9) == 4862\n    assert candidate(7) == 429\n\ndef test_check():\n    check(catalan_number)\n\ntest_check()\n", "sample_io": ["assert catalan_number(10) == 16796"], "source_codes": ["\ndef catalan_number(num: int) -> int:\n    \"\"\"\n    Returns the nth Catalan number.\n    \n    The Catalan numbers are a sequence of natural numbers that occur in various counting problems.\n    The nth Catalan number can be calculated using the formula:\n    C(n) = (2n)! / ((n+1)! * n!)\n    \n    Or using the recursive relation:\n    C(0) = 1\n    C(n) = sum(C(i) * C(n-1-i)) for i from 0 to n-1\n    \n    Or using the more efficient formula:\n    C(n) = C(2n, n) / (n+1) where C(2n, n) is the binomial coefficient\n    \n    Args:\n        num: A non-negative integer representing the position in the Catalan sequence\n        \n    Returns:\n        The nth Catalan number\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if num <= 1:\n        return 1\n    \n    # Using dynamic programming approach for efficiency\n    # C(n) = (2n)! / ((n+1)! * n!) = product from i=0 to n-1 of (2n-i)/(i+1) * 1/(n+1)\n    # More efficiently: C(n) = C(2n, n) / (n+1)\n    \n    # Calculate using the recurrence relation with memoization\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]\n\n\n"], "responses": ["```python\ndef catalan_number(num: int) -> int:\n    \"\"\"\n    Returns the nth Catalan number.\n    \n    The Catalan numbers are a sequence of natural numbers that occur in various counting problems.\n    The nth Catalan number can be calculated using the formula:\n    C(n) = (2n)! / ((n+1)! * n!)\n    \n    Or using the recursive relation:\n    C(0) = 1\n    C(n) = sum(C(i) * C(n-1-i)) for i from 0 to n-1\n    \n    Or using the more efficient formula:\n    C(n) = C(2n, n) / (n+1) where C(2n, n) is the binomial coefficient\n    \n    Args:\n        num: A non-negative integer representing the position in the Catalan sequence\n        \n    Returns:\n        The nth Catalan number\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if num <= 1:\n        return 1\n    \n    # Using dynamic programming approach for efficiency\n    # C(n) = (2n)! / ((n+1)! * n!) = product from i=0 to n-1 of (2n-i)/(i+1) * 1/(n+1)\n    # More efficiently: C(n) = C(2n, n) / (n+1)\n    \n    # Calculate using the recurrence relation with memoization\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]\n```"], "prompt_tokens": [74], "completion_tokens": [387], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_583_catalan_number"}
{"name": "mbpp_584_find_adverbs", "language": "Python3", "prompt": "def find_adverbs(text: str) -> str:\n    \"\"\"\n\tWrite a function to find the first adverb ending with ly and its positions in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverbs", "test": "def check(candidate):\n    assert candidate('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'\n    assert candidate('Please handle the situation carefuly') == '28-36: carefuly'\n    assert candidate('Complete the task quickly') == '18-25: quickly'\n\ndef test_check():\n    check(find_adverbs)\n\ntest_check()\n", "sample_io": ["assert find_adverbs('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'"], "source_codes": ["\nimport re\n\ndef find_adverbs(text: str) -> str:\n    \"\"\"\n    Find the first adverb ending with 'ly' and its positions in a given string.\n    \n    Args:\n        text (str): The input string to search for adverbs\n        \n    Returns:\n        str: A string containing the adverb and its positions, or an empty string if none found\n    \"\"\"\n    # Pattern to match words ending with 'ly' (adverbs)\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches with their positions\n    matches = re.finditer(pattern, text)\n    \n    # Get the first match\n    for match in matches:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{adverb} found at position {start_pos}-{end_pos}\"\n    \n    # Return empty string if no adverb found\n    return \"\"\n\n\n"], "responses": ["```python\nimport re\n\ndef find_adverbs(text: str) -> str:\n    \"\"\"\n    Find the first adverb ending with 'ly' and its positions in a given string.\n    \n    Args:\n        text (str): The input string to search for adverbs\n        \n    Returns:\n        str: A string containing the adverb and its positions, or an empty string if none found\n    \"\"\"\n    # Pattern to match words ending with 'ly' (adverbs)\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches with their positions\n    matches = re.finditer(pattern, text)\n    \n    # Get the first match\n    for match in matches:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{adverb} found at position {start_pos}-{end_pos}\"\n    \n    # Return empty string if no adverb found\n    return \"\"\n```"], "prompt_tokens": [84], "completion_tokens": [197], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_584_find_adverbs"}
{"name": "mbpp_585_expensive_items", "language": "Python3", "prompt": "from typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n\tWrite a function to find the n most expensive items in a given dataset.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "expensive_items", "test": "def check(candidate):\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }], 2) == [{ 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-1', 'price': 101.1 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }, { 'name': 'Item-4', 'price': 22.75 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n\ndef test_check():\n    check(expensive_items)\n\ntest_check()\n", "sample_io": ["assert expensive_items([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]"], "source_codes": ["\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \n    Args:\n        items: List of dictionaries containing item information with price as float\n        n: Number of most expensive items to return\n        \n    Returns:\n        List of n most expensive items sorted by price in descending order\n    \"\"\"\n    # Sort items by price in descending order and take first n items\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]\n\n\n"], "responses": ["```python\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \n    Args:\n        items: List of dictionaries containing item information with price as float\n        n: Number of most expensive items to return\n        \n    Returns:\n        List of n most expensive items sorted by price in descending order\n    \"\"\"\n    # Sort items by price in descending order and take first n items\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]\n```"], "prompt_tokens": [109], "completion_tokens": [138], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_585_expensive_items"}
{"name": "mbpp_586_split_Arr", "language": "Python3", "prompt": "from typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to split a list at the nth eelment and add the first part to the end.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_Arr", "test": "def check(candidate):\n    assert candidate([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]\n    assert candidate([1, 2, 3, 4], 1) == [2, 3, 4, 1]\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7], 3) == [3, 4, 5, 6, 7, 0, 1, 2]\n\ndef test_check():\n    check(split_Arr)\n\ntest_check()\n", "sample_io": ["assert split_Arr([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]"], "source_codes": ["\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    if n <= 0 or n >= len(l):\n        return l\n    \n    first_part = l[:n]\n    second_part = l[n:]\n    \n    return second_part + first_part\n\n\n"], "responses": ["```python\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    if n <= 0 or n >= len(l):\n        return l\n    \n    first_part = l[:n]\n    second_part = l[n:]\n    \n    return second_part + first_part\n```"], "prompt_tokens": [98], "completion_tokens": [82], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_586_split_Arr"}
{"name": "mbpp_587_list_tuple", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n\tWrite a function to convert a list to a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_587_list_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_tuple", "test": "def check(candidate):\n    assert candidate([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    assert candidate([2, 4, 5, 6, 2, 3, 4, 4, 7]) == (2, 4, 5, 6, 2, 3, 4, 4, 7)\n    assert candidate([58, 44, 56]) == (58, 44, 56)\n\ndef test_check():\n    check(list_tuple)\n\ntest_check()\n", "sample_io": ["assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"], "source_codes": ["\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n\n\n"], "responses": ["```python\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n```"], "prompt_tokens": [83], "completion_tokens": [39], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_587_list_tuple"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)\n\n\n"], "responses": ["```python\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)\n```"], "prompt_tokens": [87], "completion_tokens": [53], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_589_perfect_squares", "language": "Python3", "prompt": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find perfect squares between two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perfect_squares", "test": "def check(candidate):\n    assert candidate(1, 30) == [1, 4, 9, 16, 25]\n    assert candidate(50, 100) == [64, 81, 100]\n    assert candidate(100, 200) == [100, 121, 144, 169, 196]\n\ndef test_check():\n    check(perfect_squares)\n\ntest_check()\n", "sample_io": ["assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"], "source_codes": ["\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Find perfect squares between two given numbers.\n    \n    Args:\n        a: First number (inclusive)\n        b: Second number (inclusive)\n    \n    Returns:\n        List of perfect squares between a and b (inclusive)\n    \"\"\"\n    # Ensure a is the smaller number\n    if a > b:\n        a, b = b, a\n    \n    # Find the starting point - smallest integer whose square >= a\n    start = int(a ** 0.5)\n    if start * start < a:\n        start += 1\n    \n    # Find all perfect squares up to b\n    result = []\n    i = start\n    while i * i <= b:\n        result.append(i * i)\n        i += 1\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Find perfect squares between two given numbers.\n    \n    Args:\n        a: First number (inclusive)\n        b: Second number (inclusive)\n    \n    Returns:\n        List of perfect squares between a and b (inclusive)\n    \"\"\"\n    # Ensure a is the smaller number\n    if a > b:\n        a, b = b, a\n    \n    # Find the starting point - smallest integer whose square >= a\n    start = int(a ** 0.5)\n    if start * start < a:\n        start += 1\n    \n    # Find all perfect squares up to b\n    result = []\n    i = start\n    while i * i <= b:\n        result.append(i * i)\n        i += 1\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [182], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_589_perfect_squares"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["```python\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n```"], "prompt_tokens": [86], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_592_sum_Of_product", "language": "Python3", "prompt": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the product of consecutive binomial co-efficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_product", "test": "def check(candidate):\n    assert candidate(3) == 15\n    assert candidate(4) == 56\n    assert candidate(1) == 1\n\ndef test_check():\n    check(sum_Of_product)\n\ntest_check()\n", "sample_io": ["assert sum_Of_product(3) == 15"], "source_codes": ["\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Calculate binomial coefficients\n    def binomial_coeff(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        # Use the property C(n,k) = C(n,n-k) to minimize calculations\n        k = min(k, n - k)\n        \n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Sum of products of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of products of consecutive binomial coefficients.\n\nLet me think about what this means:\n- For a given n, I need to consider binomial coefficients C(n,k) for k = 0,1,2,...,n\n- The products of consecutive binomial coefficients would be: C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n\nThere's actually a known formula for this sum. The sum of products of consecutive binomial coefficients equals (2n)! / ((n-1)!(n+1)!) which can also be written as C(2n, n-1).\n\nAlternatively, I can compute it directly by calculating each binomial coefficient and summing their products.\n\nLet me implement the direct approach:\n\n```python\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Calculate binomial coefficients\n    def binomial_coeff(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        # Use the property C(n,k) = C(n,n-k) to minimize calculations\n        k = min(k, n - k)\n        \n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Sum of products of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n    \n    return total_sum\n```"], "prompt_tokens": [83], "completion_tokens": [389], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_592_sum_Of_product"}
{"name": "mbpp_593_removezero_ip", "language": "Python3", "prompt": "def removezero_ip(ip: str) -> str:\n    \"\"\"\n\tWrite a function to remove leading zeroes from an ip address.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "removezero_ip", "test": "def check(candidate):\n    assert candidate('216.08.094.196') == '216.8.94.196'\n    assert candidate('12.01.024') == '12.1.24'\n    assert candidate('216.08.094.0196') == '216.8.94.196'\n\ndef test_check():\n    check(removezero_ip)\n\ntest_check()\n", "sample_io": ["assert removezero_ip('216.08.094.196') == '216.8.94.196'"], "source_codes": ["\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address by dots\n    parts = ip.split('.')\n    \n    # Remove leading zeros from each part\n    cleaned_parts = []\n    for part in parts:\n        # Convert to integer and back to string to remove leading zeros\n        cleaned_parts.append(str(int(part)))\n    \n    # Join the parts back with dots\n    return '.'.join(cleaned_parts)\n\n\n"], "responses": ["```python\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address by dots\n    parts = ip.split('.')\n    \n    # Remove leading zeros from each part\n    cleaned_parts = []\n    for part in parts:\n        # Convert to integer and back to string to remove leading zeros\n        cleaned_parts.append(str(int(part)))\n    \n    # Join the parts back with dots\n    return '.'.join(cleaned_parts)\n```"], "prompt_tokens": [76], "completion_tokens": [109], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_593_removezero_ip"}
{"name": "mbpp_594_diff_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the difference of the first even and first odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "diff_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n    assert candidate([1, 5, 7, 9, 10]) == 9\n\ndef test_check():\n    check(diff_even_odd)\n\ntest_check()\n", "sample_io": ["assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"], "source_codes": ["\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference of the first even and first odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even number\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    # Find the first odd number\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    \n    # If either first_even or first_odd is not found, return None or raise an exception\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number\")\n    \n    return first_even - first_odd\n\n\n"], "responses": ["```python\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference of the first even and first odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even number\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    # Find the first odd number\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    \n    # If either first_even or first_odd is not found, return None or raise an exception\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number\")\n    \n    return first_even - first_odd\n```"], "prompt_tokens": [91], "completion_tokens": [176], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_594_diff_even_odd"}
{"name": "mbpp_595_min_Swaps", "language": "Python3", "prompt": "from typing import Any\n\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n\tWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Swaps", "test": "def check(candidate):\n    assert candidate('1101', '1110') == 1\n    assert candidate('111', '000') == 'Not Possible'\n    assert candidate('111', '110') == 'Not Possible'\n\ndef test_check():\n    check(min_Swaps)\n\ntest_check()\n", "sample_io": ["assert min_Swaps('1101', '1110') == 1"], "source_codes": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n    Count minimum number of swaps required to convert one binary number \n    represented as a string to another.\n    \"\"\"\n    # Check if both strings have same length\n    if len(str1) != len(str2):\n        return -1\n    \n    # Check if both strings have same number of 0s and 1s\n    if str1.count('0') != str2.count('0') or str1.count('1') != str2.count('1'):\n        return -1\n    \n    # Count mismatches at each position\n    mismatch_count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            mismatch_count += 1\n    \n    # Each swap can fix 2 mismatches (one 0 with one 1)\n    # So minimum swaps needed is mismatch_count // 2\n    return mismatch_count // 2\n\n\n"], "responses": ["```python\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n    Count minimum number of swaps required to convert one binary number \n    represented as a string to another.\n    \"\"\"\n    # Check if both strings have same length\n    if len(str1) != len(str2):\n        return -1\n    \n    # Check if both strings have same number of 0s and 1s\n    if str1.count('0') != str2.count('0') or str1.count('1') != str2.count('1'):\n        return -1\n    \n    # Count mismatches at each position\n    mismatch_count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            mismatch_count += 1\n    \n    # Each swap can fix 2 mismatches (one 0 with one 1)\n    # So minimum swaps needed is mismatch_count // 2\n    return mismatch_count // 2\n```"], "prompt_tokens": [99], "completion_tokens": [209], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_595_min_Swaps"}
{"name": "mbpp_597_find_kth", "language": "Python3", "prompt": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find kth element from the given two sorted arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_kth", "test": "def check(candidate):\n    assert candidate([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    assert candidate([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256\n    assert candidate([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8\n\ndef test_check():\n    check(find_kth)\n\ntest_check()\n", "sample_io": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"], "source_codes": ["\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n    \"\"\"\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if len(arr1) == 0:\n        return arr2[k-1]\n    \n    if k == 1:\n        return min(arr1[0], arr2[0])\n    \n    # Binary search approach\n    left, right = 0, min(k, len(arr1))\n    \n    while left <= right:\n        # Partition arr1 and arr2\n        partition1 = (left + right) // 2\n        partition2 = k - partition1\n        \n        # Handle boundary cases\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1\n    \n    return -1  # Should not reach here for valid input\n\n\n"], "responses": ["```python\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n    \"\"\"\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if len(arr1) == 0:\n        return arr2[k-1]\n    \n    if k == 1:\n        return min(arr1[0], arr2[0])\n    \n    # Binary search approach\n    left, right = 0, min(k, len(arr1))\n    \n    while left <= right:\n        # Partition arr1 and arr2\n        partition1 = (left + right) // 2\n        partition2 = k - partition1\n        \n        # Handle boundary cases\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1\n    \n    return -1  # Should not reach here for valid input\n```"], "prompt_tokens": [96], "completion_tokens": [376], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_597_find_kth"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if sum equals the original number\n    return sum_of_powers == number\n\n\n"], "responses": ["```python\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if sum equals the original number\n    return sum_of_powers == number\n```"], "prompt_tokens": [79], "completion_tokens": [119], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_599_sum_average", "language": "Python3", "prompt": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n\tWrite a function to find sum and average of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_599_sum_average.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_average", "test": "def check(candidate):\n    assert candidate(10) == (55, 5.5)\n    assert candidate(15) == (120, 8.0)\n    assert candidate(20) == (210, 10.5)\n\ndef test_check():\n    check(sum_average)\n\ntest_check()\n", "sample_io": ["assert sum_average(10) == (55, 5.5)"], "source_codes": ["\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Find sum and average of first n natural numbers.\n    \n    Args:\n        number: A positive integer representing the count of natural numbers\n        \n    Returns:\n        A tuple containing (sum, average) of first n natural numbers\n    \"\"\"\n    if number <= 0:\n        return (0, 0.0)\n    \n    # Sum of first n natural numbers = n * (n + 1) / 2\n    total_sum = number * (number + 1) // 2\n    \n    # Average = sum / count\n    average = total_sum / number\n    \n    return (total_sum, average)\n\n\n"], "responses": ["```python\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Find sum and average of first n natural numbers.\n    \n    Args:\n        number: A positive integer representing the count of natural numbers\n        \n    Returns:\n        A tuple containing (sum, average) of first n natural numbers\n    \"\"\"\n    if number <= 0:\n        return (0, 0.0)\n    \n    # Sum of first n natural numbers = n * (n + 1) / 2\n    total_sum = number * (number + 1) // 2\n    \n    # Average = sum / count\n    average = total_sum / number\n    \n    return (total_sum, average)\n```"], "prompt_tokens": [85], "completion_tokens": [147], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_599_sum_average"}
{"name": "mbpp_600_is_Even", "language": "Python3", "prompt": "def is_Even(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Even", "test": "def check(candidate):\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(3) == False\n\ndef test_check():\n    check(is_Even)\n\ntest_check()\n", "sample_io": ["assert is_Even(1) == False"], "source_codes": ["\ndef is_Even(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given number is even or not.\n    \"\"\"\n    return n % 2 == 0\n\n\n"], "responses": ["```python\ndef is_Even(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given number is even or not.\n    \"\"\"\n    return n % 2 == 0\n```"], "prompt_tokens": [79], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_600_is_Even"}
{"name": "mbpp_602_first_repeated_char", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_repeated_char", "test": "def check(candidate):\n    assert candidate('abcabc') == 'a'\n    assert candidate('abc') == None\n    assert candidate('123123') == '1'\n\ndef test_check():\n    check(first_repeated_char)\n\ntest_check()\n", "sample_io": ["assert first_repeated_char('abcabc') == 'a'"], "source_codes": ["\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n\n\n"], "responses": ["```python\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n```"], "prompt_tokens": [87], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_602_first_repeated_char"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": ["\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Start with list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    ludic_numbers = []\n    index = 0\n    \n    while index < len(numbers):\n        # The current number is ludic\n        ludic_num = numbers[index]\n        ludic_numbers.append(ludic_num)\n        \n        # Remove every ludic_num-th element from the remaining list\n        # Start from the next position after current index\n        new_numbers = []\n        for i in range(len(numbers)):\n            # Keep elements whose position (1-indexed) is not divisible by ludic_num\n            if (i - index) % ludic_num != 0 or i <= index:\n                new_numbers.append(numbers[i])\n        \n        numbers = new_numbers\n        index += 1\n    \n    return ludic_numbers\n\n\n"], "responses": ["Looking at this problem, I need to generate Ludic numbers (also known as Ludic sequence), not \"lucid\" numbers. The Ludic sequence is generated by a process similar to the Sieve of Eratosthenes:\n\n1. Start with the list of natural numbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]\n2. The first number (1) is ludic\n3. Remove every 1st number from the remaining list (which removes nothing)\n4. The next number (2) is ludic\n5. Remove every 2nd number from the remaining list\n6. Continue this process...\n\nLet me implement this algorithm:\n\n```python\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Start with list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    ludic_numbers = []\n    index = 0\n    \n    while index < len(numbers):\n        # The current number is ludic\n        ludic_num = numbers[index]\n        ludic_numbers.append(ludic_num)\n        \n        # Remove every ludic_num-th element from the remaining list\n        # Start from the next position after current index\n        new_numbers = []\n        for i in range(len(numbers)):\n            # Keep elements whose position (1-indexed) is not divisible by ludic_num\n            if (i - index) % ludic_num != 0 or i <= index:\n                new_numbers.append(numbers[i])\n        \n        numbers = new_numbers\n        index += 1\n    \n    return ludic_numbers\n```"], "prompt_tokens": [89], "completion_tokens": [360], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join back with spaces\n    return ' '.join(s.split()[::-1])\n\n\n"], "responses": ["```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join back with spaces\n    return ' '.join(s.split()[::-1])\n```"], "prompt_tokens": [78], "completion_tokens": [64], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    # Check for divisibility from 2 to sqrt(num)\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    # Check for divisibility from 2 to sqrt(num)\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n```"], "prompt_tokens": [77], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n\n"], "responses": ["```python\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n```"], "prompt_tokens": [74], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
{"name": "mbpp_607_find_literals", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n\tWrite a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_literals", "test": "def check(candidate):\n    assert candidate('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    assert candidate('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)\n    assert candidate('Hardest choices required strongest will', 'will') == ('will', 35, 39)\n\ndef test_check():\n    check(find_literals)\n\ntest_check()\n", "sample_io": ["assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"], "source_codes": ["\nimport re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern. The function should return the matching substring, a start index and an end index.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return (\"\", -1, -1)\n\n\n"], "responses": ["```python\nimport re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern. The function should return the matching substring, a start index and an end index.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return (\"\", -1, -1)\n```"], "prompt_tokens": [106], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_607_find_literals"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of last row (which is the nth Bell number)\n    return bell[n][0]\n\n\n"], "responses": ["```python\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of last row (which is the nth Bell number)\n    return bell[n][0]\n```"], "prompt_tokens": [73], "completion_tokens": [225], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_610_remove_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_kth_element", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], 4) == [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], 5) == [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10]\n\ndef test_check():\n    check(remove_kth_element)\n\ntest_check()\n", "sample_io": ["assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"], "source_codes": ["\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    if L < 0 or L >= len(list1):\n        return list1.copy()\n    \n    result = list1.copy()\n    result.pop(L)\n    return result\n\n\n"], "responses": ["```python\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    if L < 0 or L >= len(list1):\n        return list1.copy()\n    \n    result = list1.copy()\n    result.pop(L)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [89], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_610_remove_kth_element"}
{"name": "mbpp_611_max_of_nth", "language": "Python3", "prompt": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n\tWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_of_nth", "test": "def check(candidate):\n    assert candidate([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    assert candidate([[6, 7, 8], [2, 4, 6], [9, 10, 20]], 1) == 10\n    assert candidate([[7, 8, 9], [3, 5, 7], [10, 11, 21]], 1) == 11\n\ndef test_check():\n    check(max_of_nth)\n\ntest_check()\n", "sample_io": ["assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"], "source_codes": ["\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Extract the N-th column from each row and find the maximum\n    return max(row[N] for row in test_list)\n\n\n"], "responses": ["```python\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Extract the N-th column from each row and find the maximum\n    return max(row[N] for row in test_list)\n```"], "prompt_tokens": [99], "completion_tokens": [78], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_611_max_of_nth"}
{"name": "mbpp_612_merge", "language": "Python3", "prompt": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]\n    assert candidate([['x', 'y', 'z'], ['a', 'b', 'c'], ['m', 'n', 'o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'], ['z', 'c', 'o']]\n\ndef test_check():\n    check(merge)\n\ntest_check()\n", "sample_io": ["assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"], "source_codes": ["\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    first_elements = []\n    second_elements = []\n    \n    for sublist in lst:\n        first_elements.append(sublist[0])\n        second_elements.append(sublist[1])\n    \n    return [first_elements, second_elements]\n\n\n"], "responses": ["```python\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    first_elements = []\n    second_elements = []\n    \n    for sublist in lst:\n        first_elements.append(sublist[0])\n        second_elements.append(sublist[1])\n    \n    return [first_elements, second_elements]\n```"], "prompt_tokens": [117], "completion_tokens": [121], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_612_merge"}
{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n\n\n"], "responses": ["```python\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n```"], "prompt_tokens": [95], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n\n\n"], "responses": ["```python\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_616_tuple_modulo", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function which takes two tuples of the same length and performs the element wise modulo.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_modulo", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n    assert candidate((11, 5, 6, 7), (6, 7, 8, 6)) == (5, 5, 6, 1)\n    assert candidate((12, 6, 7, 8), (7, 8, 9, 7)) == (5, 6, 7, 1)\n\ndef test_check():\n    check(tuple_modulo)\n\ntest_check()\n", "sample_io": ["assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)"], "source_codes": ["\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [118], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_616_tuple_modulo"}
{"name": "mbpp_617_min_Jumps", "language": "Python3", "prompt": "from typing import Tuple\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n\tWrite a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Jumps", "test": "def check(candidate):\n    assert candidate((3, 4), 11) == 3.5\n    assert candidate((3, 4), 0) == 0\n    assert candidate((11, 14), 11) == 1\n\ndef test_check():\n    check(min_Jumps)\n\ntest_check()\n", "sample_io": ["assert min_Jumps((3, 4), 11) == 3.5"], "source_codes": ["\nfrom typing import Tuple\nfrom collections import deque\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0.0\n    \n    # BFS to find minimum jumps\n    queue = deque([(0, 0)])  # (current_distance, jumps_count)\n    visited = {0}\n    \n    step1, step2 = steps\n    \n    while queue:\n        current_pos, jumps = queue.popleft()\n        \n        # Try both step sizes\n        for step in [step1, step2]:\n            # Jump forward\n            new_pos = current_pos + step\n            if new_pos == d:\n                return float(jumps + 1)\n            if new_pos < d * 2 and new_pos not in visited:  # Reasonable bound\n                visited.add(new_pos)\n                queue.append((new_pos, jumps + 1))\n            \n            # Jump backward (only if we're not at origin and it makes sense)\n            if current_pos >= step:\n                new_pos = current_pos - step\n                if new_pos == d:\n                    return float(jumps + 1)\n                if new_pos >= 0 and new_pos not in visited:\n                    visited.add(new_pos)\n                    queue.append((new_pos, jumps + 1))\n    \n    # If we can't reach exactly, return infinity\n    return float('inf')\n\n\n"], "responses": ["Looking at this problem, I need to find the minimum number of jumps to reach a point (d, 0) from the origin (0, 0) where each jump can be of two possible lengths given in the `steps` tuple.\n\nLet me think about this step by step:\n\n1. I'm at origin (0, 0) and want to reach (d, 0)\n2. Each jump can be either `steps[0]` or `steps[1]` units long\n3. I can jump in any direction, but I want to minimize the total number of jumps\n4. Since I'm moving on a 2D plane, I can use the triangle inequality - the direct distance to cover is `d`\n\nThe key insight is that this is essentially finding the minimum number of jumps where each jump contributes some amount toward covering the distance `d`. Since jumps can be in any direction, the optimal strategy would be to jump directly toward the target when possible.\n\nHowever, since we might not have a jump length that exactly divides `d`, we need to consider combinations. This becomes a variant of the coin change problem where we want the minimum number of \"coins\" (jumps) to make up distance `d`.\n\nBut wait - we're dealing with floating point return type, which suggests we might need to consider cases where exact reaching isn't possible, or we're looking for expected values.\n\nActually, re-reading the problem: we want to reach exactly (d, 0), and we can jump in any direction with given step lengths. The minimum number of jumps would be when we jump directly towards the target.\n\nIf `d` is divisible by either step size, that gives us one solution. If not, we need to find the minimum combination.\n\nThis is a BFS problem - find the minimum number of steps to reach exactly distance `d` from origin.\n\n```python\nfrom typing import Tuple\nfrom collections import deque\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0.0\n    \n    # BFS to find minimum jumps\n    queue = deque([(0, 0)])  # (current_distance, jumps_count)\n    visited = {0}\n    \n    step1, step2 = steps\n    \n    while queue:\n        current_pos, jumps = queue.popleft()\n        \n        # Try both step sizes\n        for step in [step1, step2]:\n            # Jump forward\n            new_pos = current_pos + step\n            if new_pos == d:\n                return float(jumps + 1)\n            if new_pos < d * 2 and new_pos not in visited:  # Reasonable bound\n                visited.add(new_pos)\n                queue.append((new_pos, jumps + 1))\n            \n            # Jump backward (only if we're not at origin and it makes sense)\n            if current_pos >= step:\n                new_pos = current_pos - step\n                if new_pos == d:\n                    return float(jumps + 1)\n                if new_pos >= 0 and new_pos not in visited:\n                    visited.add(new_pos)\n                    queue.append((new_pos, jumps + 1))\n    \n    # If we can't reach exactly, return infinity\n    return float('inf')\n```"], "prompt_tokens": [111], "completion_tokens": [679], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_617_min_Jumps"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": ["\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    return [a / b for a, b in zip(nums1, nums2)]\n\n\n"], "responses": ["```python\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    return [a / b for a, b in zip(nums1, nums2)]\n```"], "prompt_tokens": [87], "completion_tokens": [57], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_618_div_list"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters and digits\n    chars = []\n    nums = []\n    \n    for char in test_str:\n        if char.isdigit():\n            nums.append(char)\n        else:\n            chars.append(char)\n    \n    # Combine characters first, then numbers\n    return ''.join(chars) + ''.join(nums)\n\n\n"], "responses": ["```python\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters and digits\n    chars = []\n    nums = []\n    \n    for char in test_str:\n        if char.isdigit():\n            nums.append(char)\n        else:\n            chars.append(char)\n    \n    # Combine characters first, then numbers\n    return ''.join(chars) + ''.join(nums)\n```"], "prompt_tokens": [80], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n\n\n"], "responses": ["```python\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n```"], "prompt_tokens": [95], "completion_tokens": [264], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n\n\n"], "responses": ["```python\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n```"], "prompt_tokens": [90], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "responses": ["```python\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n```"], "prompt_tokens": [75], "completion_tokens": [37], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["```python\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n```"], "prompt_tokens": [87], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": ["\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    The largest triangle inscribed in a semicircle has its base as the diameter of the semicircle\n    and its height equal to the radius. The area is (1/2) * base * height = (1/2) * 2r * r = r^2.\n    \n    Args:\n        r: radius of the semicircle\n        \n    Returns:\n        Area of the largest inscribed triangle, or None if radius is negative\n    \"\"\"\n    if r < 0:\n        return None\n    \n    # The maximum area triangle has base = 2*r (diameter) and height = r\n    # Area = (1/2) * base * height = (1/2) * 2*r * r = r^2\n    return r * r\n\n\n"], "responses": ["```python\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    The largest triangle inscribed in a semicircle has its base as the diameter of the semicircle\n    and its height equal to the radius. The area is (1/2) * base * height = (1/2) * 2r * r = r^2.\n    \n    Args:\n        r: radius of the semicircle\n        \n    Returns:\n        Area of the largest inscribed triangle, or None if radius is negative\n    \"\"\"\n    if r < 0:\n        return None\n    \n    # The maximum area triangle has base = 2*r (diameter) and height = r\n    # Area = (1/2) * base * height = (1/2) * 2*r * r = r^2\n    return r * r\n```"], "prompt_tokens": [96], "completion_tokens": [206], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_627_find_First_Missing", "language": "Python3", "prompt": "from typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest missing number from a sorted list of natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_First_Missing", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3]) == 4\n    assert candidate([0, 1, 2, 6, 9]) == 3\n    assert candidate([2, 3, 5, 8, 9]) == 0\n\ndef test_check():\n    check(find_First_Missing)\n\ntest_check()\n", "sample_io": ["assert find_First_Missing([0, 1, 2, 3]) == 4"], "source_codes": ["\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \n    Args:\n        array: A sorted list of natural numbers (non-negative integers)\n    \n    Returns:\n        The smallest missing natural number\n    \"\"\"\n    # Handle edge case: empty array or array doesn't start with 0\n    if not array or array[0] > 0:\n        return 0\n    \n    # Binary search approach for O(log n) time complexity\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the value at mid equals mid, then all numbers before mid are present\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If array[mid] > mid, there's a missing number before or at mid\n            right = mid - 1\n    \n    # At the end, left will be the first missing number\n    return left\n\n\n"], "responses": ["```python\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \n    Args:\n        array: A sorted list of natural numbers (non-negative integers)\n    \n    Returns:\n        The smallest missing natural number\n    \"\"\"\n    # Handle edge case: empty array or array doesn't start with 0\n    if not array or array[0] > 0:\n        return 0\n    \n    # Binary search approach for O(log n) time complexity\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the value at mid equals mid, then all numbers before mid are present\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If array[mid] > mid, there's a missing number before or at mid\n            right = mid - 1\n    \n    # At the end, left will be the first missing number\n    return left\n```"], "prompt_tokens": [89], "completion_tokens": [228], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_627_find_First_Missing"}
{"name": "mbpp_628_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(string: str) -> str:\n    \"\"\"\n\tWrite a function to replace all spaces in the given string with '%20'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('My Name is Dawood') == 'My%20Name%20is%20Dawood'\n    assert candidate('I am a Programmer') == 'I%20am%20a%20Programmer'\n    assert candidate('I love Coding') == 'I%20love%20Coding'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('My Name is Dawood') == 'My%20Name%20is%20Dawood'"], "source_codes": ["\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n\n\n"], "responses": ["```python\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n```"], "prompt_tokens": [79], "completion_tokens": [46], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_628_replace_spaces"}
{"name": "mbpp_629_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to find even numbers from a list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [2, 4]\n    assert candidate([4, 5, 6, 7, 8, 0, 1]) == [4, 6, 8, 0]\n    assert candidate([8, 12, 15, 19]) == [8, 12]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5]) == [2, 4]"], "source_codes": ["\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]\n\n\n"], "responses": ["```python\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]\n```"], "prompt_tokens": [83], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_629_Split"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate itself\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n\n\n"], "responses": ["```python\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate itself\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n```"], "prompt_tokens": [92], "completion_tokens": [137], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_631_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace whitespaces with an underscore and vice versa in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert candidate('The_Avengers') == 'The Avengers'\n    assert candidate('Fast and Furious') == 'Fast_and_Furious'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"], "source_codes": ["\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = \"\"\n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = \"\"\n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result\n```"], "prompt_tokens": [81], "completion_tokens": [78], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_631_replace_spaces"}
{"name": "mbpp_632_move_zero", "language": "Python3", "prompt": "from typing import List\n\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to move all zeroes to the end of the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_zero", "test": "def check(candidate):\n    assert candidate([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]\n    assert candidate([2, 3, 2, 0, 0, 4, 0, 5, 0]) == [2, 3, 2, 4, 5, 0, 0, 0, 0]\n    assert candidate([0, 1, 0, 1, 1]) == [1, 1, 1, 0, 0]\n\ndef test_check():\n    check(move_zero)\n\ntest_check()\n", "sample_io": ["assert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"], "source_codes": ["\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \"\"\"\n    # Count the number of zeros\n    zero_count = num_list.count(0)\n    \n    # Remove all zeros from the list\n    non_zero_list = [x for x in num_list if x != 0]\n    \n    # Append the zeros at the end\n    result = non_zero_list + [0] * zero_count\n    \n    return result\n\n\n"], "responses": ["```python\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \"\"\"\n    # Count the number of zeros\n    zero_count = num_list.count(0)\n    \n    # Remove all zeros from the list\n    non_zero_list = [x for x in num_list if x != 0]\n    \n    # Append the zeros at the end\n    result = non_zero_list + [0] * zero_count\n    \n    return result\n```"], "prompt_tokens": [87], "completion_tokens": [108], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_632_move_zero"}
{"name": "mbpp_633_pair_xor_Sum", "language": "Python3", "prompt": "from typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of xor of all pairs of numbers in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_xor_Sum", "test": "def check(candidate):\n    assert candidate([5, 9, 7, 6], 4) == 47\n    assert candidate([7, 3, 5], 3) == 12\n    assert candidate([7, 3], 2) == 4\n\ndef test_check():\n    check(pair_xor_Sum)\n\ntest_check()\n", "sample_io": ["assert pair_xor_Sum([5, 9, 7, 6], 4) == 47"], "source_codes": ["\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of XOR of all pairs of numbers in the given list.\n\nLet me think about this step by step:\n\n1. For each pair (i,j) where i < j, I need to calculate arr[i] XOR arr[j]\n2. Sum all these XOR results\n\nHowever, there's a more efficient approach using bit manipulation:\n- For each bit position, count how many numbers have that bit set to 1\n- For each bit position, the contribution to the final XOR sum is: count_of_ones * count_of_zeros * 2^bit_position\n- This works because XOR of two bits is 1 when they're different\n\nLet me implement the straightforward approach first, then optimize:\n\n```python\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [233], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_633_pair_xor_Sum"}
{"name": "mbpp_635_heap_sort", "language": "Python3", "prompt": "from typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_sort", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    assert candidate([7, 1, 9, 5]) == [1, 5, 7, 9]\n\ndef test_check():\n    check(heap_sort)\n\ntest_check()\n", "sample_io": ["assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "source_codes": ["\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sorts the given list using heap sort algorithm.\n    \"\"\"\n    # Convert to list if it's not already (to avoid modifying original)\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Helper function to maintain heap property.\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\n\n"], "responses": ["```python\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sorts the given list using heap sort algorithm.\n    \"\"\"\n    # Convert to list if it's not already (to avoid modifying original)\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Helper function to maintain heap property.\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n```"], "prompt_tokens": [80], "completion_tokens": [351], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_635_heap_sort"}
{"name": "mbpp_637_noprofit_noloss", "language": "Python3", "prompt": "def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given amount has no profit and no loss\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "noprofit_noloss", "test": "def check(candidate):\n    assert candidate(1500, 1200) == False\n    assert candidate(100, 100) == True\n    assert candidate(2000, 5000) == False\n\ndef test_check():\n    check(noprofit_noloss)\n\ntest_check()\n", "sample_io": ["assert noprofit_noloss(1500, 1200) == False"], "source_codes": ["\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n\n\n"], "responses": ["```python\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n```"], "prompt_tokens": [89], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_637_noprofit_noloss"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    Where T is temperature in Celsius and V is wind velocity in km/h\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in Celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return int(math.ceil(wci))\n\n\n"], "responses": ["```python\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    Where T is temperature in Celsius and V is wind velocity in km/h\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in Celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return int(math.ceil(wci))\n```"], "prompt_tokens": [96], "completion_tokens": [229], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names \n    after removing the names that start with a lowercase letter.\n    \"\"\"\n    total_length = 0\n    for name in sample_names:\n        if name and name[0].isupper():\n            total_length += len(name)\n    return total_length\n\n\n"], "responses": ["```python\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names \n    after removing the names that start with a lowercase letter.\n    \"\"\"\n    total_length = 0\n    for name in sample_names:\n        if name and name[0].isupper():\n            total_length += len(name)\n    return total_length\n```"], "prompt_tokens": [98], "completion_tokens": [89], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_640_remove_parenthesis", "language": "Python3", "prompt": "from typing import List\n\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n\tWrite a function to remove the parenthesis and what is inbetween them from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_parenthesis", "test": "def check(candidate):\n    assert candidate(['python (chrome)']) == 'python'\n    assert candidate(['string(.abc)']) == 'string'\n    assert candidate(['alpha(num)']) == 'alpha'\n\ndef test_check():\n    check(remove_parenthesis)\n\ntest_check()\n", "sample_io": ["assert remove_parenthesis(['python (chrome)']) == 'python'"], "source_codes": ["\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove parentheses and their contents from strings in the list and join them.\n    \"\"\"\n    result = []\n    for item in items:\n        # Remove everything between parentheses including the parentheses\n        cleaned = \"\"\n        i = 0\n        while i < len(item):\n            if item[i] == '(':\n                # Skip until closing parenthesis\n                while i < len(item) and item[i] != ')':\n                    i += 1\n                # Skip the closing parenthesis\n                if i < len(item):\n                    i += 1\n            else:\n                cleaned += item[i]\n                i += 1\n        result.append(cleaned)\n    \n    return ' '.join(result)\n\n\n"], "responses": ["```python\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove parentheses and their contents from strings in the list and join them.\n    \"\"\"\n    result = []\n    for item in items:\n        # Remove everything between parentheses including the parentheses\n        cleaned = \"\"\n        i = 0\n        while i < len(item):\n            if item[i] == '(':\n                # Skip until closing parenthesis\n                while i < len(item) and item[i] != ')':\n                    i += 1\n                # Skip the closing parenthesis\n                if i < len(item):\n                    i += 1\n            else:\n                cleaned += item[i]\n                i += 1\n        result.append(cleaned)\n    \n    return ' '.join(result)\n```"], "prompt_tokens": [88], "completion_tokens": [157], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_640_remove_parenthesis"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n (int): The position of the nonagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2\n\n\n"], "responses": ["```python\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n (int): The position of the nonagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2\n```"], "prompt_tokens": [75], "completion_tokens": [133], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_643_text_match_wordz_middle", "language": "Python3", "prompt": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks if a strings contains 'z', except at the start and end of the word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz_middle", "test": "def check(candidate):\n    assert candidate('pythonzabc.') == True\n    assert candidate('zxyabc.') == False\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz_middle)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz_middle('pythonzabc.') == True"], "source_codes": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    words = text.split()\n    \n    for word in words:\n        # Check if word has at least 3 characters (so we can have middle positions)\n        if len(word) >= 3:\n            # Check if 'z' or 'Z' appears in the middle (not first or last character)\n            middle_part = word[1:-1]\n            if 'z' in middle_part or 'Z' in middle_part:\n                return True\n        # If word has less than 3 characters, z cannot be in the middle\n        # If word has exactly 2 characters, z cannot be in the middle\n    \n    return False\n\n\n"], "responses": ["```python\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    words = text.split()\n    \n    for word in words:\n        # Check if word has at least 3 characters (so we can have middle positions)\n        if len(word) >= 3:\n            # Check if 'z' or 'Z' appears in the middle (not first or last character)\n            middle_part = word[1:-1]\n            if 'z' in middle_part or 'Z' in middle_part:\n                return True\n        # If word has less than 3 characters, z cannot be in the middle\n        # If word has exactly 2 characters, z cannot be in the middle\n    \n    return False\n```"], "prompt_tokens": [88], "completion_tokens": [176], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_643_text_match_wordz_middle"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if k <= 0:\n        return input[:]\n    if k > len(input):\n        k = len(input)\n    \n    # Convert k to 0-based index\n    k_index = k - 1\n    \n    # Create a copy of the input list\n    result = input[:]\n    \n    # Reverse the portion from index 0 to k_index (inclusive)\n    result[:k_index + 1] = result[:k_index + 1][::-1]\n    \n    return result\n\n\n"], "responses": ["```python\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if k <= 0:\n        return input[:]\n    if k > len(input):\n        k = len(input)\n    \n    # Convert k to 0-based index\n    k_index = k - 1\n    \n    # Create a copy of the input list\n    result = input[:]\n    \n    # Reverse the portion from index 0 to k_index (inclusive)\n    result[:k_index + 1] = result[:k_index + 1][::-1]\n    \n    return result\n```"], "prompt_tokens": [90], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n\n\n"], "responses": ["```python\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n```"], "prompt_tokens": [115], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
{"name": "mbpp_721_maxAverageOfPath", "language": "Python3", "prompt": "from typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maxAverageOfPath", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n    assert candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2\n    assert candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8\n\ndef test_check():\n    check(maxAverageOfPath)\n\ntest_check()\n", "sample_io": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"], "source_codes": ["\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    n = len(cost)\n    \n    # DP table to store maximum sum for each cell\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize first cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill rest of the table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Path length is always 2*n - 1 (n steps right, n-1 steps down, or vice versa)\n    path_length = 2 * n - 1\n    \n    # Return maximum average\n    return dp[n-1][n-1] / path_length\n\n\n"], "responses": ["```python\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    n = len(cost)\n    \n    # DP table to store maximum sum for each cell\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize first cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill rest of the table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Path length is always 2*n - 1 (n steps right, n-1 steps down, or vice versa)\n    path_length = 2 * n - 1\n    \n    # Return maximum average\n    return dp[n-1][n-1] / path_length\n```"], "prompt_tokens": [159], "completion_tokens": [280], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_721_maxAverageOfPath"}
{"name": "mbpp_722_filter_data", "language": "Python3", "prompt": "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n\tThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_data", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.9, 67) == { 'Cierra Vega': (6.2, 70), 'Kierra Gentry': (6.0, 68) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.7, 64) == { 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }\n\ndef test_check():\n    check(filter_data)\n\ntest_check()\n", "sample_io": ["assert filter_data({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }"], "source_codes": ["\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n    Filter students that have height and weight above the minimum.\n    \n    Args:\n        students: Dictionary with student names as keys and (height, weight) tuples as values\n        h: Minimum height threshold\n        w: Minimum weight threshold\n    \n    Returns:\n        Dictionary containing only students whose height > h and weight > w\n    \"\"\"\n    filtered_students = {}\n    \n    for name, (height, weight) in students.items():\n        if height > h and weight > w:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students\n\n\n"], "responses": ["```python\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n    Filter students that have height and weight above the minimum.\n    \n    Args:\n        students: Dictionary with student names as keys and (height, weight) tuples as values\n        h: Minimum height threshold\n        w: Minimum weight threshold\n    \n    Returns:\n        Dictionary containing only students whose height > h and weight > w\n    \"\"\"\n    filtered_students = {}\n    \n    for name, (height, weight) in students.items():\n        if height > h and weight > w:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students\n```"], "prompt_tokens": [145], "completion_tokens": [152], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_722_filter_data"}
{"name": "mbpp_723_count_same_pair", "language": "Python3", "prompt": "from typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n\tThe input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_same_pair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 11\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 1\n    assert candidate([0, 1, 1, 2], [0, 1, 2, 2]) == 3\n\ndef test_check():\n    check(count_same_pair)\n\ntest_check()\n", "sample_io": ["assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"], "source_codes": ["\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n    \"\"\"\n    count = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n    \"\"\"\n    count = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            count += 1\n    return count\n```"], "prompt_tokens": [103], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_723_count_same_pair"}
{"name": "mbpp_724_power_base_sum", "language": "Python3", "prompt": "def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n\tWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power_base_sum", "test": "def check(candidate):\n    assert candidate(2, 100) == 115\n    assert candidate(8, 10) == 37\n    assert candidate(8, 15) == 62\n    assert candidate(3, 3) == 9\n\ndef test_check():\n    check(power_base_sum)\n\ntest_check()\n", "sample_io": ["assert power_base_sum(2, 100) == 115"], "source_codes": ["\ndef power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base (int): The base number\n        power (int): The power to raise the base to\n    \n    Returns:\n        int: Sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to easily access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n\n\n"], "responses": ["```python\ndef power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base (int): The base number\n        power (int): The power to raise the base to\n    \n    Returns:\n        int: Sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to easily access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n```"], "prompt_tokens": [93], "completion_tokens": [143], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_724_power_base_sum"}
{"name": "mbpp_725_extract_quotation", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks \" \" of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_quotation", "test": "def check(candidate):\n    assert candidate('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    assert candidate('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']\n    assert candidate('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']\n    assert candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == []\n\ndef test_check():\n    check(extract_quotation)\n\ntest_check()\n", "sample_io": ["assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"], "source_codes": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regex to find all substrings between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text1)\n    \n    # Convert matches to list of strings (or keep as is if you want string type)\n    result = [match for match in matches]\n    \n    return result\n\n\n"], "responses": ["```python\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regex to find all substrings between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text1)\n    \n    # Convert matches to list of strings (or keep as is if you want string type)\n    result = [match for match in matches]\n    \n    return result\n```"], "prompt_tokens": [89], "completion_tokens": [112], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_725_extract_quotation"}
{"name": "mbpp_726_multiply_elements", "language": "Python3", "prompt": "from typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, 8, 10]) == [5, 35, 56, 80]\n    assert candidate([2, 4, 5, 6, 7]) == [8, 20, 30, 42]\n    assert candidate([12, 13, 14, 9, 15]) == [156, 182, 126, 135]\n    assert candidate([12]) == []\n\ndef test_check():\n    check(multiply_elements)\n\ntest_check()\n", "sample_io": ["assert multiply_elements([1, 5, 7, 8, 10]) == [5, 35, 56, 80]"], "source_codes": ["\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N \n    where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return result\n\n\n"], "responses": ["```python\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N \n    where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return result\n```"], "prompt_tokens": [124], "completion_tokens": [111], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_726_multiply_elements"}
{"name": "mbpp_728_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_list", "test": "def check(candidate):\n    assert candidate([10, 20, 30], [15, 25, 35]) == [25, 45, 65]\n    assert candidate([1, 2, 3], [5, 6, 7]) == [6, 8, 10]\n    assert candidate([15, 20, 30], [15, 45, 75]) == [30, 65, 105]\n\ndef test_check():\n    check(sum_list)\n\ntest_check()\n", "sample_io": ["assert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"], "source_codes": ["\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n\n\n"], "responses": ["```python\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n```"], "prompt_tokens": [119], "completion_tokens": [85], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_728_sum_list"}
{"name": "mbpp_730_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function to remove consecutive duplicates of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd', 'a', 'a']) == ['a', 'b', 'c', 'd', 'a']\n\ndef test_check():\n    check(consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"], "source_codes": ["\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n        \n    Examples:\n        >>> consecutive_duplicates([0, 0, 1, 2, 2, 2, 3])\n        [0, 1, 2, 3]\n        >>> consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        ['a', 'b', 'c']\n        >>> consecutive_duplicates([])\n        []\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            result.append(nums[i])\n    \n    return result\n\n\n"], "responses": ["```python\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n        \n    Examples:\n        >>> consecutive_duplicates([0, 0, 1, 2, 2, 2, 3])\n        [0, 1, 2, 3]\n        >>> consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        ['a', 'b', 'c']\n        >>> consecutive_duplicates([])\n        []\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            result.append(nums[i])\n    \n    return result\n```"], "prompt_tokens": [84], "completion_tokens": [182], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_730_consecutive_duplicates"}
{"name": "mbpp_731_lateralsurface_cone", "language": "Python3", "prompt": "def lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cone given radius r and the height h.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cone", "test": "def check(candidate):\n    assert candidate(5, 12) == 204.20352248333654\n    assert candidate(10, 15) == 566.3586699569488\n    assert candidate(19, 17) == 1521.8090132193388\n\ndef test_check():\n    check(lateralsurface_cone)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cone(5, 12) == 204.20352248333654"], "source_codes": ["\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    Formula: \u03c0 * r * l, where l is the slant height = \u221a(r\u00b2 + h\u00b2)\n    \"\"\"\n    # Calculate the slant height\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate and return the lateral surface area\n    return math.pi * r * l\n\n\n"], "responses": ["```python\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    Formula: \u03c0 * r * l, where l is the slant height = \u221a(r\u00b2 + h\u00b2)\n    \"\"\"\n    # Calculate the slant height\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate and return the lateral surface area\n    return math.pi * r * l\n```"], "prompt_tokens": [90], "completion_tokens": [113], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_731_lateralsurface_cone"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n\n"], "responses": ["```python\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n```"], "prompt_tokens": [82], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "responses": ["```python\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # sum_of_products_ending_here represents the sum of products of all subarrays ending at current position\n    sum_of_products_ending_here = 0\n    total_sum = 0\n    \n    for num in arr:\n        # For each existing subarray ending at previous position, \n        # we can extend it by including current element\n        # Plus we start a new subarray with just current element\n        sum_of_products_ending_here = num * (1 + sum_of_products_ending_here)\n        total_sum += sum_of_products_ending_here\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of products of all possible subarrays (contiguous subsequences) of a given list.\n\nLet me think about an efficient approach:\n\nFor each element in the array, I need to consider how many subarrays it contributes to and what its contribution is to the product of those subarrays.\n\nA better approach is to use the mathematical property:\n- For each element arr[i], it appears in (i+1) * (n-i) subarrays\n- But since we're dealing with products of subarrays, I need to be more careful\n\nLet me use a dynamic programming approach:\n- For each position, keep track of the sum of products of all subarrays ending at that position\n- The recurrence relation would be: if we have all subarray products ending at position i-1, then for position i, we can either extend all those subarrays by multiplying with arr[i], or start a new subarray with just arr[i]\n\nActually, let me think of it this way:\n- dp[i] = sum of products of all subarrays ending at index i\n- dp[i] = arr[i] * (1 + sum of products of all subarrays ending at index i-1) + arr[i]\n- Wait, that's not right.\n\nLet me reconsider:\n- For subarrays ending at index i, they are:\n  - [i,i], [i-1,i], [i-2,i], ..., [0,i]\n- The product of subarray [j,i] = product of subarray [j,i-1] * arr[i]\n- So sum of products of subarrays ending at i = arr[i] * (1 + sum of products of subarrays ending at i-1)\n\nLet me trace through an example:\narr = [1,2,3]\n- Subarrays: [1], [2], [3], [1,2], [2,3], [1,2,3]\n- Products: 1, 2, 3, 2, 6, 6\n- Sum: 20\n\nUsing my approach:\n- i=0: dp[0] = 1, total = 1\n- i=1: dp[1] = 2 * (1 + 1) = 4, total = 1 + 4 = 5\n- i=2: dp[2] = 3 * (1 + 4) = 15, total = 5 + 15 = 20 \u2713\n\n```python\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # sum_of_products_ending_here represents the sum of products of all subarrays ending at current position\n    sum_of_products_ending_here = 0\n    total_sum = 0\n    \n    for num in arr:\n        # For each existing subarray ending at previous position, \n        # we can extend it by including current element\n        # Plus we start a new subarray with just current element\n        sum_of_products_ending_here = num * (1 + sum_of_products_ending_here)\n        total_sum += sum_of_products_ending_here\n    \n    return total_sum\n```"], "prompt_tokens": [111], "completion_tokens": [678], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all 1s in the middle positions\n    # We want to toggle bits from position 1 to num_bits-2 (0-indexed from right)\n    # This means we need a mask of (num_bits-2) bits set to 1, shifted left by 1\n    mask = ((1 << (num_bits - 2)) - 1) << 1\n    \n    # XOR with mask to toggle the middle bits\n    return n ^ mask\n\n\n"], "responses": ["Looking at this problem, I need to toggle all bits except the first (most significant) and last (least significant) bits.\n\nLet me think through the approach:\n1. First, I need to identify the positions of all bits in the number\n2. Create a mask that has 1s in all positions except the first and last bit\n3. XOR the number with this mask to toggle the middle bits\n\nFor example, if we have a 5-bit number like 10110:\n- First bit (MSB): 1\n- Last bit (LSB): 0  \n- Middle bits: 011\n- After toggling middle bits: 11000\n\nThe approach is to:\n1. Find the number of bits in n\n2. Create a mask with all 1s except first and last positions set to 0\n3. XOR with the mask\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all 1s in the middle positions\n    # We want to toggle bits from position 1 to num_bits-2 (0-indexed from right)\n    # This means we need a mask of (num_bits-2) bits set to 1, shifted left by 1\n    mask = ((1 << (num_bits - 2)) - 1) << 1\n    \n    # XOR with mask to toggle the middle bits\n    return n ^ mask\n```"], "prompt_tokens": [102], "completion_tokens": [370], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_736_left_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(left_insertion)\n\ntest_check()\n", "sample_io": ["assert left_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to find the insertion point for\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "responses": ["```python\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to find the insertion point for\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n```"], "prompt_tokens": [118], "completion_tokens": [138], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_736_left_insertion"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Define pattern to match strings starting with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, string))\n\n\n"], "responses": ["```python\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Define pattern to match strings starting with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, string))\n```"], "prompt_tokens": [82], "completion_tokens": [89], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_738_geometric_sum", "language": "Python3", "prompt": "def geometric_sum(n: int) -> float:\n    \"\"\"\n\tWrite a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "geometric_sum", "test": "def check(candidate):\n    assert candidate(7) == 1.9921875\n    assert candidate(4) == 1.9375\n    assert candidate(8) == 1.99609375\n\ndef test_check():\n    check(geometric_sum)\n\ntest_check()\n", "sample_io": ["assert geometric_sum(7) == 1.9921875"], "source_codes": ["\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n\n\n"], "responses": ["Looking at this problem, I need to calculate the geometric sum of n-1. Based on the context and typical geometric series problems, this likely refers to the sum of a geometric series where each term is half of the previous one, starting with 1.\n\nThe geometric sum formula for the series 1 + 1/2 + 1/4 + 1/8 + ... up to n terms is:\nSum = 2 - 1/(2^(n-1))\n\nBut since we want the geometric sum of (n-1), I'll calculate the sum up to (n-1) terms.\n\nLet me implement this recursively as suggested by the exercise reference:\n\n```python\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n```\n\nWait, let me reconsider the problem. Looking at the typical interpretation of \"geometric sum of n-1\", it usually means the sum of the geometric series with n-1 terms. The standard geometric series with ratio 1/2 is: 1 + 1/2 + 1/4 + 1/8 + ...\n\nSo for n=1, we want sum of 0 terms = 0\nFor n=2, we want sum of 1 term = 1  \nFor n=3, we want sum of 2 terms = 1 + 1/2 = 1.5\nAnd so on.\n\n```python\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n```"], "prompt_tokens": [101], "completion_tokens": [457], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_738_geometric_sum"}
{"name": "mbpp_739_find_Index", "language": "Python3", "prompt": "def find_Index(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Index", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 14\n    assert candidate(4) == 45\n\ndef test_check():\n    check(find_Index)\n\ntest_check()\n", "sample_io": ["assert find_Index(2) == 4"], "source_codes": ["\ndef find_Index(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    # Start from the approximate value and search\n    import math\n    \n    # Approximate starting point from solving k(k+1)/2 >= 10^(n-1)\n    start_k = int((-1 + math.sqrt(1 + 8 * (10 ** (n - 1)))) / 2)\n    \n    k = max(1, start_k)\n    \n    # Search for the first k where T(k) has n digits but T(k-1) has fewer than n digits\n    while True:\n        triangular_num = k * (k + 1) // 2\n        num_digits = len(str(triangular_num))\n        \n        if num_digits == n:\n            # Check if this is indeed the first triangular number with n digits\n            if k == 1:\n                return 1\n            prev_triangular = (k - 1) * k // 2\n            prev_digits = len(str(prev_triangular))\n            if prev_digits < n:\n                return k\n            else:\n                k -= 1\n        elif num_digits < n:\n            k += 1\n        else:  # num_digits > n\n            k -= 1\n            if k < 1:\n                k = 1\n\n\n"], "responses": ["Looking at this problem, I need to find the smallest triangular number that has exactly n digits.\n\nA triangular number is defined as T(k) = k(k+1)/2.\n\nTo have n digits, a number must satisfy: 10^(n-1) \u2264 number < 10^n\n\nSo I need to find the smallest k such that T(k) = k(k+1)/2 \u2265 10^(n-1).\n\nLet me solve this step by step:\n\n1. For a triangular number to have n digits, it must be at least 10^(n-1)\n2. So I need k(k+1)/2 \u2265 10^(n-1)\n3. This gives us k\u00b2 + k \u2265 2 \u00d7 10^(n-1)\n4. Solving: k\u00b2 + k - 2\u00d710^(n-1) \u2265 0\n5. Using quadratic formula: k \u2265 (-1 + \u221a(1 + 8\u00d710^(n-1)))/2\n\nI'll use this as my starting point and then verify by checking the actual number of digits.\n\n```python\ndef find_Index(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    # Calculate the lower bound using the quadratic approximation\n    # k >= (-1 + sqrt(1 + 8 * 10^(n-1))) / 2\n    import math\n    \n    lower_bound = (-1 + math.sqrt(1 + 8 * (10 ** (n - 1)))) / 2\n    k = int(lower_bound)\n    \n    # Check if we need to go higher\n    while True:\n        triangular_num = k * (k + 1) // 2\n        num_digits = len(str(triangular_num))\n        \n        if num_digits == n:\n            # Make sure this is the first one with n digits\n            if k > 1:\n                prev_triangular = (k - 1) * k // 2\n                prev_digits = len(str(prev_triangular))\n                if prev_digits < n:\n                    return k\n            else:\n                return k\n        \n        if num_digits < n:\n            k += 1\n        else:\n            # num_digits > n, check previous values\n            k -= 1\n            if k < 1:\n                k = 1\n                continue\n```\n\nWait, let me reconsider this approach. Let me make it cleaner:\n\n```python\ndef find_Index(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    # Start from the approximate value and search\n    import math\n    \n    # Approximate starting point from solving k(k+1)/2 >= 10^(n-1)\n    start_k = int((-1 + math.sqrt(1 + 8 * (10 ** (n - 1)))) / 2)\n    \n    k = max(1, start_k)\n    \n    # Search for the first k where T(k) has n digits but T(k-1) has fewer than n digits\n    while True:\n        triangular_num = k * (k + 1) // 2\n        num_digits = len(str(triangular_num))\n        \n        if num_digits == n:\n            # Check if this is indeed the first triangular number with n digits\n            if k == 1:\n                return 1\n            prev_triangular = (k - 1) * k // 2\n            prev_digits = len(str(prev_triangular))\n            if prev_digits < n:\n                return k\n            else:\n                k -= 1\n        elif num_digits < n:\n            k += 1\n        else:  # num_digits > n\n            k -= 1\n            if k < 1:\n                k = 1\n```"], "prompt_tokens": [100], "completion_tokens": [805], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_739_find_Index"}
{"name": "mbpp_740_tuple_to_dict", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_dict", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }\n    assert candidate((1, 2, 3, 4, 5, 6)) == { 1: 2, 3: 4, 5: 6 }\n    assert candidate((7, 8, 9, 10, 11, 12)) == { 7: 8, 9: 10, 11: 12 }\n\ndef test_check():\n    check(tuple_to_dict)\n\ntest_check()\n", "sample_io": ["assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }"], "source_codes": ["\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result\n\n\n"], "responses": ["```python\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result\n```"], "prompt_tokens": [126], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_740_tuple_to_dict"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    if len(s) == 0:\n        return True\n    \n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    if len(s) == 0:\n        return True\n    \n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True\n```"], "prompt_tokens": [81], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_742_area_tetrahedron", "language": "Python3", "prompt": "def area_tetrahedron(side: int) -> float:\n    \"\"\"\n\tWrite a function to caluclate the area of a tetrahedron.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "area_tetrahedron", "test": "def check(candidate):\n    assert candidate(3) == 15.588457268119894\n    assert candidate(20) == 692.8203230275509\n    assert candidate(10) == 173.20508075688772\n\ndef test_check():\n    check(area_tetrahedron)\n\ntest_check()\n", "sample_io": ["assert area_tetrahedron(3) == 15.588457268119894"], "source_codes": ["\ndef area_tetrahedron(side: int) -> float:\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    The area of one equilateral triangle with side length 's' is (sqrt(3)/4) * s^2.\n    So the total surface area is 4 * (sqrt(3)/4) * s^2 = sqrt(3) * s^2.\n    \n    Args:\n        side: The length of a side of the tetrahedron\n        \n    Returns:\n        The surface area of the tetrahedron\n    \"\"\"\n    import math\n    return math.sqrt(3) * side ** 2\n\n\n"], "responses": ["```python\ndef area_tetrahedron(side: int) -> float:\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    The area of one equilateral triangle with side length 's' is (sqrt(3)/4) * s^2.\n    So the total surface area is 4 * (sqrt(3)/4) * s^2 = sqrt(3) * s^2.\n    \n    Args:\n        side: The length of a side of the tetrahedron\n        \n    Returns:\n        The surface area of the tetrahedron\n    \"\"\"\n    import math\n    return math.sqrt(3) * side ** 2\n```"], "prompt_tokens": [84], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_742_area_tetrahedron"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n\n\n"], "responses": ["```python\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n```"], "prompt_tokens": [108], "completion_tokens": [118], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_744_check_none", "language": "Python3", "prompt": "from typing import Any\n\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuple has any none value or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_none", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6, None)) == True\n    assert candidate((7, 8, 9, 11, 14)) == False\n    assert candidate((1, 2, 3, 4, None)) == True\n\ndef test_check():\n    check(check_none)\n\ntest_check()\n", "sample_io": ["assert check_none((10, 4, 5, 6, None)) == True"], "source_codes": ["\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check if any element in the tuple is None\n    for element in test_tup:\n        if element is None:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check if any element in the tuple is None\n    for element in test_tup:\n        if element is None:\n            return True\n    \n    return False\n```"], "prompt_tokens": [86], "completion_tokens": [95], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_744_check_none"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": ["\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Find numbers within a given range where every number is divisible by every digit it contains.\n    \"\"\"\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        # Convert number to string to access individual digits\n        num_str = str(num)\n        \n        # Check if any digit is 0 (division by zero not allowed)\n        if '0' in num_str:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n        \n        if valid:\n            result.append(num)\n    \n    return result\n\n\n"], "responses": ["```python\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Find numbers within a given range where every number is divisible by every digit it contains.\n    \"\"\"\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        # Convert number to string to access individual digits\n        num_str = str(num)\n        \n        # Check if any digit is 0 (division by zero not allowed)\n        if '0' in num_str:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n        \n        if valid:\n            result.append(num)\n    \n    return result\n```"], "prompt_tokens": [125], "completion_tokens": [176], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_746_sector_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sector_area", "test": "def check(candidate):\n    assert candidate(4, 45) == 6.283185307179586\n    assert candidate(9, 45) == 31.808625617596654\n    assert candidate(9, 361) == None\n\ndef test_check():\n    check(sector_area)\n\ntest_check()\n", "sample_io": ["assert sector_area(4, 45) == 6.283185307179586"], "source_codes": ["\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n    Find area of a sector given radius and angle in degrees.\n    Returns None if angle is larger than 360 degrees.\n    \"\"\"\n    if a > 360:\n        return None\n    \n    # Formula: Area = (\u03b8/360) * \u03c0 * r\u00b2\n    # where \u03b8 is in degrees\n    area = (a / 360) * 3.141592653589793 * (r ** 2)\n    return area\n\n\n"], "responses": ["```python\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n    Find area of a sector given radius and angle in degrees.\n    Returns None if angle is larger than 360 degrees.\n    \"\"\"\n    if a > 360:\n        return None\n    \n    # Formula: Area = (\u03b8/360) * \u03c0 * r\u00b2\n    # where \u03b8 is in degrees\n    area = (a / 360) * 3.141592653589793 * (r ** 2)\n    return area\n```"], "prompt_tokens": [109], "completion_tokens": [133], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_746_sector_area"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],\n                        dp[i][j-1][k],\n                        dp[i][j][k-1]\n                    )\n    \n    return dp[m][n][o]\n\n\n"], "responses": ["```python\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],\n                        dp[i][j-1][k],\n                        dp[i][j][k-1]\n                    )\n    \n    return dp[m][n][o]\n```"], "prompt_tokens": [109], "completion_tokens": [276], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    result = \"\"\n    for i, char in enumerate(str1):\n        if char.isupper() and i > 0:\n            result += \" \"\n        result += char\n    return result\n\n\n"], "responses": ["```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    result = \"\"\n    for i, char in enumerate(str1):\n        if char.isupper() and i > 0:\n            result += \" \"\n        result += char\n    return result\n```"], "prompt_tokens": [82], "completion_tokens": [75], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_749_sort_numeric_strings", "language": "Python3", "prompt": "from typing import List\n\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_numeric_strings", "test": "def check(candidate):\n    assert candidate(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    assert candidate(['2', '3', '8', '4', '7', '9', '8', '2', '6', '5', '1', '6', '1', '2', '3', '4', '6', '9', '1', '2']) == [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]\n    assert candidate(['1', '3', '5', '7', '1', '3', '13', '15', '17', '5', '7 ', '9', '1', '11']) == [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]\n\ndef test_check():\n    check(sort_numeric_strings)\n\ntest_check()\n", "sample_io": ["assert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"], "source_codes": ["\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: List of strings representing numbers\n        \n    Returns:\n        List of integers sorted numerically\n    \"\"\"\n    # Convert strings to integers and sort\n    return sorted([int(num) for num in nums_str])\n\n\n"], "responses": ["```python\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: List of strings representing numbers\n        \n    Returns:\n        List of integers sorted numerically\n    \"\"\"\n    # Convert strings to integers and sort\n    return sorted([int(num) for num in nums_str])\n```"], "prompt_tokens": [105], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_749_sort_numeric_strings"}
{"name": "mbpp_750_add_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n\tWrite a function to add the given tuple to the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_tuple", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    assert candidate([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]\n    assert candidate([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]\n\ndef test_check():\n    check(add_tuple)\n\ntest_check()\n", "sample_io": ["assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"], "source_codes": ["\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list with it\n    result = test_list.copy()  # Create a copy to avoid modifying the original list\n    result.extend(list(test_tup))\n    return result\n\n\n"], "responses": ["```python\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list with it\n    result = test_list.copy()  # Create a copy to avoid modifying the original list\n    result.extend(list(test_tup))\n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [92], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_750_add_tuple"}
{"name": "mbpp_751_check_min_heap", "language": "Python3", "prompt": "from typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_min_heap", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 10, 15]) == True\n    assert candidate([2, 10, 4, 5, 3, 15]) == False\n\ndef test_check():\n    check(check_min_heap)\n\ntest_check()\n", "sample_io": ["assert check_min_heap([1, 2, 3, 4, 5, 6]) == True"], "source_codes": ["\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap or not.\n    \n    In a min heap, for every parent node at index i:\n    - Left child is at index 2*i + 1\n    - Right child is at index 2*i + 2\n    - Parent value should be less than or equal to both children\n    \n    We only need to check up to the last parent node, which is at index (n//2 - 1)\n    \"\"\"\n    n = len(arr)\n    \n    # Check each parent node\n    for i in range(n // 2):\n        # Check left child\n        left_child_index = 2 * i + 1\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check right child\n        right_child_index = 2 * i + 2\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap or not.\n    \n    In a min heap, for every parent node at index i:\n    - Left child is at index 2*i + 1\n    - Right child is at index 2*i + 2\n    - Parent value should be less than or equal to both children\n    \n    We only need to check up to the last parent node, which is at index (n//2 - 1)\n    \"\"\"\n    n = len(arr)\n    \n    # Check each parent node\n    for i in range(n // 2):\n        # Check left child\n        left_child_index = 2 * i + 1\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check right child\n        right_child_index = 2 * i + 2\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [109], "completion_tokens": [223], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_751_check_min_heap"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Find the nth jacobsthal number.\n    Jacobsthal numbers follow the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    with initial conditions J(0) = 0, J(1) = 1\n    \n    Examples:\n    J(0) = 0\n    J(1) = 1\n    J(2) = 1\n    J(3) = 3\n    J(4) = 5\n    J(5) = 11\n    etc.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to avoid recursion overhead\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["```python\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Find the nth jacobsthal number.\n    Jacobsthal numbers follow the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    with initial conditions J(0) = 0, J(1) = 1\n    \n    Examples:\n    J(0) = 0\n    J(1) = 1\n    J(2) = 1\n    J(3) = 3\n    J(4) = 5\n    J(5) = 11\n    etc.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to avoid recursion overhead\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n```"], "prompt_tokens": [160], "completion_tokens": [249], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the second element (integer) in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) in each tuple\n    # and return the first K elements\n    return sorted(test_list, key=lambda x: x[1])[:K]\n\n\n"], "responses": ["```python\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the second element (integer) in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) in each tuple\n    # and return the first K elements\n    return sorted(test_list, key=lambda x: x[1])[:K]\n```"], "prompt_tokens": [129], "completion_tokens": [141], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_754_extract_index_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n\tWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_index_list", "test": "def check(candidate):\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 6, 5], [0, 1, 2, 3, 4, 6, 7]) == [1, 6]\n    assert candidate([1, 1, 3, 4, 6, 5, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 5]\n    assert candidate([1, 2, 3, 4, 6, 6, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == []\n\ndef test_check():\n    check(extract_index_list)\n\ntest_check()\n", "sample_io": ["assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"], "source_codes": ["\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    \n    # Get the minimum length among all three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through indices up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at index i are equal\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result\n\n\n"], "responses": ["```python\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    \n    # Get the minimum length among all three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through indices up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at index i are equal\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result\n```"], "prompt_tokens": [134], "completion_tokens": [179], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_754_extract_index_list"}
{"name": "mbpp_755_second_smallest", "language": "Python3", "prompt": "from typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find the second smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "second_smallest", "test": "def check(candidate):\n    assert candidate([1, 2, -8, -2, 0, -2]) == -2\n    assert candidate([1, 1, -0.5, 0, 2, -2, -2]) == -0.5\n    assert candidate([2, 2]) == None\n    assert candidate([2, 2, 2]) == None\n\ndef test_check():\n    check(second_smallest)\n\ntest_check()\n", "sample_io": ["assert second_smallest([1, 2, -8, -2, 0, -2]) == -2"], "source_codes": ["\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n    Find the second smallest number in a list.\n    \n    Args:\n        numbers: A list of integers or floats\n        \n    Returns:\n        The second smallest number, or None if there are fewer than 2 distinct numbers\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 distinct numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest (index 1)\n    return float(unique_numbers[1])\n\n\n"], "responses": ["```python\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n    Find the second smallest number in a list.\n    \n    Args:\n        numbers: A list of integers or floats\n        \n    Returns:\n        The second smallest number, or None if there are fewer than 2 distinct numbers\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 distinct numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest (index 1)\n    return float(unique_numbers[1])\n```"], "prompt_tokens": [92], "completion_tokens": [146], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_755_second_smallest"}
{"name": "mbpp_756_text_match_zero_one", "language": "Python3", "prompt": "def text_match_zero_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_zero_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('dsabbbba') == True\n    assert candidate('asbbbba') == False\n    assert candidate('abaaa') == True\n\ndef test_check():\n    check(text_match_zero_one)\n\ntest_check()\n", "sample_io": ["assert text_match_zero_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [106], "completion_tokens": [63], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_756_text_match_zero_one"}
{"name": "mbpp_757_count_reverse_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n\tWrite a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_reverse_pairs", "test": "def check(candidate):\n    assert candidate(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2\n    assert candidate(['geeks', 'best', 'for', 'skeeg']) == 1\n    assert candidate(['makes', 'best', 'sekam', 'for', 'rof']) == 2\n\ndef test_check():\n    check(count_reverse_pairs)\n\ntest_check()\n", "sample_io": ["assert count_reverse_pairs(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2"], "source_codes": ["\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for string in test_list:\n        reversed_string = string[::-1]\n        if reversed_string in seen:\n            count += 1\n        seen.add(string)\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for string in test_list:\n        reversed_string = string[::-1]\n        if reversed_string in seen:\n            count += 1\n        seen.add(string)\n    \n    return count\n```"], "prompt_tokens": [108], "completion_tokens": [85], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_757_count_reverse_pairs"}
{"name": "mbpp_759_is_decimal", "language": "Python3", "prompt": "def is_decimal(num: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether a given string is a decimal number with a precision of 2.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_decimal", "test": "def check(candidate):\n    assert candidate('123.11') == True\n    assert candidate('e666.86') == False\n    assert candidate('3.124587') == False\n    assert candidate('1.11') == True\n    assert candidate('1.1.11') == False\n\ndef test_check():\n    check(is_decimal)\n\ntest_check()\n", "sample_io": ["assert is_decimal('123.11') == True"], "source_codes": ["\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    num = num.strip()\n    \n    # Check if empty string\n    if not num:\n        return False\n    \n    # Check for valid decimal format with exactly 2 decimal places\n    parts = num.split('.')\n    \n    # Must have exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    # Check if both parts are non-empty\n    if not integer_part and not decimal_part:\n        return False\n    \n    # Integer part can be empty (for numbers like .25) or contain digits only\n    # If not empty, it should contain only digits (and optional sign at start)\n    if integer_part:\n        # Check for sign\n        if integer_part[0] in '+-':\n            if len(integer_part) == 1:\n                return False  # Just a sign\n            int_part_to_check = integer_part[1:]\n        else:\n            int_part_to_check = integer_part\n        \n        if not int_part_to_check.isdigit():\n            return False\n    \n    # Decimal part must exist and have exactly 2 digits\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    \n    # If we reach here, it's a valid decimal with 2 precision\n    return True\n\n\n"], "responses": ["```python\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    num = num.strip()\n    \n    # Check if empty string\n    if not num:\n        return False\n    \n    # Check for valid decimal format with exactly 2 decimal places\n    parts = num.split('.')\n    \n    # Must have exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    # Check if both parts are non-empty\n    if not integer_part and not decimal_part:\n        return False\n    \n    # Integer part can be empty (for numbers like .25) or contain digits only\n    # If not empty, it should contain only digits (and optional sign at start)\n    if integer_part:\n        # Check for sign\n        if integer_part[0] in '+-':\n            if len(integer_part) == 1:\n                return False  # Just a sign\n            int_part_to_check = integer_part[1:]\n        else:\n            int_part_to_check = integer_part\n        \n        if not int_part_to_check.isdigit():\n            return False\n    \n    # Decimal part must exist and have exactly 2 digits\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    \n    # If we reach here, it's a valid decimal with 2 precision\n    return True\n```"], "prompt_tokens": [83], "completion_tokens": [311], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_759_is_decimal"}
{"name": "mbpp_760_unique_Element", "language": "Python3", "prompt": "from typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list of numbers contains only one distinct element or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_Element", "test": "def check(candidate):\n    assert candidate([1, 1, 1]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == False\n\ndef test_check():\n    check(unique_Element)\n\ntest_check()\n", "sample_io": ["assert unique_Element([1, 1, 1]) == True"], "source_codes": ["\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if all elements are the same, False otherwise\n    \"\"\"\n    if not arr:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if all elements are the same, False otherwise\n    \"\"\"\n    if not arr:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n```"], "prompt_tokens": [88], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_760_unique_Element"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    # Check if the month number is valid (1-12) and has 30 days\n    if 1 <= monthnum3 <= 12:\n        return monthnum3 in months_with_30_days\n    else:\n        return False\n\n\n"], "responses": ["```python\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    # Check if the month number is valid (1-12) and has 30 days\n    if 1 <= monthnum3 <= 12:\n        return monthnum3 in months_with_30_days\n    else:\n        return False\n```"], "prompt_tokens": [98], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": ["\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Minimum difference between any two elements\n    \"\"\"\n    # Sort the array to make adjacent elements closest to each other\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Check difference between consecutive elements\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "responses": ["```python\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Minimum difference between any two elements\n    \"\"\"\n    # Sort the array to make adjacent elements closest to each other\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Check difference between consecutive elements\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n```"], "prompt_tokens": [108], "completion_tokens": [156], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_764_number_ctr", "language": "Python3", "prompt": "def number_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count number of digits in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_ctr", "test": "def check(candidate):\n    assert candidate('program2bedone') == 1\n    assert candidate('3wonders') == 1\n    assert candidate('123') == 3\n    assert candidate('3wond-1ers2') == 3\n\ndef test_check():\n    check(number_ctr)\n\ntest_check()\n", "sample_io": ["assert number_ctr('program2bedone') == 1"], "source_codes": ["\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \n    Args:\n        str: Input string to check for digits\n        \n    Returns:\n        int: Number of digits found in the string\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \n    Args:\n        str: Input string to check for digits\n        \n    Returns:\n        int: Number of digits found in the string\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n```"], "prompt_tokens": [77], "completion_tokens": [84], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_764_number_ctr"}
{"name": "mbpp_765_is_polite", "language": "Python3", "prompt": "def is_polite(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_polite", "test": "def check(candidate):\n    assert candidate(7) == 11\n    assert candidate(4) == 7\n    assert candidate(9) == 13\n\ndef test_check():\n    check(is_polite)\n\ntest_check()\n", "sample_io": ["assert is_polite(7) == 11"], "source_codes": ["\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as the sum of \n    two or more consecutive positive integers.\n    \"\"\"\n    count = 0\n    num = 1\n    \n    while count < n:\n        # Check if num is a power of 2\n        # A number is a power of 2 if (num & (num - 1)) == 0\n        if (num & (num - 1)) != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num\n\n\n"], "responses": ["Looking at this problem, I need to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers.\n\nFrom mathematical analysis, the polite numbers are all positive integers except for powers of 2. This is because powers of 2 cannot be expressed as sums of consecutive positive integers.\n\nSo to find the nth polite number, I need to skip all powers of 2 and count the remaining numbers.\n\n```python\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as the sum of \n    two or more consecutive positive integers.\n    \"\"\"\n    count = 0\n    num = 1\n    \n    while count < n:\n        # Check if num is a power of 2\n        # A number is a power of 2 if (num & (num - 1)) == 0\n        if (num & (num - 1)) != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num\n```"], "prompt_tokens": [84], "completion_tokens": [241], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_765_is_polite"}
{"name": "mbpp_766_pair_wise", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to return a list of all pairs of consecutive items in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_wise", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    assert candidate([1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)]\n    assert candidate([5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n\ndef test_check():\n    check(pair_wise)\n\ntest_check()\n", "sample_io": ["assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"], "source_codes": ["\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n\n\n"], "responses": ["```python\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n```"], "prompt_tokens": [96], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_766_pair_wise"}
{"name": "mbpp_767_get_pairs_count", "language": "Python3", "prompt": "from typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_pairs_count", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1], 2) == 6\n    assert candidate([1, 5, 7, -1, 5], 6) == 3\n    assert candidate([1, -2, 3], 1) == 1\n    assert candidate([-1, -2, 3], -3) == 1\n\ndef test_check():\n    check(get_pairs_count)\n\ntest_check()\n", "sample_io": ["assert get_pairs_count([1, 1, 1, 1], 2) == 6"], "source_codes": ["\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum value\n    \n    Returns:\n        Number of pairs that sum to the target value\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # For each element, check if (sum - element) exists\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in array\n        if complement in freq:\n            # If both elements are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2\n\n\n"], "responses": ["```python\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum value\n    \n    Returns:\n        Number of pairs that sum to the target value\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # For each element, check if (sum - element) exists\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in array\n        if complement in freq:\n            # If both elements are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2\n```"], "prompt_tokens": [106], "completion_tokens": [239], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_767_get_pairs_count"}
{"name": "mbpp_769_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the difference between two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Diff", "test": "def check(candidate):\n    assert candidate([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 1]) == [2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3], [6, 7, 1]) == [2, 3, 6, 7]\n\ndef test_check():\n    check(Diff)\n\ntest_check()\n", "sample_io": ["assert Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"], "source_codes": ["\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    return [item for item in li1 if item not in li2]\n\n\n"], "responses": ["```python\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    return [item for item in li1 if item not in li2]\n```"], "prompt_tokens": [88], "completion_tokens": [56], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_769_Diff"}
{"name": "mbpp_770_odd_num_sum", "language": "Python3", "prompt": "def odd_num_sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of fourth power of first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_num_sum", "test": "def check(candidate):\n    assert candidate(2) == 82\n    assert candidate(3) == 707\n    assert candidate(4) == 3108\n\ndef test_check():\n    check(odd_num_sum)\n\ntest_check()\n", "sample_io": ["assert odd_num_sum(2) == 82"], "source_codes": ["\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total\n\n\n"], "responses": ["```python\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total\n```"], "prompt_tokens": [82], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_770_odd_num_sum"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    \"\"\"\n    stack = []\n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or brackets don't match, it's unbalanced\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n\n\n"], "responses": ["```python\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    \"\"\"\n    stack = []\n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or brackets don't match, it's unbalanced\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n```"], "prompt_tokens": [96], "completion_tokens": [181], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n\n\n"], "responses": ["```python\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n```"], "prompt_tokens": [84], "completion_tokens": [103], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_773_occurance_substring", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "occurance_substring", "test": "def check(candidate):\n    assert candidate('python programming, python language', 'python') == ('python', 0, 6)\n    assert candidate('python programming,programming language', 'programming') == ('programming', 7, 18)\n    assert candidate('python programming,programming language', 'language') == ('language', 31, 39)\n    assert candidate('c++ programming, c++ language', 'python') == None\n\ndef test_check():\n    check(occurance_substring)\n\ntest_check()\n", "sample_io": ["assert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"], "source_codes": ["\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Returns a tuple containing (pattern, start_index, end_index) if found,\n    or None if there is no match.\n    \"\"\"\n    # Find the first occurrence of the pattern\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate the end index\n    end_index = start_index + len(pattern)\n    \n    # Return the result as a tuple\n    return (pattern, start_index, end_index)\n\n\n"], "responses": ["```python\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Returns a tuple containing (pattern, start_index, end_index) if found,\n    or None if there is no match.\n    \"\"\"\n    # Find the first occurrence of the pattern\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate the end index\n    end_index = start_index + len(pattern)\n    \n    # Return the result as a tuple\n    return (pattern, start_index, end_index)\n```"], "prompt_tokens": [108], "completion_tokens": [152], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_773_occurance_substring"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": ["\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n```"], "prompt_tokens": [87], "completion_tokens": [68], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_776_count_vowels", "language": "Python3", "prompt": "def count_vowels(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to count those characters which have vowels as their neighbors in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_vowels", "test": "def check(candidate):\n    assert candidate('bestinstareels') == 7\n    assert candidate('partofthejourneyistheend') == 12\n    assert candidate('amazonprime') == 5\n\ndef test_check():\n    check(count_vowels)\n\ntest_check()\n", "sample_io": ["assert count_vowels('bestinstareels') == 7"], "source_codes": ["\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) < 3:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Check each character (except first and last) to see if it has vowel neighbors\n    for i in range(1, len(test_str) - 1):\n        if test_str[i-1] in vowels and test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) < 3:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Check each character (except first and last) to see if it has vowel neighbors\n    for i in range(1, len(test_str) - 1):\n        if test_str[i-1] in vowels and test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [84], "completion_tokens": [137], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_776_count_vowels"}
{"name": "mbpp_777_find_sum", "language": "Python3", "prompt": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of non-repeated elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    assert candidate([1, 10, 9, 4, 2, 10, 10, 45, 4]) == 71\n    assert candidate([12, 10, 9, 45, 2, 10, 10, 45, 10]) == 78\n\ndef test_check():\n    check(find_sum)\n\ntest_check()\n", "sample_io": ["assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21"], "source_codes": ["\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Sum elements that appear exactly once\n    total = 0\n    for num, count in freq.items():\n        if count == 1:\n            total += num\n    \n    return total\n\n\n"], "responses": ["```python\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Sum elements that appear exactly once\n    total = 0\n    for num, count in freq.items():\n        if count == 1:\n            total += num\n    \n    return total\n```"], "prompt_tokens": [87], "completion_tokens": [107], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_777_find_sum"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n\n\n"], "responses": ["```python\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [108], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": ["\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    \n    # Generate all possible non-empty combinations\n    for r in range(1, len(test_list) + 1):\n        for combo in combinations(test_list, r):\n            # Calculate element-wise sum of all tuples in this combination\n            sum_tuple = [0, 0]\n            for tuple_item in combo:\n                sum_tuple[0] += tuple_item[0]\n                sum_tuple[1] += tuple_item[1]\n            result.append((sum_tuple[0], sum_tuple[1]))\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find combinations of sums with tuples in the given tuple list. Based on the reference link, this appears to be about finding all possible combinations of tuples and calculating their element-wise sums.\n\nLet me think through this step by step:\n\n1. I need to generate all possible non-empty combinations of tuples from the input list\n2. For each combination, calculate the element-wise sum of all tuples in that combination\n3. Return all these sum tuples\n\n```python\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    \n    # Generate all possible non-empty combinations\n    for r in range(1, len(test_list) + 1):\n        for combo in combinations(test_list, r):\n            # Calculate element-wise sum of all tuples in this combination\n            sum_tuple = [0, 0]\n            for tuple_item in combo:\n                sum_tuple[0] += tuple_item[0]\n                sum_tuple[1] += tuple_item[1]\n            result.append((sum_tuple[0], sum_tuple[1]))\n    \n    return result\n```"], "prompt_tokens": [120], "completion_tokens": [276], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_781_count_divisors", "language": "Python3", "prompt": "def count_divisors(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_divisors", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(100) == False\n    assert candidate(125) == True\n\ndef test_check():\n    check(count_divisors)\n\ntest_check()\n", "sample_io": ["assert count_divisors(10) == True"], "source_codes": ["\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Check whether the count of divisors is even.\n    \"\"\"\n    if n <= 0:\n        return True  # 0 has infinitely many divisors, but for practical purposes, we can consider it even\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case - only count once\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count % 2 == 0\n\n\n"], "responses": ["```python\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Check whether the count of divisors is even.\n    \"\"\"\n    if n <= 0:\n        return True  # 0 has infinitely many divisors, but for practical purposes, we can consider it even\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case - only count once\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count % 2 == 0\n```"], "prompt_tokens": [101], "completion_tokens": [146], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_781_count_divisors"}
{"name": "mbpp_782_odd_length_sum", "language": "Python3", "prompt": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_length_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 4]) == 14\n    assert candidate([1, 2, 1, 2]) == 15\n    assert candidate([1, 7]) == 8\n\ndef test_check():\n    check(odd_length_sum)\n\ntest_check()\n", "sample_io": ["assert odd_length_sum([1, 2, 4]) == 14"], "source_codes": ["\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of all odd length subarrays\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    # For each element, calculate how many odd length subarrays include it\n    for i in range(n):\n        # Count of subarrays that include arr[i]\n        # Left choices: i+1 (from 0 to i)\n        # Right choices: n-i (from i to n-1)\n        # Total subarrays including arr[i]: (i+1) * (n-i)\n        \n        # Count of odd length subarrays including arr[i]\n        # For odd length subarrays, we need to count how many start and end positions\n        # create subarrays of odd length that include arr[i]\n        \n        # Method 2: Direct calculation\n        # Number of ways to choose left boundary: i+1\n        # Number of ways to choose right boundary: n-i\n        # Total subarrays including element at index i: (i+1) * (n-i)\n        \n        # For odd length subarrays:\n        # If we fix the element at position i, we need to count subarrays\n        # where (left_index + right_index) is even (since length = right_index - left_index + 1)\n        # This happens when left_index and right_index have the same parity\n        \n        left_choices = i + 1  # positions 0 to i\n        right_choices = n - i  # positions i to n-1\n        \n        # Number of odd length subarrays that include arr[i]\n        # Left positions with same parity as right positions\n        odd_count = ((left_choices + 1) // 2) * ((right_choices + 1) // 2) + \\\n                   (left_choices // 2) * (right_choices // 2)\n        \n        total_sum += arr[i] * odd_count\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of all odd length subarrays\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    # For each element, calculate how many odd length subarrays include it\n    for i in range(n):\n        # Count of subarrays that include arr[i]\n        # Left choices: i+1 (from 0 to i)\n        # Right choices: n-i (from i to n-1)\n        # Total subarrays including arr[i]: (i+1) * (n-i)\n        \n        # Count of odd length subarrays including arr[i]\n        # For odd length subarrays, we need to count how many start and end positions\n        # create subarrays of odd length that include arr[i]\n        \n        # Method 2: Direct calculation\n        # Number of ways to choose left boundary: i+1\n        # Number of ways to choose right boundary: n-i\n        # Total subarrays including element at index i: (i+1) * (n-i)\n        \n        # For odd length subarrays:\n        # If we fix the element at position i, we need to count subarrays\n        # where (left_index + right_index) is even (since length = right_index - left_index + 1)\n        # This happens when left_index and right_index have the same parity\n        \n        left_choices = i + 1  # positions 0 to i\n        right_choices = n - i  # positions i to n-1\n        \n        # Number of odd length subarrays that include arr[i]\n        # Left positions with same parity as right positions\n        odd_count = ((left_choices + 1) // 2) * ((right_choices + 1) // 2) + \\\n                   (left_choices // 2) * (right_choices // 2)\n        \n        total_sum += arr[i] * odd_count\n    \n    return total_sum\n```"], "prompt_tokens": [103], "completion_tokens": [438], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_782_odd_length_sum"}
{"name": "mbpp_783_rgb_to_hsv", "language": "Python3", "prompt": "from typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    \"\"\"\n\tWrite a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rgb_to_hsv", "test": "def check(candidate):\n    assert candidate(255, 255, 255) == [0.0, 0.0, 100.0]\n    assert candidate(0, 215, 0) == [120.0, 100.0, 84.31372549019608]\n    assert candidate(10, 215, 110) == [149.26829268292684, 95.34883720930233, 84.31372549019608]\n\ndef test_check():\n    check(rgb_to_hsv)\n\ntest_check()\n", "sample_io": ["assert rgb_to_hsv(255, 255, 255) == [0.0, 0.0, 100.0]"], "source_codes": ["\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Normalize RGB values to range [0, 1]\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n    \n    # Find maximum and minimum values\n    c_max = max(r_norm, g_norm, b_norm)\n    c_min = min(r_norm, g_norm, b_norm)\n    delta = c_max - c_min\n    \n    # Calculate Hue\n    if delta == 0:\n        h = 0\n    elif c_max == r_norm:\n        h = 60 * (((g_norm - b_norm) / delta) % 6)\n    elif c_max == g_norm:\n        h = 60 * (((b_norm - r_norm) / delta) + 2)\n    else:  # c_max == b_norm\n        h = 60 * (((r_norm - g_norm) / delta) + 4)\n    \n    # Calculate Saturation\n    if c_max == 0:\n        s = 0\n    else:\n        s = delta / c_max\n    \n    # Calculate Value\n    v = c_max\n    \n    return [h, s * 100, v * 100]\n\n\n"], "responses": ["```python\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Normalize RGB values to range [0, 1]\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n    \n    # Find maximum and minimum values\n    c_max = max(r_norm, g_norm, b_norm)\n    c_min = min(r_norm, g_norm, b_norm)\n    delta = c_max - c_min\n    \n    # Calculate Hue\n    if delta == 0:\n        h = 0\n    elif c_max == r_norm:\n        h = 60 * (((g_norm - b_norm) / delta) % 6)\n    elif c_max == g_norm:\n        h = 60 * (((b_norm - r_norm) / delta) + 2)\n    else:  # c_max == b_norm\n        h = 60 * (((r_norm - g_norm) / delta) + 4)\n    \n    # Calculate Saturation\n    if c_max == 0:\n        s = 0\n    else:\n        s = delta / c_max\n    \n    # Calculate Value\n    v = c_max\n    \n    return [h, s * 100, v * 100]\n```"], "prompt_tokens": [110], "completion_tokens": [292], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_783_rgb_to_hsv"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we couldn't find both even and odd numbers\n    return 0\n\n\n"], "responses": ["```python\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we couldn't find both even and odd numbers\n    return 0\n```"], "prompt_tokens": [89], "completion_tokens": [150], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_785_tuple_str_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function to convert tuple string to integer tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_str_int", "test": "def check(candidate):\n    assert candidate('(7, 8, 9)') == (7, 8, 9)\n    assert candidate('(1, 2, 3)') == (1, 2, 3)\n    assert candidate('(4, 5, 6)') == (4, 5, 6)\n    assert candidate('(7, 81, 19)') == (7, 81, 19)\n\ndef test_check():\n    check(tuple_str_int)\n\ntest_check()\n", "sample_io": ["assert tuple_str_int('(7, 8, 9)') == (7, 8, 9)"], "source_codes": ["\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Convert tuple string to integer tuple.\n    \n    Args:\n        test_str: A string representation of a tuple containing integers\n        \n    Returns:\n        A tuple of three integers\n        \n    Example:\n        >>> tuple_str_int(\"(1, 2, 3)\")\n        (1, 2, 3)\n    \"\"\"\n    # Remove parentheses and whitespace, then split by comma\n    cleaned_str = test_str.strip().strip('()')\n    # Split by comma and convert each element to integer\n    elements = [int(x.strip()) for x in cleaned_str.split(',')]\n    # Return as tuple\n    return tuple(elements)\n\n\n"], "responses": ["```python\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Convert tuple string to integer tuple.\n    \n    Args:\n        test_str: A string representation of a tuple containing integers\n        \n    Returns:\n        A tuple of three integers\n        \n    Example:\n        >>> tuple_str_int(\"(1, 2, 3)\")\n        (1, 2, 3)\n    \"\"\"\n    # Remove parentheses and whitespace, then split by comma\n    cleaned_str = test_str.strip().strip('()')\n    # Split by comma and convert each element to integer\n    elements = [int(x.strip()) for x in cleaned_str.split(',')]\n    # Return as tuple\n    return tuple(elements)\n```"], "prompt_tokens": [86], "completion_tokens": [151], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_785_tuple_str_int"}
{"name": "mbpp_786_right_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the right insertion point for a specified value in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "right_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(right_insertion)\n\ntest_check()\n", "sample_io": ["assert right_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "responses": ["```python\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n```"], "prompt_tokens": [91], "completion_tokens": [97], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_786_right_insertion"}
{"name": "mbpp_787_text_match_three", "language": "Python3", "prompt": "def text_match_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by three 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('caacabbbba') == True\n\ndef test_check():\n    check(text_match_three)\n\ntest_check()\n", "sample_io": ["assert text_match_three('ac') == False"], "source_codes": ["\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    return 'abbb' in text\n\n\n"], "responses": ["```python\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    return 'abbb' in text\n```"], "prompt_tokens": [81], "completion_tokens": [47], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_787_text_match_three"}
{"name": "mbpp_788_new_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n\tWrite a function to create a new tuple from the given string and list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "new_tuple", "test": "def check(candidate):\n    assert candidate(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')\n    assert candidate(['We', 'are'], 'Developers') == ('We', 'are', 'Developers')\n    assert candidate(['Part', 'is'], 'Wrong') == ('Part', 'is', 'Wrong')\n\ndef test_check():\n    check(new_tuple)\n\ntest_check()\n", "sample_io": ["assert new_tuple(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')"], "source_codes": ["\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    # Use the first two elements from the list and the given string\n    # If the list has fewer than 2 elements, use empty strings as defaults\n    first_element = test_list[0] if len(test_list) > 0 else \"\"\n    second_element = test_list[1] if len(test_list) > 1 else \"\"\n    third_element = test_str\n    \n    return (first_element, second_element, third_element)\n\n\n"], "responses": ["Looking at the function signature and docstring, I need to create a function that takes a list of strings and a string, then returns a tuple containing three strings.\n\nSince the function is supposed to create a \"new tuple from the given string and list\", I'll combine the string with elements from the list to form a 3-element tuple.\n\nLet me analyze what would make sense:\n- We have a list of strings and a single string\n- We need to return a tuple with exactly 3 strings\n- A logical approach would be to use the given string and combine it with elements from the list\n\nHere's my implementation:\n\n```python\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    # Use the first two elements from the list and the given string\n    # If the list has fewer than 2 elements, use empty strings as defaults\n    first_element = test_list[0] if len(test_list) > 0 else \"\"\n    second_element = test_list[1] if len(test_list) > 1 else \"\"\n    third_element = test_str\n    \n    return (first_element, second_element, third_element)\n```"], "prompt_tokens": [97], "completion_tokens": [263], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_788_new_tuple"}
{"name": "mbpp_790_even_position", "language": "Python3", "prompt": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every even index contains even numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_position", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == False\n    assert candidate([1, 2, 3]) == False\n    assert candidate([2, 1, 4]) == True\n\ndef test_check():\n    check(even_position)\n\ntest_check()\n", "sample_io": ["assert even_position([3, 2, 1]) == False"], "source_codes": ["\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True\n```"], "prompt_tokens": [87], "completion_tokens": [73], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_790_even_position"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    \n    # Convert to tuple and return exactly 4 integers\n    # Pad with zeros if needed or truncate to 4 elements\n    while len(result) < 4:\n        result.append(0)\n    \n    return tuple(result[:4])\n\n\n"], "responses": ["Looking at this problem, I need to write a function that removes nested tuples from a given tuple and returns a flat tuple of integers.\n\nLet me think through this step by step:\n1. I need to traverse through the input tuple\n2. If an element is a tuple, I should skip it or flatten it\n3. If an element is not a tuple, I should include it in the result\n4. The function signature suggests returning a tuple of 4 integers\n\nBased on the function name \"remove_nested\" and the docstring, it seems like I should remove nested tuples entirely, not flatten them.\n\n```python\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    \n    # Convert to tuple and return exactly 4 integers\n    # Pad with zeros if needed or truncate to 4 elements\n    while len(result) < 4:\n        result.append(0)\n    \n    return tuple(result[:4])\n```"], "prompt_tokens": [90], "completion_tokens": [240], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_792_count_list", "language": "Python3", "prompt": "from typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of lists in a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    assert candidate([[1, 2], [2, 3], [4, 5]]) == 3\n    assert candidate([[1, 0], [2, 0]]) == 2\n\ndef test_check():\n    check(count_list)\n\ntest_check()\n", "sample_io": ["assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"], "source_codes": ["\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of lists in a given list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        The number of lists in the input list\n    \"\"\"\n    return len(input_list)\n\n\n"], "responses": ["```python\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of lists in a given list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        The number of lists in the input list\n    \"\"\"\n    return len(input_list)\n```"], "prompt_tokens": [88], "completion_tokens": [69], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_792_count_list"}
{"name": "mbpp_793_last", "language": "Python3", "prompt": "from typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last position of an element in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 1) == 0\n    assert candidate([1, 1, 1, 2, 3, 4], 1) == 2\n    assert candidate([2, 3, 2, 3, 6, 8, 9], 3) == 3\n\ndef test_check():\n    check(last)\n\ntest_check()\n", "sample_io": ["assert last([1, 2, 3], 1) == 0"], "source_codes": ["\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n    Find the last position of an element in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers\n        x: The element to find\n        \n    Returns:\n        The last (rightmost) position of x in the array, or -1 if not found\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid  # Found the element, but continue searching to the right\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "responses": ["```python\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n    Find the last position of an element in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers\n        x: The element to find\n        \n    Returns:\n        The last (rightmost) position of x in the array, or -1 if not found\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid  # Found the element, but continue searching to the right\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"], "prompt_tokens": [89], "completion_tokens": [184], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_793_last"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": ["\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    if len(text) < 2:\n        return False\n    \n    return text[0] == 'a' and text[-1] == 'b'\n\n\n"], "responses": ["```python\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    if len(text) < 2:\n        return False\n    \n    return text[0] == 'a' and text[-1] == 'b'\n```"], "prompt_tokens": [88], "completion_tokens": [77], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_796_return_sum", "language": "Python3", "prompt": "from typing import Dict\n\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n\tWrite function to find the sum of all items in the given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_796_return_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "return_sum", "test": "def check(candidate):\n    assert candidate({ 'a': 100, 'b': 200, 'c': 300 }) == 600\n    assert candidate({ 'a': 25, 'b': 18, 'c': 45 }) == 88\n    assert candidate({ 'a': 36, 'b': 39, 'c': 49 }) == 124\n\ndef test_check():\n    check(return_sum)\n\ntest_check()\n", "sample_io": ["assert return_sum({ 'a': 100, 'b': 200, 'c': 300 }) == 600"], "source_codes": ["\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n    Write function to find the sum of all items in the given dictionary.\n    \"\"\"\n    return sum(dict.values())\n\n\n"], "responses": ["```python\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n    Write function to find the sum of all items in the given dictionary.\n    \"\"\"\n    return sum(dict.values())\n```"], "prompt_tokens": [85], "completion_tokens": [42], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_796_return_sum"}
{"name": "mbpp_797_sum_in_range", "language": "Python3", "prompt": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd natural numbers within the range l and r.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_in_range", "test": "def check(candidate):\n    assert candidate(2, 5) == 8\n    assert candidate(5, 7) == 12\n    assert candidate(7, 13) == 40\n\ndef test_check():\n    check(sum_in_range)\n\ntest_check()\n", "sample_io": ["assert sum_in_range(2, 5) == 8"], "source_codes": ["\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Find the sum of all odd natural numbers within the range l and r (inclusive).\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:\n            total += i\n    return total\n\n\n"], "responses": ["```python\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Find the sum of all odd natural numbers within the range l and r (inclusive).\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:\n            total += i\n    return total\n```"], "prompt_tokens": [88], "completion_tokens": [79], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_797_sum_in_range"}
{"name": "mbpp_798__sum", "language": "Python3", "prompt": "from typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([15, 12, 13, 10]) == 50\n    assert candidate([0, 1, 2]) == 3\n\ndef test_check():\n    check(_sum)\n\ntest_check()\n", "sample_io": ["assert _sum([1, 2, 3]) == 6"], "source_codes": ["\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    total = 0\n    for num in arr:\n        total += num\n    return total\n\n\n"], "responses": ["```python\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    total = 0\n    for num in arr:\n        total += num\n    return total\n```"], "prompt_tokens": [81], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_798__sum"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're working with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d positions\n    # (n >> (32 - d)) gets the bits that would overflow and moves them to the right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n\n\n"], "responses": ["```python\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're working with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d positions\n    # (n >> (32 - d)) gets the bits that would overflow and moves them to the right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n```"], "prompt_tokens": [93], "completion_tokens": [155], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_800_remove_all_spaces", "language": "Python3", "prompt": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_all_spaces", "test": "def check(candidate):\n    assert candidate('python  program') == 'pythonprogram'\n    assert candidate('python   programming    language') == 'pythonprogramminglanguage'\n    assert candidate('python                     program') == 'pythonprogram'\n    assert candidate('   python                     program') == 'pythonprogram'\n\ndef test_check():\n    check(remove_all_spaces)\n\ntest_check()\n", "sample_io": ["assert remove_all_spaces('python  program') == 'pythonprogram'"], "source_codes": ["\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n\n\n"], "responses": ["```python\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n```"], "prompt_tokens": [76], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_800_remove_all_spaces"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n```"], "prompt_tokens": [88], "completion_tokens": [93], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_802_count_rotation", "language": "Python3", "prompt": "from typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_rotation", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == 1\n    assert candidate([4, 5, 1, 2, 3]) == 2\n    assert candidate([7, 8, 9, 1, 2, 3]) == 3\n    assert candidate([1, 2, 3]) == 0\n    assert candidate([1, 3, 2]) == 2\n\ndef test_check():\n    check(count_rotation)\n\ntest_check()\n", "sample_io": ["assert count_rotation([3, 2, 1]) == 1"], "source_codes": ["\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n    Count the number of rotations required to generate a sorted array.\n    \n    The idea is to find the index of the minimum element in the rotated sorted array.\n    This index represents the number of rotations performed on the original sorted array.\n    \n    Args:\n        arr: A rotated sorted array\n        \n    Returns:\n        The number of rotations\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    \n    # Find the index of the minimum element\n    min_index = 0\n    for i in range(1, n):\n        if arr[i] < arr[min_index]:\n            min_index = i\n    \n    return min_index\n\n\n"], "responses": ["```python\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n    Count the number of rotations required to generate a sorted array.\n    \n    The idea is to find the index of the minimum element in the rotated sorted array.\n    This index represents the number of rotations performed on the original sorted array.\n    \n    Args:\n        arr: A rotated sorted array\n        \n    Returns:\n        The number of rotations\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    \n    # Find the index of the minimum element\n    min_index = 0\n    for i in range(1, n):\n        if arr[i] < arr[min_index]:\n            min_index = i\n    \n    return min_index\n```"], "prompt_tokens": [108], "completion_tokens": [152], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_802_count_rotation"}
{"name": "mbpp_803_is_perfect_square", "language": "Python3", "prompt": "def is_perfect_square(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_perfect_square", "test": "def check(candidate):\n    assert candidate(10) == False\n    assert candidate(36) == True\n    assert candidate(14) == False\n    assert candidate(196) == True\n    assert candidate(125) == False\n    assert candidate(15625) == True\n\ndef test_check():\n    check(is_perfect_square)\n\ntest_check()\n", "sample_io": ["assert is_perfect_square(10) == False"], "source_codes": ["\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search approach\n    left, right = 1, n // 2 + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search approach\n    left, right = 1, n // 2 + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n```"], "prompt_tokens": [102], "completion_tokens": [176], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_803_is_perfect_square"}
{"name": "mbpp_804_is_product_even", "language": "Python3", "prompt": "from typing import List\n\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether the product of numbers in a list is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_804_is_product_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_product_even", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 4]) == True\n    assert candidate([1, 1]) == False\n\ndef test_check():\n    check(is_product_even)\n\ntest_check()\n", "sample_io": ["assert is_product_even([1, 2, 3]) == True"], "source_codes": ["\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if product is even, False if product is odd\n    \"\"\"\n    # If any number in the list is even, the product will be even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If all numbers are odd, the product will be odd\n    return False\n\n\n"], "responses": ["```python\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if product is even, False if product is odd\n    \"\"\"\n    # If any number in the list is even, the product will be even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If all numbers are odd, the product will be odd\n    return False\n```"], "prompt_tokens": [88], "completion_tokens": [120], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_804_is_product_even"}
{"name": "mbpp_805_max_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that returns the list in a list of lists whose sum of elements is the highest.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_list", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]\n    assert candidate([[3, 2, 1], [6, 5, 4], [12, 11, 10]]) == [12, 11, 10]\n    assert candidate([[2, 3, 1]]) == [2, 3, 1]\n\ndef test_check():\n    check(max_sum_list)\n\ntest_check()\n", "sample_io": ["assert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"], "source_codes": ["\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n\n\n"], "responses": ["```python\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n```"], "prompt_tokens": [93], "completion_tokens": [102], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_805_max_sum_list"}
{"name": "mbpp_806_max_run_uppercase", "language": "Python3", "prompt": "def max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to find maximum run of uppercase characters in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_run_uppercase", "test": "def check(candidate):\n    assert candidate('GeMKSForGERksISBESt') == 5\n    assert candidate('PrECIOusMOVemENTSYT') == 6\n    assert candidate('GooGLEFluTTER') == 4\n\ndef test_check():\n    check(max_run_uppercase)\n\ntest_check()\n", "sample_io": ["assert max_run_uppercase('GeMKSForGERksISBESt') == 5"], "source_codes": ["\ndef max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n    Find maximum run of uppercase characters in the given string.\n    \"\"\"\n    if not test_str:\n        return 0\n    \n    max_count = 0\n    current_count = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    return max_count\n\n\n"], "responses": ["```python\ndef max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n    Find maximum run of uppercase characters in the given string.\n    \"\"\"\n    if not test_str:\n        return 0\n    \n    max_count = 0\n    current_count = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    return max_count\n```"], "prompt_tokens": [81], "completion_tokens": [105], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_806_max_run_uppercase"}
{"name": "mbpp_807_first_odd", "language": "Python3", "prompt": "from typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the first odd number in a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5]) == 1\n    assert candidate([2, 4, 1, 3]) == 1\n    assert candidate([8, 9, 1]) == 9\n\ndef test_check():\n    check(first_odd)\n\ntest_check()\n", "sample_io": ["assert first_odd([1, 3, 5]) == 1"], "source_codes": ["\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        The first odd number in the list\n        \n    Raises:\n        ValueError: If no odd number is found in the list\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    \n    raise ValueError(\"No odd number found in the list\")\n\n\n"], "responses": ["```python\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        The first odd number in the list\n        \n    Raises:\n        ValueError: If no odd number is found in the list\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    \n    raise ValueError(\"No odd number found in the list\")\n```"], "prompt_tokens": [86], "completion_tokens": [104], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_807_first_odd"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n\n\n"], "responses": ["```python\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n```"], "prompt_tokens": [90], "completion_tokens": [49], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_809_check_smaller", "language": "Python3", "prompt": "from typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n\tWrite a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_smaller", "test": "def check(candidate):\n    assert candidate((1, 2, 3), (2, 3, 4)) == False\n    assert candidate((4, 5, 6), (3, 4, 5)) == True\n    assert candidate((11, 12, 13), (10, 11, 12)) == True\n\ndef test_check():\n    check(check_smaller)\n\ntest_check()\n", "sample_io": ["assert check_smaller((1, 2, 3), (2, 3, 4)) == False"], "source_codes": ["\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    return all(test_tup2[i] < test_tup1[i] for i in range(len(test_tup1)))\n\n\n"], "responses": ["```python\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    return all(test_tup2[i] < test_tup1[i] for i in range(len(test_tup1)))\n```"], "prompt_tokens": [111], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_809_check_smaller"}
