{"name": "mbpp_12_sort_matrix", "language": "Python3", "prompt": "from typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_matrix", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    assert candidate([[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n    assert candidate([[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\n\ndef test_check():\n    check(sort_matrix)\n\ntest_check()\n", "sample_io": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"], "source_codes": ["def sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    # Handle edge case: empty matrix\n    if not M:\n        return []\n    \n    # Sort matrix rows by the sum of their elements\n    return sorted(M, key=sum)"], "responses": ["\nfrom typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    # Handle edge case: empty matrix\n    if not M:\n        return []\n    \n    # Sort matrix rows by the sum of their elements\n    return sorted(M, key=sum)\n\n\n"], "prompt_tokens": [2111], "completion_tokens": [1080], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_12_sort_matrix"}
{"name": "mbpp_20_is_woodall", "language": "Python3", "prompt": "def is_woodall(x: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given number is woodball or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_woodall", "test": "def check(candidate):\n    assert candidate(383) == True\n    assert candidate(254) == False\n    assert candidate(200) == False\n\ndef test_check():\n    check(is_woodall)\n\ntest_check()\n", "sample_io": ["assert is_woodall(383) == True"], "source_codes": ["def is_woodall(x: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is woodball or not.\n    \"\"\"\n    if x <= 0:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1"], "responses": ["\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is woodball or not.\n    \"\"\"\n    if x <= 0:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n\n\n"], "prompt_tokens": [2035], "completion_tokens": [1126], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_20_is_woodall"}
{"name": "mbpp_66_pos_count", "language": "Python3", "prompt": "from typing import List\n\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of positive numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pos_count", "test": "def check(candidate):\n    assert candidate([1, -2, 3, -4]) == 2\n    assert candidate([3, 4, 5, -1]) == 3\n    assert candidate([1, 2, 3, 4]) == 4\n\ndef test_check():\n    check(pos_count)\n\ntest_check()\n", "sample_io": ["assert pos_count([1, -2, 3, -4]) == 2"], "source_codes": ["def pos_count(list: List[int]) -> int:\n    \"\"\"\n    Count the number of positive numbers in a list.\n    \n    Args:\n        list: A list of integers\n        \n    Returns:\n        The count of positive numbers in the list\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count"], "responses": ["\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Count the number of positive numbers in a list.\n    \n    Args:\n        list: A list of integers\n        \n    Returns:\n        The count of positive numbers in the list\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1843], "completion_tokens": [934], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_66_pos_count"}
{"name": "mbpp_77_is_Diff", "language": "Python3", "prompt": "def is_Diff(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether a number is divisible by 11.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Diff", "test": "def check(candidate):\n    assert candidate(12345) == False\n    assert candidate(1212112) == True\n    assert candidate(1212) == False\n\ndef test_check():\n    check(is_Diff)\n\ntest_check()\n", "sample_io": ["assert is_Diff(12345) == False"], "source_codes": ["def is_Diff(n: int) -> bool:\n    # Work with absolute value to handle negative numbers\n    n = abs(n)\n    \n    # Convert number to string to access individual digits\n    str_n = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate through each digit with its index\n    for i, digit in enumerate(str_n):\n        # If index is even (0-based), it's an odd position (1st, 3rd, 5th...)\n        if i % 2 == 0:\n            odd_sum += int(digit)\n        # If index is odd (0-based), it's an even position (2nd, 4th, 6th...)\n        else:\n            even_sum += int(digit)\n    \n    # Calculate the difference\n    diff = abs(odd_sum - even_sum)\n    \n    # Check if difference is divisible by 11\n    return diff % 11 == 0"], "responses": ["\ndef is_Diff(n: int) -> bool:\n    # Work with absolute value to handle negative numbers\n    n = abs(n)\n    \n    # Convert number to string to access individual digits\n    str_n = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate through each digit with its index\n    for i, digit in enumerate(str_n):\n        # If index is even (0-based), it's an odd position (1st, 3rd, 5th...)\n        if i % 2 == 0:\n            odd_sum += int(digit)\n        # If index is odd (0-based), it's an even position (2nd, 4th, 6th...)\n        else:\n            even_sum += int(digit)\n    \n    # Calculate the difference\n    diff = abs(odd_sum - even_sum)\n    \n    # Check if difference is divisible by 11\n    return diff % 11 == 0\n\n\n"], "prompt_tokens": [1992], "completion_tokens": [1265], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_77_is_Diff"}
{"name": "mbpp_86_centered_hexagonal_number", "language": "Python3", "prompt": "def centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth centered hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "centered_hexagonal_number", "test": "def check(candidate):\n    assert candidate(10) == 271\n    assert candidate(2) == 7\n    assert candidate(9) == 217\n\ndef test_check():\n    check(centered_hexagonal_number)\n\ntest_check()\n", "sample_io": ["assert centered_hexagonal_number(10) == 271"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 247: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_86_centered_hexagonal_number"}
{"name": "mbpp_89_closest_num", "language": "Python3", "prompt": "def closest_num(N: int) -> int:\n    \"\"\"\n\tWrite a function to find the closest smaller number than n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "closest_num", "test": "def check(candidate):\n    assert candidate(11) == 10\n    assert candidate(7) == 6\n    assert candidate(12) == 11\n\ndef test_check():\n    check(closest_num)\n\ntest_check()\n", "sample_io": ["assert closest_num(11) == 10"], "source_codes": ["def closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n    \"\"\"\n    return N - 1"], "responses": ["\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n\n\n"], "prompt_tokens": [1364], "completion_tokens": [721], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_89_closest_num"}
{"name": "mbpp_123_amicable_numbers_sum", "language": "Python3", "prompt": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n\tWrite a function to sum all amicable numbers from 1 to a specified number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "amicable_numbers_sum", "test": "def check(candidate):\n    assert candidate(999) == 504\n    assert candidate(9999) == 31626\n    assert candidate(99) == 0\n\ndef test_check():\n    check(amicable_numbers_sum)\n\ntest_check()\n", "sample_io": ["assert amicable_numbers_sum(999) == 504"], "source_codes": ["def amicable_numbers_sum(limit: int) -> int:\n    if limit < 220:\n        return 0\n    \n    # Create array to store sum of proper divisors for each number\n    divisor_sums = [0] * (limit + 1)\n    \n    # Calculate sum of proper divisors for each number up to limit\n    for i in range(1, limit + 1):\n        for j in range(i * 2, limit + 1, i):\n            divisor_sums[j] += i\n    \n    # Find amicable numbers and sum them\n    amicable_sum = 0\n    visited = set()\n    \n    for a in range(2, limit + 1):\n        if a in visited:\n            continue\n            \n        b = divisor_sums[a]\n        \n        # Check if b is within range and forms an amicable pair with a\n        if b <= limit and b != a and divisor_sums[b] == a:\n            amicable_sum += a + b\n            visited.add(a)\n            visited.add(b)\n    \n    return amicable_sum"], "responses": ["\ndef amicable_numbers_sum(limit: int) -> int:\n    if limit < 220:\n        return 0\n    \n    # Create array to store sum of proper divisors for each number\n    divisor_sums = [0] * (limit + 1)\n    \n    # Calculate sum of proper divisors for each number up to limit\n    for i in range(1, limit + 1):\n        for j in range(i * 2, limit + 1, i):\n            divisor_sums[j] += i\n    \n    # Find amicable numbers and sum them\n    amicable_sum = 0\n    visited = set()\n    \n    for a in range(2, limit + 1):\n        if a in visited:\n            continue\n            \n        b = divisor_sums[a]\n        \n        # Check if b is within range and forms an amicable pair with a\n        if b <= limit and b != a and divisor_sums[b] == a:\n            amicable_sum += a + b\n            visited.add(a)\n            visited.add(b)\n    \n    return amicable_sum\n\n\n"], "prompt_tokens": [2074], "completion_tokens": [1311], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_123_amicable_numbers_sum"}
{"name": "mbpp_130_max_occurrences", "language": "Python3", "prompt": "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_occurrences", "test": "def check(candidate):\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]) == 8\n    assert candidate([10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]) == 20\n\ndef test_check():\n    check(max_occurrences)\n\ntest_check()\n", "sample_io": ["assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2"], "source_codes": ["def max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    return max(freq_count.values())", "def max_occurrences(nums: List[int]):\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n    if not nums:\n        return None\n    \n    # Count frequency of each element\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Find first element with maximum frequency\n    for num in nums:\n        if freq_count[num] == max_freq:\n            return num"], "responses": ["\nfrom typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    return max(freq_count.values())\n\n\n", "\nfrom typing import List\n\ndef max_occurrences(nums: List[int]):\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n    if not nums:\n        return None\n    \n    # Count frequency of each element\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Find first element with maximum frequency\n    for num in nums:\n        if freq_count[num] == max_freq:\n            return num\n\n\n"], "prompt_tokens": [5176, 1896], "completion_tokens": [5338, 1197], "no_of_try": 2, "api_calls": 14, "is_solved": false, "task_id": "mbpp_130_max_occurrences"}
{"name": "mbpp_162_sum_series", "language": "Python3", "prompt": "def sum_series(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_series", "test": "def check(candidate):\n    assert candidate(6) == 12\n    assert candidate(10) == 30\n    assert candidate(9) == 25\n\ndef test_check():\n    check(sum_series)\n\ntest_check()\n", "sample_io": ["assert sum_series(6) == 12"], "source_codes": ["def sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    \n    This is an arithmetic series with first term 'n', common difference '-2',\n    and last term >= 0.\n    \"\"\"\n    # Handle negative numbers gracefully\n    if n < 0:\n        return 0\n    \n    # Number of terms in the series (i ranges from 0 to n//2 inclusive)\n    num_terms = n // 2 + 1\n    \n    # Last term in the series\n    last_term = n - 2 * (n // 2)\n    \n    # Use arithmetic series sum formula: num_terms * (first_term + last_term) / 2\n    return num_terms * (n + last_term) // 2"], "responses": ["\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    \n    This is an arithmetic series with first term 'n', common difference '-2',\n    and last term >= 0.\n    \"\"\"\n    # Handle negative numbers gracefully\n    if n < 0:\n        return 0\n    \n    # Number of terms in the series (i ranges from 0 to n//2 inclusive)\n    num_terms = n // 2 + 1\n    \n    # Last term in the series\n    last_term = n - 2 * (n // 2)\n    \n    # Use arithmetic series sum formula: num_terms * (first_term + last_term) / 2\n    return num_terms * (n + last_term) // 2\n\n\n"], "prompt_tokens": [1763], "completion_tokens": [1103], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_162_sum_series"}
{"name": "mbpp_224_count_Set_Bits", "language": "Python3", "prompt": "def count_Set_Bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of set bits (binary digits with value 1) in a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Set_Bits", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(4) == 1\n    assert candidate(6) == 2\n\ndef test_check():\n    check(count_Set_Bits)\n\ntest_check()\n", "sample_io": ["assert count_Set_Bits(2) == 1"], "source_codes": ["def count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"], "responses": ["\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n\n"], "prompt_tokens": [1893], "completion_tokens": [1239], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_224_count_Set_Bits"}
{"name": "mbpp_234_volume_cube", "language": "Python3", "prompt": "def volume_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the volume of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "volume_cube", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(2) == 8\n    assert candidate(5) == 125\n\ndef test_check():\n    check(volume_cube)\n\ntest_check()\n", "sample_io": ["assert volume_cube(3) == 27"], "source_codes": ["def volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    # Validate input parameter\n    if l < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    \n    # Calculate and return the volume\n    return l ** 3"], "responses": ["\ndef volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    # Validate input parameter\n    if l < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    \n    # Calculate and return the volume\n    return l ** 3\n\n\n"], "prompt_tokens": [1421], "completion_tokens": [837], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_234_volume_cube"}
{"name": "mbpp_237_check_occurences", "language": "Python3", "prompt": "from typing import List, Tuple, Dict\n\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_occurences", "test": "def check(candidate):\n    assert candidate([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }\n    assert candidate([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]) == { (2, 4): 2, (3, 6): 2, (4, 7): 1 }\n    assert candidate([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]) == { (2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1 }\n\ndef test_check():\n    check(check_occurences)\n\ntest_check()\n", "sample_io": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }"], "source_codes": ["def check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    result = {}\n    for item in test_list:\n        # Create a canonical form by sorting the tuple elements\n        canonical_item = tuple(sorted(item))\n        result[canonical_item] = result.get(canonical_item, 0) + 1\n    return result"], "responses": ["\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    result = {}\n    for item in test_list:\n        # Create a canonical form by sorting the tuple elements\n        canonical_item = tuple(sorted(item))\n        result[canonical_item] = result.get(canonical_item, 0) + 1\n    return result\n\n\n"], "prompt_tokens": [5505], "completion_tokens": [2407], "no_of_try": 1, "api_calls": 9, "is_solved": true, "task_id": "mbpp_237_check_occurences"}
{"name": "mbpp_245_max_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum", "test": "def check(candidate):\n    assert candidate([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert candidate([80, 60, 30, 40, 20, 10]) == 210\n    assert candidate([2, 3, 14, 16, 21, 23, 29, 30]) == 138\n\ndef test_check():\n    check(max_sum)\n\ntest_check()\n", "sample_io": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"], "source_codes": ["def max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    \n    # inc_sum[i] stores the maximum sum of increasing subsequence ending at index i\n    inc_sum = [0] * n\n    # dec_sum[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec_sum = [0] * n\n    \n    # Fill inc_sum array\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    \n    # Fill dec_sum array\n    for i in range(n-1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    \n    # Find maximum sum bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # Bitonic subsequence sum with peak at i\n        bitonic_sum = inc_sum[i] + dec_sum[i] - arr[i]\n        max_bitonic_sum = max(max_bitonic_sum, bitonic_sum)\n    \n    return max_bitonic_sum"], "responses": ["\nfrom typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    \n    # inc_sum[i] stores the maximum sum of increasing subsequence ending at index i\n    inc_sum = [0] * n\n    # dec_sum[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec_sum = [0] * n\n    \n    # Fill inc_sum array\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    \n    # Fill dec_sum array\n    for i in range(n-1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    \n    # Find maximum sum bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # Bitonic subsequence sum with peak at i\n        bitonic_sum = inc_sum[i] + dec_sum[i] - arr[i]\n        max_bitonic_sum = max(max_bitonic_sum, bitonic_sum)\n    \n    return max_bitonic_sum\n\n\n"], "prompt_tokens": [2349], "completion_tokens": [1802], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_245_max_sum"}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum_repeated", "test": "def check(candidate):\n    assert candidate([10, 20, -30, -1], 4, 3) == 30\n    assert candidate([-1, 10, 20], 3, 2) == 59\n    assert candidate([-1, -2, -3], 3, 3) == -1\n\ndef test_check():\n    check(max_sub_array_sum_repeated)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"], "source_codes": ["def max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    \n    # Kadane's algorithm for maximum subarray sum in single array\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate maximum subarray sum for two concatenated arrays\n    # This handles the case where the maximum subarray spans across the boundary\n    max_kadane = kadane(a)\n    \n    # Calculate prefix sums\n    max_prefix = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix = max(max_prefix, current_sum)\n    \n    # Calculate suffix sums\n    max_suffix = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix = max(max_suffix, current_sum)\n    \n    # Total sum of array\n    total_sum = sum(a)\n    \n    # If total sum is positive, we can include (k-2) middle arrays\n    # Otherwise, we only consider the boundary case\n    if total_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + (k - 2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix + max_suffix)"], "responses": ["\nfrom typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    \n    # Kadane's algorithm for maximum subarray sum in single array\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate maximum subarray sum for two concatenated arrays\n    # This handles the case where the maximum subarray spans across the boundary\n    max_kadane = kadane(a)\n    \n    # Calculate prefix sums\n    max_prefix = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix = max(max_prefix, current_sum)\n    \n    # Calculate suffix sums\n    max_suffix = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix = max(max_suffix, current_sum)\n    \n    # Total sum of array\n    total_sum = sum(a)\n    \n    # If total sum is positive, we can include (k-2) middle arrays\n    # Otherwise, we only consider the boundary case\n    if total_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + (k - 2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix + max_suffix)\n\n\n"], "prompt_tokens": [1600], "completion_tokens": [1787], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_286_max_sub_array_sum_repeated"}
{"name": "mbpp_290_max_length", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list of maximum length in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1], [5, 7], [10, 12, 14, 15]]) == (4, [10, 12, 14, 15])\n    assert candidate([[5], [15, 20, 25]]) == (3, [15, 20, 25])\n\ndef test_check():\n    check(max_length)\n\ntest_check()\n", "sample_io": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["def max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not list1:\n        return (0, [])\n    \n    # Initialize variables to track maximum length and corresponding list\n    max_len = 0\n    max_list = []\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        current_len = len(sublist)\n        # Update if current sublist is longer\n        if current_len > max_len:\n            max_len = current_len\n            max_list = sublist\n    \n    return (max_len, max_list)"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not list1:\n        return (0, [])\n    \n    # Initialize variables to track maximum length and corresponding list\n    max_len = 0\n    max_list = []\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        current_len = len(sublist)\n        # Update if current sublist is longer\n        if current_len > max_len:\n            max_len = current_len\n            max_list = sublist\n    \n    return (max_len, max_list)\n\n\n"], "prompt_tokens": [1972], "completion_tokens": [1032], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_290_max_length"}
{"name": "mbpp_309_maximum", "language": "Python3", "prompt": "def maximum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximum", "test": "def check(candidate):\n    assert candidate(5, 10) == 10\n    assert candidate(-1, -2) == -1\n    assert candidate(9, 7) == 9\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n", "sample_io": ["assert maximum(5, 10) == 10"], "source_codes": ["def maximum(a: int, b: int) -> int:\n    \"\"\"\n    Find the maximum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The larger of the two numbers, or either number if they are equal\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b"], "responses": ["\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Find the maximum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The larger of the two numbers, or either number if they are equal\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b\n\n\n"], "prompt_tokens": [1771], "completion_tokens": [893], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_309_maximum"}
{"name": "mbpp_394_check_distinct", "language": "Python3", "prompt": "from typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if given list contains no duplicates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_distinct", "test": "def check(candidate):\n    assert candidate([1, 4, 5, 6, 1, 4]) == False\n    assert candidate([1, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 6]) == True\n\ndef test_check():\n    check(check_distinct)\n\ntest_check()\n", "sample_io": ["assert check_distinct([1, 4, 5, 6, 1, 4]) == False"], "source_codes": ["def check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    # Handle edge cases\n    if len(test_tup) <= 1:\n        return True\n    \n    # Use a set to track seen elements\n    seen = set()\n    \n    # Iterate through each element\n    for element in test_tup:\n        # If element is already in set, we found a duplicate\n        if element in seen:\n            return False\n        # Otherwise, add element to set\n        seen.add(element)\n    \n    # If we get here, no duplicates were found\n    return True"], "responses": ["\nfrom typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    # Handle edge cases\n    if len(test_tup) <= 1:\n        return True\n    \n    # Use a set to track seen elements\n    seen = set()\n    \n    # Iterate through each element\n    for element in test_tup:\n        # If element is already in set, we found a duplicate\n        if element in seen:\n            return False\n        # Otherwise, add element to set\n        seen.add(element)\n    \n    # If we get here, no duplicates were found\n    return True\n\n\n"], "prompt_tokens": [1797], "completion_tokens": [910], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_394_check_distinct"}
{"name": "mbpp_413_extract_nth_element", "language": "Python3", "prompt": "from typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract the nth element from a given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_nth_element", "test": "def check(candidate):\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2) == [99, 96, 94, 98]\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1) == [98, 97, 91, 94]\n\ndef test_check():\n    check(extract_nth_element)\n\ntest_check()\n", "sample_io": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"], "source_codes": ["def extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    if not list1:\n        return []\n    \n    result = []\n    for tuple_item in list1:\n        try:\n            result.append(tuple_item[n])\n        except IndexError:\n            # Skip tuples where n is out of bounds\n            pass\n    \n    return result"], "responses": ["\nfrom typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    if not list1:\n        return []\n    \n    result = []\n    for tuple_item in list1:\n        try:\n            result.append(tuple_item[n])\n        except IndexError:\n            # Skip tuples where n is out of bounds\n            pass\n    \n    return result\n\n\n"], "prompt_tokens": [2029], "completion_tokens": [1128], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_413_extract_nth_element"}
{"name": "mbpp_417_group_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to find common first element in given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "group_tuples", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]\n    assert candidate([['a', 'b'], ['a', 'c'], ['d', 'e']]) == [['a', 'b', 'c'], ['d', 'e']]\n    assert candidate([['f', 'g'], ['f', 'g'], ['h', 'i']]) == [['f', 'g', 'g'], ['h', 'i']]\n\ndef test_check():\n    check(group_tuples)\n\ntest_check()\n", "sample_io": ["assert group_tuples([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]"], "source_codes": ["def group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    if not Input:\n        return []\n    \n    # Group sublists by their first element\n    groups = {}\n    for sublist in Input:\n        if sublist:  # Ensure sublist is not empty\n            first_element = sublist[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].append(sublist)\n    \n    # For each group, create a merged list if there are multiple sublists\n    result = []\n    for first_element, sublist_group in groups.items():\n        if len(sublist_group) > 1:\n            # Merge sublists: first element + all other elements from all sublists\n            merged = [first_element]\n            for sublist in sublist_group:\n                merged.extend(sublist[1:])  # Add all elements except the first\n            result.append(merged)\n        else:\n            # If only one sublist with this first element, include it as is\n            result.append(sublist_group[0])\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    if not Input:\n        return []\n    \n    # Group sublists by their first element\n    groups = {}\n    for sublist in Input:\n        if sublist:  # Ensure sublist is not empty\n            first_element = sublist[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].append(sublist)\n    \n    # For each group, create a merged list if there are multiple sublists\n    result = []\n    for first_element, sublist_group in groups.items():\n        if len(sublist_group) > 1:\n            # Merge sublists: first element + all other elements from all sublists\n            merged = [first_element]\n            for sublist in sublist_group:\n                merged.extend(sublist[1:])  # Add all elements except the first\n            result.append(merged)\n        else:\n            # If only one sublist with this first element, include it as is\n            result.append(sublist_group[0])\n    \n    return result\n\n\n"], "prompt_tokens": [4371], "completion_tokens": [2425], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_417_group_tuples"}
{"name": "mbpp_420_cube_Sum", "language": "Python3", "prompt": "def cube_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the cube sum of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_Sum", "test": "def check(candidate):\n    assert candidate(2) == 72\n    assert candidate(3) == 288\n    assert candidate(4) == 800\n\ndef test_check():\n    check(cube_Sum)\n\ntest_check()\n", "sample_io": ["assert cube_Sum(2) == 72"], "source_codes": ["def cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The formula for sum of cubes of first n even natural numbers is: 2 * n^2 * (n+1)^2\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    n_squared = n * n\n    n_plus_1_squared = (n + 1) * (n + 1)\n    \n    return 2 * n_squared * n_plus_1_squared"], "responses": ["\ndef cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The formula for sum of cubes of first n even natural numbers is: 2 * n^2 * (n+1)^2\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    n_squared = n * n\n    n_plus_1_squared = (n + 1) * (n + 1)\n    \n    return 2 * n_squared * n_plus_1_squared\n\n\n"], "prompt_tokens": [1730], "completion_tokens": [972], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_420_cube_Sum"}
{"name": "mbpp_439_multiple_to_single", "language": "Python3", "prompt": "from typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n\tWrite a function to join a list of multiple integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiple_to_single", "test": "def check(candidate):\n    assert candidate([11, 33, 50]) == 113350\n    assert candidate([-1, 2, 3, 4, 5, 6]) == -123456\n    assert candidate([10, 15, 20, 25]) == 10152025\n\ndef test_check():\n    check(multiple_to_single)\n\ntest_check()\n", "sample_io": ["assert multiple_to_single([11, 33, 50]) == 113350"], "source_codes": ["def multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Write a function to join a list of multiple integers into a single integer.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 0\n    if not L:\n        return 0\n    \n    # Convert each integer to string, join them, then convert back to integer\n    result_str = ''.join(str(num) for num in L)\n    return int(result_str)"], "responses": ["\nfrom typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Write a function to join a list of multiple integers into a single integer.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 0\n    if not L:\n        return 0\n    \n    # Convert each integer to string, join them, then convert back to integer\n    result_str = ''.join(str(num) for num in L)\n    return int(result_str)\n\n\n"], "prompt_tokens": [1783], "completion_tokens": [1050], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_439_multiple_to_single"}
{"name": "mbpp_444_trim_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to trim each list by k in the given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "trim_tuple", "test": "def check(candidate):\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 1) == [[3, 2, 1], [4, 9, 2], [1, 2, 3], [8, 2, 1]]\n    assert candidate([[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]], 1) == [[8, 4], [8, 12], [1, 7], [6, 9]]\n\ndef test_check():\n    check(trim_tuple)\n\ntest_check()\n", "sample_io": ["assert trim_tuple([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]"], "source_codes": ["def trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    # Handle edge case when input list is empty\n    if not test_list:\n        return []\n    \n    # Validate that K is non-negative\n    if K < 0:\n        raise ValueError(\"K must be non-negative\")\n    \n    result = []\n    for sublist in test_list:\n        # If K is 0, return the sublist unchanged\n        if K == 0:\n            trimmed_sublist = sublist[:]\n        # If K is greater than or equal to half the length of sublist, return empty list\n        elif K >= len(sublist):\n            trimmed_sublist = []\n        else:\n            # Use list slicing to remove K elements from both start and end\n            trimmed_sublist = sublist[K:-K]\n        \n        result.append(trimmed_sublist)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    # Handle edge case when input list is empty\n    if not test_list:\n        return []\n    \n    # Validate that K is non-negative\n    if K < 0:\n        raise ValueError(\"K must be non-negative\")\n    \n    result = []\n    for sublist in test_list:\n        # If K is 0, return the sublist unchanged\n        if K == 0:\n            trimmed_sublist = sublist[:]\n        # If K is greater than or equal to half the length of sublist, return empty list\n        elif K >= len(sublist):\n            trimmed_sublist = []\n        else:\n            # Use list slicing to remove K elements from both start and end\n            trimmed_sublist = sublist[K:-K]\n        \n        result.append(trimmed_sublist)\n    \n    return result\n\n\n"], "prompt_tokens": [1962], "completion_tokens": [1242], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_444_trim_tuple"}
{"name": "mbpp_450_extract_string", "language": "Python3", "prompt": "from typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n\tWrite a function to extract specified size of strings from a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_string", "test": "def check(candidate):\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 6) == ['Python']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 9) == ['exercises']\n\ndef test_check():\n    check(extract_string)\n\ntest_check()\n", "sample_io": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"], "source_codes": ["def extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]"], "responses": ["\nfrom typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]\n\n\n"], "prompt_tokens": [1859], "completion_tokens": [848], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_450_extract_string"}
{"name": "mbpp_455_check_monthnumb_number", "language": "Python3", "prompt": "def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 31 days or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumb_number", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(2) == False\n    assert candidate(6) == False\n\ndef test_check():\n    check(check_monthnumb_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumb_number(5) == True"], "source_codes": ["def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Validate that the input month number is an integer between 1 and 12 inclusive\n    if not isinstance(monthnum2, int) or monthnum2 < 1 or monthnum2 > 12:\n        return False\n    \n    # Create a set of month numbers that have 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the input month number exists in the set of months with 31 days\n    return monthnum2 in months_with_31_days"], "responses": ["\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Validate that the input month number is an integer between 1 and 12 inclusive\n    if not isinstance(monthnum2, int) or monthnum2 < 1 or monthnum2 > 12:\n        return False\n    \n    # Create a set of month numbers that have 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the input month number exists in the set of months with 31 days\n    return monthnum2 in months_with_31_days\n\n\n"], "prompt_tokens": [1845], "completion_tokens": [1052], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_455_check_monthnumb_number"}
{"name": "mbpp_456_reverse_string_list", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n\tWrite a function to reverse each string in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_string_list", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    assert candidate(['john', 'amal', 'joel', 'george']) == ['nhoj', 'lama', 'leoj', 'egroeg']\n    assert candidate(['jack', 'john', 'mary']) == ['kcaj', 'nhoj', 'yram']\n\ndef test_check():\n    check(reverse_string_list)\n\ntest_check()\n", "sample_io": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"], "source_codes": ["def reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]"], "responses": ["\nfrom typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n\n\n"], "prompt_tokens": [1737], "completion_tokens": [815], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_456_reverse_string_list"}
{"name": "mbpp_555_difference", "language": "Python3", "prompt": "def difference(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "difference", "test": "def check(candidate):\n    assert candidate(3) == 30\n    assert candidate(5) == 210\n    assert candidate(2) == 6\n\ndef test_check():\n    check(difference)\n\ntest_check()\n", "sample_io": ["assert difference(3) == 30"], "source_codes": ["def difference(n: int) -> int:\n    if n == 0:\n        return 0\n    \n    # Sum of first n natural numbers: n*(n+1)//2\n    sum_natural = n * (n + 1) // 2\n    \n    # Sum of cubes of first n natural numbers: (n*(n+1)//2)^2\n    sum_cubes = sum_natural * sum_natural\n    \n    # Difference between sum of cubes and sum of natural numbers\n    return sum_cubes - sum_natural"], "responses": ["\ndef difference(n: int) -> int:\n    if n == 0:\n        return 0\n    \n    # Sum of first n natural numbers: n*(n+1)//2\n    sum_natural = n * (n + 1) // 2\n    \n    # Sum of cubes of first n natural numbers: (n*(n+1)//2)^2\n    sum_cubes = sum_natural * sum_natural\n    \n    # Difference between sum of cubes and sum of natural numbers\n    return sum_cubes - sum_natural\n\n\n"], "prompt_tokens": [1714], "completion_tokens": [1066], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_555_difference"}
{"name": "mbpp_566_sum_digits", "language": "Python3", "prompt": "def sum_digits(n: int) -> int:\n    \"\"\"\n\tWrite a function to get the sum of the digits of a non-negative integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_digits", "test": "def check(candidate):\n    assert candidate(345) == 12\n    assert candidate(12) == 3\n    assert candidate(97) == 16\n\ndef test_check():\n    check(sum_digits)\n\ntest_check()\n", "sample_io": ["assert sum_digits(345) == 12"], "source_codes": ["def sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    \n    return total"], "responses": ["\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    \n    return total\n\n\n"], "prompt_tokens": [1452], "completion_tokens": [934], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_566_sum_digits"}
{"name": "mbpp_577_last_Digit_Factorial", "language": "Python3", "prompt": "def last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit in factorial of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit_Factorial", "test": "def check(candidate):\n    assert candidate(4) == 4\n    assert candidate(21) == 0\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit_Factorial)\n\ntest_check()\n", "sample_io": ["assert last_Digit_Factorial(4) == 4"], "source_codes": ["def last_Digit_Factorial(n: int) -> int:\n    if n <= 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0"], "responses": ["\ndef last_Digit_Factorial(n: int) -> int:\n    if n <= 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0\n\n\n"], "prompt_tokens": [1492], "completion_tokens": [964], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_577_last_Digit_Factorial"}
{"name": "mbpp_580_extract_even", "language": "Python3", "prompt": "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n\tWrite a function to remove uneven elements in the nested mixed tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_even", "test": "def check(candidate):\n    assert candidate((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    assert candidate((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))\n    assert candidate((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)\n\ndef test_check():\n    check(extract_even)\n\ntest_check()\n", "sample_io": ["assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"], "source_codes": ["def extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    def process_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            processed_elements = []\n            for item in element:\n                result = process_element(item)\n                if result is not None:\n                    processed_elements.append(result)\n            return tuple(processed_elements) if processed_elements else ()\n        return None\n    \n    if not test_tuple:\n        return ()\n    \n    result = []\n    for item in test_tuple:\n        processed = process_element(item)\n        if processed is not None:\n            result.append(processed)\n    \n    # Handle case where all elements are filtered out\n    if not result:\n        return () if len(test_tuple) > 0 else ()\n    \n    return tuple(result)"], "responses": ["\nfrom typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    def process_element(element):\n        if isinstance(element, int):\n            return element if element % 2 == 0 else None\n        elif isinstance(element, tuple):\n            processed_elements = []\n            for item in element:\n                result = process_element(item)\n                if result is not None:\n                    processed_elements.append(result)\n            return tuple(processed_elements) if processed_elements else ()\n        return None\n    \n    if not test_tuple:\n        return ()\n    \n    result = []\n    for item in test_tuple:\n        processed = process_element(item)\n        if processed is not None:\n            result.append(processed)\n    \n    # Handle case where all elements are filtered out\n    if not result:\n        return () if len(test_tuple) > 0 else ()\n    \n    return tuple(result)\n\n\n"], "prompt_tokens": [2224], "completion_tokens": [1414], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_580_extract_even"}
{"name": "mbpp_584_find_adverbs", "language": "Python3", "prompt": "def find_adverbs(text: str) -> str:\n    \"\"\"\n\tWrite a function to find the first adverb ending with ly and its positions in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverbs", "test": "def check(candidate):\n    assert candidate('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'\n    assert candidate('Please handle the situation carefuly') == '28-36: carefuly'\n    assert candidate('Complete the task quickly') == '18-25: quickly'\n\ndef test_check():\n    check(find_adverbs)\n\ntest_check()\n", "sample_io": ["assert find_adverbs('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'"], "source_codes": ["import re\n\ndef find_adverbs(text: str) -> str:\n    pattern = r'\\b\\w+ly\\b'\n    match = re.search(pattern, text)\n    if match:\n        word = match.group()\n        start, end = match.span()\n        return f\"{start}-{end-1}: {word}\"\n    return \"\"", "import re\n\ndef find_adverbs(text: str) -> str:\n    # Pattern to match words ending with 'ly' as complete words\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first match in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the formatted result\n    if match:\n        adverb = match.group()\n        start, end = match.span()\n        return f\"{start}-{end}: {adverb}\"\n    \n    # Return None if no adverb is found\n    return None"], "responses": ["\nimport re\n\ndef find_adverbs(text: str) -> str:\n    pattern = r'\\b\\w+ly\\b'\n    match = re.search(pattern, text)\n    if match:\n        word = match.group()\n        start, end = match.span()\n        return f\"{start}-{end-1}: {word}\"\n    return \"\"\n\n\n", "\nimport re\n\ndef find_adverbs(text: str) -> str:\n    # Pattern to match words ending with 'ly' as complete words\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first match in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the formatted result\n    if match:\n        adverb = match.group()\n        start, end = match.span()\n        return f\"{start}-{end}: {adverb}\"\n    \n    # Return None if no adverb is found\n    return None\n\n\n"], "prompt_tokens": [5508, 3603], "completion_tokens": [3062, 1605], "no_of_try": 2, "api_calls": 17, "is_solved": false, "task_id": "mbpp_584_find_adverbs"}
{"name": "mbpp_585_expensive_items", "language": "Python3", "prompt": "from typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n\tWrite a function to find the n most expensive items in a given dataset.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "expensive_items", "test": "def check(candidate):\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }], 2) == [{ 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-1', 'price': 101.1 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }, { 'name': 'Item-4', 'price': 22.75 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n\ndef test_check():\n    check(expensive_items)\n\ntest_check()\n", "sample_io": ["assert expensive_items([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]"], "source_codes": ["def expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    # Handle edge cases\n    if not items or n <= 0:\n        return []\n    \n    # Sort items by price in descending order\n    # Python's sort is stable, so items with equal prices will maintain their relative order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the first n items (or all items if n > length of items)\n    return sorted_items[:n]"], "responses": ["\nfrom typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    # Handle edge cases\n    if not items or n <= 0:\n        return []\n    \n    # Sort items by price in descending order\n    # Python's sort is stable, so items with equal prices will maintain their relative order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the first n items (or all items if n > length of items)\n    return sorted_items[:n]\n\n\n"], "prompt_tokens": [2471], "completion_tokens": [1272], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_585_expensive_items"}
{"name": "mbpp_587_list_tuple", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n\tWrite a function to convert a list to a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_587_list_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_tuple", "test": "def check(candidate):\n    assert candidate([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    assert candidate([2, 4, 5, 6, 2, 3, 4, 4, 7]) == (2, 4, 5, 6, 2, 3, 4, 4, 7)\n    assert candidate([58, 44, 56]) == (58, 44, 56)\n\ndef test_check():\n    check(list_tuple)\n\ntest_check()\n", "sample_io": ["assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"], "source_codes": ["def list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)"], "responses": ["\nfrom typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n\n\n"], "prompt_tokens": [1755], "completion_tokens": [804], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_587_list_tuple"}
{"name": "mbpp_610_remove_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_kth_element", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], 4) == [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], 5) == [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10]\n\ndef test_check():\n    check(remove_kth_element)\n\ntest_check()\n", "sample_io": ["assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"], "source_codes": ["def remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    # Handle edge cases\n    if not list1 or L <= 0 or L > len(list1):\n        return list1.copy()\n    \n    # Convert 1-based indexing to 0-based indexing\n    index = L - 1\n    \n    # Create a new list excluding the element at index\n    return list1[:index] + list1[index + 1:]"], "responses": ["\nfrom typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    # Handle edge cases\n    if not list1 or L <= 0 or L > len(list1):\n        return list1.copy()\n    \n    # Convert 1-based indexing to 0-based indexing\n    index = L - 1\n    \n    # Create a new list excluding the element at index\n    return list1[:index] + list1[index + 1:]\n\n\n"], "prompt_tokens": [1406], "completion_tokens": [1030], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_610_remove_kth_element"}
{"name": "mbpp_612_merge", "language": "Python3", "prompt": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]\n    assert candidate([['x', 'y', 'z'], ['a', 'b', 'c'], ['m', 'n', 'o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'], ['z', 'c', 'o']]\n\ndef test_check():\n    check(merge)\n\ntest_check()\n", "sample_io": ["assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"], "source_codes": ["def merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    # This will create tuples, so we convert them back to lists\n    transposed = list(zip(*lst))\n    \n    # Convert tuples to lists\n    return [list(transposed[0]), list(transposed[1])]", "def merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists \n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    # Use zip to transpose the list of lists\n    transposed = list(zip(*lst))\n    \n    # Convert tuples to lists\n    return [list(transposed[0]), list(transposed[1])]", "def merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    transposed = zip(*lst)\n    \n    # Convert tuples back to lists\n    result = [list(t) for t in transposed]\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    # This will create tuples, so we convert them back to lists\n    transposed = list(zip(*lst))\n    \n    # Convert tuples to lists\n    return [list(transposed[0]), list(transposed[1])]\n\n\n", "\nfrom typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists \n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    # Use zip to transpose the list of lists\n    transposed = list(zip(*lst))\n    \n    # Convert tuples to lists\n    return [list(transposed[0]), list(transposed[1])]\n\n\n", "\nfrom typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    transposed = zip(*lst)\n    \n    # Convert tuples back to lists\n    result = [list(t) for t in transposed]\n    \n    return result\n\n\n"], "prompt_tokens": [2008, 1918, 1867], "completion_tokens": [1221, 1096, 1082], "no_of_try": 3, "api_calls": 12, "is_solved": true, "task_id": "mbpp_612_merge"}
{"name": "mbpp_628_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(string: str) -> str:\n    \"\"\"\n\tWrite a function to replace all spaces in the given string with '%20'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('My Name is Dawood') == 'My%20Name%20is%20Dawood'\n    assert candidate('I am a Programmer') == 'I%20am%20a%20Programmer'\n    assert candidate('I love Coding') == 'I%20love%20Coding'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('My Name is Dawood') == 'My%20Name%20is%20Dawood'"], "source_codes": ["def replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')"], "responses": ["\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n\n\n"], "prompt_tokens": [1741], "completion_tokens": [791], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_628_replace_spaces"}
{"name": "mbpp_728_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_list", "test": "def check(candidate):\n    assert candidate([10, 20, 30], [15, 25, 35]) == [25, 45, 65]\n    assert candidate([1, 2, 3], [5, 6, 7]) == [6, 8, 10]\n    assert candidate([15, 20, 30], [15, 45, 75]) == [30, 65, 105]\n\ndef test_check():\n    check(sum_list)\n\ntest_check()\n", "sample_io": ["assert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"], "source_codes": ["def sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]"], "responses": ["\nfrom typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n\n\n"], "prompt_tokens": [1852], "completion_tokens": [839], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_728_sum_list"}
{"name": "mbpp_742_area_tetrahedron", "language": "Python3", "prompt": "def area_tetrahedron(side: int) -> float:\n    \"\"\"\n\tWrite a function to caluclate the area of a tetrahedron.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "area_tetrahedron", "test": "def check(candidate):\n    assert candidate(3) == 15.588457268119894\n    assert candidate(20) == 692.8203230275509\n    assert candidate(10) == 173.20508075688772\n\ndef test_check():\n    check(area_tetrahedron)\n\ntest_check()\n", "sample_io": ["assert area_tetrahedron(3) == 15.588457268119894"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 293: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_742_area_tetrahedron"}
{"name": "mbpp_793_last", "language": "Python3", "prompt": "from typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last position of an element in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 1) == 0\n    assert candidate([1, 1, 1, 2, 3, 4], 1) == 2\n    assert candidate([2, 3, 2, 3, 6, 8, 9], 3) == 3\n\ndef test_check():\n    check(last)\n\ntest_check()\n", "sample_io": ["assert last([1, 2, 3], 1) == 0"], "source_codes": ["def last(arr: List[int], x: int) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return -1\n    \n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return -1\n    \n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "prompt_tokens": [1960], "completion_tokens": [1026], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_793_last"}
{"name": "mbpp_805_max_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that returns the list in a list of lists whose sum of elements is the highest.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_list", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]\n    assert candidate([[3, 2, 1], [6, 5, 4], [12, 11, 10]]) == [12, 11, 10]\n    assert candidate([[2, 3, 1]]) == [2, 3, 1]\n\ndef test_check():\n    check(max_sum_list)\n\ntest_check()\n", "sample_io": ["assert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"], "source_codes": ["def max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    In case of a tie, returns the first occurrence.\n    Returns an empty list if the input is empty.\n    \"\"\"\n    if not lists:\n        return []\n    \n    return max(lists, key=sum)"], "responses": ["\nfrom typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    In case of a tie, returns the first occurrence.\n    Returns an empty list if the input is empty.\n    \"\"\"\n    if not lists:\n        return []\n    \n    return max(lists, key=sum)\n\n\n"], "prompt_tokens": [2181], "completion_tokens": [1401], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_805_max_sum_list"}
{"name": "mbpp_806_max_run_uppercase", "language": "Python3", "prompt": "def max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to find maximum run of uppercase characters in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_run_uppercase", "test": "def check(candidate):\n    assert candidate('GeMKSForGERksISBESt') == 5\n    assert candidate('PrECIOusMOVemENTSYT') == 6\n    assert candidate('GooGLEFluTTER') == 4\n\ndef test_check():\n    check(max_run_uppercase)\n\ntest_check()\n", "sample_io": ["assert max_run_uppercase('GeMKSForGERksISBESt') == 5"], "source_codes": ["def max_run_uppercase(test_str: str) -> int:\n    if not test_str:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run"], "responses": ["\ndef max_run_uppercase(test_str: str) -> int:\n    if not test_str:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run\n\n\n"], "prompt_tokens": [1777], "completion_tokens": [913], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_806_max_run_uppercase"}
