{"name": "mbpp_135_hexagonal_num", "language": "Python3", "prompt": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "hexagonal_num", "test": "def check(candidate):\n    assert candidate(10) == 190\n    assert candidate(5) == 45\n    assert candidate(7) == 91\n\ndef test_check():\n    check(hexagonal_num)\n\ntest_check()\n", "sample_io": ["assert hexagonal_num(10) == 190"], "source_codes": ["\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    A hexagonal number is a figurate number that represents a hexagon.\n    The nth hexagonal number is given by the formula: H(n) = n(2n-1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n\n\n"], "responses": ["```python\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    A hexagonal number is a figurate number that represents a hexagon.\n    The nth hexagonal number is given by the formula: H(n) = n(2n-1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n```"], "prompt_tokens": [75], "completion_tokens": [167], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_135_hexagonal_num"}
{"name": "mbpp_800_remove_all_spaces", "language": "Python3", "prompt": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_all_spaces", "test": "def check(candidate):\n    assert candidate('python  program') == 'pythonprogram'\n    assert candidate('python   programming    language') == 'pythonprogramminglanguage'\n    assert candidate('python                     program') == 'pythonprogram'\n    assert candidate('   python                     program') == 'pythonprogram'\n\ndef test_check():\n    check(remove_all_spaces)\n\ntest_check()\n", "sample_io": ["assert remove_all_spaces('python  program') == 'pythonprogram'"], "source_codes": ["\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n\n\n"], "responses": ["```python\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n```"], "prompt_tokens": [76], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_800_remove_all_spaces"}
{"name": "mbpp_127_multiply_int", "language": "Python3", "prompt": "def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n\tWrite a function to multiply two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_int", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(5, 10) == 50\n    assert candidate(4, 8) == 32\n\ndef test_check():\n    check(multiply_int)\n\ntest_check()\n", "sample_io": ["assert multiply_int(10, 20) == 200"], "source_codes": ["\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n\n\n"], "responses": ["```python\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n```"], "prompt_tokens": [75], "completion_tokens": [38], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_127_multiply_int"}
{"name": "mbpp_764_number_ctr", "language": "Python3", "prompt": "def number_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count number of digits in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_ctr", "test": "def check(candidate):\n    assert candidate('program2bedone') == 1\n    assert candidate('3wonders') == 1\n    assert candidate('123') == 3\n    assert candidate('3wond-1ers2') == 3\n\ndef test_check():\n    check(number_ctr)\n\ntest_check()\n", "sample_io": ["assert number_ctr('program2bedone') == 1"], "source_codes": ["\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \n    Args:\n        str: Input string to check for digits\n        \n    Returns:\n        int: Number of digits found in the string\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \n    Args:\n        str: Input string to check for digits\n        \n    Returns:\n        int: Number of digits found in the string\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n```"], "prompt_tokens": [77], "completion_tokens": [84], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_764_number_ctr"}
{"name": "mbpp_767_get_pairs_count", "language": "Python3", "prompt": "from typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_pairs_count", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1], 2) == 6\n    assert candidate([1, 5, 7, -1, 5], 6) == 3\n    assert candidate([1, -2, 3], 1) == 1\n    assert candidate([-1, -2, 3], -3) == 1\n\ndef test_check():\n    check(get_pairs_count)\n\ntest_check()\n", "sample_io": ["assert get_pairs_count([1, 1, 1, 1], 2) == 6"], "source_codes": ["\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum value\n    \n    Returns:\n        Number of pairs that sum to the target value\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # For each element, check if (sum - element) exists\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in array\n        if complement in freq:\n            # If both elements are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2\n\n\n"], "responses": ["```python\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum value\n    \n    Returns:\n        Number of pairs that sum to the target value\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # For each element, check if (sum - element) exists\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in array\n        if complement in freq:\n            # If both elements are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2\n```"], "prompt_tokens": [106], "completion_tokens": [239], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_767_get_pairs_count"}
{"name": "mbpp_99_decimal_to_binary", "language": "Python3", "prompt": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n\tWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(8) == '1000'\n    assert candidate(18) == '10010'\n    assert candidate(7) == '111'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "sample_io": ["assert decimal_to_binary(8) == '1000'"], "source_codes": ["\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n\n\n"], "responses": ["```python\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n```"], "prompt_tokens": [87], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_99_decimal_to_binary"}
{"name": "mbpp_119_search", "language": "Python3", "prompt": "from typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the element that appears only once in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "search", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8\n    assert candidate([1, 2, 2, 3, 3, 4, 4]) == 1\n\ndef test_check():\n    check(search)\n\ntest_check()\n", "sample_io": ["assert search([1, 1, 2, 2, 3]) == 3"], "source_codes": ["\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If the pair is maintained, the single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If the pair is broken, the single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n\n\n"], "responses": ["```python\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If the pair is maintained, the single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If the pair is broken, the single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n```"], "prompt_tokens": [85], "completion_tokens": [170], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_119_search"}
{"name": "mbpp_92_is_undulating", "language": "Python3", "prompt": "def is_undulating(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is undulating or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_undulating", "test": "def check(candidate):\n    assert candidate(1212121) == True\n    assert candidate(1991) == False\n    assert candidate(121) == True\n\ndef test_check():\n    check(is_undulating)\n\ntest_check()\n", "sample_io": ["assert is_undulating(1212121) == True"], "source_codes": ["\ndef is_undulating(n: int) -> bool:\n    # Convert number to string to work with individual digits\n    s = str(n)\n    \n    # Numbers with less than 3 digits cannot be undulating\n    if len(s) < 3:\n        return False\n    \n    # First two digits must be different for undulation\n    if s[0] == s[1]:\n        return False\n    \n    # Check if the pattern alternates consistently\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n\n\n"], "responses": ["Looking at this problem, I need to understand what an \"undulating\" number is. Based on the function name and typical mathematical definitions, an undulating number has digits that alternate between two values in a wave-like pattern (like 121212 or 47474).\n\nLet me think through the approach:\n1. Convert the number to a string to easily access individual digits\n2. For a number to be undulating, it should alternate between exactly two different digits\n3. The pattern should be consistent throughout (e.g., ababab... where a and b are different digits)\n\nHere's my solution:\n\n```python\ndef is_undulating(n: int) -> bool:\n    # Convert number to string to work with individual digits\n    s = str(n)\n    \n    # Numbers with less than 3 digits cannot be undulating\n    if len(s) < 3:\n        return False\n    \n    # First two digits must be different for undulation\n    if s[0] == s[1]:\n        return False\n    \n    # Check if the pattern alternates consistently\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n```"], "prompt_tokens": [80], "completion_tokens": [326], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_92_is_undulating"}
{"name": "mbpp_105_count", "language": "Python3", "prompt": "from typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n\tWrite a python function to count true booleans in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count", "test": "def check(candidate):\n    assert candidate([True, False, True]) == 2\n    assert candidate([False, False]) == 0\n    assert candidate([True, True, True]) == 3\n\ndef test_check():\n    check(count)\n\ntest_check()\n", "sample_io": ["assert count([True, False, True]) == 2"], "source_codes": ["\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n\n\n"], "responses": ["```python\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n```"], "prompt_tokens": [83], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_105_count"}
{"name": "mbpp_766_pair_wise", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to return a list of all pairs of consecutive items in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_wise", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    assert candidate([1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)]\n    assert candidate([5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n\ndef test_check():\n    check(pair_wise)\n\ntest_check()\n", "sample_io": ["assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"], "source_codes": ["\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n\n\n"], "responses": ["```python\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n```"], "prompt_tokens": [96], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_766_pair_wise"}
{"name": "mbpp_464_check_value", "language": "Python3", "prompt": "from typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n\tWrite a function to check if all values are same in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_value", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 12) == True\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 5) == False\n\ndef test_check():\n    check(check_value)\n\ntest_check()\n", "sample_io": ["assert check_value({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False"], "source_codes": ["\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n\n\n"], "responses": ["```python\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n```"], "prompt_tokens": [89], "completion_tokens": [98], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_464_check_value"}
{"name": "mbpp_443_largest_neg", "language": "Python3", "prompt": "from typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest negative number from the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "largest_neg", "test": "def check(candidate):\n    assert candidate([1, 2, 3, -4, -6]) == -6\n    assert candidate([1, 2, 3, -8, -9]) == -9\n    assert candidate([1, 2, 3, 4, -1]) == -1\n\ndef test_check():\n    check(largest_neg)\n\ntest_check()\n", "sample_io": ["assert largest_neg([1, 2, 3, -4, -6]) == -6"], "source_codes": ["\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_numbers = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_numbers:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_numbers)\n\n\n"], "responses": ["```python\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_numbers = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_numbers:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_numbers)\n```"], "prompt_tokens": [85], "completion_tokens": [108], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_443_largest_neg"}
{"name": "mbpp_602_first_repeated_char", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_repeated_char", "test": "def check(candidate):\n    assert candidate('abcabc') == 'a'\n    assert candidate('abc') == None\n    assert candidate('123123') == '1'\n\ndef test_check():\n    check(first_repeated_char)\n\ntest_check()\n", "sample_io": ["assert first_repeated_char('abcabc') == 'a'"], "source_codes": ["\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n\n\n"], "responses": ["```python\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n```"], "prompt_tokens": [87], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_602_first_repeated_char"}
{"name": "mbpp_770_odd_num_sum", "language": "Python3", "prompt": "def odd_num_sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of fourth power of first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_num_sum", "test": "def check(candidate):\n    assert candidate(2) == 82\n    assert candidate(3) == 707\n    assert candidate(4) == 3108\n\ndef test_check():\n    check(odd_num_sum)\n\ntest_check()\n", "sample_io": ["assert odd_num_sum(2) == 82"], "source_codes": ["\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total\n\n\n"], "responses": ["```python\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total\n```"], "prompt_tokens": [82], "completion_tokens": [101], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_770_odd_num_sum"}
{"name": "mbpp_424_extract_rear", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n\tWrite a function to extract only the rear index element of each string in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_rear", "test": "def check(candidate):\n    assert candidate(('Mers', 'for', 'Vers')) == ['s', 'r', 's']\n    assert candidate(('Avenge', 'for', 'People')) == ['e', 'r', 'e']\n    assert candidate(('Gotta', 'get', 'go')) == ['a', 't', 'o']\n\ndef test_check():\n    check(extract_rear)\n\ntest_check()\n", "sample_io": ["assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"], "source_codes": ["\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [string[-1] for string in test_tuple]\n\n\n"], "responses": ["```python\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [string[-1] for string in test_tuple]\n```"], "prompt_tokens": [96], "completion_tokens": [59], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_424_extract_rear"}
{"name": "mbpp_133_sum_negativenum", "language": "Python3", "prompt": "from typing import List\n\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of the negative numbers of a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_negativenum", "test": "def check(candidate):\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32\n    assert candidate([10, 15, -14, 13, -18, 12, -20]) == -52\n    assert candidate([19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894\n\ndef test_check():\n    check(sum_negativenum)\n\ntest_check()\n", "sample_io": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"], "source_codes": ["\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n\n\n"], "responses": ["```python\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n```"], "prompt_tokens": [90], "completion_tokens": [56], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_133_sum_negativenum"}
{"name": "mbpp_760_unique_Element", "language": "Python3", "prompt": "from typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list of numbers contains only one distinct element or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_Element", "test": "def check(candidate):\n    assert candidate([1, 1, 1]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == False\n\ndef test_check():\n    check(unique_Element)\n\ntest_check()\n", "sample_io": ["assert unique_Element([1, 1, 1]) == True"], "source_codes": ["\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if all elements are the same, False otherwise\n    \"\"\"\n    if not arr:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if all elements are the same, False otherwise\n    \"\"\"\n    if not arr:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n```"], "prompt_tokens": [88], "completion_tokens": [101], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_760_unique_Element"}
{"name": "mbpp_281_all_unique", "language": "Python3", "prompt": "from typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check if the elements of a given list are unique or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_unique", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == True\n\ndef test_check():\n    check(all_unique)\n\ntest_check()\n", "sample_io": ["assert all_unique([1, 2, 3]) == True"], "source_codes": ["\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n\n\n"], "responses": ["```python\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n```"], "prompt_tokens": [88], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_281_all_unique"}
{"name": "mbpp_406_find_Parity", "language": "Python3", "prompt": "def find_Parity(x: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether the parity of a given number is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Parity", "test": "def check(candidate):\n    assert candidate(12) == False\n    assert candidate(7) == True\n    assert candidate(10) == False\n\ndef test_check():\n    check(find_Parity)\n\ntest_check()\n", "sample_io": ["assert find_Parity(12) == False"], "source_codes": ["\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the parity is odd, False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if even\n    return count % 2 == 1\n\n\n"], "responses": ["```python\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the parity is odd, False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if even\n    return count % 2 == 1\n```"], "prompt_tokens": [80], "completion_tokens": [172], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_406_find_Parity"}
{"name": "mbpp_562_Find_Max_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 4], [5, 6, 7, 8]]) == 4\n    assert candidate([[0, 1], [2, 2], [3, 2, 1]]) == 3\n    assert candidate([[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5\n\ndef test_check():\n    check(Find_Max_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"], "source_codes": ["\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        current_length = len(sublist)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        current_length = len(sublist)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n```"], "prompt_tokens": [85], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_562_Find_Max_Length"}
{"name": "mbpp_87_merge_dictionaries_three", "language": "Python3", "prompt": "from typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to merge three dictionaries into a single dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_dictionaries_three", "test": "def check(candidate):\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'L': 'lavender', 'B': 'Blue' }) == { 'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'L': 'lavender', 'B': 'Blue' }, { 'G': 'Green', 'W': 'White' }) == { 'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White' }\n\ndef test_check():\n    check(merge_dictionaries_three)\n\ntest_check()\n", "sample_io": ["assert merge_dictionaries_three({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }"], "source_codes": ["\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n\n\n"], "responses": ["```python\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n```"], "prompt_tokens": [105], "completion_tokens": [83], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_87_merge_dictionaries_three"}
{"name": "mbpp_11_remove_Occ", "language": "Python3", "prompt": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n\tWrite a python function to remove first and last occurrence of a given character from the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_Occ", "test": "def check(candidate):\n    assert candidate('hello', 'l') == 'heo'\n    assert candidate('abcda', 'a') == 'bcd'\n    assert candidate('PHP', 'P') == 'H'\n\ndef test_check():\n    check(remove_Occ)\n\ntest_check()\n", "sample_io": ["assert remove_Occ('hello', 'l') == 'heo'"], "source_codes": ["\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n\n\n"], "responses": ["```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [197], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_11_remove_Occ"}
{"name": "mbpp_751_check_min_heap", "language": "Python3", "prompt": "from typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_min_heap", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 10, 15]) == True\n    assert candidate([2, 10, 4, 5, 3, 15]) == False\n\ndef test_check():\n    check(check_min_heap)\n\ntest_check()\n", "sample_io": ["assert check_min_heap([1, 2, 3, 4, 5, 6]) == True"], "source_codes": ["\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap or not.\n    \n    In a min heap, for every parent node at index i:\n    - Left child is at index 2*i + 1\n    - Right child is at index 2*i + 2\n    - Parent value should be less than or equal to both children\n    \n    We only need to check up to the last parent node, which is at index (n//2 - 1)\n    \"\"\"\n    n = len(arr)\n    \n    # Check each parent node\n    for i in range(n // 2):\n        # Check left child\n        left_child_index = 2 * i + 1\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check right child\n        right_child_index = 2 * i + 2\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap or not.\n    \n    In a min heap, for every parent node at index i:\n    - Left child is at index 2*i + 1\n    - Right child is at index 2*i + 2\n    - Parent value should be less than or equal to both children\n    \n    We only need to check up to the last parent node, which is at index (n//2 - 1)\n    \"\"\"\n    n = len(arr)\n    \n    # Check each parent node\n    for i in range(n // 2):\n        # Check left child\n        left_child_index = 2 * i + 1\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check right child\n        right_child_index = 2 * i + 2\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [109], "completion_tokens": [223], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_751_check_min_heap"}
{"name": "mbpp_410_min_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 2\n    assert candidate(['Python', 15, 20, 25]) == 15\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 20\n\ndef test_check():\n    check(min_val)\n\ntest_check()\n", "sample_io": ["assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"], "source_codes": ["\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of the integer values\n    return min(int_values)\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of the integer values\n    return min(int_values)\n```"], "prompt_tokens": [90], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_410_min_val"}
{"name": "mbpp_578_interleave_lists", "language": "Python3", "prompt": "from typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to interleave 3 lists of the same length into a single flat list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "interleave_lists", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    assert candidate([10, 20], [15, 2], [5, 10]) == [10, 15, 5, 20, 2, 10]\n    assert candidate([11, 44], [10, 15], [20, 5]) == [11, 10, 20, 44, 15, 5]\n\ndef test_check():\n    check(interleave_lists)\n\ntest_check()\n", "sample_io": ["assert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"], "source_codes": ["\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n\n"], "responses": ["```python\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_578_interleave_lists"}
{"name": "mbpp_90_len_log", "language": "Python3", "prompt": "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "len_log", "test": "def check(candidate):\n    assert candidate(['python', 'PHP', 'bigdata']) == 7\n    assert candidate(['a', 'ab', 'abc']) == 3\n    assert candidate(['small', 'big', 'tall']) == 5\n\ndef test_check():\n    check(len_log)\n\ntest_check()\n", "sample_io": ["assert len_log(['python', 'PHP', 'bigdata']) == 7"], "source_codes": ["\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n```"], "prompt_tokens": [83], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_90_len_log"}
{"name": "mbpp_452_loss_amount", "language": "Python3", "prompt": "def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n\tWrite a function that gives loss amount on a sale if the given amount has loss else return 0.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "loss_amount", "test": "def check(candidate):\n    assert candidate(1500, 1200) == 0\n    assert candidate(100, 200) == 100\n    assert candidate(2000, 5000) == 3000\n\ndef test_check():\n    check(loss_amount)\n\ntest_check()\n", "sample_io": ["assert loss_amount(1500, 1200) == 0"], "source_codes": ["\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n```"], "prompt_tokens": [90], "completion_tokens": [70], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_452_loss_amount"}
{"name": "mbpp_798__sum", "language": "Python3", "prompt": "from typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([15, 12, 13, 10]) == 50\n    assert candidate([0, 1, 2]) == 3\n\ndef test_check():\n    check(_sum)\n\ntest_check()\n", "sample_io": ["assert _sum([1, 2, 3]) == 6"], "source_codes": ["\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    total = 0\n    for num in arr:\n        total += num\n    return total\n\n\n"], "responses": ["```python\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    total = 0\n    for num in arr:\n        total += num\n    return total\n```"], "prompt_tokens": [81], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_798__sum"}
{"name": "mbpp_393_max_length_list", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list with maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length_list", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5])\n    assert candidate([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9])\n\ndef test_check():\n    check(max_length_list)\n\ntest_check()\n", "sample_io": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = max(input_list, key=len)\n    return (len(max_list), max_list)\n\n\n"], "responses": ["```python\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = max(input_list, key=len)\n    return (len(max_list), max_list)\n```"], "prompt_tokens": [89], "completion_tokens": [107], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_393_max_length_list"}
{"name": "mbpp_272_rear_extract", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rear_extract", "test": "def check(candidate):\n    assert candidate([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n    assert candidate([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\n    assert candidate([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\n\ndef test_check():\n    check(rear_extract)\n\ntest_check()\n", "sample_io": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"], "source_codes": ["\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n\n\n"], "responses": ["```python\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n```"], "prompt_tokens": [101], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_272_rear_extract"}
{"name": "mbpp_564_count_Pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Pairs", "test": "def check(candidate):\n    assert candidate([1, 2, 1], 3) == 2\n    assert candidate([1, 1, 1, 1], 4) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 10\n\ndef test_check():\n    check(count_Pairs)\n\ntest_check()\n", "sample_io": ["assert count_Pairs([1, 2, 1], 3) == 2"], "source_codes": ["\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Total possible pairs = n * (n-1) / 2\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with same elements\n    same_element_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            same_element_pairs += count * (count - 1) // 2\n    \n    return total_pairs - same_element_pairs\n\n\n"], "responses": ["```python\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Total possible pairs = n * (n-1) / 2\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with same elements\n    same_element_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            same_element_pairs += count * (count - 1) // 2\n    \n    return total_pairs - same_element_pairs\n```"], "prompt_tokens": [98], "completion_tokens": [161], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_564_count_Pairs"}
{"name": "mbpp_438_count_bidirectional", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to count bidirectional tuple pairs.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_bidirectional", "test": "def check(candidate):\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3\n    assert candidate([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4\n\ndef test_check():\n    check(count_bidirectional)\n\ntest_check()\n", "sample_io": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3"], "source_codes": ["\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Count bidirectional tuple pairs in a list of tuples.\n    A bidirectional pair exists when both (a,b) and (b,a) are present in the list.\n    \"\"\"\n    # Convert list to set for O(1) lookup\n    tuple_set = set(test_list)\n    count = 0\n    \n    # For each tuple (a,b), check if (b,a) exists and a != b\n    for a, b in test_list:\n        if a != b and (b, a) in tuple_set:\n            count += 1\n    \n    # Since we count each pair twice ((a,b) and (b,a)), divide by 2\n    return count // 2\n\n\n"], "responses": ["```python\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Count bidirectional tuple pairs in a list of tuples.\n    A bidirectional pair exists when both (a,b) and (b,a) are present in the list.\n    \"\"\"\n    # Convert list to set for O(1) lookup\n    tuple_set = set(test_list)\n    count = 0\n    \n    # For each tuple (a,b), check if (b,a) exists and a != b\n    for a, b in test_list:\n        if a != b and (b, a) in tuple_set:\n            count += 1\n    \n    # Since we count each pair twice ((a,b) and (b,a)), divide by 2\n    return count // 2\n```"], "prompt_tokens": [87], "completion_tokens": [167], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_438_count_bidirectional"}
{"name": "mbpp_640_remove_parenthesis", "language": "Python3", "prompt": "from typing import List\n\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n\tWrite a function to remove the parenthesis and what is inbetween them from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_parenthesis", "test": "def check(candidate):\n    assert candidate(['python (chrome)']) == 'python'\n    assert candidate(['string(.abc)']) == 'string'\n    assert candidate(['alpha(num)']) == 'alpha'\n\ndef test_check():\n    check(remove_parenthesis)\n\ntest_check()\n", "sample_io": ["assert remove_parenthesis(['python (chrome)']) == 'python'"], "source_codes": ["\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove parentheses and their contents from strings in the list and join them.\n    \"\"\"\n    result = []\n    for item in items:\n        # Remove everything between parentheses including the parentheses\n        cleaned = \"\"\n        i = 0\n        while i < len(item):\n            if item[i] == '(':\n                # Skip until closing parenthesis\n                while i < len(item) and item[i] != ')':\n                    i += 1\n                # Skip the closing parenthesis\n                if i < len(item):\n                    i += 1\n            else:\n                cleaned += item[i]\n                i += 1\n        result.append(cleaned)\n    \n    return ' '.join(result)\n\n\n"], "responses": ["```python\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove parentheses and their contents from strings in the list and join them.\n    \"\"\"\n    result = []\n    for item in items:\n        # Remove everything between parentheses including the parentheses\n        cleaned = \"\"\n        i = 0\n        while i < len(item):\n            if item[i] == '(':\n                # Skip until closing parenthesis\n                while i < len(item) and item[i] != ')':\n                    i += 1\n                # Skip the closing parenthesis\n                if i < len(item):\n                    i += 1\n            else:\n                cleaned += item[i]\n                i += 1\n        result.append(cleaned)\n    \n    return ' '.join(result)\n```"], "prompt_tokens": [88], "completion_tokens": [157], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_640_remove_parenthesis"}
{"name": "mbpp_72_dif_Square", "language": "Python3", "prompt": "def dif_Square(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dif_Square", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(10) == False\n    assert candidate(15) == True\n\ndef test_check():\n    check(dif_Square)\n\ntest_check()\n", "sample_io": ["assert dif_Square(5) == True"], "source_codes": ["\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n \u2262 2 (mod 4)).\n    \n    This is because:\n    - If n = a\u00b2 - b\u00b2 = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even: n is divisible by 4\n    - If both are odd: n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n\n\n"], "responses": ["```python\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n \u2262 2 (mod 4)).\n    \n    This is because:\n    - If n = a\u00b2 - b\u00b2 = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even: n is divisible by 4\n    - If both are odd: n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n```"], "prompt_tokens": [86], "completion_tokens": [177], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_72_dif_Square"}
{"name": "mbpp_448_cal_sum", "language": "Python3", "prompt": "def cal_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of perrin numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cal_sum", "test": "def check(candidate):\n    assert candidate(9) == 49\n    assert candidate(10) == 66\n    assert candidate(11) == 88\n\ndef test_check():\n    check(cal_sum)\n\ntest_check()\n", "sample_io": ["assert cal_sum(9) == 49"], "source_codes": ["\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of P(0) + P(1) + P(2)\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to calculate the sum of Perrin numbers. The Perrin sequence is defined as:\n- P(0) = 3\n- P(1) = 0  \n- P(2) = 2\n- P(n) = P(n-2) + P(n-3) for n > 2\n\nLet me write a function to calculate the sum of the first n+1 Perrin numbers (from P(0) to P(n)).\n\n```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of P(0) + P(1) + P(2)\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n```"], "prompt_tokens": [76], "completion_tokens": [401], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_448_cal_sum"}
{"name": "mbpp_96_divisor", "language": "Python3", "prompt": "def divisor(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of divisors of a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisor", "test": "def check(candidate):\n    assert candidate(15) == 4\n    assert candidate(12) == 6\n    assert candidate(9) == 3\n\ndef test_check():\n    check(divisor)\n\ntest_check()\n", "sample_io": ["assert divisor(15) == 4"], "source_codes": ["\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n (int): The integer to find divisors for\n        \n    Returns:\n        int: The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n\n\n"], "responses": ["```python\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n (int): The integer to find divisors for\n        \n    Returns:\n        int: The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n```"], "prompt_tokens": [78], "completion_tokens": [160], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_96_divisor"}
{"name": "mbpp_296_get_Inv_Count", "language": "Python3", "prompt": "from typing import List\n\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count inversions in an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Inv_Count", "test": "def check(candidate):\n    assert candidate([1, 20, 6, 4, 5]) == 5\n    assert candidate([1, 2, 1]) == 1\n    assert candidate([1, 2, 5, 6, 1]) == 3\n\ndef test_check():\n    check(get_Inv_Count)\n\ntest_check()\n", "sample_io": ["assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"], "source_codes": ["\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n\n\n"], "responses": ["```python\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n```"], "prompt_tokens": [83], "completion_tokens": [427], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_296_get_Inv_Count"}
{"name": "mbpp_57_find_Max_Num", "language": "Python3", "prompt": "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest number that can be formed with the given list of digits.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Max_Num", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 321\n    assert candidate([4, 5, 6, 1]) == 6541\n    assert candidate([1, 2, 3, 9]) == 9321\n\ndef test_check():\n    check(find_Max_Num)\n\ntest_check()\n", "sample_io": ["assert find_Max_Num([1, 2, 3]) == 321"], "source_codes": ["\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest number that can be formed with the given list of digits.\n    \"\"\"\n    # Convert all digits to strings for easy comparison\n    str_arr = [str(digit) for digit in arr]\n    \n    # Sort the array in descending order based on string comparison\n    # We compare 'a' + 'b' vs 'b' + 'a' to determine which combination is larger\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all digits are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all digits to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n\n\n"], "responses": ["```python\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest number that can be formed with the given list of digits.\n    \"\"\"\n    # Convert all digits to strings for easy comparison\n    str_arr = [str(digit) for digit in arr]\n    \n    # Sort the array in descending order based on string comparison\n    # We compare 'a' + 'b' vs 'b' + 'a' to determine which combination is larger\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all digits are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all digits to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n```"], "prompt_tokens": [90], "completion_tokens": [184], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_57_find_Max_Num"}
{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n\n\n"], "responses": ["```python\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n```"], "prompt_tokens": [95], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n\n\n"], "responses": ["```python\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n```"], "prompt_tokens": [90], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're working with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d positions\n    # (n >> (32 - d)) gets the bits that would overflow and moves them to the right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n\n\n"], "responses": ["```python\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're working with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d positions\n    # (n >> (32 - d)) gets the bits that would overflow and moves them to the right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n```"], "prompt_tokens": [93], "completion_tokens": [155], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": ["\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D array to store results of subproblems\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for substrings of length 3 and more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n\n\n"], "responses": ["```python\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D array to store results of subproblems\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2\n    for i in range(n - 1):\n        if str[i] == str[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for substrings of length 3 and more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n```"], "prompt_tokens": [84], "completion_tokens": [266], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_247_lps"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all 1s in the middle positions\n    # We want to toggle bits from position 1 to num_bits-2 (0-indexed from right)\n    # This means we need a mask of (num_bits-2) bits set to 1, shifted left by 1\n    mask = ((1 << (num_bits - 2)) - 1) << 1\n    \n    # XOR with mask to toggle the middle bits\n    return n ^ mask\n\n\n"], "responses": ["Looking at this problem, I need to toggle all bits except the first (most significant) and last (least significant) bits.\n\nLet me think through the approach:\n1. First, I need to identify the positions of all bits in the number\n2. Create a mask that has 1s in all positions except the first and last bit\n3. XOR the number with this mask to toggle the middle bits\n\nFor example, if we have a 5-bit number like 10110:\n- First bit (MSB): 1\n- Last bit (LSB): 0  \n- Middle bits: 011\n- After toggling middle bits: 11000\n\nThe approach is to:\n1. Find the number of bits in n\n2. Create a mask with all 1s except first and last positions set to 0\n3. XOR with the mask\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all 1s in the middle positions\n    # We want to toggle bits from position 1 to num_bits-2 (0-indexed from right)\n    # This means we need a mask of (num_bits-2) bits set to 1, shifted left by 1\n    mask = ((1 << (num_bits - 2)) - 1) << 1\n    \n    # XOR with mask to toggle the middle bits\n    return n ^ mask\n```"], "prompt_tokens": [102], "completion_tokens": [370], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n\n\n"], "responses": ["```python\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n```"], "prompt_tokens": [82], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n\n\n"], "responses": ["```python\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n\n"], "responses": ["```python\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n```"], "prompt_tokens": [74], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
{"name": "mbpp_167_next_power_of_2", "language": "Python3", "prompt": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest power of 2 greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_power_of_2", "test": "def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 8\n    assert candidate(17) == 32\n\ndef test_check():\n    check(next_power_of_2)\n\ntest_check()\n", "sample_io": ["assert next_power_of_2(0) == 1"], "source_codes": ["\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    n += 1\n    \n    return n\n\n\n"], "responses": ["```python\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    n += 1\n    \n    return n\n```"], "prompt_tokens": [85], "completion_tokens": [181], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_167_next_power_of_2"}
{"name": "mbpp_756_text_match_zero_one", "language": "Python3", "prompt": "def text_match_zero_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_zero_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('dsabbbba') == True\n    assert candidate('asbbbba') == False\n    assert candidate('abaaa') == True\n\ndef test_check():\n    check(text_match_zero_one)\n\ntest_check()\n", "sample_io": ["assert text_match_zero_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [106], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_756_text_match_zero_one"}
{"name": "mbpp_633_pair_xor_Sum", "language": "Python3", "prompt": "from typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of xor of all pairs of numbers in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_xor_Sum", "test": "def check(candidate):\n    assert candidate([5, 9, 7, 6], 4) == 47\n    assert candidate([7, 3, 5], 3) == 12\n    assert candidate([7, 3], 2) == 4\n\ndef test_check():\n    check(pair_xor_Sum)\n\ntest_check()\n", "sample_io": ["assert pair_xor_Sum([5, 9, 7, 6], 4) == 47"], "source_codes": ["\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of XOR of all pairs of numbers in the given list.\n\nLet me think about this step by step:\n\n1. For each pair (i,j) where i < j, I need to calculate arr[i] XOR arr[j]\n2. Sum all these XOR results\n\nHowever, there's a more efficient approach using bit manipulation:\n- For each bit position, count how many numbers have that bit set to 1\n- For each bit position, the contribution to the final XOR sum is: count_of_ones * count_of_zeros * 2^bit_position\n- This works because XOR of two bits is 1 when they're different\n\nLet me implement the straightforward approach first, then optimize:\n\n```python\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [233], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_633_pair_xor_Sum"}
{"name": "mbpp_458_rectangle_area", "language": "Python3", "prompt": "def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to find the area of a rectangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rectangle_area", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(10, 5) == 50\n    assert candidate(4, 2) == 8\n\ndef test_check():\n    check(rectangle_area)\n\ntest_check()\n", "sample_io": ["assert rectangle_area(10, 20) == 200"], "source_codes": ["\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n\n\n"], "responses": ["```python\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n```"], "prompt_tokens": [78], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_458_rectangle_area"}
