{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n\n\n"], "responses": ["```python\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n```"], "prompt_tokens": [88], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n\n\n"], "responses": ["```python\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n```"], "prompt_tokens": [79], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n\n\n"], "responses": ["```python\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [108], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the second element (integer) in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) in each tuple\n    # and return the first K elements\n    return sorted(test_list, key=lambda x: x[1])[:K]\n\n\n"], "responses": ["```python\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the second element (integer) in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) in each tuple\n    # and return the first K elements\n    return sorted(test_list, key=lambda x: x[1])[:K]\n```"], "prompt_tokens": [129], "completion_tokens": [141], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check if the first character is a sign\n    start_index = 0\n    if text[0] in '+-':\n        # If string has only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n        start_index = 1\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check if the first character is a sign\n    start_index = 0\n    if text[0] in '+-':\n        # If string has only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n        start_index = 1\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n```"], "prompt_tokens": [77], "completion_tokens": [181], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n\n\n"], "responses": ["```python\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n```"], "prompt_tokens": [108], "completion_tokens": [118], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if sum equals the original number\n    return sum_of_powers == number\n\n\n"], "responses": ["```python\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if sum equals the original number\n    return sum_of_powers == number\n```"], "prompt_tokens": [79], "completion_tokens": [119], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total += int(char)\n    \n    return total\n\n\n"], "responses": ["```python\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total += int(char)\n    \n    return total\n```"], "prompt_tokens": [89], "completion_tokens": [109], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n\n\n"], "responses": ["```python\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n```"], "prompt_tokens": [125], "completion_tokens": [125], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    Where T is temperature in Celsius and V is wind velocity in km/h\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in Celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return int(math.ceil(wci))\n\n\n"], "responses": ["```python\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    Where T is temperature in Celsius and V is wind velocity in km/h\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in Celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return int(math.ceil(wci))\n```"], "prompt_tokens": [96], "completion_tokens": [229], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of last row (which is the nth Bell number)\n    return bell[n][0]\n\n\n"], "responses": ["```python\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of last row (which is the nth Bell number)\n    return bell[n][0]\n```"], "prompt_tokens": [73], "completion_tokens": [225], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n\n\n"], "responses": ["```python\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n```"], "prompt_tokens": [78], "completion_tokens": [87], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate itself\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n\n\n"], "responses": ["```python\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate itself\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n```"], "prompt_tokens": [92], "completion_tokens": [137], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n    Returns a tuple containing elements that are in either tuple but not in both.\n    \"\"\"\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple and return\n    return tuple(dissimilar)\n\n\n"], "responses": ["```python\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n    Returns a tuple containing elements that are in either tuple but not in both.\n    \"\"\"\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple and return\n    return tuple(dissimilar)\n```"], "prompt_tokens": [116], "completion_tokens": [144], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["\ndef find_length(string: str) -> int:\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        # Treat '0' as +1 and '1' as -1\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        \n        # Reset to 0 if current_diff becomes negative\n        # (we can always choose empty substring with diff = 0)\n        current_diff = max(current_diff, 0)\n        \n        # Update maximum difference\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum difference between the number of 0s and 1s in any substring of a binary string.\n\nThis is equivalent to finding the maximum sum of a subarray where:\n- Each '0' contributes +1 to the sum\n- Each '1' contributes -1 to the sum\n\nI can use Kadane's algorithm to find the maximum subarray sum:\n\n```python\ndef find_length(string: str) -> int:\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        # Treat '0' as +1 and '1' as -1\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        \n        # Reset to 0 if current_diff becomes negative\n        # (we can always choose empty substring with diff = 0)\n        current_diff = max(current_diff, 0)\n        \n        # Update maximum difference\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n```"], "prompt_tokens": [94], "completion_tokens": [222], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n\n\n"], "responses": ["```python\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n```"], "prompt_tokens": [119], "completion_tokens": [97], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    \"\"\"\n    stack = []\n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or brackets don't match, it's unbalanced\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n\n\n"], "responses": ["```python\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    \"\"\"\n    stack = []\n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or brackets don't match, it's unbalanced\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n```"], "prompt_tokens": [96], "completion_tokens": [181], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n```"], "prompt_tokens": [88], "completion_tokens": [93], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    The Lucas sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use iterative approach to avoid recursion overhead\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["```python\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    The Lucas sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use iterative approach to avoid recursion overhead\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n```"], "prompt_tokens": [77], "completion_tokens": [210], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert a snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join all words together\n    return ''.join(result)\n\n\n"], "responses": ["```python\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert a snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the first letter of subsequent words\n    result = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join all words together\n    return ''.join(result)\n```"], "prompt_tokens": [79], "completion_tokens": [103], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join back with spaces\n    return ' '.join(s.split()[::-1])\n\n\n"], "responses": ["```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join back with spaces\n    return ' '.join(s.split()[::-1])\n```"], "prompt_tokens": [78], "completion_tokens": [64], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "responses": ["```python\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n```"], "prompt_tokens": [75], "completion_tokens": [37], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str1 = str(abs(n1))\n    str2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    distance = 0\n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        distance += abs(digit1 - digit2)\n    \n    return distance\n\n\n"], "responses": ["```python\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str1 = str(abs(n1))\n    str2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    distance = 0\n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        distance += abs(digit1 - digit2)\n    \n    return distance\n```"], "prompt_tokens": [87], "completion_tokens": [164], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n```"], "prompt_tokens": [85], "completion_tokens": [63], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_143_find_lists"}
{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n\n\n"], "responses": ["```python\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n\n"], "responses": ["```python\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n```"], "prompt_tokens": [91], "completion_tokens": [184], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n\n\n"], "responses": ["```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n```"], "prompt_tokens": [86], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n\n\n"], "responses": ["```python\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n```"], "prompt_tokens": [90], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    result = []\n    \n    # For each element in the list\n    for i in range(len(l)):\n        # Get all combinations of length n-1\n        smaller_combinations = combinations_colors(l[i:], n-1)\n        \n        # Prepend current element to each smaller combination\n        for combo in smaller_combinations:\n            result.append([l[i]] + combo)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    result = []\n    \n    # For each element in the list\n    for i in range(len(l)):\n        # Get all combinations of length n-1\n        smaller_combinations = combinations_colors(l[i:], n-1)\n        \n        # Prepend current element to each smaller combination\n        for combo in smaller_combinations:\n            result.append([l[i]] + combo)\n    \n    return result\n```"], "prompt_tokens": [112], "completion_tokens": [174], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters and digits\n    chars = []\n    nums = []\n    \n    for char in test_str:\n        if char.isdigit():\n            nums.append(char)\n        else:\n            chars.append(char)\n    \n    # Combine characters first, then numbers\n    return ''.join(chars) + ''.join(nums)\n\n\n"], "responses": ["```python\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters and digits\n    chars = []\n    nums = []\n    \n    for char in test_str:\n        if char.isdigit():\n            nums.append(char)\n        else:\n            chars.append(char)\n    \n    # Combine characters first, then numbers\n    return ''.join(chars) + ''.join(nums)\n```"], "prompt_tokens": [80], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets to remove duplicates and enable set intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Find intersection and convert back to list\n    return list(set1 & set2)\n\n\n"], "responses": ["```python\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets to remove duplicates and enable set intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Find intersection and convert back to list\n    return list(set1 & set2)\n```"], "prompt_tokens": [90], "completion_tokens": [131], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occurrences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n\n\n"], "responses": ["```python\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occurrences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n```"], "prompt_tokens": [100], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n\n\n"], "responses": ["```python\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n```"], "prompt_tokens": [95], "completion_tokens": [264], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    The nth tetrahedral number is the sum of the first n triangular numbers,\n    or equivalently, it can be calculated using the formula:\n    T(n) = n * (n + 1) * (n + 2) / 6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "responses": ["```python\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    The nth tetrahedral number is the sum of the first n triangular numbers,\n    or equivalently, it can be calculated using the formula:\n    T(n) = n * (n + 1) * (n + 2) / 6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n```"], "prompt_tokens": [77], "completion_tokens": [126], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": ["\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    \n    # Generate all possible non-empty combinations\n    for r in range(1, len(test_list) + 1):\n        for combo in combinations(test_list, r):\n            # Calculate element-wise sum of all tuples in this combination\n            sum_tuple = [0, 0]\n            for tuple_item in combo:\n                sum_tuple[0] += tuple_item[0]\n                sum_tuple[1] += tuple_item[1]\n            result.append((sum_tuple[0], sum_tuple[1]))\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find combinations of sums with tuples in the given tuple list. Based on the reference link, this appears to be about finding all possible combinations of tuples and calculating their element-wise sums.\n\nLet me think through this step by step:\n\n1. I need to generate all possible non-empty combinations of tuples from the input list\n2. For each combination, calculate the element-wise sum of all tuples in that combination\n3. Return all these sum tuples\n\n```python\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    \n    # Generate all possible non-empty combinations\n    for r in range(1, len(test_list) + 1):\n        for combo in combinations(test_list, r):\n            # Calculate element-wise sum of all tuples in this combination\n            sum_tuple = [0, 0]\n            for tuple_item in combo:\n                sum_tuple[0] += tuple_item[0]\n                sum_tuple[1] += tuple_item[1]\n            result.append((sum_tuple[0], sum_tuple[1]))\n    \n    return result\n```"], "prompt_tokens": [120], "completion_tokens": [276], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "responses": ["```python\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has only one bit set)\n    # A number is power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n\n\n"], "responses": ["```python\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has only one bit set)\n    # A number is power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n```"], "prompt_tokens": [90], "completion_tokens": [166], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    # Check if the month number is valid (1-12) and has 30 days\n    if 1 <= monthnum3 <= 12:\n        return monthnum3 in months_with_30_days\n    else:\n        return False\n\n\n"], "responses": ["```python\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    # Check if the month number is valid (1-12) and has 30 days\n    if 1 <= monthnum3 <= 12:\n        return monthnum3 in months_with_30_days\n    else:\n        return False\n```"], "prompt_tokens": [98], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["```python\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n```"], "prompt_tokens": [87], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n    Create the next bigger number by rearranging the digits of a given number.\n    If no such number exists, return None.\n    \"\"\"\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit found, no bigger permutation exists\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n\n\n"], "responses": ["```python\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n    Create the next bigger number by rearranging the digits of a given number.\n    If no such number exists, return None.\n    \"\"\"\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit found, no bigger permutation exists\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n```"], "prompt_tokens": [89], "completion_tokens": [244], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 1:\n            memo[num] = num\n            return num\n        \n        # Calculate the sum of breaking down into parts\n        breakdown_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum between keeping the number or breaking it down\n        result = max(num, breakdown_sum)\n        memo[num] = result\n        return result\n    \n    return f(n)\n\n\n"], "responses": ["Looking at this problem, I need to implement a recursive function with memoization to find the maximum sum using the given equation.\n\nThe function f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n) means:\n- Either take n as is\n- Or break it down into parts and sum up their maximum values\n\nI'll use dynamic programming with memoization to avoid recalculating values.\n\n```python\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num <= 1:\n            memo[num] = num\n            return num\n        \n        # Calculate the sum of breaking down into parts\n        breakdown_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum between keeping the number or breaking it down\n        result = max(num, breakdown_sum)\n        memo[num] = result\n        return result\n    \n    return f(n)\n```"], "prompt_tokens": [110], "completion_tokens": [233], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we couldn't find both even and odd numbers\n    return 0\n\n\n"], "responses": ["```python\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we couldn't find both even and odd numbers\n    return 0\n```"], "prompt_tokens": [89], "completion_tokens": [150], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # Check the original string\n    if s[-1] == '1':\n        count += 1\n    \n    # Check each rotation\n    for i in range(1, min(n, length)):\n        # After i left rotations, the character at position i (0-indexed) becomes the last character\n        if s[i] == '1':\n            count += 1\n    \n    return count\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Understand what \"rotating a binary string\" means - it typically means shifting characters left or right\n2. For each rotation, convert the binary string to a decimal number and check if it's odd\n3. Count how many rotations result in odd numbers\n\nLet me think about this step by step:\n- A binary number is odd if its last digit is '1'\n- When we rotate left, the first character moves to the end\n- When we rotate right, the last character moves to the front\n- I'll assume left rotation based on common interpretation\n\nFor each rotation position, I'll check if the last digit is '1' (making the number odd).\n\n```python\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # Check the original string\n    if s[-1] == '1':\n        count += 1\n    \n    # Check each rotation\n    for i in range(1, min(n, length)):\n        # After i left rotations, the character at position i (0-indexed) becomes the last character\n        if s[i] == '1':\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [304], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n\n\n"], "responses": ["```python\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n```"], "prompt_tokens": [89], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n\n\n"], "responses": ["```python\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n```"], "prompt_tokens": [114], "completion_tokens": [135], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n (int): The position of the nonagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2\n\n\n"], "responses": ["```python\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n (int): The position of the nonagonal number to find (1-indexed)\n        \n    Returns:\n        int: The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2\n```"], "prompt_tokens": [75], "completion_tokens": [133], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": ["\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n\u00b2 - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n\n\n"], "responses": ["```python\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n\u00b2 - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n```"], "prompt_tokens": [75], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_59_is_octagonal"}
