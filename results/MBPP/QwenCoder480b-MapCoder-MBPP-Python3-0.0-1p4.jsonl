{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n (int): Dividend\n        m (int): Divisor\n    \n    Returns:\n        int: Quotient rounded down to nearest integer\n        \n    Raises:\n        ZeroDivisionError: If divisor is zero\n    \"\"\"\n    return n // m\n\n\n"], "responses": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n (int): Dividend\n        m (int): Divisor\n    \n    Returns:\n        int: Quotient rounded down to nearest integer\n        \n    Raises:\n        ZeroDivisionError: If divisor is zero\n    \"\"\"\n    return n // m\n\n\n"], "prompt_tokens": [1322], "completion_tokens": [621], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": ["\nfrom typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n    Write a function to get all lucid numbers smaller than or equal to a given integer.\n    \"\"\"\n    # Handle edge cases\n    if n < 1:\n        return []\n    \n    # Initialize list with numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    \n    # Start with index 0 (number 1) as the first ludic number\n    index = 0\n    \n    # Process the list iteratively\n    while index < len(numbers):\n        # Get the current ludic number (step size)\n        step = numbers[index]\n        \n        # If step is 1, we just move to the next number\n        if step == 1:\n            index += 1\n            continue\n        \n        # Remove every step-th element starting from the step-th position\n        # We start from index 'step' (0-based indexing) and remove every 'step' elements\n        i = index + step\n        while i < len(numbers):\n            numbers.pop(i)\n            i += step - 1  # Adjust for the removed element\n        \n        # Move to the next unprocessed number\n        index += 1\n    \n    return numbers\n\n\n"], "responses": ["\nfrom typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n    Write a function to get all lucid numbers smaller than or equal to a given integer.\n    \"\"\"\n    # Handle edge cases\n    if n < 1:\n        return []\n    \n    # Initialize list with numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    \n    # Start with index 0 (number 1) as the first ludic number\n    index = 0\n    \n    # Process the list iteratively\n    while index < len(numbers):\n        # Get the current ludic number (step size)\n        step = numbers[index]\n        \n        # If step is 1, we just move to the next number\n        if step == 1:\n            index += 1\n            continue\n        \n        # Remove every step-th element starting from the step-th position\n        # We start from index 'step' (0-based indexing) and remove every 'step' elements\n        i = index + step\n        while i < len(numbers):\n            numbers.pop(i)\n            i += step - 1  # Adjust for the removed element\n        \n        # Move to the next unprocessed number\n        index += 1\n    \n    return numbers\n\n\n"], "prompt_tokens": [1919], "completion_tokens": [1353], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    total_sum = 0\n    n = len(arr)\n    \n    # Generate all possible subarrays\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    \n    return total_sum\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    total_sum = 0\n    n = len(arr)\n    \n    # Generate all possible subarrays\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    \n    return total_sum\n\n\n"], "prompt_tokens": [2127], "completion_tokens": [1184], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Pattern to match quoted strings, handling escaped quotes\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*)\"'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n"], "responses": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Pattern to match quoted strings, handling escaped quotes\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*)\"'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n"], "prompt_tokens": [2675], "completion_tokens": [1234], "no_of_try": 1, "api_calls": 6, "is_solved": true, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n\n"], "responses": ["\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n\n"], "prompt_tokens": [2197], "completion_tokens": [913], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    \n    for element in data_list:\n        if isinstance(element, int):\n            # Base case: if element is an integer, add it to total\n            total += element\n        elif isinstance(element, list):\n            # Recursive case: if element is a list, recursively sum its elements\n            total += recursive_list_sum(element)\n    \n    return total\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    \n    for element in data_list:\n        if isinstance(element, int):\n            # Base case: if element is an integer, add it to total\n            total += element\n        elif isinstance(element, list):\n            # Recursive case: if element is a list, recursively sum its elements\n            total += recursive_list_sum(element)\n    \n    return total\n\n\n"], "prompt_tokens": [1626], "completion_tokens": [848], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to eliminate duplicates\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation\n    union_set = set1 | set2\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to eliminate duplicates\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation\n    union_set = set1 | set2\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "prompt_tokens": [1665], "completion_tokens": [854], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.match(pattern, string))\n\n\n"], "responses": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.match(pattern, string))\n\n\n"], "prompt_tokens": [1460], "completion_tokens": [811], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1445], "completion_tokens": [873], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize with the first element\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Calculate new max and min products\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update the global maximum\n        result = max(result, max_product)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize with the first element\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Calculate new max and min products\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update the global maximum\n        result = max(result, max_product)\n    \n    return result\n\n\n"], "prompt_tokens": [1796], "completion_tokens": [1129], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Handle edge cases\n    if n == 0:\n        return False\n    \n    # Find first occurrence of x using binary search\n    def find_first_occurrence():\n        left, right = 0, n - 1\n        first_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_pos = mid\n                right = mid - 1  # Continue searching in left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return first_pos\n    \n    # Find last occurrence of x using binary search\n    def find_last_occurrence():\n        left, right = 0, n - 1\n        last_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_pos = mid\n                left = mid + 1  # Continue searching in right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return last_pos\n    \n    # Find first and last positions\n    first = find_first_occurrence()\n    \n    # If element is not found\n    if first == -1:\n        return False\n    \n    last = find_last_occurrence()\n    \n    # Calculate count of occurrences\n    count = last - first + 1\n    \n    # Check if count is greater than n/2\n    return count > n // 2\n\n\n"], "responses": ["\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Handle edge cases\n    if n == 0:\n        return False\n    \n    # Find first occurrence of x using binary search\n    def find_first_occurrence():\n        left, right = 0, n - 1\n        first_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_pos = mid\n                right = mid - 1  # Continue searching in left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return first_pos\n    \n    # Find last occurrence of x using binary search\n    def find_last_occurrence():\n        left, right = 0, n - 1\n        last_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_pos = mid\n                left = mid + 1  # Continue searching in right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return last_pos\n    \n    # Find first and last positions\n    first = find_first_occurrence()\n    \n    # If element is not found\n    if first == -1:\n        return False\n    \n    last = find_last_occurrence()\n    \n    # Calculate count of occurrences\n    count = last - first + 1\n    \n    # Check if count is greater than n/2\n    return count > n // 2\n\n\n"], "prompt_tokens": [2225], "completion_tokens": [1371], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "responses": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "prompt_tokens": [1366], "completion_tokens": [692], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    # Handle edge case of empty list\n    if not list_:\n        return []\n    \n    # Use list comprehension to convert each element to string and apply format\n    return [string.format(str(element)) for element in list_]\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    # Handle edge case of empty list\n    if not list_:\n        return []\n    \n    # Use list comprehension to convert each element to string and apply format\n    return [string.format(str(element)) for element in list_]\n\n\n"], "prompt_tokens": [1820], "completion_tokens": [1143], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    # Handle edge case of empty string\n    if not s:\n        return True\n    \n    # Select the first character as reference\n    reference_char = s[0]\n    \n    # Iterate through each character and compare with reference\n    for char in s:\n        if char != reference_char:\n            return False\n    \n    return True\n\n\n"], "responses": ["\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    # Handle edge case of empty string\n    if not s:\n        return True\n    \n    # Select the first character as reference\n    reference_char = s[0]\n    \n    # Iterate through each character and compare with reference\n    for char in s:\n        if char != reference_char:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1492], "completion_tokens": [853], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": ["\nfrom typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    # Iterate through odd indices only\n    for i in range(1, len(nums), 2):\n        # Check if the number at odd index is even\n        if nums[i] % 2 == 0:\n            return False\n    \n    # If we've checked all odd indices and found no even numbers, return True\n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    # Iterate through odd indices only\n    for i in range(1, len(nums), 2):\n        # Check if the number at odd index is even\n        if nums[i] % 2 == 0:\n            return False\n    \n    # If we've checked all odd indices and found no even numbers, return True\n    return True\n\n\n"], "prompt_tokens": [1787], "completion_tokens": [913], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k == 0:\n        return input\n    \n    # Validate k parameter\n    if k < 0 or k > len(input):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    \n    # Slice the array into two parts and reverse the first part\n    return input[:k][::-1] + input[k:]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k == 0:\n        return input\n    \n    # Validate k parameter\n    if k < 0 or k > len(input):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    \n    # Slice the array into two parts and reverse the first part\n    return input[:k][::-1] + input[k:]\n\n\n"], "prompt_tokens": [1780], "completion_tokens": [945], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["\nfrom typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    return max(nums) - min(nums)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    return max(nums) - min(nums)\n\n\n"], "prompt_tokens": [1606], "completion_tokens": [843], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    \"\"\"\n    Write a function to flatten a given nested list structure.\n    \"\"\"\n    result = []\n    \n    for element in list1:\n        if isinstance(element, int):\n            result.append(element)\n        elif isinstance(element, list):\n            result.extend(flatten_list(element))\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    \"\"\"\n    Write a function to flatten a given nested list structure.\n    \"\"\"\n    result = []\n    \n    for element in list1:\n        if isinstance(element, int):\n            result.append(element)\n        elif isinstance(element, list):\n            result.extend(flatten_list(element))\n    \n    return result\n\n\n"], "prompt_tokens": [4158], "completion_tokens": [2518], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 and not test_tup2:\n        return []\n    \n    # Validate dimensions\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Lists must have the same number of rows\")\n    \n    result = []\n    \n    for i in range(len(test_tup1)):\n        # Validate that corresponding rows have the same length\n        if len(test_tup1[i]) != len(test_tup2[i]):\n            raise ValueError(\"Corresponding rows must have the same number of columns\")\n        \n        row_result = []\n        for j in range(len(test_tup1[i])):\n            # Multiply corresponding elements\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row_result.append(product)\n        \n        result.append(row_result)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 and not test_tup2:\n        return []\n    \n    # Validate dimensions\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Lists must have the same number of rows\")\n    \n    result = []\n    \n    for i in range(len(test_tup1)):\n        # Validate that corresponding rows have the same length\n        if len(test_tup1[i]) != len(test_tup2[i]):\n            raise ValueError(\"Corresponding rows must have the same number of columns\")\n        \n        row_result = []\n        for j in range(len(test_tup1[i])):\n            # Multiply corresponding elements\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row_result.append(product)\n        \n        result.append(row_result)\n    \n    return result\n\n\n"], "prompt_tokens": [1798], "completion_tokens": [990], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes for better efficiency\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    \n    # Count the number of True values in the sieve\n    return sum(sieve)\n\n\n"], "responses": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes for better efficiency\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as not prime\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    \n    # Count the number of True values in the sieve\n    return sum(sieve)\n\n\n"], "prompt_tokens": [1843], "completion_tokens": [1198], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle negative indices by converting them to positive equivalents\n    if m < 0:\n        m = len(list1) + m\n    if n < 0:\n        n = len(list1) + n\n    \n    # Ensure indices are within bounds\n    m = max(0, min(m, len(list1) - 1))\n    n = max(0, min(n, len(list1) - 1))\n    \n    # Swap if m > n\n    if m > n:\n        m, n = n, m\n    \n    # Calculate sum of elements from index m to n (inclusive)\n    return sum(list1[m:n+1])\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle negative indices by converting them to positive equivalents\n    if m < 0:\n        m = len(list1) + m\n    if n < 0:\n        n = len(list1) + n\n    \n    # Ensure indices are within bounds\n    m = max(0, min(m, len(list1) - 1))\n    n = max(0, min(n, len(list1) - 1))\n    \n    # Swap if m > n\n    if m > n:\n        m, n = n, m\n    \n    # Calculate sum of elements from index m to n (inclusive)\n    return sum(list1[m:n+1])\n\n\n"], "prompt_tokens": [1585], "completion_tokens": [1318], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())\n\n\n"], "responses": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())\n\n\n"], "prompt_tokens": [1444], "completion_tokens": [722], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    # Get lengths of the three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Initialize a 3D DP array with all zeros\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table using bottom-up approach\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take maximum of three possible subsequences\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude current character from X\n                        dp[i][j-1][k],    # Exclude current character from Y\n                        dp[i][j][k-1]     # Exclude current character from Z\n                    )\n    \n    # Return the length of LCS for full strings\n    return dp[m][n][o]\n\n\n"], "responses": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    # Get lengths of the three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Initialize a 3D DP array with all zeros\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table using bottom-up approach\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take maximum of three possible subsequences\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude current character from X\n                        dp[i][j-1][k],    # Exclude current character from Y\n                        dp[i][j][k-1]     # Exclude current character from Z\n                    )\n    \n    # Return the length of LCS for full strings\n    return dp[m][n][o]\n\n\n"], "prompt_tokens": [2136], "completion_tokens": [1360], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": ["\nfrom typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "prompt_tokens": [1353], "completion_tokens": [562], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "prompt_tokens": [1958], "completion_tokens": [906], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["\nfrom typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Write a function to convert a given tuple of positive integers into a single integer.\n    \"\"\"\n    # Convert each integer to string and concatenate them\n    concatenated = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated)\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Write a function to convert a given tuple of positive integers into a single integer.\n    \"\"\"\n    # Convert each integer to string and concatenate them\n    concatenated = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated)\n\n\n"], "prompt_tokens": [1451], "completion_tokens": [874], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Write a python function to find the first digit of a given number.\n    \"\"\"\n    # Handle the edge case where the input number is 0\n    if n == 0:\n        return 0\n    \n    # Convert the absolute value of the number to a string\n    str_n = str(abs(n))\n    \n    # Extract the first character and convert it back to an integer\n    first_digit = int(str_n[0])\n    \n    return first_digit\n\n\n"], "responses": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Write a python function to find the first digit of a given number.\n    \"\"\"\n    # Handle the edge case where the input number is 0\n    if n == 0:\n        return 0\n    \n    # Convert the absolute value of the number to a string\n    str_n = str(abs(n))\n    \n    # Extract the first character and convert it back to an integer\n    first_digit = int(str_n[0])\n    \n    return first_digit\n\n\n"], "prompt_tokens": [1045], "completion_tokens": [767], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n\n\n"], "responses": ["\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n\n\n"], "prompt_tokens": [1363], "completion_tokens": [837], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": ["\nfrom typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n        \n    Returns:\n        Minimum difference between any two elements\n        \n    Raises:\n        ValueError: If array has fewer than 2 elements\n    \"\"\"\n    # Handle edge case where array has fewer than 2 elements\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to bring potential minimum differences together\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Iterate through adjacent elements and calculate differences\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n        \n    Returns:\n        Minimum difference between any two elements\n        \n    Raises:\n        ValueError: If array has fewer than 2 elements\n    \"\"\"\n    # Handle edge case where array has fewer than 2 elements\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to bring potential minimum differences together\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Iterate through adjacent elements and calculate differences\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "prompt_tokens": [1847], "completion_tokens": [1264], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    # Handle edge cases\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Initialize heap with the first pair (smallest sum)\n    # Heap stores: (sum, index_in_nums1, index_in_nums2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Keep track of visited pairs to avoid duplicates\n    visited = {(0, 0)}\n    result = []\n    \n    # Extract minimum k times or until heap is empty\n    while heap and len(result) < k:\n        # Get the pair with smallest sum\n        current_sum, i, j = heapq.heappop(heap)\n        # Add the actual pair values to result\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        # Move one step in nums1 (i+1, j)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        # Move one step in nums2 (i, j+1)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    # Handle edge cases\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Initialize heap with the first pair (smallest sum)\n    # Heap stores: (sum, index_in_nums1, index_in_nums2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Keep track of visited pairs to avoid duplicates\n    visited = {(0, 0)}\n    result = []\n    \n    # Extract minimum k times or until heap is empty\n    while heap and len(result) < k:\n        # Get the pair with smallest sum\n        current_sum, i, j = heapq.heappop(heap)\n        # Add the actual pair values to result\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        # Move one step in nums1 (i+1, j)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        # Move one step in nums2 (i, j+1)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "prompt_tokens": [2075], "completion_tokens": [1391], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    # Handle edge cases\n    if not str1:\n        return str1\n    \n    result = []\n    \n    for i, char in enumerate(str1):\n        # If it's an uppercase letter and not the first character, add a space before it\n        if char.isupper() and i > 0:\n            # Check if the previous character is not a space (to avoid double spaces)\n            if result and result[-1] != ' ':\n                result.append(' ')\n        \n        result.append(char)\n    \n    return ''.join(result)\n\n\n"], "responses": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    # Handle edge cases\n    if not str1:\n        return str1\n    \n    result = []\n    \n    for i, char in enumerate(str1):\n        # If it's an uppercase letter and not the first character, add a space before it\n        if char.isupper() and i > 0:\n            # Check if the previous character is not a space (to avoid double spaces)\n            if result and result[-1] != ' ':\n                result.append(' ')\n        \n        result.append(char)\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [1483], "completion_tokens": [752], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_252_convert"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    result = []\n    for num in list1:\n        if num < 0:\n            result.append(num)\n    return result\n\n\n"], "responses": ["\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    result = []\n    for num in list1:\n        if num < 0:\n            result.append(num)\n    return result\n\n\n"], "prompt_tokens": [1139], "completion_tokens": [651], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n        \n    Returns:\n        float: The median value of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))\n\n\n"], "responses": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n        \n    Returns:\n        float: The median value of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))\n\n\n"], "prompt_tokens": [1582], "completion_tokens": [895], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Find all possible combinations of the elements of a given list.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not list1:\n        return [[]]\n    \n    result = []\n    n = len(list1)\n    \n    # Generate all possible combinations using bit manipulation\n    # For each number from 0 to 2^n - 1\n    for i in range(2**n):\n        combination = []\n        # Check each bit position from left to right (MSB to LSB)\n        for j in range(n-1, -1, -1):\n            # If the (n-1-j)-th bit is set, include the j-th element\n            if i & (1 << (n-1-j)):\n                combination.append(list1[j])\n        result.append(combination)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Find all possible combinations of the elements of a given list.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not list1:\n        return [[]]\n    \n    result = []\n    n = len(list1)\n    \n    # Generate all possible combinations using bit manipulation\n    # For each number from 0 to 2^n - 1\n    for i in range(2**n):\n        combination = []\n        # Check each bit position from left to right (MSB to LSB)\n        for j in range(n-1, -1, -1):\n            # If the (n-1-j)-th bit is set, include the j-th element\n            if i & (1 << (n-1-j)):\n                combination.append(list1[j])\n        result.append(combination)\n    \n    return result\n\n\n"], "prompt_tokens": [3658], "completion_tokens": [2974], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "prompt_tokens": [1675], "completion_tokens": [782], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Split the string into words using whitespace as delimiter\n    # This automatically handles multiple consecutive spaces\n    words = str.split()\n    \n    # Filter words that have length greater than n\n    result = [word for word in words if len(word) > n]\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Split the string into words using whitespace as delimiter\n    # This automatically handles multiple consecutive spaces\n    words = str.split()\n    \n    # Filter words that have length greater than n\n    result = [word for word in words if len(word) > n]\n    \n    return result\n\n\n"], "prompt_tokens": [1542], "completion_tokens": [757], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge cases\n    if not s:  # Empty sublist is always a sublist\n        return True\n    \n    if len(s) > len(l):  # Sublist longer than main list\n        return False\n    \n    if len(s) == len(l):  # Same length, check for direct equality\n        return l == s\n    \n    # Sliding window approach\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    \n    return False\n\n\n"], "responses": ["\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge cases\n    if not s:  # Empty sublist is always a sublist\n        return True\n    \n    if len(s) > len(l):  # Sublist longer than main list\n        return False\n    \n    if len(s) == len(l):  # Same length, check for direct equality\n        return l == s\n    \n    # Sliding window approach\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    \n    return False\n\n\n"], "prompt_tokens": [2183], "completion_tokens": [1158], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": ["\nfrom typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Handle edge cases: if either list is empty, return False\n    if not list1 or not list2:\n        return False\n    \n    # Optimize by using the smaller list for set creation\n    if len(list1) <= len(list2):\n        smaller_list, larger_list = list1, list2\n    else:\n        smaller_list, larger_list = list2, list1\n    \n    # Create a set from the smaller list for O(1) lookups\n    smaller_set = set(smaller_list)\n    \n    # Check if any element in the larger list exists in the set\n    for element in larger_list:\n        if element in smaller_set:\n            return True\n    \n    # No common elements found\n    return False\n\n\n"], "responses": ["\nfrom typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Handle edge cases: if either list is empty, return False\n    if not list1 or not list2:\n        return False\n    \n    # Optimize by using the smaller list for set creation\n    if len(list1) <= len(list2):\n        smaller_list, larger_list = list1, list2\n    else:\n        smaller_list, larger_list = list2, list1\n    \n    # Create a set from the smaller list for O(1) lookups\n    smaller_set = set(smaller_list)\n    \n    # Check if any element in the larger list exists in the set\n    for element in larger_list:\n        if element in smaller_set:\n            return True\n    \n    # No common elements found\n    return False\n\n\n"], "prompt_tokens": [1848], "completion_tokens": [1015], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    # Use regex to replace spaces, commas, or dots with colons\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "responses": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    # Use regex to replace spaces, commas, or dots with colons\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "prompt_tokens": [1378], "completion_tokens": [614], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": ["\nfrom typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list using pancake sorting algorithm and returns the sorted list.\n    \n    Args:\n        nums: List of integers to be sorted\n        \n    Returns:\n        List of sorted integers\n    \"\"\"\n    # Handle edge cases\n    if len(nums) <= 1:\n        return nums[:]\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    n = len(arr)\n    \n    # Work from the end of the array towards the beginning\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted portion (0 to i)\n        max_idx = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        \n        # If the maximum element is already in its correct position, skip\n        if max_idx == i:\n            continue\n            \n        # If max element is not at the front, flip to bring it to the front\n        if max_idx != 0:\n            # Perform the flip\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n        \n        # Flip from 0 to i to move max element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n    \n    return arr\n\n\n"], "responses": ["\nfrom typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list using pancake sorting algorithm and returns the sorted list.\n    \n    Args:\n        nums: List of integers to be sorted\n        \n    Returns:\n        List of sorted integers\n    \"\"\"\n    # Handle edge cases\n    if len(nums) <= 1:\n        return nums[:]\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    n = len(arr)\n    \n    # Work from the end of the array towards the beginning\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted portion (0 to i)\n        max_idx = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        \n        # If the maximum element is already in its correct position, skip\n        if max_idx == i:\n            continue\n            \n        # If max element is not at the front, flip to bring it to the front\n        if max_idx != 0:\n            # Perform the flip\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n        \n        # Flip from 0 to i to move max element to its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n    \n    return arr\n\n\n"], "prompt_tokens": [2878], "completion_tokens": [2043], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["\nfrom typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Calculate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # If N is greater than the number of products, adjust N\n    N = min(N, len(products))\n    \n    # Use a min-heap to keep track of the N largest products\n    heap = []\n    for product in products:\n        if len(heap) < N:\n            heapq.heappush(heap, product)\n        else:\n            if product > heap[0]:\n                heapq.heapreplace(heap, product)\n    \n    # Extract elements from heap and sort in descending order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    # Reverse to get descending order\n    result.reverse()\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Calculate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # If N is greater than the number of products, adjust N\n    N = min(N, len(products))\n    \n    # Use a min-heap to keep track of the N largest products\n    heap = []\n    for product in products:\n        if len(heap) < N:\n            heapq.heappush(heap, product)\n        else:\n            if product > heap[0]:\n                heapq.heapreplace(heap, product)\n    \n    # Extract elements from heap and sort in descending order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    # Reverse to get descending order\n    result.reverse()\n    \n    return result\n\n\n"], "prompt_tokens": [2084], "completion_tokens": [1211], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, concatenate with the input list, then convert back to tuple\n    result = list(test_tup) + test_list\n    return tuple(result)\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, concatenate with the input list, then convert back to tuple\n    result = list(test_tup) + test_list\n    return tuple(result)\n\n\n"], "prompt_tokens": [1686], "completion_tokens": [1011], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n\n\n"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n\n\n"], "prompt_tokens": [1866], "completion_tokens": [886], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
