{"name": "mbpp_395_first_non_repeating_character", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first non-repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_non_repeating_character", "test": "def check(candidate):\n    assert candidate('abcabc') == None\n    assert candidate('abc') == 'a'\n    assert candidate('ababc') == 'c'\n\ndef test_check():\n    check(first_non_repeating_character)\n\ntest_check()\n", "sample_io": ["assert first_non_repeating_character('abcabc') == None"], "source_codes": ["\nfrom typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Handle edge case: if input string is empty, return None immediately\n    if not str1:\n        return None\n    \n    # Create a dictionary to count the frequency of each character\n    char_count = {}\n    \n    # First pass: count frequency of each character\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: find the first character with frequency 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None\n\n\n"], "responses": ["\nfrom typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Handle edge case: if input string is empty, return None immediately\n    if not str1:\n        return None\n    \n    # Create a dictionary to count the frequency of each character\n    char_count = {}\n    \n    # First pass: count frequency of each character\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: find the first character with frequency 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None\n\n\n"], "prompt_tokens": [1521], "completion_tokens": [1113], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_395_first_non_repeating_character"}
{"name": "mbpp_457_Find_Min", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min", "test": "def check(candidate):\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert candidate([[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1]\n    assert candidate([['x'], ['x', 'y'], ['x', 'y', 'z']]) == ['x']\n\ndef test_check():\n    check(Find_Min)\n\ntest_check()\n", "sample_io": ["assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"], "source_codes": ["\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return min(lst, key=len)\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return min(lst, key=len)\n\n\n"], "prompt_tokens": [1862], "completion_tokens": [951], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_457_Find_Min"}
{"name": "mbpp_725_extract_quotation", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks \" \" of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_quotation", "test": "def check(candidate):\n    assert candidate('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    assert candidate('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']\n    assert candidate('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']\n    assert candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == []\n\ndef test_check():\n    check(extract_quotation)\n\ntest_check()\n", "sample_io": ["assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"], "source_codes": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Pattern to match text between double quotes, including escaped quotes\n    pattern = r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"'\n    \n    # Find all matched quoted strings\n    matches = re.findall(pattern, text1)\n    \n    # Handle unmatched quotes - if there's an odd number of quotes,\n    # treat everything after the last quote as a quoted string\n    quote_count = text1.count('\"')\n    if quote_count % 2 == 1:\n        # Find the last quote position\n        last_quote_pos = text1.rfind('\"')\n        # Extract everything after the last quote\n        remaining_text = text1[last_quote_pos + 1:]\n        if remaining_text:\n            matches.append(remaining_text)\n    \n    return matches\n\n\n"], "responses": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Pattern to match text between double quotes, including escaped quotes\n    pattern = r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"'\n    \n    # Find all matched quoted strings\n    matches = re.findall(pattern, text1)\n    \n    # Handle unmatched quotes - if there's an odd number of quotes,\n    # treat everything after the last quote as a quoted string\n    quote_count = text1.count('\"')\n    if quote_count % 2 == 1:\n        # Find the last quote position\n        last_quote_pos = text1.rfind('\"')\n        # Extract everything after the last quote\n        remaining_text = text1[last_quote_pos + 1:]\n        if remaining_text:\n            matches.append(remaining_text)\n    \n    return matches\n\n\n"], "prompt_tokens": [1498], "completion_tokens": [959], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_725_extract_quotation"}
{"name": "mbpp_9_find_Rotations", "language": "Python3", "prompt": "def find_Rotations(str: str) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Rotations", "test": "def check(candidate):\n    assert candidate('aaaa') == 1\n    assert candidate('ab') == 2\n    assert candidate('abc') == 3\n\ndef test_check():\n    check(find_Rotations)\n\ntest_check()\n", "sample_io": ["assert find_Rotations('aaaa') == 1"], "source_codes": ["\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    # Handle edge cases\n    if len(str) <= 1:\n        return 1\n    \n    # Concatenate the string with itself\n    double_str = str + str\n    \n    # Find the first occurrence of the original string in the double string, starting from index 1\n    # This avoids matching the string at position 0, which would correspond to 0 rotations\n    return double_str.find(str, 1)\n\n\n"], "responses": ["\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    # Handle edge cases\n    if len(str) <= 1:\n        return 1\n    \n    # Concatenate the string with itself\n    double_str = str + str\n    \n    # Find the first occurrence of the original string in the double string, starting from index 1\n    # This avoids matching the string at position 0, which would correspond to 0 rotations\n    return double_str.find(str, 1)\n\n\n"], "prompt_tokens": [1431], "completion_tokens": [1017], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_9_find_Rotations"}
{"name": "mbpp_792_count_list", "language": "Python3", "prompt": "from typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of lists in a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    assert candidate([[1, 2], [2, 3], [4, 5]]) == 3\n    assert candidate([[1, 0], [2, 0]]) == 2\n\ndef test_check():\n    check(count_list)\n\ntest_check()\n", "sample_io": ["assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"], "source_codes": ["\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)\n\n\n"], "responses": ["\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)\n\n\n"], "prompt_tokens": [1409], "completion_tokens": [747], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_792_count_list"}
{"name": "mbpp_477_is_lower", "language": "Python3", "prompt": "def is_lower(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert the given string to lower case.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_lower", "test": "def check(candidate):\n    assert candidate('InValid') == 'invalid'\n    assert candidate('TruE') == 'true'\n    assert candidate('SenTenCE') == 'sentence'\n\ndef test_check():\n    check(is_lower)\n\ntest_check()\n", "sample_io": ["assert is_lower('InValid') == 'invalid'"], "source_codes": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "responses": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "prompt_tokens": [280], "completion_tokens": [258], "no_of_try": 1, "api_calls": 2, "is_solved": true, "task_id": "mbpp_477_is_lower"}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "Python3", "prompt": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n\tWrite a python function to find the average of cubes of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Average_Of_Cube", "test": "def check(candidate):\n    assert candidate(2) == 4.5\n    assert candidate(3) == 12\n    assert candidate(1) == 1\n\ndef test_check():\n    check(find_Average_Of_Cube)\n\ntest_check()\n", "sample_io": ["assert find_Average_Of_Cube(2) == 4.5"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_422_find_Average_Of_Cube"}
{"name": "mbpp_637_noprofit_noloss", "language": "Python3", "prompt": "def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given amount has no profit and no loss\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "noprofit_noloss", "test": "def check(candidate):\n    assert candidate(1500, 1200) == False\n    assert candidate(100, 100) == True\n    assert candidate(2000, 5000) == False\n\ndef test_check():\n    check(noprofit_noloss)\n\ntest_check()\n", "sample_io": ["assert noprofit_noloss(1500, 1200) == False"], "source_codes": ["\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n\n\n"], "responses": ["\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n\n\n"], "prompt_tokens": [1863], "completion_tokens": [866], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_637_noprofit_noloss"}
{"name": "mbpp_557_toggle_string", "language": "Python3", "prompt": "def toggle_string(string: str) -> str:\n    \"\"\"\n\tWrite a function to toggle the case of all characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_string", "test": "def check(candidate):\n    assert candidate('Python') == 'pYTHON'\n    assert candidate('Pangram') == 'pANGRAM'\n    assert candidate('LIttLE') == 'liTTle'\n\ndef test_check():\n    check(toggle_string)\n\ntest_check()\n", "sample_io": ["assert toggle_string('Python') == 'pYTHON'"], "source_codes": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    # Handle edge case of empty string\n    if not string:\n        return string\n    \n    # Build the result string by processing each character\n    result = []\n    for char in string:\n        if char.isupper():\n            result.append(char.lower())\n        elif char.islower():\n            result.append(char.upper())\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n\n"], "responses": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    # Handle edge case of empty string\n    if not string:\n        return string\n    \n    # Build the result string by processing each character\n    result = []\n    for char in string:\n        if char.isupper():\n            result.append(char.lower())\n        elif char.islower():\n            result.append(char.upper())\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [1504], "completion_tokens": [834], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_557_toggle_string"}
{"name": "mbpp_786_right_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the right insertion point for a specified value in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "right_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(right_insertion)\n\ntest_check()\n", "sample_io": ["assert right_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\nfrom typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to find the insertion point for\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order,\n        positioned after any existing occurrences of x\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n\n"], "responses": ["\nfrom typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to find the insertion point for\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order,\n        positioned after any existing occurrences of x\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n\n"], "prompt_tokens": [1871], "completion_tokens": [978], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_786_right_insertion"}
{"name": "mbpp_807_first_odd", "language": "Python3", "prompt": "from typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the first odd number in a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5]) == 1\n    assert candidate([2, 4, 1, 3]) == 1\n    assert candidate([8, 9, 1]) == 9\n\ndef test_check():\n    check(first_odd)\n\ntest_check()\n", "sample_io": ["assert first_odd([1, 3, 5]) == 1"], "source_codes": ["\nfrom typing import List, Optional\n\ndef first_odd(nums: List[int]) -> Optional[int]:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list, or None if no odd number is found\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None\n\n\n"], "responses": ["\nfrom typing import List, Optional\n\ndef first_odd(nums: List[int]) -> Optional[int]:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list, or None if no odd number is found\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None\n\n\n"], "prompt_tokens": [1509], "completion_tokens": [883], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_807_first_odd"}
{"name": "mbpp_631_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace whitespaces with an underscore and vice versa in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert candidate('The_Avengers') == 'The Avengers'\n    assert candidate('Fast and Furious') == 'Fast_and_Furious'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"], "source_codes": ["\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    # Use a temporary placeholder that's unlikely to appear in normal text\n    placeholder = \"\\x00\"\n    \n    # First, replace spaces with placeholder\n    text = text.replace(' ', placeholder)\n    \n    # Then, replace underscores with spaces\n    text = text.replace('_', ' ')\n    \n    # Finally, replace placeholder with underscores\n    text = text.replace(placeholder, '_')\n    \n    return text\n\n\n"], "responses": ["\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    # Use a temporary placeholder that's unlikely to appear in normal text\n    placeholder = \"\\x00\"\n    \n    # First, replace spaces with placeholder\n    text = text.replace(' ', placeholder)\n    \n    # Then, replace underscores with spaces\n    text = text.replace('_', ' ')\n    \n    # Finally, replace placeholder with underscores\n    text = text.replace(placeholder, '_')\n    \n    return text\n\n\n"], "prompt_tokens": [1392], "completion_tokens": [753], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_631_replace_spaces"}
{"name": "mbpp_573_unique_product", "language": "Python3", "prompt": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to calculate the product of the unique numbers in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_product", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    assert candidate([1, 2, 3, 1]) == 6\n    assert candidate([7, 8, 9, 0, 1, 1]) == 0\n\ndef test_check():\n    check(unique_product)\n\ntest_check()\n", "sample_io": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"], "source_codes": ["\nfrom typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a python function to calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Convert list to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Handle edge case: empty set\n    if not unique_numbers:\n        return 1\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n\n\n"], "responses": ["\nfrom typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a python function to calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Convert list to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Handle edge case: empty set\n    if not unique_numbers:\n        return 1\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n\n\n"], "prompt_tokens": [1519], "completion_tokens": [892], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_573_unique_product"}
{"name": "mbpp_643_text_match_wordz_middle", "language": "Python3", "prompt": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks if a strings contains 'z', except at the start and end of the word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz_middle", "test": "def check(candidate):\n    assert candidate('pythonzabc.') == True\n    assert candidate('zxyabc.') == False\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz_middle)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz_middle('pythonzabc.') == True"], "source_codes": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Handle edge cases: empty string or less than 3 characters\n    if len(text) < 3:\n        return False\n    \n    # Extract the middle portion (excluding first and last characters)\n    middle_portion = text[1:-1]\n    \n    # Check if 'z' exists in the middle portion\n    return 'z' in middle_portion\n\n\n"], "responses": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Handle edge cases: empty string or less than 3 characters\n    if len(text) < 3:\n        return False\n    \n    # Extract the middle portion (excluding first and last characters)\n    middle_portion = text[1:-1]\n    \n    # Check if 'z' exists in the middle portion\n    return 'z' in middle_portion\n\n\n"], "prompt_tokens": [1794], "completion_tokens": [853], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_643_text_match_wordz_middle"}
{"name": "mbpp_299_max_aggregate", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n\tWrite a function to calculate the maximum aggregate from the list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_aggregate", "test": "def check(candidate):\n    assert candidate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)\n    assert candidate([('Juan Whelan', 50), ('Sabah Colley', 48), ('Peter Nichols', 37), ('Juan Whelan', 22), ('Sabah Colley', 14)]) == ('Juan Whelan', 72)\n    assert candidate([('Juan Whelan', 10), ('Sabah Colley', 20), ('Peter Nichols', 30), ('Juan Whelan', 40), ('Sabah Colley', 50)]) == ('Sabah Colley', 70)\n\ndef test_check():\n    check(max_aggregate)\n\ntest_check()\n", "sample_io": ["assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return None\n    \n    # Initialize dictionary to store aggregate sums\n    aggregates = {}\n    \n    # Calculate aggregate sums for each string key\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    # Find the key with maximum aggregate sum\n    max_key = max(aggregates, key=aggregates.get)\n    max_value = aggregates[max_key]\n    \n    return (max_key, max_value)\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return None\n    \n    # Initialize dictionary to store aggregate sums\n    aggregates = {}\n    \n    # Calculate aggregate sums for each string key\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    # Find the key with maximum aggregate sum\n    max_key = max(aggregates, key=aggregates.get)\n    max_value = aggregates[max_key]\n    \n    return (max_key, max_value)\n\n\n"], "prompt_tokens": [1661], "completion_tokens": [1045], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_299_max_aggregate"}
{"name": "mbpp_474_replace_char", "language": "Python3", "prompt": "def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n\tWrite a function to replace characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_char", "test": "def check(candidate):\n    assert candidate('polygon', 'y', 'l') == 'pollgon'\n    assert candidate('character', 'c', 'a') == 'aharaater'\n    assert candidate('python', 'l', 'a') == 'python'\n\ndef test_check():\n    check(replace_char)\n\ntest_check()\n", "sample_io": ["assert replace_char('polygon', 'y', 'l') == 'pollgon'"], "source_codes": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: Check if input string is empty\n    if not str1:\n        return \"\"\n    \n    # Validate input parameters: Ensure ch and newch are single characters\n    if len(ch) != 1 or len(newch) != 1:\n        raise ValueError(\"Both ch and newch must be single characters\")\n    \n    # Use built-in string replace() method to replace all occurrences of ch with newch\n    result = str1.replace(ch, newch)\n    \n    # Return the resulting string\n    return result\n\n\n"], "responses": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: Check if input string is empty\n    if not str1:\n        return \"\"\n    \n    # Validate input parameters: Ensure ch and newch are single characters\n    if len(ch) != 1 or len(newch) != 1:\n        raise ValueError(\"Both ch and newch must be single characters\")\n    \n    # Use built-in string replace() method to replace all occurrences of ch with newch\n    result = str1.replace(ch, newch)\n    \n    # Return the resulting string\n    return result\n\n\n"], "prompt_tokens": [1520], "completion_tokens": [771], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_474_replace_char"}
{"name": "mbpp_433_check_greater", "language": "Python3", "prompt": "from typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the entered number is greater than the elements of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_greater", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 4) == False\n    assert candidate([2, 3, 4, 5, 6], 8) == True\n    assert candidate([9, 7, 4, 8, 6, 1], 11) == True\n\ndef test_check():\n    check(check_greater)\n\ntest_check()\n", "sample_io": ["assert check_greater([1, 2, 3, 4, 5], 4) == False"], "source_codes": ["\nfrom typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: If array is empty, return True\n    if not arr:\n        return True\n    \n    # Check if number is greater than all elements\n    for element in arr:\n        if number <= element:\n            return False\n    \n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: If array is empty, return True\n    if not arr:\n        return True\n    \n    # Check if number is greater than all elements\n    for element in arr:\n        if number <= element:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1779], "completion_tokens": [1073], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_433_check_greater"}
{"name": "mbpp_427_change_date_format", "language": "Python3", "prompt": "def change_date_format(dt: str) -> str:\n    \"\"\"\n\tWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "change_date_format", "test": "def check(candidate):\n    assert candidate('2026-01-02') == '02-01-2026'\n    assert candidate('2020-11-13') == '13-11-2020'\n    assert candidate('2021-04-26') == '26-04-2021'\n\ndef test_check():\n    check(change_date_format)\n\ntest_check()\n", "sample_io": ["assert change_date_format('2026-01-02') == '02-01-2026'"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_427_change_date_format"}
{"name": "mbpp_442_positive_count", "language": "Python3", "prompt": "from typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n\tWrite a function to find the ration of positive numbers in an array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "positive_count", "test": "def check(candidate):\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54\n    assert candidate([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56\n\ndef test_check():\n    check(positive_count)\n\ntest_check()\n", "sample_io": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"], "source_codes": ["\nfrom typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of positive numbers in an array of integers.\n    \"\"\"\n    # Handle the edge case of an empty list\n    if not nums:\n        return 0.0\n    \n    # Count positive numbers\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    \n    # Calculate and return the ratio\n    return positive_count / len(nums)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Write a function to find the ratio of positive numbers in an array of integers.\n    \"\"\"\n    # Handle the edge case of an empty list\n    if not nums:\n        return 0.0\n    \n    # Count positive numbers\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    \n    # Calculate and return the ratio\n    return positive_count / len(nums)\n\n\n"], "prompt_tokens": [3346], "completion_tokens": [1505], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_442_positive_count"}
{"name": "mbpp_453_sumofFactors", "language": "Python3", "prompt": "def sumofFactors(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even factors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sumofFactors", "test": "def check(candidate):\n    assert candidate(18) == 26\n    assert candidate(30) == 48\n    assert candidate(6) == 8\n\ndef test_check():\n    check(sumofFactors)\n\ntest_check()\n", "sample_io": ["assert sumofFactors(18) == 26"], "source_codes": ["\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Initialize sum of even factors\n    sum_even_factors = 0\n    \n    # Iterate through potential factors up to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:  # If i is a factor\n            # Check if i is even\n            if i % 2 == 0:\n                sum_even_factors += i\n            \n            # Check if the corresponding factor (n/i) is different and even\n            if i != n // i and (n // i) % 2 == 0:\n                sum_even_factors += n // i\n        \n        i += 1\n    \n    return sum_even_factors\n\n\n"], "responses": ["\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Initialize sum of even factors\n    sum_even_factors = 0\n    \n    # Iterate through potential factors up to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:  # If i is a factor\n            # Check if i is even\n            if i % 2 == 0:\n                sum_even_factors += i\n            \n            # Check if the corresponding factor (n/i) is different and even\n            if i != n // i and (n // i) % 2 == 0:\n                sum_even_factors += n // i\n        \n        i += 1\n    \n    return sum_even_factors\n\n\n"], "prompt_tokens": [1636], "completion_tokens": [1118], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_453_sumofFactors"}
{"name": "mbpp_478_remove_lowercase", "language": "Python3", "prompt": "def remove_lowercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove lowercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_lowercase", "test": "def check(candidate):\n    assert candidate('PYTHon') == 'PYTH'\n    assert candidate('FInD') == 'FID'\n    assert candidate('STRinG') == 'STRG'\n\ndef test_check():\n    check(remove_lowercase)\n\ntest_check()\n", "sample_io": ["assert remove_lowercase('PYTHon') == 'PYTH'"], "source_codes": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())\n\n\n"], "responses": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())\n\n\n"], "prompt_tokens": [1538], "completion_tokens": [712], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_478_remove_lowercase"}
{"name": "mbpp_18_remove_dirty_chars", "language": "Python3", "prompt": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n\tWrite a function to remove characters from the first string which are present in the second string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_dirty_chars", "test": "def check(candidate):\n    assert candidate('probasscurve', 'pros') == 'bacuve'\n    assert candidate('digitalindia', 'talent') == 'digiidi'\n    assert candidate('exoticmiles', 'toxic') == 'emles'\n\ndef test_check():\n    check(remove_dirty_chars)\n\ntest_check()\n", "sample_io": ["assert remove_dirty_chars('probasscurve', 'pros') == 'bacuve'"], "source_codes": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Collect characters that are not in the removal set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    # Join the result list into a string and return\n    return ''.join(result)\n\n\n"], "responses": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Collect characters that are not in the removal set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    # Join the result list into a string and return\n    return ''.join(result)\n\n\n"], "prompt_tokens": [1616], "completion_tokens": [954], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_18_remove_dirty_chars"}
{"name": "mbpp_730_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function to remove consecutive duplicates of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd', 'a', 'a']) == ['a', 'b', 'c', 'd', 'a']\n\ndef test_check():\n    check(consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"], "source_codes": ["\nfrom typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function to remove consecutive duplicates of a given list.\n    \"\"\"\n    # Handle edge case: If input list is empty, return empty list immediately\n    if not nums:\n        return []\n    \n    # Initialize result list with first element\n    result = [nums[0]]\n    \n    # Iterate through input list starting from second element\n    for i in range(1, len(nums)):\n        # Compare current element with last element in result\n        if nums[i] != result[-1]:\n            # If different, append to result\n            result.append(nums[i])\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function to remove consecutive duplicates of a given list.\n    \"\"\"\n    # Handle edge case: If input list is empty, return empty list immediately\n    if not nums:\n        return []\n    \n    # Initialize result list with first element\n    result = [nums[0]]\n    \n    # Iterate through input list starting from second element\n    for i in range(1, len(nums)):\n        # Compare current element with last element in result\n        if nums[i] != result[-1]:\n            # If different, append to result\n            result.append(nums[i])\n    \n    return result\n\n\n"], "prompt_tokens": [2027], "completion_tokens": [1170], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_730_consecutive_duplicates"}
{"name": "mbpp_446_count_Occurrence", "language": "Python3", "prompt": "from typing import Any, List\n\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n\tWrite a python function to count the occurence of all elements of list in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Occurrence", "test": "def check(candidate):\n    assert candidate(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    assert candidate((1, 2, 3, 1, 4, 6, 7, 1, 4), [1, 4, 7]) == 6\n    assert candidate((1, 2, 3, 4, 5, 6), [1, 2]) == 2\n\ndef test_check():\n    check(count_Occurrence)\n\ntest_check()\n", "sample_io": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"], "source_codes": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    total_count = 0\n    for element in lst:\n        total_count += tup.count(element)\n    return total_count\n\n\n"], "responses": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    total_count = 0\n    for element in lst:\n        total_count += tup.count(element)\n    return total_count\n\n\n"], "prompt_tokens": [1833], "completion_tokens": [924], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_446_count_Occurrence"}
{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Handle empty string case\n    if not test_str.strip():\n        return \"\"\n    \n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return \" \".join(filtered_words)\n\n\n"], "responses": ["\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Handle empty string case\n    if not test_str.strip():\n        return \"\"\n    \n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return \" \".join(filtered_words)\n\n\n"], "prompt_tokens": [1097], "completion_tokens": [957], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \"\"\"\n    # Handle base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize previous two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Compute Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \"\"\"\n    # Handle base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize previous two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Compute Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "prompt_tokens": [2163], "completion_tokens": [1188], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return 0\n    \n    # Initialize min and max with first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the array to find min and max\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    \n    # Return the maximum absolute difference\n    return max_val - min_val\n\n\n"], "responses": ["\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return 0\n    \n    # Initialize min and max with first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the array to find min and max\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    \n    # Return the maximum absolute difference\n    return max_val - min_val\n\n\n"], "prompt_tokens": [1553], "completion_tokens": [892], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove numbers that appear more than once from a given list.\n    \n    Args:\n        nums: A list of integers that may contain duplicates\n        \n    Returns:\n        A list of integers that appear exactly once in the input list,\n        preserving their original order\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that appear exactly once, preserving order\n    result = []\n    for num in nums:\n        if count_dict[num] == 1:\n            result.append(num)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove numbers that appear more than once from a given list.\n    \n    Args:\n        nums: A list of integers that may contain duplicates\n        \n    Returns:\n        A list of integers that appear exactly once in the input list,\n        preserving their original order\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that appear exactly once, preserving order\n    result = []\n    for num in nums:\n        if count_dict[num] == 1:\n            result.append(num)\n    \n    return result\n\n\n"], "prompt_tokens": [2067], "completion_tokens": [1167], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, then multiply them to get the total\n    number of pairs with odd XOR.\n    \"\"\"\n    if N < 2:\n        return 0\n    \n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, then multiply them to get the total\n    number of pairs with odd XOR.\n    \"\"\"\n    if N < 2:\n        return 0\n    \n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n\n\n"], "prompt_tokens": [1676], "completion_tokens": [1060], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The highest power of 2 that is less than or equal to n\n        \n    Raises:\n        ValueError: If n is less than 1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Find the position of the most significant bit\n    # This is equivalent to floor(log2(n))\n    msb_position = n.bit_length() - 1\n    \n    # Return 2 raised to the power of msb_position\n    return 1 << msb_position\n\n\n"], "responses": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The highest power of 2 that is less than or equal to n\n        \n    Raises:\n        ValueError: If n is less than 1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Find the position of the most significant bit\n    # This is equivalent to floor(log2(n))\n    msb_position = n.bit_length() - 1\n    \n    # Return 2 raised to the power of msb_position\n    return 1 << msb_position\n\n\n"], "prompt_tokens": [1725], "completion_tokens": [1242], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    # Handle edge cases\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    result = []\n    \n    # Process common rows only\n    min_rows = min(len(test_tup1), len(test_tup2))\n    \n    for i in range(min_rows):\n        row1 = test_tup1[i]\n        row2 = test_tup2[i]\n        \n        # Handle empty sublists\n        if not row1 or not row2:\n            result.append([])\n            continue\n        \n        # Process common columns only\n        min_cols = min(len(row1), len(row2))\n        new_row = []\n        \n        for j in range(min_cols):\n            new_row.append(row1[j] + row2[j])\n        \n        result.append(new_row)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    # Handle edge cases\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    result = []\n    \n    # Process common rows only\n    min_rows = min(len(test_tup1), len(test_tup2))\n    \n    for i in range(min_rows):\n        row1 = test_tup1[i]\n        row2 = test_tup2[i]\n        \n        # Handle empty sublists\n        if not row1 or not row2:\n            result.append([])\n            continue\n        \n        # Process common columns only\n        min_cols = min(len(row1), len(row2))\n        new_row = []\n        \n        for j in range(min_cols):\n            new_row.append(row1[j] + row2[j])\n        \n        result.append(new_row)\n    \n    return result\n\n\n"], "prompt_tokens": [1687], "completion_tokens": [1097], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_401_add_nested_tuples"}
{"name": "mbpp_435_last_Digit", "language": "Python3", "prompt": "def last_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit", "test": "def check(candidate):\n    assert candidate(123) == 3\n    assert candidate(25) == 5\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit)\n\ntest_check()\n", "sample_io": ["assert last_Digit(123) == 3"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_435_last_Digit"}
{"name": "mbpp_611_max_of_nth", "language": "Python3", "prompt": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n\tWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_of_nth", "test": "def check(candidate):\n    assert candidate([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    assert candidate([[6, 7, 8], [2, 4, 6], [9, 10, 20]], 1) == 10\n    assert candidate([[7, 8, 9], [3, 5, 7], [10, 11, 21]], 1) == 11\n\ndef test_check():\n    check(max_of_nth)\n\ntest_check()\n", "sample_io": ["assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"], "source_codes": ["\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Check if the matrix is empty\n    if not test_list:\n        raise ValueError(\"Matrix is empty\")\n    \n    # Extract the N-th column elements from rows that have enough elements\n    column_elements = [row[N] for row in test_list if len(row) > N]\n    \n    # Check if we have any elements in the column\n    if not column_elements:\n        raise IndexError(\"Column index out of range\")\n    \n    # Return the maximum value in the column\n    return max(column_elements)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Check if the matrix is empty\n    if not test_list:\n        raise ValueError(\"Matrix is empty\")\n    \n    # Extract the N-th column elements from rows that have enough elements\n    column_elements = [row[N] for row in test_list if len(row) > N]\n    \n    # Check if we have any elements in the column\n    if not column_elements:\n        raise IndexError(\"Column index out of range\")\n    \n    # Return the maximum value in the column\n    return max(column_elements)\n\n\n"], "prompt_tokens": [1999], "completion_tokens": [1255], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_611_max_of_nth"}
{"name": "mbpp_280_sequential_search", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n\tWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequential_search", "test": "def check(candidate):\n    assert candidate([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)\n    assert candidate([12, 32, 45, 62, 35, 47, 44, 61], 61) == (True, 7)\n    assert candidate([9, 10, 17, 19, 22, 39, 48, 56], 48) == (True, 6)\n\ndef test_check():\n    check(sequential_search)\n\ntest_check()\n", "sample_io": ["assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    # Handle edge case of empty array\n    if not dlist:\n        return (False, -1)\n    \n    # Iterate through each element in the array\n    for index, element in enumerate(dlist):\n        # If match found, return True and current index\n        if element == item:\n            return (True, index)\n    \n    # If loop completes without finding match, return False and -1\n    return (False, -1)\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    # Handle edge case of empty array\n    if not dlist:\n        return (False, -1)\n    \n    # Iterate through each element in the array\n    for index, element in enumerate(dlist):\n        # If match found, return True and current index\n        if element == item:\n            return (True, index)\n    \n    # If loop completes without finding match, return False and -1\n    return (False, -1)\n\n\n"], "prompt_tokens": [1950], "completion_tokens": [953], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_280_sequential_search"}
{"name": "mbpp_576_is_Sub_Array", "language": "Python3", "prompt": "from typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list is sublist of another or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sub_Array", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 5], [1, 2]) == False\n    assert candidate([1, 2, 1], [1, 2, 1]) == True\n    assert candidate([1, 0, 2, 2], [2, 2, 0]) == False\n\ndef test_check():\n    check(is_Sub_Array)\n\ntest_check()\n", "sample_io": ["assert is_Sub_Array([1, 4, 3, 5], [1, 2]) == False"], "source_codes": ["\nfrom typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether a list is sublist of another or not.\n    \"\"\"\n    # Handle edge cases\n    if not B:  # Empty list is a sublist of any list\n        return True\n    \n    if len(B) > len(A):  # B cannot be a sublist if it's longer than A\n        return False\n    \n    # Use sliding window approach\n    for i in range(len(A) - len(B) + 1):\n        # Check if B matches the subarray of A starting at index i\n        if A[i:i+len(B)] == B:\n            return True\n    \n    return False\n\n\n"], "responses": ["\nfrom typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether a list is sublist of another or not.\n    \"\"\"\n    # Handle edge cases\n    if not B:  # Empty list is a sublist of any list\n        return True\n    \n    if len(B) > len(A):  # B cannot be a sublist if it's longer than A\n        return False\n    \n    # Use sliding window approach\n    for i in range(len(A) - len(B) + 1):\n        # Check if B matches the subarray of A starting at index i\n        if A[i:i+len(B)] == B:\n            return True\n    \n    return False\n\n\n"], "prompt_tokens": [1943], "completion_tokens": [1046], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_576_is_Sub_Array"}
{"name": "mbpp_131_reverse_vowels", "language": "Python3", "prompt": "def reverse_vowels(str1: str) -> str:\n    \"\"\"\n\tWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_vowels", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('USA') == 'ASU'\n    assert candidate('ab') == 'ab'\n\ndef test_check():\n    check(reverse_vowels)\n\ntest_check()\n", "sample_io": ["assert reverse_vowels('Python') == 'Python'"], "source_codes": ["\ndef reverse_vowels(str1: str) -> str:\n    \"\"\"\n    Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n    \"\"\"\n    if not str1:\n        return str1\n    \n    # Convert string to list for mutable operations\n    chars = list(str1)\n    \n    # Define vowels set for O(1) lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Two pointers approach\n    left = 0\n    right = len(chars) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and chars[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and chars[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    \n    # Convert back to string and return\n    return ''.join(chars)\n\n\n"], "responses": ["\ndef reverse_vowels(str1: str) -> str:\n    \"\"\"\n    Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n    \"\"\"\n    if not str1:\n        return str1\n    \n    # Convert string to list for mutable operations\n    chars = list(str1)\n    \n    # Define vowels set for O(1) lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Two pointers approach\n    left = 0\n    right = len(chars) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and chars[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and chars[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    \n    # Convert back to string and return\n    return ''.join(chars)\n\n\n"], "prompt_tokens": [1416], "completion_tokens": [896], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_131_reverse_vowels"}
{"name": "mbpp_432_median_trapezium", "language": "Python3", "prompt": "def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n\tWrite a function to find the median length of a trapezium.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_trapezium", "test": "def check(candidate):\n    assert candidate(15, 25, 35) == 20\n    assert candidate(10, 20, 30) == 15\n    assert candidate(6, 9, 4) == 7.5\n\ndef test_check():\n    check(median_trapezium)\n\ntest_check()\n", "sample_io": ["assert median_trapezium(15, 25, 35) == 20"], "source_codes": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides. Its length equals the average of the lengths \n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium (not used in calculation)\n        \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2\n\n\n"], "responses": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides. Its length equals the average of the lengths \n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium (not used in calculation)\n        \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2\n\n\n"], "prompt_tokens": [1619], "completion_tokens": [854], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_432_median_trapezium"}
{"name": "mbpp_161_remove_elements", "language": "Python3", "prompt": "from typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to remove all elements from a given list present in another list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_elements", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]\n\ndef test_check():\n    check(remove_elements)\n\ntest_check()\n", "sample_io": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"], "source_codes": ["\nfrom typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [element for element in list1 if element not in set2]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [element for element in list1 if element not in set2]\n\n\n"], "prompt_tokens": [1803], "completion_tokens": [896], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_161_remove_elements"}
{"name": "mbpp_597_find_kth", "language": "Python3", "prompt": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find kth element from the given two sorted arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_kth", "test": "def check(candidate):\n    assert candidate([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    assert candidate([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256\n    assert candidate([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8\n\ndef test_check():\n    check(find_kth)\n\ntest_check()\n", "sample_io": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"], "source_codes": ["\nfrom typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Handle edge cases where one array is empty\n    if not arr1:\n        return arr2[k - 1]\n    if not arr2:\n        return arr1[k - 1]\n    \n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Binary search on the smaller array\n    low, high = max(0, k - len(arr2)), min(len(arr1), k)\n    \n    while low <= high:\n        # Partition points for both arrays\n        mid1 = (low + high) // 2\n        mid2 = k - mid1\n        \n        # Boundary values for comparison\n        left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if left1 <= right2 and left2 <= right1:\n            return max(left1, left2)\n        elif left1 > right2:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    \n    # This should never be reached for valid inputs\n    raise ValueError(\"Invalid input or k value\")\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Handle edge cases where one array is empty\n    if not arr1:\n        return arr2[k - 1]\n    if not arr2:\n        return arr1[k - 1]\n    \n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Binary search on the smaller array\n    low, high = max(0, k - len(arr2)), min(len(arr1), k)\n    \n    while low <= high:\n        # Partition points for both arrays\n        mid1 = (low + high) // 2\n        mid2 = k - mid1\n        \n        # Boundary values for comparison\n        left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if left1 <= right2 and left2 <= right1:\n            return max(left1, left2)\n        elif left1 > right2:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    \n    # This should never be reached for valid inputs\n    raise ValueError(\"Invalid input or k value\")\n\n\n"], "prompt_tokens": [2165], "completion_tokens": [1427], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_597_find_kth"}
{"name": "mbpp_226_odd_values_string", "language": "Python3", "prompt": "def odd_values_string(str: str) -> str:\n    \"\"\"\n\tWrite a python function to remove the characters which have odd index values of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_values_string", "test": "def check(candidate):\n    assert candidate('abcdef') == 'ace'\n    assert candidate('python') == 'pto'\n    assert candidate('data') == 'dt'\n    assert candidate('lambs') == 'lms'\n\ndef test_check():\n    check(odd_values_string)\n\ntest_check()\n", "sample_io": ["assert odd_values_string('abcdef') == 'ace'"], "source_codes": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]\n\n\n"], "responses": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]\n\n\n"], "prompt_tokens": [1578], "completion_tokens": [779], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_226_odd_values_string"}
{"name": "mbpp_278_count_first_elements", "language": "Python3", "prompt": "from typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n\tWrite a function to find the number of elements that occurs before the list element in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_first_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, (4, 6), 10]) == 3\n    assert candidate([2, 9, (5, 7), 11]) == 2\n    assert candidate([11, 15, 5, 8, (2, 3), 8]) == 4\n\ndef test_check():\n    check(count_first_elements)\n\ntest_check()\n", "sample_io": ["assert count_first_elements([1, 5, 7, (4, 6), 10]) == 3"], "source_codes": ["\nfrom typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, List, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    count = 0\n    for element in test_tup:\n        if isinstance(element, list):\n            return count\n        count += 1\n    return count\n\n\n"], "responses": ["\nfrom typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, List, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    count = 0\n    for element in test_tup:\n        if isinstance(element, list):\n            return count\n        count += 1\n    return count\n\n\n"], "prompt_tokens": [3602], "completion_tokens": [3584], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_278_count_first_elements"}
{"name": "mbpp_269_ascii_value", "language": "Python3", "prompt": "def ascii_value(k: str) -> int:\n    \"\"\"\n\tWrite a function to find the ascii value of a character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "ascii_value", "test": "def check(candidate):\n    assert candidate('A') == 65\n    assert candidate('R') == 82\n    assert candidate('S') == 83\n\ndef test_check():\n    check(ascii_value)\n\ntest_check()\n", "sample_io": ["assert ascii_value('A') == 65"], "source_codes": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \n    Args:\n        k (str): A single character string\n        \n    Returns:\n        int: The ASCII value of the character\n        \n    Raises:\n        TypeError: If input is not a string\n        ValueError: If input is not exactly one character\n    \"\"\"\n    # Validate that input is a string\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Validate that string contains exactly one character\n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n    \n    # Return ASCII value using ord() function\n    return ord(k)\n\n\n"], "responses": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \n    Args:\n        k (str): A single character string\n        \n    Returns:\n        int: The ASCII value of the character\n        \n    Raises:\n        TypeError: If input is not a string\n        ValueError: If input is not exactly one character\n    \"\"\"\n    # Validate that input is a string\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Validate that string contains exactly one character\n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n    \n    # Return ASCII value using ord() function\n    return ord(k)\n\n\n"], "prompt_tokens": [1343], "completion_tokens": [878], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_269_ascii_value"}
{"name": "mbpp_739_find_Index", "language": "Python3", "prompt": "def find_Index(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Index", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 14\n    assert candidate(4) == 45\n\ndef test_check():\n    check(find_Index)\n\ntest_check()\n", "sample_io": ["assert find_Index(2) == 4"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_739_find_Index"}
{"name": "mbpp_19_test_duplicate", "language": "Python3", "prompt": "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to find whether a given array of integers contains any duplicate element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_duplicate", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 4]) == True\n    assert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True\n\ndef test_check():\n    check(test_duplicate)\n\ntest_check()\n", "sample_io": ["assert test_duplicate([1, 2, 3, 4, 5]) == False"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_19_test_duplicate"}
{"name": "mbpp_62_smallest_num", "language": "Python3", "prompt": "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "smallest_num", "test": "def check(candidate):\n    assert candidate([10, 20, 1, 45, 99]) == 1\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([45, 46, 50, 60]) == 45\n\ndef test_check():\n    check(smallest_num)\n\ntest_check()\n", "sample_io": ["assert smallest_num([10, 20, 1, 45, 99]) == 1"], "source_codes": ["\nfrom typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Write a python function to find smallest number in a list.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for num in xs[1:]:\n        if num < min_val:\n            min_val = num\n    \n    return min_val\n\n\n"], "responses": ["\nfrom typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Write a python function to find smallest number in a list.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for num in xs[1:]:\n        if num < min_val:\n            min_val = num\n    \n    return min_val\n\n\n"], "prompt_tokens": [1451], "completion_tokens": [734], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_62_smallest_num"}
{"name": "mbpp_746_sector_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sector_area", "test": "def check(candidate):\n    assert candidate(4, 45) == 6.283185307179586\n    assert candidate(9, 45) == 31.808625617596654\n    assert candidate(9, 361) == None\n\ndef test_check():\n    check(sector_area)\n\ntest_check()\n", "sample_io": ["assert sector_area(4, 45) == 6.283185307179586"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_746_sector_area"}
{"name": "mbpp_142_count_samepair", "language": "Python3", "prompt": "from typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n\tWrite a function to count number items that are identical in the same position of three given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_samepair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 4\n    assert candidate([1, 2, 3, 4, 2, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 5\n\ndef test_check():\n    check(count_samepair)\n\ntest_check()\n", "sample_io": ["assert count_samepair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3"], "source_codes": ["\nfrom typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Write a function to count number items that are identical in the same position of three given lists.\n    \"\"\"\n    # Determine the minimum length among the three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at the same index are identical\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["\nfrom typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Write a function to count number items that are identical in the same position of three given lists.\n    \"\"\"\n    # Determine the minimum length among the three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at the same index are identical\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1913], "completion_tokens": [1058], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_142_count_samepair"}
{"name": "mbpp_400_extract_freq", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to extract the number of unique tuples in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_freq", "test": "def check(candidate):\n    assert candidate([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    assert candidate([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    assert candidate([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n\ndef test_check():\n    check(extract_freq)\n\ntest_check()\n", "sample_io": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n\n\n"], "prompt_tokens": [2384], "completion_tokens": [1491], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_400_extract_freq"}
{"name": "mbpp_595_min_Swaps", "language": "Python3", "prompt": "from typing import Any\n\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n\tWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Swaps", "test": "def check(candidate):\n    assert candidate('1101', '1110') == 1\n    assert candidate('111', '000') == 'Not Possible'\n    assert candidate('111', '110') == 'Not Possible'\n\ndef test_check():\n    check(min_Swaps)\n\ntest_check()\n", "sample_io": ["assert min_Swaps('1101', '1110') == 1"], "source_codes": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Initialize counters for mismatches\n    count_0_to_1 = 0  # str1 has '0', str2 has '1'\n    count_1_to_0 = 0  # str1 has '1', str2 has '0'\n    \n    # Iterate through both strings\n    for i in range(len(str1)):\n        if str1[i] == '0' and str2[i] == '1':\n            count_0_to_1 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_1_to_0 += 1\n    \n    # Check if conversion is possible\n    if count_0_to_1 != count_1_to_0:\n        return -1\n    \n    # Return the minimum number of swaps\n    return count_0_to_1\n\n\n"], "responses": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Initialize counters for mismatches\n    count_0_to_1 = 0  # str1 has '0', str2 has '1'\n    count_1_to_0 = 0  # str1 has '1', str2 has '0'\n    \n    # Iterate through both strings\n    for i in range(len(str1)):\n        if str1[i] == '0' and str2[i] == '1':\n            count_0_to_1 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_1_to_0 += 1\n    \n    # Check if conversion is possible\n    if count_0_to_1 != count_1_to_0:\n        return -1\n    \n    # Return the minimum number of swaps\n    return count_0_to_1\n\n\n"], "prompt_tokens": [2110], "completion_tokens": [1270], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_595_min_Swaps"}
