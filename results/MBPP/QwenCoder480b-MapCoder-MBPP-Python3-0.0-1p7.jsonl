{"name": "mbpp_738_geometric_sum", "language": "Python3", "prompt": "def geometric_sum(n: int) -> float:\n    \"\"\"\n\tWrite a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "geometric_sum", "test": "def check(candidate):\n    assert candidate(7) == 1.9921875\n    assert candidate(4) == 1.9375\n    assert candidate(8) == 1.99609375\n\ndef test_check():\n    check(geometric_sum)\n\ntest_check()\n", "sample_io": ["assert geometric_sum(7) == 1.9921875"], "source_codes": ["\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n terms where each term is (1/2)^i for i from 0 to n-1.\n    This is equivalent to the sum: 1 + 1/2 + 1/4 + 1/8 + ... + (1/2)^(n-1)\n    \"\"\"\n    # Handle base cases\n    if n <= 0:\n        return 0.0\n    if n == 1:\n        return 1.0\n    \n    # For n > 1, calculate the geometric sum using the formula:\n    # Sum = a * (1 - r^n) / (1 - r) where a = 1 (first term) and r = 1/2 (common ratio)\n    # This simplifies to: Sum = 2 * (1 - (1/2)^n)\n    \n    return 2 * (1 - (1/2)**n)\n\n\n"], "responses": ["\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n terms where each term is (1/2)^i for i from 0 to n-1.\n    This is equivalent to the sum: 1 + 1/2 + 1/4 + 1/8 + ... + (1/2)^(n-1)\n    \"\"\"\n    # Handle base cases\n    if n <= 0:\n        return 0.0\n    if n == 1:\n        return 1.0\n    \n    # For n > 1, calculate the geometric sum using the formula:\n    # Sum = a * (1 - r^n) / (1 - r) where a = 1 (first term) and r = 1/2 (common ratio)\n    # This simplifies to: Sum = 2 * (1 - (1/2)^n)\n    \n    return 2 * (1 - (1/2)**n)\n\n\n"], "prompt_tokens": [2474], "completion_tokens": [1997], "no_of_try": 1, "api_calls": 5, "is_solved": false, "task_id": "mbpp_738_geometric_sum"}
{"name": "mbpp_426_filter_oddnumbers", "language": "Python3", "prompt": "from typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to filter odd numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_oddnumbers", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 20, 45, 67, 84, 93]) == [45, 67, 93]\n    assert candidate([5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3]\n\ndef test_check():\n    check(filter_oddnumbers)\n\ntest_check()\n", "sample_io": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"], "source_codes": ["\nfrom typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\n\n"], "prompt_tokens": [1713], "completion_tokens": [838], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_426_filter_oddnumbers"}
{"name": "mbpp_437_remove_odd", "language": "Python3", "prompt": "def remove_odd(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove odd characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate('python') == 'yhn'\n    assert candidate('program') == 'rga'\n    assert candidate('language') == 'agae'\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd('python') == 'yhn'"], "source_codes": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return str1[::2]\n\n\n"], "responses": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return str1[::2]\n\n\n"], "prompt_tokens": [1372], "completion_tokens": [796], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_437_remove_odd"}
{"name": "mbpp_227_min_of_three", "language": "Python3", "prompt": "def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find minimum of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_of_three", "test": "def check(candidate):\n    assert candidate(10, 20, 0) == 0\n    assert candidate(19, 15, 18) == 15\n    assert candidate(-10, -20, -30) == -30\n\ndef test_check():\n    check(min_of_three)\n\ntest_check()\n", "sample_io": ["assert min_of_three(10, 20, 0) == 0"], "source_codes": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n\n"], "responses": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n\n"], "prompt_tokens": [1505], "completion_tokens": [794], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_227_min_of_three"}
{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    # Iterate through the string, checking each possible starting position\n    for i in range(len(s) - 2):  # We need at least 3 characters left to match 'std'\n        if s[i:i+3] == 'std':  # Check if substring matches 'std'\n            count += 1\n    return count\n\n\n"], "responses": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    # Iterate through the string, checking each possible starting position\n    for i in range(len(s) - 2):  # We need at least 3 characters left to match 'std'\n        if s[i:i+3] == 'std':  # Check if substring matches 'std'\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1472], "completion_tokens": [845], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1394], "completion_tokens": [587], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # For n >= 3, use dynamic programming with space optimization\n    # dp1 represents ways for i-2 posts\n    # dp2 represents ways for i-1 posts\n    dp1 = k\n    dp2 = k * k\n    \n    # Calculate for posts 3 to n\n    for i in range(3, n + 1):\n        # For each new post, we can either:\n        # 1. Paint it different from the previous post: (k-1) * dp2 ways\n        # 2. Paint it same as the previous post but different from the one before that: (k-1) * dp1 ways\n        current = (k - 1) * (dp2 + dp1)\n        dp1, dp2 = dp2, current\n    \n    return dp2\n\n\n"], "responses": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    # For n >= 3, use dynamic programming with space optimization\n    # dp1 represents ways for i-2 posts\n    # dp2 represents ways for i-1 posts\n    dp1 = k\n    dp2 = k * k\n    \n    # Calculate for posts 3 to n\n    for i in range(3, n + 1):\n        # For each new post, we can either:\n        # 1. Paint it different from the previous post: (k-1) * dp2 ways\n        # 2. Paint it same as the previous post but different from the one before that: (k-1) * dp1 ways\n        current = (k - 1) * (dp2 + dp1)\n        dp1, dp2 = dp2, current\n    \n    return dp2\n\n\n"], "prompt_tokens": [1904], "completion_tokens": [1146], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["\nfrom typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        The product of all elements in the array modulo n\n    \"\"\"\n    # Handle edge case: empty array\n    if not arr:\n        return 1\n    \n    # Handle edge case: n is 0 (would cause division by zero in modulo)\n    if n == 0:\n        raise ValueError(\"n cannot be zero\")\n    \n    # Handle edge case: n is 1 (any product modulo 1 is 0)\n    if n == 1:\n        return 0\n    \n    result = 1\n    for num in arr:\n        result = (result * num) % n\n        # Early termination if result becomes 0\n        if result == 0:\n            break\n    \n    # Handle negative results\n    if result < 0:\n        result += n\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        The product of all elements in the array modulo n\n    \"\"\"\n    # Handle edge case: empty array\n    if not arr:\n        return 1\n    \n    # Handle edge case: n is 0 (would cause division by zero in modulo)\n    if n == 0:\n        raise ValueError(\"n cannot be zero\")\n    \n    # Handle edge case: n is 1 (any product modulo 1 is 0)\n    if n == 1:\n        return 0\n    \n    result = 1\n    for num in arr:\n        result = (result * num) % n\n        # Early termination if result becomes 0\n        if result == 0:\n            break\n    \n    # Handle negative results\n    if result < 0:\n        result += n\n    \n    return result\n\n\n"], "prompt_tokens": [2233], "completion_tokens": [1358], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["\nfrom typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n\n\n"], "responses": ["\nfrom typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n\n\n"], "prompt_tokens": [1516], "completion_tokens": [805], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given array is monotonic or not.\n    \"\"\"\n    # Handle edge cases: empty array or single element array\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    is_increasing = all(A[i] <= A[i+1] for i in range(len(A)-1))\n    \n    # Check if array is monotonic decreasing\n    is_decreasing = all(A[i] >= A[i+1] for i in range(len(A)-1))\n    \n    # Return True if either condition is satisfied\n    return is_increasing or is_decreasing\n\n\n"], "responses": ["\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given array is monotonic or not.\n    \"\"\"\n    # Handle edge cases: empty array or single element array\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    is_increasing = all(A[i] <= A[i+1] for i in range(len(A)-1))\n    \n    # Check if array is monotonic decreasing\n    is_decreasing = all(A[i] >= A[i+1] for i in range(len(A)-1))\n    \n    # Return True if either condition is satisfied\n    return is_increasing or is_decreasing\n\n\n"], "prompt_tokens": [1263], "completion_tokens": [898], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_618_div_list"}
{"name": "mbpp_421_concatenate_tuple", "language": "Python3", "prompt": "from typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n\tWrite a function to concatenate each element of tuple by the delimiter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "concatenate_tuple", "test": "def check(candidate):\n    assert candidate(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'\n    assert candidate(('QWE', 'is', 4, 'RTY')) == 'QWE-is-4-RTY'\n    assert candidate(('ZEN', 'is', 4, 'OP')) == 'ZEN-is-4-OP'\n\ndef test_check():\n    check(concatenate_tuple)\n\ntest_check()\n", "sample_io": ["assert concatenate_tuple(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'"], "source_codes": ["\nfrom typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with hyphen delimiter\n    return '-'.join(str(element) for element in test_tup)\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with hyphen delimiter\n    return '-'.join(str(element) for element in test_tup)\n\n\n"], "prompt_tokens": [1885], "completion_tokens": [790], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_421_concatenate_tuple"}
{"name": "mbpp_750_add_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n\tWrite a function to add the given tuple to the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_tuple", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    assert candidate([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]\n    assert candidate([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]\n\ndef test_check():\n    check(add_tuple)\n\ntest_check()\n", "sample_io": ["assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, ...]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    return test_list + list(test_tup)\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, ...]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    return test_list + list(test_tup)\n\n\n"], "prompt_tokens": [1566], "completion_tokens": [947], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_750_add_tuple"}
{"name": "mbpp_304_find_Element", "language": "Python3", "prompt": "from typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    \"\"\"\n\tWrite a python function to find element at a given index after number of rotations.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3\n    assert candidate([1, 2, 3, 4], [[0, 1], [0, 2]], 1, 2) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [[0, 1], [0, 2]], 1, 1) == 1\n\ndef test_check():\n    check(find_Element)\n\ntest_check()\n", "sample_io": ["assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3"], "source_codes": ["\nfrom typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Handle empty array case\n    if not arr:\n        raise IndexError(\"Array is empty\")\n    \n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Apply rotations for each range\n    for start, end in ranges:\n        # Validate range indices\n        if start < 0 or end >= len(result_arr) or start > end:\n            continue  # Skip invalid ranges\n        \n        # Calculate the length of the subarray\n        subarray_length = end - start + 1\n        \n        # If subarray has only one element or no rotations, no change needed\n        if subarray_length <= 1 or rotations == 0:\n            continue\n            \n        # Calculate effective rotations (handle cases where rotations > subarray_length)\n        effective_rotations = rotations % subarray_length\n        \n        # Perform right rotation\n        if effective_rotations > 0:\n            # Extract the subarray\n            subarray = result_arr[start:end+1]\n            # Rotate right by moving last 'effective_rotations' elements to the front\n            rotated_subarray = subarray[-effective_rotations:] + subarray[:-effective_rotations]\n            # Put the rotated subarray back\n            result_arr[start:end+1] = rotated_subarray\n    \n    # Check if index is valid\n    if index < 0 or index >= len(result_arr):\n        raise IndexError(\"Index out of bounds\")\n    \n    # Return the element at the specified index\n    return result_arr[index]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Handle empty array case\n    if not arr:\n        raise IndexError(\"Array is empty\")\n    \n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Apply rotations for each range\n    for start, end in ranges:\n        # Validate range indices\n        if start < 0 or end >= len(result_arr) or start > end:\n            continue  # Skip invalid ranges\n        \n        # Calculate the length of the subarray\n        subarray_length = end - start + 1\n        \n        # If subarray has only one element or no rotations, no change needed\n        if subarray_length <= 1 or rotations == 0:\n            continue\n            \n        # Calculate effective rotations (handle cases where rotations > subarray_length)\n        effective_rotations = rotations % subarray_length\n        \n        # Perform right rotation\n        if effective_rotations > 0:\n            # Extract the subarray\n            subarray = result_arr[start:end+1]\n            # Rotate right by moving last 'effective_rotations' elements to the front\n            rotated_subarray = subarray[-effective_rotations:] + subarray[:-effective_rotations]\n            # Put the rotated subarray back\n            result_arr[start:end+1] = rotated_subarray\n    \n    # Check if index is valid\n    if index < 0 or index >= len(result_arr):\n        raise IndexError(\"Index out of bounds\")\n    \n    # Return the element at the specified index\n    return result_arr[index]\n\n\n"], "prompt_tokens": [2006], "completion_tokens": [1575], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_304_find_Element"}
{"name": "mbpp_740_tuple_to_dict", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_dict", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }\n    assert candidate((1, 2, 3, 4, 5, 6)) == { 1: 2, 3: 4, 5: 6 }\n    assert candidate((7, 8, 9, 10, 11, 12)) == { 7: 8, 9: 10, 11: 12 }\n\ndef test_check():\n    check(tuple_to_dict)\n\ntest_check()\n", "sample_io": ["assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }"], "source_codes": ["\nfrom typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    # Extract elements at even indices (keys) and odd indices (values)\n    keys = test_tup[::2]  # Elements at index 0, 2, 4, ...\n    values = test_tup[1::2]  # Elements at index 1, 3, 5, ...\n    \n    # Pair keys and values using zip and convert to dictionary\n    return dict(zip(keys, values))\n\n\n"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    # Extract elements at even indices (keys) and odd indices (values)\n    keys = test_tup[::2]  # Elements at index 0, 2, 4, ...\n    values = test_tup[1::2]  # Elements at index 1, 3, 5, ...\n    \n    # Pair keys and values using zip and convert to dictionary\n    return dict(zip(keys, values))\n\n\n"], "prompt_tokens": [1880], "completion_tokens": [1092], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_740_tuple_to_dict"}
{"name": "mbpp_627_find_First_Missing", "language": "Python3", "prompt": "from typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest missing number from a sorted list of natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_First_Missing", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3]) == 4\n    assert candidate([0, 1, 2, 6, 9]) == 3\n    assert candidate([2, 3, 5, 8, 9]) == 0\n\ndef test_check():\n    check(find_First_Missing)\n\ntest_check()\n", "sample_io": ["assert find_First_Missing([0, 1, 2, 3]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \"\"\"\n    # Handle edge case of empty array\n    if not array:\n        return 0\n    \n    # Handle case where array starts with a number other than 0\n    if array[0] != 0:\n        return 0\n    \n    # Binary search implementation\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If array[mid] equals mid, the missing number is in the right half\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # Otherwise, the missing number is in the left half (including mid)\n            right = mid - 1\n    \n    # When the loop ends, left will be the first missing number\n    return left\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \"\"\"\n    # Handle edge case of empty array\n    if not array:\n        return 0\n    \n    # Handle case where array starts with a number other than 0\n    if array[0] != 0:\n        return 0\n    \n    # Binary search implementation\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If array[mid] equals mid, the missing number is in the right half\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # Otherwise, the missing number is in the left half (including mid)\n            right = mid - 1\n    \n    # When the loop ends, left will be the first missing number\n    return left\n\n\n"], "prompt_tokens": [1692], "completion_tokens": [1301], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_627_find_First_Missing"}
{"name": "mbpp_294_max_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 5\n    assert candidate(['Python', 15, 20, 25]) == 25\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 50\n\ndef test_check():\n    check(max_val)\n\ntest_check()\n", "sample_io": ["assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"], "source_codes": ["\nfrom typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"List cannot be empty\")\n    \n    max_value = None\n    \n    for item in listval:\n        # Convert item to integer if it's a string representing a number\n        if isinstance(item, str):\n            try:\n                num_value = int(item)\n            except ValueError:\n                # Skip non-numeric strings\n                continue\n        else:\n            num_value = item\n            \n        # Update max_value\n        if max_value is None or num_value > max_value:\n            max_value = num_value\n    \n    if max_value is None:\n        raise ValueError(\"No valid numeric values found in the list\")\n        \n    return max_value\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"List cannot be empty\")\n    \n    max_value = None\n    \n    for item in listval:\n        # Convert item to integer if it's a string representing a number\n        if isinstance(item, str):\n            try:\n                num_value = int(item)\n            except ValueError:\n                # Skip non-numeric strings\n                continue\n        else:\n            num_value = item\n            \n        # Update max_value\n        if max_value is None or num_value > max_value:\n            max_value = num_value\n    \n    if max_value is None:\n        raise ValueError(\"No valid numeric values found in the list\")\n        \n    return max_value\n\n\n"], "prompt_tokens": [1573], "completion_tokens": [1061], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_294_max_val"}
{"name": "mbpp_165_count_char_position", "language": "Python3", "prompt": "def count_char_position(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_char_position", "test": "def check(candidate):\n    assert candidate('xbcefg') == 2\n    assert candidate('ABcED') == 3\n    assert candidate('AbgdeF') == 5\n\ndef test_check():\n    check(count_char_position)\n\ntest_check()\n", "sample_io": ["assert count_char_position('xbcefg') == 2"], "source_codes": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    # Convert to lowercase for case insensitivity\n    str1 = str1.lower()\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through string with index\n    for i, char in enumerate(str1):\n        # Check if character is a letter\n        if char.isalpha():\n            # Calculate alphabet position (a=1, b=2, etc.)\n            alphabet_position = ord(char) - ord('a') + 1\n            \n            # Compare with string position (1-indexed)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    # Convert to lowercase for case insensitivity\n    str1 = str1.lower()\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through string with index\n    for i, char in enumerate(str1):\n        # Check if character is a letter\n        if char.isalpha():\n            # Calculate alphabet position (a=1, b=2, etc.)\n            alphabet_position = ord(char) - ord('a') + 1\n            \n            # Compare with string position (1-indexed)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1637], "completion_tokens": [943], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_165_count_char_position"}
{"name": "mbpp_589_perfect_squares", "language": "Python3", "prompt": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find perfect squares between two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perfect_squares", "test": "def check(candidate):\n    assert candidate(1, 30) == [1, 4, 9, 16, 25]\n    assert candidate(50, 100) == [64, 81, 100]\n    assert candidate(100, 200) == [100, 121, 144, 169, 196]\n\ndef test_check():\n    check(perfect_squares)\n\ntest_check()\n", "sample_io": ["assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_589_perfect_squares"}
{"name": "mbpp_744_check_none", "language": "Python3", "prompt": "from typing import Any\n\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuple has any none value or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_none", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6, None)) == True\n    assert candidate((7, 8, 9, 11, 14)) == False\n    assert candidate((1, 2, 3, 4, None)) == True\n\ndef test_check():\n    check(check_none)\n\ntest_check()\n", "sample_io": ["assert check_none((10, 4, 5, 6, None)) == True"], "source_codes": ["\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Iterate through each element in the tuple\n    for element in test_tup:\n        # If element is None, return True\n        if element is None:\n            return True\n        # If element is a tuple, recursively check it\n        elif isinstance(element, tuple):\n            if check_none(element):\n                return True\n    \n    # If no None value is found, return False\n    return False\n\n\n"], "responses": ["\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Iterate through each element in the tuple\n    for element in test_tup:\n        # If element is None, return True\n        if element is None:\n            return True\n        # If element is a tuple, recursively check it\n        elif isinstance(element, tuple):\n            if check_none(element):\n                return True\n    \n    # If no None value is found, return False\n    return False\n\n\n"], "prompt_tokens": [1614], "completion_tokens": [974], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_744_check_none"}
{"name": "mbpp_726_multiply_elements", "language": "Python3", "prompt": "from typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, 8, 10]) == [5, 35, 56, 80]\n    assert candidate([2, 4, 5, 6, 7]) == [8, 20, 30, 42]\n    assert candidate([12, 13, 14, 9, 15]) == [156, 182, 126, 135]\n    assert candidate([12]) == []\n\ndef test_check():\n    check(multiply_elements)\n\ntest_check()\n", "sample_io": ["assert multiply_elements([1, 5, 7, 8, 10]) == [5, 35, 56, 80]"], "source_codes": ["\nfrom typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Write a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    # Handle edge cases: if input list has fewer than 2 elements, return empty list\n    if len(test_tup) < 2:\n        return []\n    \n    # Initialize an empty result list to store products of adjacent elements\n    result = []\n    \n    # Iterate through the input list from index 0 to length-2 (inclusive)\n    for i in range(len(test_tup) - 1):\n        # Calculate product of element at i and i+1, append to result\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    # Return the result list containing all adjacent products\n    return result\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Write a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    # Handle edge cases: if input list has fewer than 2 elements, return empty list\n    if len(test_tup) < 2:\n        return []\n    \n    # Initialize an empty result list to store products of adjacent elements\n    result = []\n    \n    # Iterate through the input list from index 0 to length-2 (inclusive)\n    for i in range(len(test_tup) - 1):\n        # Calculate product of element at i and i+1, append to result\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    # Return the result list containing all adjacent products\n    return result\n\n\n"], "prompt_tokens": [1611], "completion_tokens": [827], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_726_multiply_elements"}
{"name": "mbpp_736_left_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(left_insertion)\n\ntest_check()\n", "sample_io": ["assert left_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\nfrom typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    # Handle edge case of empty list\n    if not a:\n        return 0\n    \n    # Initialize pointers for binary search\n    low = 0\n    high = len(a)\n    \n    # Perform binary search\n    while low < high:\n        mid = (low + high) // 2\n        if a[mid] < x:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n\n\n"], "responses": ["\nfrom typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    # Handle edge case of empty list\n    if not a:\n        return 0\n    \n    # Initialize pointers for binary search\n    low = 0\n    high = len(a)\n    \n    # Perform binary search\n    while low < high:\n        mid = (low + high) // 2\n        if a[mid] < x:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n\n\n"], "prompt_tokens": [1881], "completion_tokens": [942], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_736_left_insertion"}
{"name": "mbpp_63_max_difference", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between available pairs in the given tuple list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_difference", "test": "def check(candidate):\n    assert candidate([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    assert candidate([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    assert candidate([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n\ndef test_check():\n    check(max_difference)\n\ntest_check()\n", "sample_io": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \n    Args:\n        test_list: A list of tuples containing integer pairs\n        \n    Returns:\n        The maximum absolute difference between elements in any tuple,\n        or negative infinity if the list is empty\n    \"\"\"\n    if not test_list:\n        return float('-inf')\n    \n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \n    Args:\n        test_list: A list of tuples containing integer pairs\n        \n    Returns:\n        The maximum absolute difference between elements in any tuple,\n        or negative infinity if the list is empty\n    \"\"\"\n    if not test_list:\n        return float('-inf')\n    \n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\n\n"], "prompt_tokens": [1707], "completion_tokens": [1067], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_63_max_difference"}
{"name": "mbpp_264_dog_age", "language": "Python3", "prompt": "def dog_age(h_age: int) -> int:\n    \"\"\"\n\tWrite a function to calculate a dog's age in dog's years.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dog_age", "test": "def check(candidate):\n    assert candidate(12) == 61\n    assert candidate(15) == 73\n    assert candidate(24) == 109\n\ndef test_check():\n    check(dog_age)\n\ntest_check()\n", "sample_io": ["assert dog_age(12) == 61"], "source_codes": ["\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    \n    if h_age <= 2:\n        return int(h_age * 10.5)\n    \n    # First 2 years = 21 dog years, then 4 dog years for each additional year\n    return int(21 + (h_age - 2) * 4)\n\n\n"], "responses": ["\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    \n    if h_age <= 2:\n        return int(h_age * 10.5)\n    \n    # First 2 years = 21 dog years, then 4 dog years for each additional year\n    return int(21 + (h_age - 2) * 4)\n\n\n"], "prompt_tokens": [1127], "completion_tokens": [910], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_264_dog_age"}
{"name": "mbpp_273_substract_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "substract_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    assert candidate((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    assert candidate((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n\ndef test_check():\n    check(substract_elements)\n\ntest_check()\n", "sample_io": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"], "source_codes": ["\nfrom typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (\n        test_tup1[0] - test_tup2[0],\n        test_tup1[1] - test_tup2[1],\n        test_tup1[2] - test_tup2[2]\n    )\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (\n        test_tup1[0] - test_tup2[0],\n        test_tup1[1] - test_tup2[1],\n        test_tup1[2] - test_tup2[2]\n    )\n\n\n"], "prompt_tokens": [1937], "completion_tokens": [946], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_273_substract_elements"}
{"name": "mbpp_83_get_Char", "language": "Python3", "prompt": "def get_Char(strr: str) -> str:\n    \"\"\"\n\tWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Char", "test": "def check(candidate):\n    assert candidate('abc') == 'f'\n    assert candidate('gfg') == 't'\n    assert candidate('ab') == 'c'\n\ndef test_check():\n    check(get_Char)\n\ntest_check()\n", "sample_io": ["assert get_Char('abc') == 'f'"], "source_codes": ["\ndef get_Char(strr: str) -> str:\n    \"\"\"\n    Find the character made by adding the ASCII value of all the characters \n    of the given string modulo 26.\n    \"\"\"\n    # Calculate the sum of ASCII values of all characters\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Calculate modulo 26 to get a value between 0 and 25\n    mod_result = ascii_sum % 26\n    \n    # Convert to corresponding lowercase letter\n    # 'a' has ASCII value 97, so we add our result to 97\n    result_char = chr(97 + mod_result)\n    \n    return result_char\n\n\n"], "responses": ["\ndef get_Char(strr: str) -> str:\n    \"\"\"\n    Find the character made by adding the ASCII value of all the characters \n    of the given string modulo 26.\n    \"\"\"\n    # Calculate the sum of ASCII values of all characters\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Calculate modulo 26 to get a value between 0 and 25\n    mod_result = ascii_sum % 26\n    \n    # Convert to corresponding lowercase letter\n    # 'a' has ASCII value 97, so we add our result to 97\n    result_char = chr(97 + mod_result)\n    \n    return result_char\n\n\n"], "prompt_tokens": [2915], "completion_tokens": [1545], "no_of_try": 1, "api_calls": 5, "is_solved": false, "task_id": "mbpp_83_get_Char"}
{"name": "mbpp_91_find_substring", "language": "Python3", "prompt": "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string is present as a substring in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_substring", "test": "def check(candidate):\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ack') == True\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'abc') == False\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ange') == True\n\ndef test_check():\n    check(find_substring)\n\ntest_check()\n", "sample_io": ["assert find_substring(['red', 'black', 'white', 'green', 'orange'], 'ack') == True"], "source_codes": ["\nfrom typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Handle edge case: empty substring (empty string is substring of any string)\n    if sub_str == \"\":\n        return True\n    \n    # Iterate through each string in the list\n    for string in str1:\n        # Check if substring exists in current string\n        if sub_str in string:\n            return True\n    \n    # If we've checked all strings and found no match\n    return False\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Handle edge case: empty substring (empty string is substring of any string)\n    if sub_str == \"\":\n        return True\n    \n    # Iterate through each string in the list\n    for string in str1:\n        # Check if substring exists in current string\n        if sub_str in string:\n            return True\n    \n    # If we've checked all strings and found no match\n    return False\n\n\n"], "prompt_tokens": [1656], "completion_tokens": [847], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_91_find_substring"}
{"name": "mbpp_100_next_smallest_palindrome", "language": "Python3", "prompt": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_smallest_palindrome", "test": "def check(candidate):\n    assert candidate(99) == 101\n    assert candidate(1221) == 1331\n    assert candidate(120) == 121\n\ndef test_check():\n    check(next_smallest_palindrome)\n\ntest_check()\n", "sample_io": ["assert next_smallest_palindrome(99) == 101"], "source_codes": ["\ndef next_smallest_palindrome(num: int) -> int:\n    num_str = str(num)\n    length = len(num_str)\n    \n    # Handle case where all digits are 9\n    if all(digit == '9' for digit in num_str):\n        return int('1' + '0' * (length - 1) + '1')\n    \n    # Get the first half of the number\n    mid = length // 2\n    first_half = num_str[:mid]\n    \n    if length % 2 == 0:\n        # Even length\n        palindrome = first_half + first_half[::-1]\n    else:\n        # Odd length\n        middle_digit = num_str[mid]\n        palindrome = first_half + middle_digit + first_half[::-1]\n    \n    # Convert palindrome back to integer\n    palindrome_int = int(palindrome)\n    \n    # If the palindrome is not greater than num, we need to increment\n    if palindrome_int <= num:\n        if length % 2 == 0:\n            # Even length\n            first_half = num_str[:mid]\n            incremented = str(int(first_half) + 1)\n            palindrome = incremented + incremented[::-1]\n        else:\n            # Odd length\n            first_half = num_str[:mid]\n            middle_digit = num_str[mid]\n            incremented_middle = str(int(middle_digit) + 1)\n            \n            # Handle carry-over\n            if len(incremented_middle) > 1:\n                first_half = str(int(first_half) + 1)\n                incremented_middle = '0'\n            \n            palindrome = first_half + incremented_middle + first_half[::-1]\n        \n        palindrome_int = int(palindrome)\n    \n    return palindrome_int\n\n\n"], "responses": ["\ndef next_smallest_palindrome(num: int) -> int:\n    num_str = str(num)\n    length = len(num_str)\n    \n    # Handle case where all digits are 9\n    if all(digit == '9' for digit in num_str):\n        return int('1' + '0' * (length - 1) + '1')\n    \n    # Get the first half of the number\n    mid = length // 2\n    first_half = num_str[:mid]\n    \n    if length % 2 == 0:\n        # Even length\n        palindrome = first_half + first_half[::-1]\n    else:\n        # Odd length\n        middle_digit = num_str[mid]\n        palindrome = first_half + middle_digit + first_half[::-1]\n    \n    # Convert palindrome back to integer\n    palindrome_int = int(palindrome)\n    \n    # If the palindrome is not greater than num, we need to increment\n    if palindrome_int <= num:\n        if length % 2 == 0:\n            # Even length\n            first_half = num_str[:mid]\n            incremented = str(int(first_half) + 1)\n            palindrome = incremented + incremented[::-1]\n        else:\n            # Odd length\n            first_half = num_str[:mid]\n            middle_digit = num_str[mid]\n            incremented_middle = str(int(middle_digit) + 1)\n            \n            # Handle carry-over\n            if len(incremented_middle) > 1:\n                first_half = str(int(first_half) + 1)\n                incremented_middle = '0'\n            \n            palindrome = first_half + incremented_middle + first_half[::-1]\n        \n        palindrome_int = int(palindrome)\n    \n    return palindrome_int\n\n\n"], "prompt_tokens": [1745], "completion_tokens": [1208], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_100_next_smallest_palindrome"}
{"name": "mbpp_282_sub_list", "language": "Python3", "prompt": "from typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to subtract two lists element-wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sub_list", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\n    assert candidate([1, 2], [3, 4]) == [-2, -2]\n    assert candidate([90, 120], [50, 70]) == [40, 50]\n\ndef test_check():\n    check(sub_list)\n\ntest_check()\n", "sample_io": ["assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"], "source_codes": ["\nfrom typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    # Check if both lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Handle empty lists\n    if len(nums1) == 0:\n        return []\n    \n    # Perform element-wise subtraction\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    # Check if both lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Handle empty lists\n    if len(nums1) == 0:\n        return []\n    \n    # Perform element-wise subtraction\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result\n\n\n"], "prompt_tokens": [1784], "completion_tokens": [915], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_282_sub_list"}
{"name": "mbpp_790_even_position", "language": "Python3", "prompt": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every even index contains even numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_position", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == False\n    assert candidate([1, 2, 3]) == False\n    assert candidate([2, 1, 4]) == True\n\ndef test_check():\n    check(even_position)\n\ntest_check()\n", "sample_io": ["assert even_position([3, 2, 1]) == False"], "source_codes": ["\nfrom typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Handle edge case: empty list (vacuous truth)\n    if not nums:\n        return True\n    \n    # Iterate through all even indices\n    for i in range(0, len(nums), 2):\n        # Check if the number at even index is even\n        if nums[i] % 2 != 0:\n            return False\n    \n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Handle edge case: empty list (vacuous truth)\n    if not nums:\n        return True\n    \n    # Iterate through all even indices\n    for i in range(0, len(nums), 2):\n        # Check if the number at even index is even\n        if nums[i] % 2 != 0:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1698], "completion_tokens": [866], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_790_even_position"}
{"name": "mbpp_411_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert the given snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('android_tv') == 'AndroidTv'\n    assert candidate('google_pixel') == 'GooglePixel'\n    assert candidate('apple_watch') == 'AppleWatch'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('android_tv') == 'AndroidTv'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert the given snake case string to camel case string.\n    \"\"\"\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of each word and join them\n    result = [word.capitalize() for word in words]\n    \n    return ''.join(result)\n\n\n"], "responses": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Write a function to convert the given snake case string to camel case string.\n    \"\"\"\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of each word and join them\n    result = [word.capitalize() for word in words]\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [2052], "completion_tokens": [1412], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_411_snake_to_camel"}
{"name": "mbpp_754_extract_index_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n\tWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_index_list", "test": "def check(candidate):\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 6, 5], [0, 1, 2, 3, 4, 6, 7]) == [1, 6]\n    assert candidate([1, 1, 3, 4, 6, 5, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 5]\n    assert candidate([1, 2, 3, 4, 6, 6, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == []\n\ndef test_check():\n    check(extract_index_list)\n\ntest_check()\n", "sample_io": ["assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"], "source_codes": ["\nfrom typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    # Determine the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through indices from 0 to minimum length\n    for i in range(min_length):\n        # Check if element at current index is same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to result\n            result.append(l1[i])\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    # Determine the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through indices from 0 to minimum length\n    for i in range(min_length):\n        # Check if element at current index is same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to result\n            result.append(l1[i])\n    \n    return result\n\n\n"], "prompt_tokens": [2162], "completion_tokens": [1181], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_754_extract_index_list"}
{"name": "mbpp_56_checks", "language": "Python3", "prompt": "def checks(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check if a given number is one less than twice its reverse.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "checks", "test": "def check(candidate):\n    assert candidate(70) == False\n    assert candidate(23) == False\n    assert candidate(73) == True\n\ndef test_check():\n    check(checks)\n\ntest_check()\n", "sample_io": ["assert checks(70) == False"], "source_codes": ["\ndef checks(n: int) -> bool:\n    # Handle negative numbers and numbers ending with 0 (except 0 itself)\n    if n < 0 or (n > 0 and n % 10 == 0):\n        return False\n    \n    # Convert to string to easily reverse the digits\n    str_n = str(n)\n    \n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1\n\n\n"], "responses": ["\ndef checks(n: int) -> bool:\n    # Handle negative numbers and numbers ending with 0 (except 0 itself)\n    if n < 0 or (n > 0 and n % 10 == 0):\n        return False\n    \n    # Convert to string to easily reverse the digits\n    str_n = str(n)\n    \n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1\n\n\n"], "prompt_tokens": [1989], "completion_tokens": [1205], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_56_checks"}
{"name": "mbpp_724_power_base_sum", "language": "Python3", "prompt": "def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n\tWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power_base_sum", "test": "def check(candidate):\n    assert candidate(2, 100) == 115\n    assert candidate(8, 10) == 37\n    assert candidate(8, 15) == 62\n    assert candidate(3, 3) == 9\n\ndef test_check():\n    check(power_base_sum)\n\ntest_check()\n", "sample_io": ["assert power_base_sum(2, 100) == 115"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_724_power_base_sum"}
{"name": "mbpp_268_find_star_num", "language": "Python3", "prompt": "def find_star_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th star number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_star_num", "test": "def check(candidate):\n    assert candidate(3) == 37\n    assert candidate(4) == 73\n    assert candidate(5) == 121\n\ndef test_check():\n    check(find_star_num)\n\ntest_check()\n", "sample_io": ["assert find_star_num(3) == 37"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_268_find_star_num"}
{"name": "mbpp_251_insert_element", "language": "Python3", "prompt": "from typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n\tWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "insert_element", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    assert candidate(['python', 'java'], 'program') == ['program', 'python', 'program', 'java']\n    assert candidate(['happy', 'sad'], 'laugh') == ['laugh', 'happy', 'laugh', 'sad']\n\ndef test_check():\n    check(insert_element)\n\ntest_check()\n", "sample_io": ["assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"], "source_codes": ["\nfrom typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    # Handle the edge case of an empty input list\n    if not list:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through each element in the input list\n    for item in list:\n        # Append the insertion element first, then the current element\n        result.append(element)\n        result.append(item)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    # Handle the edge case of an empty input list\n    if not list:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through each element in the input list\n    for item in list:\n        # Append the insertion element first, then the current element\n        result.append(element)\n        result.append(item)\n    \n    return result\n\n\n"], "prompt_tokens": [1403], "completion_tokens": [658], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_251_insert_element"}
{"name": "mbpp_428_shell_sort", "language": "Python3", "prompt": "from typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given array by using shell sort.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "shell_sort", "test": "def check(candidate):\n    assert candidate([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    assert candidate([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]\n    assert candidate([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]\n\ndef test_check():\n    check(shell_sort)\n\ntest_check()\n", "sample_io": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"], "source_codes": ["\nfrom typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to sort the given array by using shell sort.\n    \"\"\"\n    # Handle edge cases\n    if len(my_list) <= 1:\n        return my_list\n    \n    # Create a copy to avoid modifying the original list\n    arr = my_list.copy()\n    n = len(arr)\n    \n    # Initialize gap using Shell's original sequence (half the array length)\n    gap = n // 2\n    \n    # Continue until gap becomes 0\n    while gap > 0:\n        # Perform gapped insertion sort\n        for i in range(gap, n):\n            # Store current element\n            temp = arr[i]\n            \n            # Shift earlier gap-sorted elements up until correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp in its correct location\n            arr[j] = temp\n        \n        # Reduce gap for next iteration\n        gap //= 2\n    \n    return arr\n\n\n"], "responses": ["\nfrom typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to sort the given array by using shell sort.\n    \"\"\"\n    # Handle edge cases\n    if len(my_list) <= 1:\n        return my_list\n    \n    # Create a copy to avoid modifying the original list\n    arr = my_list.copy()\n    n = len(arr)\n    \n    # Initialize gap using Shell's original sequence (half the array length)\n    gap = n // 2\n    \n    # Continue until gap becomes 0\n    while gap > 0:\n        # Perform gapped insertion sort\n        for i in range(gap, n):\n            # Store current element\n            temp = arr[i]\n            \n            # Shift earlier gap-sorted elements up until correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp in its correct location\n            arr[j] = temp\n        \n        # Reduce gap for next iteration\n        gap //= 2\n    \n    return arr\n\n\n"], "prompt_tokens": [1976], "completion_tokens": [1256], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_428_shell_sort"}
{"name": "mbpp_476_big_sum", "language": "Python3", "prompt": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the largest and smallest value in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 4\n    assert candidate([-1, 2, 3, 4]) == 3\n    assert candidate([2, 3, 6]) == 8\n\ndef test_check():\n    check(big_sum)\n\ntest_check()\n", "sample_io": ["assert big_sum([1, 2, 3]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Return the sum of the maximum and minimum values\n    return max_val + min_val\n\n\n"], "responses": ["\nfrom typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Return the sum of the maximum and minimum values\n    return max_val + min_val\n\n\n"], "prompt_tokens": [1382], "completion_tokens": [763], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_476_big_sum"}
{"name": "mbpp_465_drop_empty", "language": "Python3", "prompt": "from typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to drop empty items from a given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "drop_empty", "test": "def check(candidate):\n    assert candidate({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }\n    assert candidate({ 'c1': 'Red', 'c2': None, 'c3': None }) == { 'c1': 'Red' }\n    assert candidate({ 'c1': None, 'c2': 'Green', 'c3': None }) == { 'c2': 'Green' }\n\ndef test_check():\n    check(drop_empty)\n\ntest_check()\n", "sample_io": ["assert drop_empty({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }"], "source_codes": ["\nfrom typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n\n\n"], "responses": ["\nfrom typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n\n\n"], "prompt_tokens": [1833], "completion_tokens": [873], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_465_drop_empty"}
{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Define a regex pattern that matches any word containing the letter 'z'\n    # \\b represents word boundaries\n    # \\w* matches zero or more word characters\n    # [zZ] matches either lowercase or uppercase 'z'\n    # \\w* matches zero or more word characters\n    pattern = r'\\b\\w*[zZ]\\w*\\b'\n    \n    # Use re.search() to find if any word in the text matches the pattern\n    # Convert the search result to a boolean\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Define a regex pattern that matches any word containing the letter 'z'\n    # \\b represents word boundaries\n    # \\w* matches zero or more word characters\n    # [zZ] matches either lowercase or uppercase 'z'\n    # \\w* matches zero or more word characters\n    pattern = r'\\b\\w*[zZ]\\w*\\b'\n    \n    # Use re.search() to find if any word in the text matches the pattern\n    # Convert the search result to a boolean\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1447], "completion_tokens": [753], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["\nimport math\n\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    if num == 2:\n        return True\n    \n    # Check if the number is even\n    if num % 2 == 0:\n        return False\n    \n    # Calculate the square root to establish upper bound\n    sqrt_num = int(math.sqrt(num))\n    \n    # Check odd divisors from 3 to sqrt(num)\n    for i in range(3, sqrt_num + 1, 2):\n        if num % i == 0:\n            return False\n    \n    return True\n\n\n"], "responses": ["\nimport math\n\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    if num == 2:\n        return True\n    \n    # Check if the number is even\n    if num % 2 == 0:\n        return False\n    \n    # Calculate the square root to establish upper bound\n    sqrt_num = int(math.sqrt(num))\n    \n    # Check odd divisors from 3 to sqrt(num)\n    for i in range(3, sqrt_num + 1, 2):\n        if num % i == 0:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1432], "completion_tokens": [938], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["\nfrom typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Sort each list first\n    num1_sorted = sorted(num1)\n    num2_sorted = sorted(num2)\n    num3_sorted = sorted(num3)\n    \n    # Initialize pointers for each sorted list\n    i, j, k = 0, 0, 0\n    result = []\n    \n    # Merge while all three lists have elements\n    while i < len(num1_sorted) and j < len(num2_sorted) and k < len(num3_sorted):\n        if num1_sorted[i] <= num2_sorted[j] and num1_sorted[i] <= num3_sorted[k]:\n            result.append(num1_sorted[i])\n            i += 1\n        elif num2_sorted[j] <= num1_sorted[i] and num2_sorted[j] <= num3_sorted[k]:\n            result.append(num2_sorted[j])\n            j += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Handle remaining elements when one list is exhausted\n    # Merge num1 and num2 if num3 is exhausted\n    while i < len(num1_sorted) and j < len(num2_sorted):\n        if num1_sorted[i] <= num2_sorted[j]:\n            result.append(num1_sorted[i])\n            i += 1\n        else:\n            result.append(num2_sorted[j])\n            j += 1\n    \n    # Merge num1 and num3 if num2 is exhausted\n    while i < len(num1_sorted) and k < len(num3_sorted):\n        if num1_sorted[i] <= num3_sorted[k]:\n            result.append(num1_sorted[i])\n            i += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Merge num2 and num3 if num1 is exhausted\n    while j < len(num2_sorted) and k < len(num3_sorted):\n        if num2_sorted[j] <= num3_sorted[k]:\n            result.append(num2_sorted[j])\n            j += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Add remaining elements from num1 if any\n    while i < len(num1_sorted):\n        result.append(num1_sorted[i])\n        i += 1\n    \n    # Add remaining elements from num2 if any\n    while j < len(num2_sorted):\n        result.append(num2_sorted[j])\n        j += 1\n    \n    # Add remaining elements from num3 if any\n    while k < len(num3_sorted):\n        result.append(num3_sorted[k])\n        k += 1\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Sort each list first\n    num1_sorted = sorted(num1)\n    num2_sorted = sorted(num2)\n    num3_sorted = sorted(num3)\n    \n    # Initialize pointers for each sorted list\n    i, j, k = 0, 0, 0\n    result = []\n    \n    # Merge while all three lists have elements\n    while i < len(num1_sorted) and j < len(num2_sorted) and k < len(num3_sorted):\n        if num1_sorted[i] <= num2_sorted[j] and num1_sorted[i] <= num3_sorted[k]:\n            result.append(num1_sorted[i])\n            i += 1\n        elif num2_sorted[j] <= num1_sorted[i] and num2_sorted[j] <= num3_sorted[k]:\n            result.append(num2_sorted[j])\n            j += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Handle remaining elements when one list is exhausted\n    # Merge num1 and num2 if num3 is exhausted\n    while i < len(num1_sorted) and j < len(num2_sorted):\n        if num1_sorted[i] <= num2_sorted[j]:\n            result.append(num1_sorted[i])\n            i += 1\n        else:\n            result.append(num2_sorted[j])\n            j += 1\n    \n    # Merge num1 and num3 if num2 is exhausted\n    while i < len(num1_sorted) and k < len(num3_sorted):\n        if num1_sorted[i] <= num3_sorted[k]:\n            result.append(num1_sorted[i])\n            i += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Merge num2 and num3 if num1 is exhausted\n    while j < len(num2_sorted) and k < len(num3_sorted):\n        if num2_sorted[j] <= num3_sorted[k]:\n            result.append(num2_sorted[j])\n            j += 1\n        else:\n            result.append(num3_sorted[k])\n            k += 1\n    \n    # Add remaining elements from num1 if any\n    while i < len(num1_sorted):\n        result.append(num1_sorted[i])\n        i += 1\n    \n    # Add remaining elements from num2 if any\n    while j < len(num2_sorted):\n        result.append(num2_sorted[j])\n        j += 1\n    \n    # Add remaining elements from num3 if any\n    while k < len(num3_sorted):\n        result.append(num3_sorted[k])\n        k += 1\n    \n    return result\n\n\n"], "prompt_tokens": [3586], "completion_tokens": [2349], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not sample_names:\n        return 0\n    \n    # Filter names that start with an uppercase letter and sum their lengths\n    total_length = 0\n    for name in sample_names:\n        # Check if name is not empty and starts with an uppercase letter\n        if name and name[0].isupper():\n            total_length += len(name)\n    \n    return total_length\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not sample_names:\n        return 0\n    \n    # Filter names that start with an uppercase letter and sum their lengths\n    total_length = 0\n    for name in sample_names:\n        # Check if name is not empty and starts with an uppercase letter\n        if name and name[0].isupper():\n            total_length += len(name)\n    \n    return total_length\n\n\n"], "prompt_tokens": [1778], "completion_tokens": [972], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through each tuple in the list\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through each tuple in the list\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n\n\n"], "prompt_tokens": [1695], "completion_tokens": [911], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["\nfrom typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    \n    return tuple(result)\n\n\n"], "responses": ["\nfrom typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    \n    return tuple(result)\n\n\n"], "prompt_tokens": [2229], "completion_tokens": [1125], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    # Handle edge cases: empty list or single element\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    # Handle edge cases: empty list or single element\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "prompt_tokens": [1463], "completion_tokens": [723], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    # Round each number in the list\n    rounded_numbers = [round(num) for num in list1]\n    \n    # Calculate the sum of all rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Multiply the sum by the length of the original list\n    result = total_sum * len(list1)\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    # Round each number in the list\n    rounded_numbers = [round(num) for num in list1]\n    \n    # Calculate the sum of all rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Multiply the sum by the length of the original list\n    result = total_sum * len(list1)\n    \n    return result\n\n\n"], "prompt_tokens": [2113], "completion_tokens": [1487], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the newman conway sequence.\n    \"\"\"\n    # Handle base cases\n    if n <= 2:\n        return 1\n    \n    # Create a dynamic programming array to store computed values\n    dp = [0] * (n + 1)\n    \n    # Initialize the first two values\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n using the recurrence relation\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    # Return the nth value\n    return dp[n]\n\n\n"], "responses": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth number in the newman conway sequence.\n    \"\"\"\n    # Handle base cases\n    if n <= 2:\n        return 1\n    \n    # Create a dynamic programming array to store computed values\n    dp = [0] * (n + 1)\n    \n    # Initialize the first two values\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n using the recurrence relation\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    # Return the nth value\n    return dp[n]\n\n\n"], "prompt_tokens": [1454], "completion_tokens": [1021], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": ["\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Find the nth Newman-Shanks-Williams prime number.\n    \n    Newman-Shanks-Williams primes are prime numbers that appear in the NSW sequence,\n    where NSW(n) = 2*NSW(n-1) + NSW(n-2) with NSW(0)=1, NSW(1)=1.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Initialize the first two NSW numbers\n    nsw_prev2 = 1  # NSW(0)\n    nsw_prev1 = 1  # NSW(1)\n    \n    # Check if the first NSW numbers are prime\n    count = 0\n    \n    # Check NSW(0) = 1 - not prime\n    # Check NSW(1) = 1 - not prime\n    \n    # Start with index 2 since we already have NSW(0) and NSW(1)\n    index = 2\n    \n    while count < n:\n        # Calculate next NSW number using recurrence relation\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        \n        # Check if this NSW number is prime\n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        \n        # Update for next iteration\n        nsw_prev2 = nsw_prev1\n        nsw_prev1 = nsw_current\n        index += 1\n    \n    return nsw_current\n\n\n"], "responses": ["\ndef newman_prime(n: int) -> int:\n    \"\"\"\n    Find the nth Newman-Shanks-Williams prime number.\n    \n    Newman-Shanks-Williams primes are prime numbers that appear in the NSW sequence,\n    where NSW(n) = 2*NSW(n-1) + NSW(n-2) with NSW(0)=1, NSW(1)=1.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Initialize the first two NSW numbers\n    nsw_prev2 = 1  # NSW(0)\n    nsw_prev1 = 1  # NSW(1)\n    \n    # Check if the first NSW numbers are prime\n    count = 0\n    \n    # Check NSW(0) = 1 - not prime\n    # Check NSW(1) = 1 - not prime\n    \n    # Start with index 2 since we already have NSW(0) and NSW(1)\n    index = 2\n    \n    while count < n:\n        # Calculate next NSW number using recurrence relation\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        \n        # Check if this NSW number is prime\n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        \n        # Update for next iteration\n        nsw_prev2 = nsw_prev1\n        nsw_prev1 = nsw_current\n        index += 1\n    \n    return nsw_current\n\n\n"], "prompt_tokens": [3317], "completion_tokens": [3882], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
