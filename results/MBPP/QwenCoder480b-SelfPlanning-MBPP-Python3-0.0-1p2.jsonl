{"name": "mbpp_635_heap_sort", "language": "Python3", "prompt": "from typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_sort", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    assert candidate([7, 1, 9, 5]) == [1, 5, 7, 9]\n\ndef test_check():\n    check(heap_sort)\n\ntest_check()\n", "sample_io": ["assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "source_codes": ["\nfrom typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list using heap sort algorithm.\n    \n    Args:\n        iterable: List of integers to sort\n        \n    Returns:\n        Sorted list of integers\n    \"\"\"\n    # Convert to list if needed and make a copy to avoid modifying original\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Handle edge cases\n    if n <= 1:\n        return arr\n    \n    # Build max heap (rearrange array)\n    # Start from the last non-leaf node and heapify each node\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root (maximum) to end\n        arr[0], arr[i] = arr[i], arr[0]\n        \n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Maintain the max heap property for subtree rooted at index i.\n    \n    Args:\n        arr: Array representing the heap\n        n: Size of the heap\n        i: Root index of the subtree\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1     # Left child index\n    right = 2 * i + 2    # Right child index\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than current largest\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root, swap and continue heapifying\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected subtree\n        heapify(arr, n, largest)\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list using heap sort algorithm.\n    \n    Args:\n        iterable: List of integers to sort\n        \n    Returns:\n        Sorted list of integers\n    \"\"\"\n    # Convert to list if needed and make a copy to avoid modifying original\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Handle edge cases\n    if n <= 1:\n        return arr\n    \n    # Build max heap (rearrange array)\n    # Start from the last non-leaf node and heapify each node\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root (maximum) to end\n        arr[0], arr[i] = arr[i], arr[0]\n        \n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Maintain the max heap property for subtree rooted at index i.\n    \n    Args:\n        arr: Array representing the heap\n        n: Size of the heap\n        i: Root index of the subtree\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1     # Left child index\n    right = 2 * i + 2    # Right child index\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than current largest\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root, swap and continue heapifying\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected subtree\n        heapify(arr, n, largest)\n```"], "prompt_tokens": [942], "completion_tokens": [1282], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_635_heap_sort"}
{"name": "mbpp_270_sum_even_and_even_index", "language": "Python3", "prompt": "from typing import List\n\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even numbers at even positions of a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_even_and_even_index", "test": "def check(candidate):\n    assert candidate([5, 6, 12, 1, 18, 8]) == 30\n    assert candidate([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26\n    assert candidate([5, 6, 12, 1]) == 12\n\ndef test_check():\n    check(sum_even_and_even_index)\n\ntest_check()\n", "sample_io": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"], "source_codes": ["\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # iterate through even indices only\n        if arr[i] % 2 == 0:  # check if the number is even\n            total += arr[i]\n    return total\n\n\n"], "responses": ["```python\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # iterate through even indices only\n        if arr[i] % 2 == 0:  # check if the number is even\n            total += arr[i]\n    return total\n```"], "prompt_tokens": [622], "completion_tokens": [572], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_270_sum_even_and_even_index"}
{"name": "mbpp_787_text_match_three", "language": "Python3", "prompt": "def text_match_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by three 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('caacabbbba') == True\n\ndef test_check():\n    check(text_match_three)\n\ntest_check()\n", "sample_io": ["assert text_match_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r'abbb'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r'abbb'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [536], "completion_tokens": [465], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_787_text_match_three"}
{"name": "mbpp_765_is_polite", "language": "Python3", "prompt": "def is_polite(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_polite", "test": "def check(candidate):\n    assert candidate(7) == 11\n    assert candidate(4) == 7\n    assert candidate(9) == 13\n\ndef test_check():\n    check(is_polite)\n\ntest_check()\n", "sample_io": ["assert is_polite(7) == 11"], "source_codes": ["\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as \n    the sum of two or more consecutive positive integers.\n    Equivalently, polite numbers are all positive integers except powers of 2.\n    \"\"\"\n    \n    def is_power_of_two(num):\n        return num > 0 and (num & (num - 1)) == 0\n    \n    count = 0\n    current = 1\n    \n    while count < n:\n        if not is_power_of_two(current):\n            count += 1\n            if count == n:\n                return current\n        current += 1\n    \n    return current\n\n\n"], "responses": ["```python\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as \n    the sum of two or more consecutive positive integers.\n    Equivalently, polite numbers are all positive integers except powers of 2.\n    \"\"\"\n    \n    def is_power_of_two(num):\n        return num > 0 and (num & (num - 1)) == 0\n    \n    count = 0\n    current = 1\n    \n    while count < n:\n        if not is_power_of_two(current):\n            count += 1\n            if count == n:\n                return current\n        current += 1\n    \n    return current\n```"], "prompt_tokens": [858], "completion_tokens": [874], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_765_is_polite"}
{"name": "mbpp_459_remove_uppercase", "language": "Python3", "prompt": "def remove_uppercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove uppercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_uppercase", "test": "def check(candidate):\n    assert candidate('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\n    assert candidate('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'\n    assert candidate('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'\n\ndef test_check():\n    check(remove_uppercase)\n\ntest_check()\n", "sample_io": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"], "source_codes": ["\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.isupper())\n\n\n"], "responses": ["```python\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.isupper())\n```"], "prompt_tokens": [617], "completion_tokens": [546], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_459_remove_uppercase"}
{"name": "mbpp_16_text_lowercase_underscore", "language": "Python3", "prompt": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n\tWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_lowercase_underscore", "test": "def check(candidate):\n    assert candidate('aab_cbbbc') == True\n    assert candidate('aab_Abbbc') == False\n    assert candidate('Aaab_abbbc') == False\n\ndef test_check():\n    check(text_lowercase_underscore)\n\ntest_check()\n", "sample_io": ["assert text_lowercase_underscore('aab_cbbbc') == True"], "source_codes": ["\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))\n```"], "prompt_tokens": [654], "completion_tokens": [585], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_16_text_lowercase_underscore"}
{"name": "mbpp_731_lateralsurface_cone", "language": "Python3", "prompt": "def lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cone given radius r and the height h.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cone", "test": "def check(candidate):\n    assert candidate(5, 12) == 204.20352248333654\n    assert candidate(10, 15) == 566.3586699569488\n    assert candidate(19, 17) == 1521.8090132193388\n\ndef test_check():\n    check(lateralsurface_cone)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cone(5, 12) == 204.20352248333654"], "source_codes": ["\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \"\"\"\n    # Calculate the slant height\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate lateral surface area: \u03c0 \u00d7 r \u00d7 l\n    lateral_surface_area = math.pi * r * slant_height\n    \n    return lateral_surface_area\n\n\n"], "responses": ["```python\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \"\"\"\n    # Calculate the slant height\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate lateral surface area: \u03c0 \u00d7 r \u00d7 l\n    lateral_surface_area = math.pi * r * slant_height\n    \n    return lateral_surface_area\n```"], "prompt_tokens": [452], "completion_tokens": [408], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_731_lateralsurface_cone"}
{"name": "mbpp_802_count_rotation", "language": "Python3", "prompt": "from typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_rotation", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == 1\n    assert candidate([4, 5, 1, 2, 3]) == 2\n    assert candidate([7, 8, 9, 1, 2, 3]) == 3\n    assert candidate([1, 2, 3]) == 0\n    assert candidate([1, 3, 2]) == 2\n\ndef test_check():\n    check(count_rotation)\n\ntest_check()\n", "sample_io": ["assert count_rotation([3, 2, 1]) == 1"], "source_codes": ["\nfrom typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    n = len(arr)\n    \n    # Handle edge cases\n    if n <= 1:\n        return 0\n    \n    # Find the index where the array breaks ascending order\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            return i + 1\n    \n    # If no break point found, array is already sorted\n    return 0\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    n = len(arr)\n    \n    # Handle edge cases\n    if n <= 1:\n        return 0\n    \n    # Find the index where the array breaks ascending order\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            return i + 1\n    \n    # If no break point found, array is already sorted\n    return 0\n```"], "prompt_tokens": [711], "completion_tokens": [634], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_802_count_rotation"}
{"name": "mbpp_782_odd_length_sum", "language": "Python3", "prompt": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_length_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 4]) == 14\n    assert candidate([1, 2, 1, 2]) == 15\n    assert candidate([1, 7]) == 8\n\ndef test_check():\n    check(odd_length_sum)\n\ntest_check()\n", "sample_io": ["assert odd_length_sum([1, 2, 4]) == 14"], "source_codes": ["\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    For each element, we calculate how many odd-length subarrays contain it,\n    then multiply by the element value.\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Number of subarrays containing arr[i]\n        # Start can be chosen in (i+1) ways (indices 0 to i)\n        # End can be chosen in (n-i) ways (indices i to n-1)\n        total_subarrays = (i + 1) * (n - i)\n        \n        # Number of odd-length subarrays containing arr[i]\n        # This follows the pattern where roughly half are odd length\n        odd_length_subarrays = (total_subarrays + 1) // 2\n        \n        total_sum += arr[i] * odd_length_subarrays\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    For each element, we calculate how many odd-length subarrays contain it,\n    then multiply by the element value.\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Number of subarrays containing arr[i]\n        # Start can be chosen in (i+1) ways (indices 0 to i)\n        # End can be chosen in (n-i) ways (indices i to n-1)\n        total_subarrays = (i + 1) * (n - i)\n        \n        # Number of odd-length subarrays containing arr[i]\n        # This follows the pattern where roughly half are odd length\n        odd_length_subarrays = (total_subarrays + 1) // 2\n        \n        total_sum += arr[i] * odd_length_subarrays\n    \n    return total_sum\n```"], "prompt_tokens": [997], "completion_tokens": [1030], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_782_odd_length_sum"}
{"name": "mbpp_470_add_pairwise", "language": "Python3", "prompt": "from typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the pairwise addition of the neighboring elements of the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_pairwise", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n    assert candidate((2, 6, 8, 9, 11)) == (8, 14, 17, 20)\n    assert candidate((3, 7, 9, 10, 12)) == (10, 16, 19, 22)\n\ndef test_check():\n    check(add_pairwise)\n\ntest_check()\n", "sample_io": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)"], "source_codes": ["\nfrom typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    return tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n\n\n"], "responses": ["```python\nfrom typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    return tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n```"], "prompt_tokens": [605], "completion_tokens": [521], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_470_add_pairwise"}
{"name": "mbpp_17_square_perimeter", "language": "Python3", "prompt": "def square_perimeter(a: int) -> int:\n    \"\"\"\n\tWrite a function that returns the perimeter of a square given its side length as input.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_perimeter", "test": "def check(candidate):\n    assert candidate(10) == 40\n    assert candidate(5) == 20\n    assert candidate(4) == 16\n\ndef test_check():\n    check(square_perimeter)\n\ntest_check()\n", "sample_io": ["assert square_perimeter(10) == 40"], "source_codes": ["\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n\n\n"], "responses": ["```python\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n```"], "prompt_tokens": [341], "completion_tokens": [258], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_17_square_perimeter"}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "Python3", "prompt": "def all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the bits are unset in the given range or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Bits_Set_In_The_Given_Range", "test": "def check(candidate):\n    assert candidate(4, 1, 2) == True\n    assert candidate(17, 2, 4) == True\n    assert candidate(39, 4, 6) == False\n\ndef test_check():\n    check(all_Bits_Set_In_The_Given_Range)\n\ntest_check()\n", "sample_io": ["assert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"], "source_codes": ["\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n    Write a python function to check whether all the bits are unset in the given range or not.\n    \"\"\"\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1  # This creates mask_length number of 1s\n    \n    # Shift the mask to the correct position\n    mask = mask << l\n    \n    # Check if any bits are set in the range by using bitwise AND\n    # If result is 0, then all bits are unset\n    return (n & mask) == 0\n\n\n"], "responses": ["```python\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n    Write a python function to check whether all the bits are unset in the given range or not.\n    \"\"\"\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1  # This creates mask_length number of 1s\n    \n    # Shift the mask to the correct position\n    mask = mask << l\n    \n    # Check if any bits are set in the range by using bitwise AND\n    # If result is 0, then all bits are unset\n    return (n & mask) == 0\n```"], "prompt_tokens": [896], "completion_tokens": [915], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_228_all_Bits_Set_In_The_Given_Range"}
{"name": "mbpp_240_replace_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_240_replace_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_list", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate(['red', 'blue', 'green'], ['yellow']) == ['red', 'blue', 'yellow']\n\ndef test_check():\n    check(replace_list)\n\ntest_check()\n", "sample_io": ["assert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"], "source_codes": ["\nfrom typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Handle case where first list is empty\n    if not list1:\n        return list2.copy()\n    \n    # Take all elements except the last one from list1, then add all elements from list2\n    return list1[:-1] + list2\n\n\n"], "responses": ["```python\nfrom typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Handle case where first list is empty\n    if not list1:\n        return list2.copy()\n    \n    # Take all elements except the last one from list1, then add all elements from list2\n    return list1[:-1] + list2\n```"], "prompt_tokens": [767], "completion_tokens": [708], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_240_replace_list"}
{"name": "mbpp_447_cube_nums", "language": "Python3", "prompt": "from typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find cubes of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    assert candidate([10, 20, 30]) == [1000, 8000, 27000]\n    assert candidate([12, 15]) == [1728, 3375]\n\ndef test_check():\n    check(cube_nums)\n\ntest_check()\n", "sample_io": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"], "source_codes": ["\nfrom typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n```"], "prompt_tokens": [436], "completion_tokens": [356], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_447_cube_nums"}
{"name": "mbpp_261_division_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "division_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)\n    assert candidate((12, 6, 8, 16), (6, 3, 4, 4)) == (2, 2, 2, 4)\n    assert candidate((20, 14, 36, 18), (5, 7, 6, 9)) == (4, 2, 6, 2)\n\ndef test_check():\n    check(division_elements)\n\ntest_check()\n", "sample_io": ["assert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)"], "source_codes": ["\nfrom typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    # Perform element-wise division\n    result = (\n        int(test_tup1[0] / test_tup2[0]),\n        int(test_tup1[1] / test_tup2[1]),\n        int(test_tup1[2] / test_tup2[2]),\n        int(test_tup1[3] / test_tup2[3])\n    )\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    # Perform element-wise division\n    result = (\n        int(test_tup1[0] / test_tup2[0]),\n        int(test_tup1[1] / test_tup2[1]),\n        int(test_tup1[2] / test_tup2[2]),\n        int(test_tup1[3] / test_tup2[3])\n    )\n    \n    return result\n```"], "prompt_tokens": [745], "completion_tokens": [703], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_261_division_elements"}
{"name": "mbpp_581_surface_Area", "language": "Python3", "prompt": "def surface_Area(b: int, s: int) -> int:\n    \"\"\"\n\tWrite a python function to find the surface area of a square pyramid with a given base edge and height.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surface_Area", "test": "def check(candidate):\n    assert candidate(3, 4) == 33\n    assert candidate(4, 5) == 56\n    assert candidate(1, 2) == 5\n\ndef test_check():\n    check(surface_Area)\n\ntest_check()\n", "sample_io": ["assert surface_Area(3, 4) == 33"], "source_codes": ["\nimport math\n\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and height.\n    \n    Args:\n        b: base edge length\n        s: height of the pyramid\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area\n    base_area = b * b\n    \n    # Slant height of triangular face\n    slant_height = math.sqrt(s * s + (b / 2) * (b / 2))\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * slant_height)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n\n\n"], "responses": ["```python\nimport math\n\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and height.\n    \n    Args:\n        b: base edge length\n        s: height of the pyramid\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area\n    base_area = b * b\n    \n    # Slant height of triangular face\n    slant_height = math.sqrt(s * s + (b / 2) * (b / 2))\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * slant_height)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n```"], "prompt_tokens": [770], "completion_tokens": [800], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_581_surface_Area"}
{"name": "mbpp_283_validate", "language": "Python3", "prompt": "def validate(n: int) -> bool:\n    \"\"\"\n\tWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "validate", "test": "def check(candidate):\n    assert candidate(1234) == True\n    assert candidate(51241) == False\n    assert candidate(321) == True\n\ndef test_check():\n    check(validate)\n\ntest_check()\n", "sample_io": ["assert validate(1234) == True"], "source_codes": ["\ndef validate(n: int) -> bool:\n    \"\"\"\n    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n    \"\"\"\n    # Convert to string to process each digit\n    str_n = str(abs(n))  # Use abs() to handle negative numbers\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit in str_n:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit itself\n    for digit, count in digit_count.items():\n        digit_value = int(digit)\n        if count > digit_value:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef validate(n: int) -> bool:\n    \"\"\"\n    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n    \"\"\"\n    # Convert to string to process each digit\n    str_n = str(abs(n))  # Use abs() to handle negative numbers\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit in str_n:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit itself\n    for digit, count in digit_count.items():\n        digit_value = int(digit)\n        if count > digit_value:\n            return False\n    \n    return True\n```"], "prompt_tokens": [895], "completion_tokens": [909], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_283_validate"}
{"name": "mbpp_284_check_element", "language": "Python3", "prompt": "from typing import List, Any\n\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n\tWrite a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_284_check_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_element", "test": "def check(candidate):\n    assert candidate(['green', 'orange', 'black', 'white'], 'blue') == False\n    assert candidate([1, 2, 3, 4], 7) == False\n    assert candidate(['green', 'green', 'green', 'green'], 'green') == True\n\ndef test_check():\n    check(check_element)\n\ntest_check()\n", "sample_io": ["assert check_element(['green', 'orange', 'black', 'white'], 'blue') == False"], "source_codes": ["\nfrom typing import List, Any\n\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n\n\n"], "responses": ["```python\nfrom typing import List, Any\n\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n```"], "prompt_tokens": [488], "completion_tokens": [399], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_284_check_element"}
{"name": "mbpp_101_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find the kth element in the given array using 1-based indexing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "kth_element", "test": "def check(candidate):\n    assert candidate([12, 3, 5, 7, 19], 2) == 3\n    assert candidate([17, 24, 8, 23], 3) == 8\n    assert candidate([16, 21, 25, 36, 4], 4) == 36\n\ndef test_check():\n    check(kth_element)\n\ntest_check()\n", "sample_io": ["assert kth_element([12, 3, 5, 7, 19], 2) == 3"], "source_codes": ["\nfrom typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the kth element in the given array using 1-based indexing.\n    \"\"\"\n    # Handle invalid k values\n    if k <= 0 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    # Convert 1-based indexing to 0-based indexing\n    # kth element in 1-based indexing is at index (k-1) in 0-based indexing\n    return arr[k - 1]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Write a function to find the kth element in the given array using 1-based indexing.\n    \"\"\"\n    # Handle invalid k values\n    if k <= 0 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    # Convert 1-based indexing to 0-based indexing\n    # kth element in 1-based indexing is at index (k-1) in 0-based indexing\n    return arr[k - 1]\n```"], "prompt_tokens": [644], "completion_tokens": [617], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_101_kth_element"}
{"name": "mbpp_461_upper_ctr", "language": "Python3", "prompt": "def upper_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the upper case characters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "upper_ctr", "test": "def check(candidate):\n    assert candidate('PYthon') == 1\n    assert candidate('BigData') == 1\n    assert candidate('program') == 0\n\ndef test_check():\n    check(upper_ctr)\n\ntest_check()\n", "sample_io": ["assert upper_ctr('PYthon') == 1"], "source_codes": ["\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n```"], "prompt_tokens": [393], "completion_tokens": [334], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_461_upper_ctr"}
{"name": "mbpp_593_removezero_ip", "language": "Python3", "prompt": "def removezero_ip(ip: str) -> str:\n    \"\"\"\n\tWrite a function to remove leading zeroes from an ip address.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "removezero_ip", "test": "def check(candidate):\n    assert candidate('216.08.094.196') == '216.8.94.196'\n    assert candidate('12.01.024') == '12.1.24'\n    assert candidate('216.08.094.0196') == '216.8.94.196'\n\ndef test_check():\n    check(removezero_ip)\n\ntest_check()\n", "sample_io": ["assert removezero_ip('216.08.094.196') == '216.8.94.196'"], "source_codes": ["\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address into octets\n    octets = ip.split('.')\n    \n    # Remove leading zeros from each octet by converting to int and back to string\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    \n    # Join them back with dots\n    return '.'.join(cleaned_octets)\n\n\n"], "responses": ["```python\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address into octets\n    octets = ip.split('.')\n    \n    # Remove leading zeros from each octet by converting to int and back to string\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    \n    # Join them back with dots\n    return '.'.join(cleaned_octets)\n```"], "prompt_tokens": [499], "completion_tokens": [488], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_593_removezero_ip"}
{"name": "mbpp_788_new_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n\tWrite a function to create a new tuple from the given string and list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "new_tuple", "test": "def check(candidate):\n    assert candidate(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')\n    assert candidate(['We', 'are'], 'Developers') == ('We', 'are', 'Developers')\n    assert candidate(['Part', 'is'], 'Wrong') == ('Part', 'is', 'Wrong')\n\ndef test_check():\n    check(new_tuple)\n\ntest_check()\n", "sample_io": ["assert new_tuple(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    # Get first element or empty string if list is empty\n    first_elem = test_list[0] if len(test_list) > 0 else \"\"\n    # Get second element or empty string if list has less than 2 elements\n    second_elem = test_list[1] if len(test_list) > 1 else \"\"\n    \n    # Return tuple with: first list element, given string, second list element\n    return (first_elem, test_str, second_elem)\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    # Get first element or empty string if list is empty\n    first_elem = test_list[0] if len(test_list) > 0 else \"\"\n    # Get second element or empty string if list has less than 2 elements\n    second_elem = test_list[1] if len(test_list) > 1 else \"\"\n    \n    # Return tuple with: first list element, given string, second list element\n    return (first_elem, test_str, second_elem)\n```"], "prompt_tokens": [601], "completion_tokens": [593], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_788_new_tuple"}
{"name": "mbpp_777_find_sum", "language": "Python3", "prompt": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of non-repeated elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    assert candidate([1, 10, 9, 4, 2, 10, 10, 45, 4]) == 71\n    assert candidate([12, 10, 9, 45, 2, 10, 10, 45, 10]) == 78\n\ndef test_check():\n    check(find_sum)\n\ntest_check()\n", "sample_io": ["assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21"], "source_codes": ["\nfrom typing import List\nfrom collections import Counter\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    \"\"\"\n    freq_count = Counter(arr)\n    return sum(element for element, count in freq_count.items() if count == 1)\n\n\n"], "responses": ["```python\nfrom typing import List\nfrom collections import Counter\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    \"\"\"\n    freq_count = Counter(arr)\n    return sum(element for element, count in freq_count.items() if count == 1)\n```"], "prompt_tokens": [671], "completion_tokens": [605], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_777_find_sum"}
{"name": "mbpp_586_split_Arr", "language": "Python3", "prompt": "from typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to split a list at the nth eelment and add the first part to the end.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_Arr", "test": "def check(candidate):\n    assert candidate([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]\n    assert candidate([1, 2, 3, 4], 1) == [2, 3, 4, 1]\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7], 3) == [3, 4, 5, 6, 7, 0, 1, 2]\n\ndef test_check():\n    check(split_Arr)\n\ntest_check()\n", "sample_io": ["assert split_Arr([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]"], "source_codes": ["\nfrom typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a python function to split a list at the nth element and add the first part to the end.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0 or n >= len(l):\n        return l[:]\n    \n    # Split the list at nth element\n    first_part = l[:n]      # Elements from start to n-1\n    second_part = l[n:]     # Elements from n to end\n    \n    # Add first part to the end\n    result = second_part + first_part\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a python function to split a list at the nth element and add the first part to the end.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0 or n >= len(l):\n        return l[:]\n    \n    # Split the list at nth element\n    first_part = l[:n]      # Elements from start to n-1\n    second_part = l[n:]     # Elements from n to end\n    \n    # Add first part to the end\n    result = second_part + first_part\n    \n    return result\n```"], "prompt_tokens": [672], "completion_tokens": [650], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_586_split_Arr"}
{"name": "mbpp_104_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([[' red ', 'green'], ['blue ', ' black'], [' orange', 'brown']]) == [[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]\n    assert candidate([['zilver', 'gold'], ['magnesium', 'aluminium'], ['steel', 'bronze']]) == [['gold', 'zilver'], ['aluminium', 'magnesium'], ['bronze', 'steel']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\nfrom typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n```"], "prompt_tokens": [519], "completion_tokens": [433], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_104_sort_sublists"}
{"name": "mbpp_472_check_Consecutive", "language": "Python3", "prompt": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given list contains consecutive numbers or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_Consecutive", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 2, 3, 5, 6]) == False\n    assert candidate([1, 2, 1]) == False\n\ndef test_check():\n    check(check_Consecutive)\n\ntest_check()\n", "sample_io": ["assert check_Consecutive([1, 2, 3, 4, 5]) == True"], "source_codes": ["\nfrom typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    # Handle edge cases\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to arrange numbers in ascending order\n    sorted_list = sorted(l)\n    \n    # Check if each adjacent pair differs by exactly 1\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] - sorted_list[i-1] != 1:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    # Handle edge cases\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to arrange numbers in ascending order\n    sorted_list = sorted(l)\n    \n    # Check if each adjacent pair differs by exactly 1\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] - sorted_list[i-1] != 1:\n            return False\n    \n    return True\n```"], "prompt_tokens": [655], "completion_tokens": [649], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_472_check_Consecutive"}
{"name": "mbpp_310_string_to_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_tuple", "test": "def check(candidate):\n    assert candidate('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n    assert candidate('item1') == ['i', 't', 'e', 'm', '1']\n    assert candidate('15.10') == ['1', '5', '.', '1', '0']\n\ndef test_check():\n    check(string_to_tuple)\n\ntest_check()\n", "sample_io": ["assert string_to_tuple('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']"], "source_codes": ["\nfrom typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n```"], "prompt_tokens": [412], "completion_tokens": [324], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_310_string_to_tuple"}
{"name": "mbpp_266_lateralsurface_cube", "language": "Python3", "prompt": "def lateralsurface_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cube", "test": "def check(candidate):\n    assert candidate(5) == 100\n    assert candidate(9) == 324\n    assert candidate(10) == 400\n\ndef test_check():\n    check(lateralsurface_cube)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cube(5) == 100"], "source_codes": ["\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    return 4 * l * l\n\n\n"], "responses": ["```python\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    return 4 * l * l\n```"], "prompt_tokens": [445], "completion_tokens": [363], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_266_lateralsurface_cube"}
{"name": "mbpp_271_even_Power_Sum", "language": "Python3", "prompt": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_Power_Sum", "test": "def check(candidate):\n    assert candidate(2) == 1056\n    assert candidate(3) == 8832\n    assert candidate(1) == 32\n\ndef test_check():\n    check(even_Power_Sum)\n\ntest_check()\n", "sample_io": ["assert even_Power_Sum(2) == 1056"], "source_codes": ["\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total_sum = 0\n    \n    # Calculate the first n even natural numbers raised to the 5th power\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total_sum = 0\n    \n    # Calculate the first n even natural numbers raised to the 5th power\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    \n    return total_sum\n```"], "prompt_tokens": [645], "completion_tokens": [602], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_271_even_Power_Sum"}
{"name": "mbpp_238_number_of_substrings", "language": "Python3", "prompt": "def number_of_substrings(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_of_substrings", "test": "def check(candidate):\n    assert candidate('abc') == 6\n    assert candidate('abcd') == 10\n    assert candidate('abcde') == 15\n\ndef test_check():\n    check(number_of_substrings)\n\ntest_check()\n", "sample_io": ["assert number_of_substrings('abc') == 6"], "source_codes": ["\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Write a python function to count the number of non-empty substrings of a given string.\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n\n\n"], "responses": ["```python\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Write a python function to count the number of non-empty substrings of a given string.\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n```"], "prompt_tokens": [783], "completion_tokens": [710], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_238_number_of_substrings"}
{"name": "mbpp_592_sum_Of_product", "language": "Python3", "prompt": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the product of consecutive binomial co-efficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_product", "test": "def check(candidate):\n    assert candidate(3) == 15\n    assert candidate(4) == 56\n    assert candidate(1) == 1\n\ndef test_check():\n    check(sum_Of_product)\n\ntest_check()\n", "sample_io": ["assert sum_Of_product(3) == 15"], "source_codes": ["\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of the product of consecutive binomial co-efficients.\n    \"\"\"\n    # Helper function to calculate binomial coefficient C(n, k)\n    def binomial_coeff(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        # Use the property C(n,k) = C(n,n-k) to minimize calculations\n        k = min(k, n - k)\n        \n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Calculate sum of products of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        product = binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n        total_sum += product\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of the product of consecutive binomial co-efficients.\n    \"\"\"\n    # Helper function to calculate binomial coefficient C(n, k)\n    def binomial_coeff(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        # Use the property C(n,k) = C(n,n-k) to minimize calculations\n        k = min(k, n - k)\n        \n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Calculate sum of products of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        product = binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n        total_sum += product\n    \n    return total_sum\n```"], "prompt_tokens": [710], "completion_tokens": [794], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_592_sum_Of_product"}
{"name": "mbpp_74_is_samepatterns", "language": "Python3", "prompt": "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n\tWrite a function to check whether it follows the sequence given in the patterns array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_samepatterns", "test": "def check(candidate):\n    assert candidate(['red', 'green', 'green'], ['a', 'b', 'b']) == True\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b', 'b']) == False\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b']) == False\n\ndef test_check():\n    check(is_samepatterns)\n\ntest_check()\n", "sample_io": ["assert is_samepatterns(['red', 'green', 'green'], ['a', 'b', 'b']) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Write a function to check whether it follows the sequence given in the patterns array.\n    \"\"\"\n    # Check if arrays have the same length\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from colors to patterns and vice versa\n    color_to_pattern = {}\n    pattern_to_color = {}\n    \n    # Check each position for consistency\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n        \n        # Check if color already has a mapping\n        if color in color_to_pattern:\n            # If the mapping doesn't match current pattern, it's inconsistent\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            # Create new mapping\n            color_to_pattern[color] = pattern\n        \n        # Check if pattern already has a mapping\n        if pattern in pattern_to_color:\n            # If the mapping doesn't match current color, it's inconsistent\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            # Create new mapping\n            pattern_to_color[pattern] = color\n    \n    return True\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Write a function to check whether it follows the sequence given in the patterns array.\n    \"\"\"\n    # Check if arrays have the same length\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from colors to patterns and vice versa\n    color_to_pattern = {}\n    pattern_to_color = {}\n    \n    # Check each position for consistency\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n        \n        # Check if color already has a mapping\n        if color in color_to_pattern:\n            # If the mapping doesn't match current pattern, it's inconsistent\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            # Create new mapping\n            color_to_pattern[color] = pattern\n        \n        # Check if pattern already has a mapping\n        if pattern in pattern_to_color:\n            # If the mapping doesn't match current color, it's inconsistent\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            # Create new mapping\n            pattern_to_color[pattern] = color\n    \n    return True\n```"], "prompt_tokens": [625], "completion_tokens": [738], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_74_is_samepatterns"}
{"name": "mbpp_415_max_Product", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n\tWrite a python function to find a pair with highest product from a given array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    assert candidate([0, -1, -2, -4, 5, 0, -6]) == (-4, -6)\n    assert candidate([1, 2, 3]) == (2, 3)\n\ndef test_check():\n    check(max_Product)\n\ntest_check()\n", "sample_io": ["assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a python function to find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily access smallest and largest elements\n    sorted_arr = sorted(arr)\n    n = len(sorted_arr)\n    \n    # The maximum product will be either:\n    # 1. Product of two smallest numbers (if both negative)\n    # 2. Product of two largest numbers\n    product_first_two = sorted_arr[0] * sorted_arr[1]\n    product_last_two = sorted_arr[n-1] * sorted_arr[n-2]\n    \n    # Return the pair that gives maximum product\n    if product_first_two > product_last_two:\n        return (sorted_arr[0], sorted_arr[1])\n    else:\n        return (sorted_arr[n-2], sorted_arr[n-1])\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Write a python function to find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily access smallest and largest elements\n    sorted_arr = sorted(arr)\n    n = len(sorted_arr)\n    \n    # The maximum product will be either:\n    # 1. Product of two smallest numbers (if both negative)\n    # 2. Product of two largest numbers\n    product_first_two = sorted_arr[0] * sorted_arr[1]\n    product_last_two = sorted_arr[n-1] * sorted_arr[n-2]\n    \n    # Return the pair that gives maximum product\n    if product_first_two > product_last_two:\n        return (sorted_arr[0], sorted_arr[1])\n    else:\n        return (sorted_arr[n-2], sorted_arr[n-1])\n```"], "prompt_tokens": [767], "completion_tokens": [838], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_415_max_Product"}
{"name": "mbpp_781_count_divisors", "language": "Python3", "prompt": "def count_divisors(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_divisors", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(100) == False\n    assert candidate(125) == True\n\ndef test_check():\n    check(count_divisors)\n\ntest_check()\n", "sample_io": ["assert count_divisors(10) == True"], "source_codes": ["\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the count of divisors is even.\n    \"\"\"\n    if n <= 0:\n        return True\n    \n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case - only one divisor\n            else:\n                count += 2  # Two divisors: i and n//i\n        i += 1\n    \n    return count % 2 == 0\n\n\n"], "responses": ["```python\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the count of divisors is even.\n    \"\"\"\n    if n <= 0:\n        return True\n    \n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case - only one divisor\n            else:\n                count += 2  # Two divisors: i and n//i\n        i += 1\n    \n    return count % 2 == 0\n```"], "prompt_tokens": [624], "completion_tokens": [590], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_781_count_divisors"}
{"name": "mbpp_441_surfacearea_cube", "language": "Python3", "prompt": "def surfacearea_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the surface area of a cube of a given size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cube", "test": "def check(candidate):\n    assert candidate(5) == 150\n    assert candidate(3) == 54\n    assert candidate(10) == 600\n\ndef test_check():\n    check(surfacearea_cube)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cube(5) == 150"], "source_codes": ["\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n\n\n"], "responses": ["```python\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n```"], "prompt_tokens": [351], "completion_tokens": [271], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_441_surfacearea_cube"}
{"name": "mbpp_396_check_char", "language": "Python3", "prompt": "def check_char(string: str) -> str:\n    \"\"\"\n\tWrite a function to check whether the given string starts and ends with the same character or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_char", "test": "def check(candidate):\n    assert candidate('abba') == 'Valid'\n    assert candidate('a') == 'Valid'\n    assert candidate('abcd') == 'Invalid'\n\ndef test_check():\n    check(check_char)\n\ntest_check()\n", "sample_io": ["assert check_char('abba') == 'Valid'"], "source_codes": ["\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"String is empty\"\n    \n    # Get first and last characters\n    first_char = string[0]\n    last_char = string[-1]\n    \n    # Check if they are the same\n    if first_char == last_char:\n        return \"Same\"\n    else:\n        return \"Not Same\"\n\n\n"], "responses": ["```python\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"String is empty\"\n    \n    # Get first and last characters\n    first_char = string[0]\n    last_char = string[-1]\n    \n    # Check if they are the same\n    if first_char == last_char:\n        return \"Same\"\n    else:\n        return \"Not Same\"\n```"], "prompt_tokens": [414], "completion_tokens": [403], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_396_check_char"}
{"name": "mbpp_757_count_reverse_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n\tWrite a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_reverse_pairs", "test": "def check(candidate):\n    assert candidate(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2\n    assert candidate(['geeks', 'best', 'for', 'skeeg']) == 1\n    assert candidate(['makes', 'best', 'sekam', 'for', 'rof']) == 2\n\ndef test_check():\n    check(count_reverse_pairs)\n\ntest_check()\n", "sample_io": ["assert count_reverse_pairs(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2"], "source_codes": ["\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    n = len(test_list)\n    \n    # Check each pair of strings\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if test_list[j] is reverse of test_list[i]\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    n = len(test_list)\n    \n    # Check each pair of strings\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if test_list[j] is reverse of test_list[i]\n            if test_list[i] == test_list[j][::-1]:\n                count += 1\n    \n    return count\n```"], "prompt_tokens": [783], "completion_tokens": [724], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_757_count_reverse_pairs"}
{"name": "mbpp_75_find_tuples", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n\tWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_tuples", "test": "def check(candidate):\n    assert candidate([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    assert candidate([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]\n    assert candidate([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]\n\ndef test_check():\n    check(find_tuples)\n\ntest_check()\n", "sample_io": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    return [tuple_item for tuple_item in test_list if all(element % K == 0 for element in tuple_item)]\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    return [tuple_item for tuple_item in test_list if all(element % K == 0 for element in tuple_item)]\n```"], "prompt_tokens": [646], "completion_tokens": [553], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_75_find_tuples"}
{"name": "mbpp_785_tuple_str_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function to convert tuple string to integer tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_str_int", "test": "def check(candidate):\n    assert candidate('(7, 8, 9)') == (7, 8, 9)\n    assert candidate('(1, 2, 3)') == (1, 2, 3)\n    assert candidate('(4, 5, 6)') == (4, 5, 6)\n    assert candidate('(7, 81, 19)') == (7, 81, 19)\n\ndef test_check():\n    check(tuple_str_int)\n\ntest_check()\n", "sample_io": ["assert tuple_str_int('(7, 8, 9)') == (7, 8, 9)"], "source_codes": ["\nfrom typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function to convert tuple string to integer tuple.\n    \"\"\"\n    # Remove parentheses if present\n    test_str = test_str.strip()\n    if test_str.startswith('(') and test_str.endswith(')'):\n        test_str = test_str[1:-1]\n    \n    # Split by comma and convert to integers\n    parts = test_str.split(',')\n    # Strip whitespace from each part and convert to int\n    result = tuple(int(part.strip()) for part in parts)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function to convert tuple string to integer tuple.\n    \"\"\"\n    # Remove parentheses if present\n    test_str = test_str.strip()\n    if test_str.startswith('(') and test_str.endswith(')'):\n        test_str = test_str[1:-1]\n    \n    # Split by comma and convert to integers\n    parts = test_str.split(',')\n    # Strip whitespace from each part and convert to int\n    result = tuple(int(part.strip()) for part in parts)\n    \n    return result\n```"], "prompt_tokens": [514], "completion_tokens": [507], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_785_tuple_str_int"}
{"name": "mbpp_776_count_vowels", "language": "Python3", "prompt": "def count_vowels(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to count those characters which have vowels as their neighbors in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_vowels", "test": "def check(candidate):\n    assert candidate('bestinstareels') == 7\n    assert candidate('partofthejourneyistheend') == 12\n    assert candidate('amazonprime') == 5\n\ndef test_check():\n    check(count_vowels)\n\ntest_check()\n", "sample_io": ["assert count_vowels('bestinstareels') == 7"], "source_codes": ["\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) <= 1:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i in range(len(test_str)):\n        has_vowel_neighbor = False\n        \n        # Check left neighbor\n        if i > 0 and test_str[i-1] in vowels:\n            has_vowel_neighbor = True\n        \n        # Check right neighbor\n        if i < len(test_str) - 1 and test_str[i+1] in vowels:\n            has_vowel_neighbor = True\n            \n        if has_vowel_neighbor:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) <= 1:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i in range(len(test_str)):\n        has_vowel_neighbor = False\n        \n        # Check left neighbor\n        if i > 0 and test_str[i-1] in vowels:\n            has_vowel_neighbor = True\n        \n        # Check right neighbor\n        if i < len(test_str) - 1 and test_str[i+1] in vowels:\n            has_vowel_neighbor = True\n            \n        if has_vowel_neighbor:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [624], "completion_tokens": [661], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_776_count_vowels"}
{"name": "mbpp_277_dict_filter", "language": "Python3", "prompt": "from typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n\tWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dict_filter", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 170) == { 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 180) == { 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 190) == { 'Pierre Cox': 190 }\n\ndef test_check():\n    check(dict_filter)\n\ntest_check()\n", "sample_io": ["assert dict_filter(3) == 27"], "source_codes": ["\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n\n\n"], "responses": ["```python\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n```"], "prompt_tokens": [617], "completion_tokens": [521], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_277_dict_filter"}
{"name": "mbpp_468_max_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product", "test": "def check(candidate):\n    assert candidate([3, 100, 4, 5, 150, 6]) == 3000\n    assert candidate([4, 42, 55, 68, 80]) == 50265600\n    assert candidate([10, 22, 9, 33, 21, 50, 41, 60]) == 2460\n\ndef test_check():\n    check(max_product)\n\ntest_check()\n", "sample_io": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000"], "source_codes": ["\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]  # Each element can form a subsequence by itself\n    max_prod = max(dp)  # Initialize with single elements\n    \n    # For each position, check all previous positions\n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element, we can extend the subsequence\n            if arr[i] > arr[j]:\n                # Update dp[i] if extending from j gives better product\n                dp[i] = max(dp[i], dp[j] * arr[i])\n                max_prod = max(max_prod, dp[i])\n    \n    return max_prod\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]  # Each element can form a subsequence by itself\n    max_prod = max(dp)  # Initialize with single elements\n    \n    # For each position, check all previous positions\n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element, we can extend the subsequence\n            if arr[i] > arr[j]:\n                # Update dp[i] if extending from j gives better product\n                dp[i] = max(dp[i], dp[j] * arr[i])\n                max_prod = max(max_prod, dp[i])\n    \n    return max_prod\n```"], "prompt_tokens": [894], "completion_tokens": [970], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_468_max_product"}
{"name": "mbpp_279_is_num_decagonal", "language": "Python3", "prompt": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth decagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_num_decagonal", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(7) == 175\n    assert candidate(10) == 370\n\ndef test_check():\n    check(is_num_decagonal)\n\ntest_check()\n", "sample_io": ["assert is_num_decagonal(3) == 27"], "source_codes": ["\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth decagonal number.\n    \"\"\"\n    return 4 * n * n - 3 * n\n\n\n"], "responses": ["```python\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth decagonal number.\n    \"\"\"\n    return 4 * n * n - 3 * n\n```"], "prompt_tokens": [453], "completion_tokens": [381], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_279_is_num_decagonal"}
{"name": "mbpp_3_is_not_prime", "language": "Python3", "prompt": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to identify non-prime numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_not_prime", "test": "def check(candidate):\n    assert candidate(2) == False\n    assert candidate(10) == True\n    assert candidate(35) == True\n    assert candidate(37) == False\n\ndef test_check():\n    check(is_not_prime)\n\ntest_check()\n", "sample_io": ["assert is_not_prime(2) == False"], "source_codes": ["\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    # Handle edge cases\n    if n < 2:\n        return True\n    \n    # Check if even (except 2)\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True   # Even numbers > 2 are not prime\n    \n    # Check odd divisors up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # Found a divisor, so not prime\n    \n    return False  # No divisors found, it's prime\n\n\n"], "responses": ["```python\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    # Handle edge cases\n    if n < 2:\n        return True\n    \n    # Check if even (except 2)\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True   # Even numbers > 2 are not prime\n    \n    # Check odd divisors up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # Found a divisor, so not prime\n    \n    return False  # No divisors found, it's prime\n```"], "prompt_tokens": [509], "completion_tokens": [562], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_3_is_not_prime"}
{"name": "mbpp_88_freq_count", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_88_freq_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "freq_count", "test": "def check(candidate):\n    assert candidate([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }\n    assert candidate([1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4]) == { 1: 3, 2: 2, 3: 3, 4: 3 }\n    assert candidate([5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5]) == { 10: 1, 5: 3, 6: 2, 7: 2, 4: 2, 9: 2 }\n\ndef test_check():\n    check(freq_count)\n\ntest_check()\n", "sample_io": ["assert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }"], "source_codes": ["\nfrom typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    \n    for element in list1:\n        frequency_dict[element] = frequency_dict.get(element, 0) + 1\n    \n    return frequency_dict\n\n\n"], "responses": ["```python\nfrom typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    \n    for element in list1:\n        frequency_dict[element] = frequency_dict.get(element, 0) + 1\n    \n    return frequency_dict\n```"], "prompt_tokens": [568], "completion_tokens": [499], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_88_freq_count"}
{"name": "mbpp_259_maximize_elements", "language": "Python3", "prompt": "from typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to maximize the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximize_elements", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[7, 8], [5, 10], [3, 10], [8, 11]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[8, 9], [6, 11], [4, 11], [9, 12]]\n\ndef test_check():\n    check(maximize_elements)\n\ntest_check()\n", "sample_io": ["assert maximize_elements([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]"], "source_codes": ["\nfrom typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    Returns a new list where each element is the maximum of corresponding elements from the two input lists.\n    \"\"\"\n    # Handle case where one or both lists are empty\n    if not test_tup1 and not test_tup2:\n        return []\n    if not test_tup1:\n        return [row[:] for row in test_tup2]\n    if not test_tup2:\n        return [row[:] for row in test_tup1]\n    \n    result = []\n    max_rows = max(len(test_tup1), len(test_tup2))\n    \n    for i in range(max_rows):\n        if i >= len(test_tup1):\n            result.append(test_tup2[i][:])\n        elif i >= len(test_tup2):\n            result.append(test_tup1[i][:])\n        else:\n            row1 = test_tup1[i]\n            row2 = test_tup2[i]\n            max_cols = max(len(row1), len(row2))\n            max_row = []\n            \n            for j in range(max_cols):\n                if j >= len(row1):\n                    max_row.append(row2[j])\n                elif j >= len(row2):\n                    max_row.append(row1[j])\n                else:\n                    max_row.append(max(row1[j], row2[j]))\n            \n            result.append(max_row)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    Returns a new list where each element is the maximum of corresponding elements from the two input lists.\n    \"\"\"\n    # Handle case where one or both lists are empty\n    if not test_tup1 and not test_tup2:\n        return []\n    if not test_tup1:\n        return [row[:] for row in test_tup2]\n    if not test_tup2:\n        return [row[:] for row in test_tup1]\n    \n    result = []\n    max_rows = max(len(test_tup1), len(test_tup2))\n    \n    for i in range(max_rows):\n        if i >= len(test_tup1):\n            result.append(test_tup2[i][:])\n        elif i >= len(test_tup2):\n            result.append(test_tup1[i][:])\n        else:\n            row1 = test_tup1[i]\n            row2 = test_tup2[i]\n            max_cols = max(len(row1), len(row2))\n            max_row = []\n            \n            for j in range(max_cols):\n                if j >= len(row1):\n                    max_row.append(row2[j])\n                elif j >= len(row2):\n                    max_row.append(row1[j])\n                else:\n                    max_row.append(max(row1[j], row2[j]))\n            \n            result.append(max_row)\n    \n    return result\n```"], "prompt_tokens": [1098], "completion_tokens": [1266], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_259_maximize_elements"}
{"name": "mbpp_568_empty_list", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n\tWrite a function to create a list of N empty dictionaries.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "empty_list", "test": "def check(candidate):\n    assert candidate(5) == [{  }, {  }, {  }, {  }, {  }]\n    assert candidate(6) == [{  }, {  }, {  }, {  }, {  }, {  }]\n    assert candidate(7) == [{  }, {  }, {  }, {  }, {  }, {  }, {  }]\n\ndef test_check():\n    check(empty_list)\n\ntest_check()\n", "sample_io": ["assert empty_list(5) == [{  }, {  }, {  }, {  }, {  }]"], "source_codes": ["\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n\n\n"], "responses": ["```python\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n```"], "prompt_tokens": [375], "completion_tokens": [288], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_568_empty_list"}
{"name": "mbpp_285_text_match_two_three", "language": "Python3", "prompt": "def text_match_two_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_two_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n\ndef test_check():\n    check(text_match_two_three)\n\ntest_check()\n", "sample_io": ["assert text_match_two_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [525], "completion_tokens": [450], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_285_text_match_two_three"}
{"name": "mbpp_721_maxAverageOfPath", "language": "Python3", "prompt": "from typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maxAverageOfPath", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n    assert candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2\n    assert candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8\n\ndef test_check():\n    check(maxAverageOfPath)\n\ntest_check()\n", "sample_io": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"], "source_codes": ["\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    if not cost or not cost[0]:\n        return 0.0\n    \n    n = len(cost)\n    \n    # dp[i][j] represents maximum sum to reach cell (i,j)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Maximum sum path divided by number of cells (always 2*n-1 for n*n grid)\n    return dp[n-1][n-1] / (2 * n - 1)\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    if not cost or not cost[0]:\n        return 0.0\n    \n    n = len(cost)\n    \n    # dp[i][j] represents maximum sum to reach cell (i,j)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Maximum sum path divided by number of cells (always 2*n-1 for n*n grid)\n    return dp[n-1][n-1] / (2 * n - 1)\n```"], "prompt_tokens": [1064], "completion_tokens": [1070], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_721_maxAverageOfPath"}
{"name": "mbpp_797_sum_in_range", "language": "Python3", "prompt": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd natural numbers within the range l and r.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_in_range", "test": "def check(candidate):\n    assert candidate(2, 5) == 8\n    assert candidate(5, 7) == 12\n    assert candidate(7, 13) == 40\n\ndef test_check():\n    check(sum_in_range)\n\ntest_check()\n", "sample_io": ["assert sum_in_range(2, 5) == 8"], "source_codes": ["\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of all odd natural numbers within the range l and r.\n    \"\"\"\n    total = 0\n    \n    # Start from l, but if l is even, start from l+1 (first odd number)\n    start = l if l % 2 == 1 else l + 1\n    \n    # Iterate through all odd numbers in the range\n    for i in range(start, r + 1, 2):\n        total += i\n    \n    return total\n\n\n"], "responses": ["```python\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of all odd natural numbers within the range l and r.\n    \"\"\"\n    total = 0\n    \n    # Start from l, but if l is even, start from l+1 (first odd number)\n    start = l if l % 2 == 1 else l + 1\n    \n    # Iterate through all odd numbers in the range\n    for i in range(start, r + 1, 2):\n        total += i\n    \n    return total\n```"], "prompt_tokens": [766], "completion_tokens": [749], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_797_sum_in_range"}
