{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n\n\n"], "responses": ["```python\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n```"], "prompt_tokens": [590], "completion_tokens": [502], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible subarrays of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    total_sum = 0\n    n = len(arr)\n    \n    # For each starting position\n    for i in range(n):\n        product = 1\n        # Extend the subarray from position i\n        for j in range(i, n):\n            product *= arr[j]  # Multiply current element\n            total_sum += product  # Add this subarray's product to total\n    \n    return total_sum\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible subarrays of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    total_sum = 0\n    n = len(arr)\n    \n    # For each starting position\n    for i in range(n):\n        product = 1\n        # Extend the subarray from position i\n        for j in range(i, n):\n            product *= arr[j]  # Multiply current element\n            total_sum += product  # Add this subarray's product to total\n    \n    return total_sum\n```"], "prompt_tokens": [867], "completion_tokens": [818], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Find all double quoted strings\n    double_quoted = re.findall(r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"', text)\n    # Find all single quoted strings  \n    single_quoted = re.findall(r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\", text)\n    \n    # Combine both lists\n    return double_quoted + single_quoted\n\n\n"], "responses": ["```python\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Find all double quoted strings\n    double_quoted = re.findall(r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"', text)\n    # Find all single quoted strings  \n    single_quoted = re.findall(r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\", text)\n    \n    # Combine both lists\n    return double_quoted + single_quoted\n```"], "prompt_tokens": [854], "completion_tokens": [846], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": ["\nfrom typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Handle edge cases: empty list or single element list is considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if each element is less than or equal to the next element\n    for i in range(len(list1) - 1):\n        if list1[i] > list1[i + 1]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Handle edge cases: empty list or single element list is considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if each element is less than or equal to the next element\n    for i in range(len(list1) - 1):\n        if list1[i] > list1[i + 1]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [534], "completion_tokens": [521], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n\n\n"], "responses": ["```python\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n```"], "prompt_tokens": [587], "completion_tokens": [501], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    \n    for element in data_list:\n        if isinstance(element, list):\n            # If element is a list, recursively sum its elements\n            total += recursive_list_sum(element)\n        else:\n            # If element is an integer, add it to total\n            total += element\n    \n    return total\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    total = 0\n    \n    for element in data_list:\n        if isinstance(element, list):\n            # If element is a list, recursively sum its elements\n            total += recursive_list_sum(element)\n        else:\n            # If element is an integer, add it to total\n            total += element\n    \n    return total\n```"], "prompt_tokens": [573], "completion_tokens": [537], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    return sorted(list(set(test_tup1) | set(test_tup2)))\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    return sorted(list(set(test_tup1) | set(test_tup2)))\n```"], "prompt_tokens": [704], "completion_tokens": [609], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.match(pattern, string))\n\n\n"], "responses": ["```python\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.match(pattern, string))\n```"], "prompt_tokens": [575], "completion_tokens": [508], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": ["\nfrom typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \"\"\"\n    if r <= 0:\n        return None\n    \n    # The largest triangle inscribed in a semicircle has:\n    # - Base = diameter = 2r\n    # - Height = radius = r\n    # - Area = (1/2) * base * height = (1/2) * 2r * r = r\u00b2\n    return r * r\n\n\n"], "responses": ["```python\nfrom typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \"\"\"\n    if r <= 0:\n        return None\n    \n    # The largest triangle inscribed in a semicircle has:\n    # - Base = diameter = 2r\n    # - Height = radius = r\n    # - Area = (1/2) * base * height = (1/2) * 2r * r = r\u00b2\n    return r * r\n```"], "prompt_tokens": [887], "completion_tokens": [862], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    return sum(1 for element in list1 if isinstance(element, int))\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    return sum(1 for element in list1 if isinstance(element, int))\n```"], "prompt_tokens": [597], "completion_tokens": [509], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize with the first element\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        # Store current values before updating\n        temp_max = max_ending_here\n        temp_min = min_ending_here\n        \n        # Calculate new max and min ending at current position\n        max_ending_here = max(arr[i], temp_max * arr[i], temp_min * arr[i])\n        min_ending_here = min(arr[i], temp_max * arr[i], temp_min * arr[i])\n        \n        # Update global maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n    Write a function to find the maximum product subarray of the given array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Initialize with the first element\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        # Store current values before updating\n        temp_max = max_ending_here\n        temp_min = min_ending_here\n        \n        # Calculate new max and min ending at current position\n        max_ending_here = max(arr[i], temp_max * arr[i], temp_min * arr[i])\n        min_ending_here = min(arr[i], temp_max * arr[i], temp_min * arr[i])\n        \n        # Update global maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```"], "prompt_tokens": [781], "completion_tokens": [866], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    \n    def find_first(arr, x, n):\n        left, right = 0, n - 1\n        result = -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Look for earlier occurrence\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    def find_last(arr, x, n):\n        left, right = 0, n - 1\n        result = -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == x:\n                result = mid\n                left = mid + 1  # Look for later occurrence\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    first_index = find_first(arr, x, n)\n    if first_index == -1:\n        return False\n    \n    last_index = find_last(arr, x, n)\n    count = last_index - first_index + 1\n    \n    return count > n // 2\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    \n    def find_first(arr, x, n):\n        left, right = 0, n - 1\n        result = -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Look for earlier occurrence\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    def find_last(arr, x, n):\n        left, right = 0, n - 1\n        result = -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == x:\n                result = mid\n                left = mid + 1  # Look for later occurrence\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    first_index = find_first(arr, x, n)\n    if first_index == -1:\n        return False\n    \n    last_index = find_last(arr, x, n)\n    count = last_index - first_index + 1\n    \n    return count > n // 2\n```"], "prompt_tokens": [1325], "completion_tokens": [1464], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": ["\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Check if string is empty or too short\n    if len(text) < 2:\n        return False\n    \n    # Check if first character is 'a' and last character is 'b'\n    return text[0] == 'a' and text[-1] == 'b'\n\n\n"], "responses": ["```python\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Check if string is empty or too short\n    if len(text) < 2:\n        return False\n    \n    # Check if first character is 'a' and last character is 'b'\n    return text[0] == 'a' and text[-1] == 'b'\n```"], "prompt_tokens": [573], "completion_tokens": [536], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "responses": ["```python\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n```"], "prompt_tokens": [394], "completion_tokens": [317], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n\n\n"], "responses": ["```python\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n```"], "prompt_tokens": [641], "completion_tokens": [550], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    # Handle empty string case\n    if len(s) == 0:\n        return True\n    \n    # Check if all characters are the same as the first character\n    first_char = s[0]\n    return all(char == first_char for char in s)\n\n\n"], "responses": ["```python\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    # Handle empty string case\n    if len(s) == 0:\n        return True\n    \n    # Check if all characters are the same as the first character\n    first_char = s[0]\n    return all(char == first_char for char in s)\n```"], "prompt_tokens": [616], "completion_tokens": [580], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": ["\nfrom typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n```"], "prompt_tokens": [556], "completion_tokens": [494], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k <= 0:\n        return input[:]\n    \n    # Make a copy to avoid modifying the original\n    result = input[:]\n    \n    # If k is greater than array length, reverse the entire array\n    k = min(k, len(input))\n    \n    # Reverse the first k elements\n    result[:k] = result[:k][::-1]\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k <= 0:\n        return input[:]\n    \n    # Make a copy to avoid modifying the original\n    result = input[:]\n    \n    # If k is greater than array length, reverse the entire array\n    k = min(k, len(input))\n    \n    # Reverse the first k elements\n    result[:k] = result[:k][::-1]\n    \n    return result\n```"], "prompt_tokens": [623], "completion_tokens": [613], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["\nfrom typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return 0\n    \n    return max(nums) - min(nums)\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return 0\n    \n    return max(nums) - min(nums)\n```"], "prompt_tokens": [422], "completion_tokens": [352], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Write a function to flatten a given nested list structure.\n    \"\"\"\n    result = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            # If item is a list, recursively flatten it and extend result\n            result.extend(flatten_list(item))\n        else:\n            # If item is an integer, append it to result\n            result.append(item)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Write a function to flatten a given nested list structure.\n    \"\"\"\n    result = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            # If item is a list, recursively flatten it and extend result\n            result.extend(flatten_list(item))\n        else:\n            # If item is an integer, append it to result\n            result.append(item)\n    \n    return result\n```"], "prompt_tokens": [616], "completion_tokens": [585], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    # Handle edge cases\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    result = []\n    \n    # Iterate through the outer lists\n    for i in range(min(len(test_tup1), len(test_tup2))):\n        inner_list1 = test_tup1[i]\n        inner_list2 = test_tup2[i]\n        \n        # Handle empty inner lists\n        if not inner_list1 or not inner_list2:\n            result.append([])\n            continue\n        \n        # Multiply corresponding elements in inner lists\n        inner_result = []\n        for j in range(min(len(inner_list1), len(inner_list2))):\n            inner_result.append(inner_list1[j] * inner_list2[j])\n        \n        result.append(inner_result)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    # Handle edge cases\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    result = []\n    \n    # Iterate through the outer lists\n    for i in range(min(len(test_tup1), len(test_tup2))):\n        inner_list1 = test_tup1[i]\n        inner_list2 = test_tup2[i]\n        \n        # Handle empty inner lists\n        if not inner_list1 or not inner_list2:\n            result.append([])\n            continue\n        \n        # Multiply corresponding elements in inner lists\n        inner_result = []\n        for j in range(min(len(inner_list1), len(inner_list2))):\n            inner_result.append(inner_list1[j] * inner_list2[j])\n        \n        result.append(inner_result)\n    \n    return result\n```"], "prompt_tokens": [660], "completion_tokens": [709], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize all entries as True\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Start from 2, the first prime\n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize all entries as True\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Start from 2, the first prime\n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [777], "completion_tokens": [861], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle negative indices and normalize them\n    len_list = len(list1)\n    \n    # Convert negative indices to positive ones\n    if m < 0:\n        m = max(0, len_list + m)\n    if n < 0:\n        n = max(0, len_list + n)\n    \n    # Ensure indices are within bounds\n    m = max(0, min(m, len_list - 1))\n    n = max(0, min(n, len_list - 1))\n    \n    # Ensure m <= n for proper range\n    if m > n:\n        m, n = n, m\n    \n    # Calculate sum of elements from index m to n (inclusive)\n    return sum(list1[m:n+1])\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle negative indices and normalize them\n    len_list = len(list1)\n    \n    # Convert negative indices to positive ones\n    if m < 0:\n        m = max(0, len_list + m)\n    if n < 0:\n        n = max(0, len_list + n)\n    \n    # Ensure indices are within bounds\n    m = max(0, min(m, len_list - 1))\n    n = max(0, min(n, len_list - 1))\n    \n    # Ensure m <= n for proper range\n    if m > n:\n        m, n = n, m\n    \n    # Calculate sum of elements from index m to n (inclusive)\n    return sum(list1[m:n+1])\n```"], "prompt_tokens": [841], "completion_tokens": [906], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": ["\nfrom typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using the comb sort algorithm.\n    \n    Comb sort is an improvement over bubble sort that uses a gap sequence\n    to compare elements that are far apart, then gradually reduces the gap.\n    \n    Args:\n        nums: List of integers to sort\n        \n    Returns:\n        Sorted list of integers\n    \"\"\"\n    if not nums or len(nums) <= 1:\n        return nums\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums.copy()\n    n = len(arr)\n    \n    # Initial gap size - typically the array length\n    gap = n\n    # Shrink factor - commonly used value is 1.3\n    shrink_factor = 1.3\n    # Flag to track if any swaps were made\n    swapped = True\n    \n    # Continue until gap is 1 and no swaps were made\n    while gap > 1 or swapped:\n        # Calculate new gap size\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n            \n        # Reset swap flag for this iteration\n        swapped = False\n        \n        # Compare elements with current gap\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap elements\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n                \n    return arr\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using the comb sort algorithm.\n    \n    Comb sort is an improvement over bubble sort that uses a gap sequence\n    to compare elements that are far apart, then gradually reduces the gap.\n    \n    Args:\n        nums: List of integers to sort\n        \n    Returns:\n        Sorted list of integers\n    \"\"\"\n    if not nums or len(nums) <= 1:\n        return nums\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums.copy()\n    n = len(arr)\n    \n    # Initial gap size - typically the array length\n    gap = n\n    # Shrink factor - commonly used value is 1.3\n    shrink_factor = 1.3\n    # Flag to track if any swaps were made\n    swapped = True\n    \n    # Continue until gap is 1 and no swaps were made\n    while gap > 1 or swapped:\n        # Calculate new gap size\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n            \n        # Reset swap flag for this iteration\n        swapped = False\n        \n        # Compare elements with current gap\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap elements\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n                \n    return arr\n```"], "prompt_tokens": [768], "completion_tokens": [957], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())\n\n\n"], "responses": ["```python\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())\n```"], "prompt_tokens": [513], "completion_tokens": [433], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    # Get lengths of all three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table initialized with zeros\n    # dp[i][j][k] represents LCS length of X[0:i], Y[0:j], Z[0:k]\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take maximum of three possibilities\n                    # Exclude one character from each string respectively\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude current char from X\n                        dp[i][j-1][k],    # Exclude current char from Y\n                        dp[i][j][k-1]     # Exclude current char from Z\n                    )\n    \n    # Return the LCS length for complete strings\n    return dp[m][n][o]\n\n\n"], "responses": ["```python\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    # Get lengths of all three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table initialized with zeros\n    # dp[i][j][k] represents LCS length of X[0:i], Y[0:j], Z[0:k]\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take maximum of three possibilities\n                    # Exclude one character from each string respectively\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude current char from X\n                        dp[i][j-1][k],    # Exclude current char from Y\n                        dp[i][j][k-1]     # Exclude current char from Z\n                    )\n    \n    # Return the LCS length for complete strings\n    return dp[m][n][o]\n```"], "prompt_tokens": [923], "completion_tokens": [1116], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": ["\nfrom typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n```"], "prompt_tokens": [350], "completion_tokens": [253], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n```"], "prompt_tokens": [479], "completion_tokens": [386], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["\nfrom typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Write a function to convert a given tuple of positive integers into a single integer.\n    \"\"\"\n    return int(''.join(str(num) for num in nums))\n\n\n"], "responses": ["```python\nfrom typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Write a function to convert a given tuple of positive integers into a single integer.\n    \"\"\"\n    return int(''.join(str(num) for num in nums))\n```"], "prompt_tokens": [468], "completion_tokens": [383], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Write a python function to find the first digit of a given number.\n    \"\"\"\n    # Convert to string and handle negative numbers\n    n_str = str(abs(n))  # Take absolute value to handle negative numbers\n    return int(n_str[0])\n\n\n"], "responses": ["```python\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Write a python function to find the first digit of a given number.\n    \"\"\"\n    # Convert to string and handle negative numbers\n    n_str = str(abs(n))  # Take absolute value to handle negative numbers\n    return int(n_str[0])\n```"], "prompt_tokens": [547], "completion_tokens": [496], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()\n```"], "prompt_tokens": [431], "completion_tokens": [339], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": ["\nfrom typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    arr.sort()\n    \n    min_diff = abs(arr[1] - arr[0])\n    \n    for i in range(1, n - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    arr.sort()\n    \n    min_diff = abs(arr[1] - arr[0])\n    \n    for i in range(1, n - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n```"], "prompt_tokens": [680], "completion_tokens": [610], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, index1, index2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Set to keep track of visited indices to avoid duplicates\n    visited = set()\n    visited.add((0, 0))\n    \n    result = []\n    \n    while heap and len(result) < k:\n        # Get the pair with minimum sum\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        # Pair with next element from nums1\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Pair with next element from nums2\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, index1, index2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Set to keep track of visited indices to avoid duplicates\n    visited = set()\n    visited.add((0, 0))\n    \n    result = []\n    \n    while heap and len(result) < k:\n        # Get the pair with minimum sum\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        # Pair with next element from nums1\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Pair with next element from nums2\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n```"], "prompt_tokens": [918], "completion_tokens": [1058], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return str1\n    \n    result = str1[0]  # Start with the first character\n    \n    for i in range(1, len(str1)):\n        if str1[i].isupper():\n            result += ' ' + str1[i]\n        else:\n            result += str1[i]\n    \n    return result\n\n\n"], "responses": ["```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return str1\n    \n    result = str1[0]  # Start with the first character\n    \n    for i in range(1, len(str1)):\n        if str1[i].isupper():\n            result += ' ' + str1[i]\n        else:\n            result += str1[i]\n    \n    return result\n```"], "prompt_tokens": [511], "completion_tokens": [492], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": ["\nfrom typing import Tuple\nimport cmath\n\ndef convert(numbers: complex) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number\n        \n    Returns:\n        Tuple containing (magnitude, phase) representing the polar coordinates\n    \"\"\"\n    return cmath.polar(numbers)\n\n\n"], "responses": ["```python\nfrom typing import Tuple\nimport cmath\n\ndef convert(numbers: complex) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number\n        \n    Returns:\n        Tuple containing (magnitude, phase) representing the polar coordinates\n    \"\"\"\n    return cmath.polar(numbers)\n```"], "prompt_tokens": [562], "completion_tokens": [505], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_252_convert"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["\nfrom typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n```"], "prompt_tokens": [407], "completion_tokens": [328], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Write a function to find the median of three numbers.\n    \"\"\"\n    # Put the numbers in a list and sort them\n    numbers = [a, b, c]\n    numbers.sort()\n    \n    # Return the middle element (index 1) as a float\n    return float(numbers[1])\n\n\n"], "responses": ["```python\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Write a function to find the median of three numbers.\n    \"\"\"\n    # Put the numbers in a list and sort them\n    numbers = [a, b, c]\n    numbers.sort()\n    \n    # Return the middle element (index 1) as a float\n    return float(numbers[1])\n```"], "prompt_tokens": [485], "completion_tokens": [443], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    # Start with empty combination\n    result = [[]]\n    \n    # For each element in the input list\n    for element in list1:\n        # Add this element to all existing combinations\n        new_combinations = []\n        for combo in result:\n            new_combinations.append(combo + [element])\n        result.extend(new_combinations)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    # Start with empty combination\n    result = [[]]\n    \n    # For each element in the input list\n    for element in list1:\n        # Add this element to all existing combinations\n        new_combinations = []\n        for combo in result:\n            new_combinations.append(combo + [element])\n        result.extend(new_combinations)\n    \n    return result\n```"], "prompt_tokens": [600], "completion_tokens": [569], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": ["\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Find numbers within a given range where every number is divisible by every digit it contains.\n    \"\"\"\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        # Convert number to string to easily access digits\n        num_str = str(num)\n        \n        # Check if number contains 0\n        if '0' in num_str:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n        \n        if valid:\n            result.append(num)\n    \n    return result\n\n\n"], "responses": ["```python\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n    Find numbers within a given range where every number is divisible by every digit it contains.\n    \"\"\"\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        # Convert number to string to easily access digits\n        num_str = str(num)\n        \n        # Check if number contains 0\n        if '0' in num_str:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n        \n        if valid:\n            result.append(num)\n    \n    return result\n```"], "prompt_tokens": [759], "completion_tokens": [712], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n```"], "prompt_tokens": [442], "completion_tokens": [364], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result\n```"], "prompt_tokens": [485], "completion_tokens": [430], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a list contains the given sublist or not.\n    \"\"\"\n    # Handle edge case: empty sublist\n    if not s:\n        return True\n    \n    # Handle edge case: sublist longer than main list\n    if len(s) > len(l):\n        return False\n    \n    # Check each possible starting position\n    for i in range(len(l) - len(s) + 1):\n        # Check if the slice matches the sublist\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a list contains the given sublist or not.\n    \"\"\"\n    # Handle edge case: empty sublist\n    if not s:\n        return True\n    \n    # Handle edge case: sublist longer than main list\n    if len(s) > len(l):\n        return False\n    \n    # Check each possible starting position\n    for i in range(len(l) - len(s) + 1):\n        # Check if the slice matches the sublist\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n```"], "prompt_tokens": [722], "completion_tokens": [720], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": ["\nfrom typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert one list to a set for efficient lookup\n    set1 = set(list1)\n    \n    # Check if any element from list2 exists in set1\n    for element in list2:\n        if element in set1:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\nfrom typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert one list to a set for efficient lookup\n    set1 = set(list1)\n    \n    # Check if any element from list2 exists in set1\n    for element in list2:\n        if element in set1:\n            return True\n    \n    return False\n```"], "prompt_tokens": [678], "completion_tokens": [624], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "responses": ["```python\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n```"], "prompt_tokens": [491], "completion_tokens": [412], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": ["\nfrom typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using pancake sort algorithm.\n    Returns a list of k-values representing the flip operations.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original\n    arr = nums.copy()\n    result = []\n    n = len(arr)\n    \n    # Work from the end of the array towards the beginning\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_idx = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        \n        # If the maximum is already at the end, no flip needed\n        if max_idx == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip to bring it to the front\n        if max_idx != 0:\n            # Flip from 0 to max_idx (inclusive)\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            result.append(max_idx + 1)\n        \n        # Flip from 0 to size-1 to move the maximum to its correct position\n        arr[:size] = arr[:size][::-1]\n        result.append(size)\n    \n    return result\n\n# Helper function to apply pancake flips to verify the result\ndef apply_pancake_flips(nums: List[int], flips: List[int]) -> List[int]:\n    \"\"\"Apply pancake flips to an array and return the result.\"\"\"\n    arr = nums.copy()\n    for k in flips:\n        arr[:k] = arr[:k][::-1]\n    return arr\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using pancake sort algorithm.\n    Returns a list of k-values representing the flip operations.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original\n    arr = nums.copy()\n    result = []\n    n = len(arr)\n    \n    # Work from the end of the array towards the beginning\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_idx = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        \n        # If the maximum is already at the end, no flip needed\n        if max_idx == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip to bring it to the front\n        if max_idx != 0:\n            # Flip from 0 to max_idx (inclusive)\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            result.append(max_idx + 1)\n        \n        # Flip from 0 to size-1 to move the maximum to its correct position\n        arr[:size] = arr[:size][::-1]\n        result.append(size)\n    \n    return result\n\n# Helper function to apply pancake flips to verify the result\ndef apply_pancake_flips(nums: List[int], flips: List[int]) -> List[int]:\n    \"\"\"Apply pancake flips to an array and return the result.\"\"\"\n    arr = nums.copy()\n    for k in flips:\n        arr[:k] = arr[:k][::-1]\n    return arr\n```"], "prompt_tokens": [830], "completion_tokens": [1081], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return first N elements\n    products.sort(reverse=True)\n    \n    # Return at most N elements\n    return products[:N]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return first N elements\n    products.sort(reverse=True)\n    \n    # Return at most N elements\n    return products[:N]\n```"], "prompt_tokens": [611], "completion_tokens": [595], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": ["\nimport math\n\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Write a function to find the third side of a right angled triangle.\n    \"\"\"\n    # Find the hypotenuse given the two legs of a right triangle\n    return math.sqrt(w**2 + h**2)\n\n\n"], "responses": ["```python\nimport math\n\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Write a function to find the third side of a right angled triangle.\n    \"\"\"\n    # Find the hypotenuse given the two legs of a right triangle\n    return math.sqrt(w**2 + h**2)\n```"], "prompt_tokens": [651], "completion_tokens": [589], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, concatenate with test_list, then convert back to tuple\n    result = list(test_tup) + test_list\n    return tuple(result)\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, concatenate with test_list, then convert back to tuple\n    result = list(test_tup) + test_list\n    return tuple(result)\n```"], "prompt_tokens": [518], "completion_tokens": [441], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n\n\n"], "responses": ["```python\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return test_tup + (test_dict,)\n```"], "prompt_tokens": [535], "completion_tokens": [420], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
