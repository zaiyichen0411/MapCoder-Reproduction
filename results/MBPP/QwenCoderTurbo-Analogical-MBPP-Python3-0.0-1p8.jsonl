{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["\nfrom typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    max_sublist = []\n    max_len = 0\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n\n\n"], "responses": ["## Algorithms:\nThe core concept used in this problem is **iteration and comparison**. We need to iterate through each sublist in the given list, compare their lengths, and find the sublist with the maximum length. This is a basic algorithm involving loops and conditionals.\n\n## Tutorial:\nIn this problem, we are given a list of lists, and we are to find the sublist with the maximum length. The algorithm works as follows:\n\n1. Initialize a variable to keep track of the maximum length found so far (e.g., `max_len = 0`) and another to store the corresponding sublist (e.g., `max_sublist = []`).\n2. Iterate through each sublist in the input list.\n3. For each sublist, check its length.\n4. If the length is greater than the current `max_len`, update `max_len` and set `max_sublist` to this sublist.\n5. After the loop, return `max_sublist`.\n\nThis is a linear time algorithm, O(n), where n is the number of sublists in the input list.\n\n## Example Problems:\n\n### Problem 1: Find the Longest Word in a Sentence\n**Description:** Given a sentence, find the longest word.\n**Solution:** Split the sentence into words, iterate through them, and keep track of the longest one.\n**Python Code:**\n```python\ndef longest_word(sentence: str) -> str:\n    words = sentence.split()\n    max_word = \"\"\n    for word in words:\n        if len(word) > len(max_word):\n            max_word = word\n    return max_word\n```\n\n### Problem 2: Find the Longest Subarray with Even Sum\n**Description:** Given an array of integers, find the longest subarray with even sum.\n**Solution:** Use a prefix sum and track the first occurrence of each remainder when divided by 2. This is a more advanced algorithm involving hash maps.\n**Python Code:**\n```python\ndef longest_even_sum_subarray(arr: List[int]) -> int:\n    prefix_sum = 0\n    first_occurrence = {0: -1}\n    max_len = 0\n    for i, num in enumerate(arr):\n        prefix_sum += num\n        remainder = prefix_sum % 2\n        if remainder in first_occurrence:\n            max_len = max(max_len, i - first_occurrence[remainder])\n        else:\n            first_occurrence[remainder] = i\n    return max_len\n```\n\n### Problem 3: Find the Longest Increasing Subsequence\n**Description:** Given an array, find the length of the longest increasing subsequence.\n**Solution:** Use dynamic programming where `dp[i]` represents the length of the longest increasing subsequence ending at index `i`.\n**Python Code:**\n```python\ndef longest_increasing_subsequence(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nWe are given a list of lists and need to find the sublist with the maximum length. We iterate through each sublist, compare its length to the current maximum, and update our result accordingly.\n\n### Python3 code:\n```python\nfrom typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    max_sublist = []\n    max_len = 0\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n```"], "prompt_tokens": [213], "completion_tokens": [778], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["\nfrom typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Split a string into characters.\n    \"\"\"\n    return list(word)\n\n# Example usage:\nprint(split(\"hello\"))  # Output: ['h', 'e', 'l', 'l', 'o']\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem is **string manipulation**, specifically **splitting a string into individual characters**. This is a basic operation that can be achieved using Python's built-in features, such as iterating over the string or using list comprehensions.\n\n## Tutorial:\nIn Python, a string is an iterable, meaning you can loop through each character. To split a string into a list of characters, you can use a list comprehension or the `list()` function. For example, `list(\"hello\")` will return `['h', 'e', 'l', 'l', 'o']`.\n\nThis is useful in many competitive programming scenarios, such as:\n- Counting character frequencies\n- Checking for palindromes\n- Solving anagram problems\n- Processing individual characters for transformations\n\n## Example Problems:\n\n### 1. **Count the number of vowels in a string**\n**Problem:** Given a string, count how many vowels (a, e, i, o, u) are present.\n\n**Solution:** Convert the string into a list of characters, iterate through each character, and check if it is a vowel.\n\n**Python3 Code:**\n```python\ndef count_vowels(word: str) -> int:\n    vowels = set(\"aeiou\")\n    return sum(1 for char in word if char in vowels)\n\n# Example usage:\nprint(count_vowels(\"hello\"))  # Output: 2\n```\n\n---\n\n### 2. **Check if a string is a palindrome**\n**Problem:** Determine if a string reads the same backward as forward.\n\n**Solution:** Convert the string to a list of characters, reverse it, and compare.\n\n**Python3 Code:**\n```python\ndef is_palindrome(word: str) -> bool:\n    return word == word[::-1]\n\n# Example usage:\nprint(is_palindrome(\"radar\"))  # Output: True\nprint(is_palindrome(\"hello\"))  # Output: False\n```\n\n---\n\n### 3. **Check if two strings are anagrams**\n**Problem:** Determine if two strings contain the same characters with the same frequencies.\n\n**Solution:** Convert both strings to lists of characters, sort them, and compare.\n\n**Python3 Code:**\n```python\ndef are_anagrams(s1: str, s2: str) -> bool:\n    return sorted(s1) == sorted(s2)\n\n# Example usage:\nprint(are_anagrams(\"listen\", \"silent\"))  # Output: True\nprint(are_anagrams(\"hello\", \"world\"))    # Output: False\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `split(word: str)` needs to return a list of characters from the input string. Since a string is iterable in Python, we can directly convert it into a list using `list(word)`. This is a simple and efficient way to split the string.\n\n### Python3 code:\n```python\nfrom typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Split a string into characters.\n    \"\"\"\n    return list(word)\n\n# Example usage:\nprint(split(\"hello\"))  # Output: ['h', 'e', 'l', 'l', 'o']\n```"], "prompt_tokens": [204], "completion_tokens": [665], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for element in list1[1:]:\n        if element == current_group[-1]:\n            current_group.append(element)\n        else:\n            result.append(current_group)\n            current_group = [element]\n    \n    result.append(current_group)\n    return result\n\n# Example usage:\n# print(pack_consecutive_duplicates([1, 1, 2, 2, 3]))  # Output: [[1, 1], [2, 2], [3]]\n\n\n"], "responses": ["## Algorithms:\nThe core concept for solving this problem is **grouping consecutive elements** in a list. We need to traverse the list and group elements that are the same and appear consecutively. This is often referred to as the **\"run-length encoding\"** or **\"grouping consecutive elements\"** algorithm.\n\n## Tutorial:\nThe task is to take a list and create a new list where consecutive duplicates are grouped into sublists. For example, given `[1, 1, 2, 2, 3]`, the result should be `[[1, 1], [2, 2], [3]]`.\n\nTo implement this:\n1. Initialize an empty result list.\n2. Initialize a temporary list to hold the current group of elements.\n3. Iterate through the input list:\n   - If the current element is the same as the last element in the temporary list, add it to the temporary list.\n   - If it's different, add the temporary list to the result and start a new temporary list with the current element.\n4. After the loop, add the last temporary list to the result.\n\nThis is a linear time algorithm (O(n)), where n is the length of the input list.\n\n## Example Problems:\n\n### 1. LeetCode 118: Pascal's Triangle\n**Problem:** Generate Pascal's triangle up to a given number of rows.\n\n**Solution:** This involves building a 2D list where each row is generated based on the previous row. While not exactly the same as grouping consecutive elements, it involves building structured sublists.\n\n```python\ndef generate_pascal_triangle(num_rows):\n    triangle = []\n    for row in range(num_rows):\n        current_row = [1] * (row + 1)\n        for i in range(1, row):\n            current_row[i] = triangle[row - 1][i - 1] + triangle[row - 1][i]\n        triangle.append(current_row)\n    return triangle\n```\n\n### 2. LeetCode 448: Find All Numbers Disappeared in an Array\n**Problem:** Given an array of integers where 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others once. Find all the elements that appear once in the array.\n\n**Solution:** While not directly grouping consecutive elements, this problem involves traversing and grouping elements in a way to detect duplicates.\n\n```python\ndef find_disappeared_numbers(nums):\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n    return [i + 1 for i, num in enumerate(nums) if num > 0]\n```\n\n### 3. LeetCode 128: Longest Consecutive Sequence\n**Problem:** Given an unsorted array of integers, find the length of the longest consecutive sequence.\n\n**Solution:** This problem involves identifying sequences of consecutive numbers, which is similar to grouping consecutive elements.\n\n```python\ndef longest_consecutive_sequence(nums):\n    num_set = set(nums)\n    longest = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n\n            longest = max(longest, current_length)\n\n    return longest\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `pack_consecutive_duplicates` takes a list and returns a list of sublists where each sublist contains consecutive duplicates. We iterate through the list and compare each element with the previous one. If they are the same, we add it to the current sublist; otherwise, we start a new sublist.\n\n### Python3 code:\n```python\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for element in list1[1:]:\n        if element == current_group[-1]:\n            current_group.append(element)\n        else:\n            result.append(current_group)\n            current_group = [element]\n    \n    result.append(current_group)\n    return result\n\n# Example usage:\n# print(pack_consecutive_duplicates([1, 1, 2, 2, 3]))  # Output: [[1, 1], [2, 2], [3]]\n```"], "prompt_tokens": [217], "completion_tokens": [943], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\nimport heapq\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find the K smallest elements from a list of tuples.\n    The tuples are compared lexicographically.\n    \"\"\"\n    return heapq.nsmallest(K, test_list)\n\n# Example usage:\ntest_list = [(\"a\", 10), (\"b\", 5), (\"c\", 15), (\"d\", 3)]\nK = 2\nprint(min_k(test_list, K))  # Output: [('d', 3), ('b', 5)]\n\n\n"], "responses": ["## Algorithms:\nThe core concept used in solving this problem is **selection of minimum elements** from a list of tuples. This can be efficiently done using the **heapq** module in Python, specifically the `nsmallest` function, which returns the k smallest elements from a list. Alternatively, we can also sort the list and pick the first k elements.\n\n## Tutorial:\nIn competitive programming, when you are required to find the k smallest or largest elements from a list, using sorting or a heap-based approach is common. For small to moderate sizes of input, sorting is straightforward and efficient. However, for very large datasets, using a heap (like `heapq.nsmallest`) is more efficient as it avoids the full sort and only keeps track of the k smallest elements.\n\nThe `heapq.nsmallest(k, iterable)` function is particularly useful here. It returns the k smallest elements from the given iterable, which in this case is a list of tuples. The tuples are compared lexicographically, so the function will find the k smallest based on the first element of the tuple, then the second, etc.\n\n## Example Problems:\n\n### 1. **Find K Smallest Elements in a List**\n**Problem:** Given a list of integers, find the k smallest elements.\n\n**Solution:** We can use the `heapq.nsmallest` function to directly get the k smallest elements.\n\n**Python3 Code:**\n```python\nimport heapq\n\ndef find_k_smallest(nums, k):\n    return heapq.nsmallest(k, nums)\n\n# Example usage:\nnums = [5, 1, 8, 3, 2, 9]\nk = 3\nprint(find_k_smallest(nums, k))  # Output: [1, 2, 3]\n```\n\n---\n\n### 2. **Find K Largest Elements in a List**\n**Problem:** Given a list of integers, find the k largest elements.\n\n**Solution:** We can use `heapq.nlargest` to find the k largest elements.\n\n**Python3 Code:**\n```python\nimport heapq\n\ndef find_k_largest(nums, k):\n    return heapq.nlargest(k, nums)\n\n# Example usage:\nnums = [5, 1, 8, 3, 2, 9]\nk = 3\nprint(find_k_largest(nums, k))  # Output: [9, 8, 5]\n```\n\n---\n\n### 3. **Find K Smallest Tuples in a List**\n**Problem:** Given a list of tuples, find the k smallest tuples based on the first element of the tuple.\n\n**Solution:** We can use `heapq.nsmallest` to directly find the k smallest tuples.\n\n**Python3 Code:**\n```python\nimport heapq\n\ndef find_k_smallest_tuples(tuples, k):\n    return heapq.nsmallest(k, tuples)\n\n# Example usage:\ntuples = [(\"a\", 10), (\"b\", 5), (\"c\", 15), (\"d\", 3)]\nk = 2\nprint(find_k_smallest_tuples(tuples, k))  # Output: [('d', 3), ('b', 5)]\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `min_k` is intended to find the k smallest elements from a list of tuples. Since tuples are compared lexicographically in Python, we can use the `heapq.nsmallest` function to directly get the k smallest tuples.\n\n### Python3 code:\n```python\nimport heapq\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find the K smallest elements from a list of tuples.\n    The tuples are compared lexicographically.\n    \"\"\"\n    return heapq.nsmallest(K, test_list)\n\n# Example usage:\ntest_list = [(\"a\", 10), (\"b\", 5), (\"c\", 15), (\"d\", 3)]\nK = 2\nprint(min_k(test_list, K))  # Output: [('d', 3), ('b', 5)]\n```"], "prompt_tokens": [254], "completion_tokens": [869], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["\ndef check_integer(text: str) -> bool:\n    text = text.strip()\n    if not text:\n        return False\n    if text[0] in \"+-\":\n        text = text[1:]\n    if not text:\n        return False\n    if text[0] == \"0\" and len(text) > 1:\n        return False\n    return text.isdigit()\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem is **string validation**. Specifically, we need to check whether a given string represents a valid integer. This involves checking for:\n\n- Optional leading sign (`+` or `-`)\n- Digits only (`0-9`)\n- No leading zeros (unless the number is exactly \"0\")\n- No other characters or whitespace\n\nThis problem involves **basic string manipulation and condition checking**.\n\n## Tutorial:\nTo determine if a string represents an integer, follow these steps:\n\n1. **Check for an optional leading sign**: The string may start with `+` or `-`.\n2. **Check for digits only**: After the optional sign, the rest of the string should consist of digits only.\n3. **Check for leading zeros**: If the string has more than one character and starts with `0`, it is invalid unless it's exactly \"0\".\n4. **Handle edge cases**: Strings like `\"0\"`, `\"-0\"`, `\"+0\"` are valid, but `\"00\"` or `\"012\"` are not.\n\nThis can be implemented using simple string checks and conditionals.\n\n## Example Problems:\n\n### Problem 1: Valid Number (LeetCode 65)\n**Problem Description**: Determine if a string is a valid number (integer or decimal).\n\n**Solution**:\n- Use a state machine or check for optional sign, digits, and optional decimal point.\n- This is an extension of the integer check problem.\n\n**Python3 Code**:\n```python\ndef is_valid_number(s: str) -> bool:\n    s = s.strip()\n    if not s:\n        return False\n    if s[0] in \"+-\":\n        s = s[1:]\n    if not s:\n        return False\n    if s[0] == \"0\" and len(s) > 1:\n        return False\n    for c in s:\n        if not c.isdigit():\n            return False\n    return True\n```\n\n---\n\n### Problem 2: Valid Integer (LeetCode 6)\n**Problem Description**: Check if a string is a valid integer, similar to the problem described here.\n\n**Solution**:\n- Use the same logic as the `check_integer` function.\n- Handle optional sign and check for valid digits.\n\n**Python3 Code**:\n```python\ndef is_valid_integer(s: str) -> bool:\n    s = s.strip()\n    if not s:\n        return False\n    if s[0] in \"+-\":\n        s = s[1:]\n    if not s:\n        return False\n    if s[0] == \"0\" and len(s) > 1:\n        return False\n    for c in s:\n        if not c.isdigit():\n            return False\n    return True\n```\n\n---\n\n### Problem 3: Check if a string is a valid integer (Codeforces)\n**Problem Description**: Given a string, check if it is a valid integer.\n\n**Solution**:\n- Similar to the problem at hand.\n- Check for optional sign and digits only.\n\n**Python3 Code**:\n```python\ndef is_valid_integer(s: str) -> bool:\n    s = s.strip()\n    if not s:\n        return False\n    if s[0] in \"+-\":\n        s = s[1:]\n    if not s:\n        return False\n    if s[0] == \"0\" and len(s) > 1:\n        return False\n    return s.isdigit()\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nWe will implement the `check_integer` function by:\n1. Stripping whitespace from the string.\n2. Checking for an optional leading sign (`+` or `-`).\n3. Ensuring that the rest of the string consists of digits.\n4. Ensuring that there are no leading zeros (unless the string is exactly `\"0\"`).\n\n### Python3 code to solve the problem:\n```python\ndef check_integer(text: str) -> bool:\n    text = text.strip()\n    if not text:\n        return False\n    if text[0] in \"+-\":\n        text = text[1:]\n    if not text:\n        return False\n    if text[0] == \"0\" and len(text) > 1:\n        return False\n    return text.isdigit()\n```"], "prompt_tokens": [202], "completion_tokens": [891], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\nfrom typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    n = len(list)\n    m = m % n  # Handle cases where m is larger than the list length\n    return list[-m:] + list[:-m]\n\n\n"], "responses": ["## Algorithms:\nThe core concept used in this problem is **array rotation**. Specifically, rotating a list to the right by `m` positions. This involves shifting elements in the list such that the last `m` elements move to the front, and the rest follow.\n\nTo achieve this efficiently, we can use slicing in Python, which allows us to take parts of the list and concatenate them in the desired order.\n\n## Tutorial:\nRotating a list to the right by `m` positions means that each element moves `m` positions to the right, and the elements that go beyond the end of the list wrap around to the front. For example, if the list is `[1, 2, 3, 4, 5]` and `m = 2`, the rotated list would be `[4, 5, 1, 2, 3]`.\n\nIn Python, we can use slicing to achieve this:\n- `list[-m:]` gives the last `m` elements of the list.\n- `list[:-m]` gives the rest of the elements except the last `m`.\n\nSo the rotated list can be formed by concatenating these two slices: `list[-m:] + list[:-m]`.\n\nThis method is efficient and has a time complexity of O(n), where n is the length of the list, as slicing and concatenation take linear time.\n\n## Example Problems:\n\n### 1. **Rotate Array (LeetCode 189)**\n**Problem Description:**\nGiven an array, rotate the array to the right by `k` steps, where `k` is non-negative.\n\n**Solution:**\nWe can use the slicing method as explained above. For example, if the array is `[1, 2, 3, 4, 5]` and `k = 2`, the result is `[4, 5, 1, 2, 3]`.\n\n**Python3 Code:**\n```python\ndef rotate(nums: List[int], k: int) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place.\n    \"\"\"\n    n = len(nums)\n    k = k % n  # Handle cases where k > n\n    nums[:] = nums[-k:] + nums[:-k]\n```\n\n---\n\n### 2. **Rotate List (LeetCode 61)**\n**Problem Description:**\nGiven a linked list, rotate the list to the right by `k` places.\n\n**Solution:**\nThis problem is similar but involves linked list manipulation. We can find the length of the list, adjust `k` to be within the list length, and then perform the rotation by reordering the nodes.\n\n**Python3 Code:**\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rotateRight(head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n        return head\n\n    # Find length of the list\n    length = 1\n    current = head\n    while current.next:\n        length += 1\n        current = current.next\n\n    # Adjust k\n    k = k % length\n    if k == 0:\n        return head\n\n    # Find the new head\n    new_head = head\n    for _ in range(length - k - 1):\n        new_head = new_head.next\n\n    # Split the list\n    result = new_head.next\n    new_head.next = None\n\n    # Find the end of the new list and connect to original head\n    current = result\n    while current.next:\n        current = current.next\n    current.next = head\n\n    return result\n```\n\n---\n\n### 3. **Right Rotate a String (GeeksforGeeks)**\n**Problem Description:**\nGiven a string and a number `k`, rotate the string to the right by `k` positions.\n\n**Solution:**\nSimilar to list rotation, we can use slicing. For example, `'abcdef'` rotated by 2 becomes `'efabcd'`.\n\n**Python3 Code:**\n```python\ndef right_rotate_string(s: str, k: int) -> str:\n    k = k % len(s)\n    return s[-k:] + s[:-k]\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `rotate_right` takes a list and an integer `m`, and returns a new list that is the original list rotated to the right by `m` positions. We use Python slicing to get the last `m` elements and the rest of the elements, then concatenate them.\n\n### Python3 code to solve the problem:\n```python\nfrom typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Write a function to rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    n = len(list)\n    m = m % n  # Handle cases where m is larger than the list length\n    return list[-m:] + list[:-m]\n```"], "prompt_tokens": [233], "completion_tokens": [1066], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb3' in position 716: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total = 0\n    for num in nums:\n        if isinstance(num, int):\n            num_str = str(abs(num))\n            total += sum(int(d) for d in num_str)\n        elif isinstance(num, float) and num.is_integer():\n            num_int = int(abs(num))\n            num_str = str(num_int)\n            total += sum(int(d) for d in num_str)\n    return total\n\n# Example usage:\nprint(sum_of_digits([123, 456, -789]))  # Output: 1+2+3 + 4+5+6 + 7+8+9 = 45\n\n\n"], "responses": ["## Algorithms:\nThe core concept here is **digit extraction and summation**. For each number in the list, we need to extract its individual digits and sum them. This involves:\n- Converting a number into its individual digits.\n- Summing the digits.\n\nThis is a common task in competitive programming, especially in problems involving number manipulation, digit sums, or properties of numbers.\n\n---\n\n## Tutorial:\nTo compute the sum of digits of a number, you can use the following approach:\n\n1. **Convert the number to a string** (this is the easiest way to access each digit).\n2. **Iterate through each character** in the string.\n3. **Convert each character back to an integer** and add it to a running total.\n\nFor example, for the number `1234`:\n- Convert to string: `\"1234\"`\n- Iterate through `'1'`, `'2'`, `'3'`, `'4'`\n- Convert each to int: `1, 2, 3, 4`\n- Sum: `1+2+3+4 = 10`\n\nThis approach works for both positive and negative numbers, but we need to ignore the negative sign if present.\n\nIn the given function, since the input is a list of `Any` type, we need to ensure that each element is a number (int or float), and handle non-numeric values appropriately (e.g., skip or raise an error).\n\n---\n\n## Example Problems:\n\n### Problem 1: **Sum of Digits (Codeforces 1001A)**\n**Problem Description:**  \nGiven a number, compute the sum of its digits.\n\n**Solution:**  \nConvert the number to a string, iterate through each character, convert to int, and sum.\n\n**Python3 Code:**\n```python\ndef sum_of_digits(n: int) -> int:\n    return sum(int(d) for d in str(abs(n)))\n\n# Example usage:\nprint(sum_of_digits(1234))  # Output: 10\n```\n\n---\n\n### Problem 2: **Digit Sum Check (LeetCode 1662)**\n**Problem Description:**  \nGiven two strings of digits, check if they have the same sum of digits.\n\n**Solution:**  \nCompute the digit sum of each string using the same method.\n\n**Python3 Code:**\n```python\ndef are_equal(s1: str, s2: str) -> bool:\n    def digit_sum(s: str) -> int:\n        return sum(int(c) for c in s)\n    return digit_sum(s1) == digit_sum(s2)\n\n# Example usage:\nprint(are_equal(\"123\", \"321\"))  # Output: True\n```\n\n---\n\n### Problem 3: **Minimum Number with Digit Sum (LeetCode 1057)**\n**Problem Description:**  \nFind the smallest number with a given digit sum and a given number of digits.\n\n**Solution:**  \nUse a greedy approach: place the largest digits at the end to minimize the number.\n\n**Python3 Code:**\n```python\ndef smallest_number_with_sum(s: int, k: int) -> str:\n    if s == 0:\n        return \"0\" * k\n    if s > 9 * k:\n        return \"-1\"\n    \n    result = ['0'] * k\n    s -= 1  # First digit is at least 1\n    for i in range(k - 1, -1, -1):\n        if s > 9:\n            result[i] = '9'\n            s -= 9\n        else:\n            result[i] = str(s)\n            s = 0\n    return ''.join(result)\n\n# Example usage:\nprint(smallest_number_with_sum(10, 3))  # Output: \"109\"\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\n- The function `sum_of_digits` takes a list of elements of type `Any`.\n- It iterates through each element in the list.\n- For each element, it checks if it is an integer (or a float that can be converted to an integer).\n- If it is, it converts it to a string, ignores the negative sign, and sums the digits.\n- If the element is not a number, it is skipped or handled accordingly.\n\n### Python3 code:\n```python\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total = 0\n    for num in nums:\n        if isinstance(num, int):\n            num_str = str(abs(num))\n            total += sum(int(d) for d in num_str)\n        elif isinstance(num, float) and num.is_integer():\n            num_int = int(abs(num))\n            num_str = str(num_int)\n            total += sum(int(d) for d in num_str)\n    return total\n\n# Example usage:\nprint(sum_of_digits([123, 456, -789]))  # Output: 1+2+3 + 4+5+6 + 7+8+9 = 45\n```"], "prompt_tokens": [214], "completion_tokens": [1067], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\narr = [-1, 2, -3, 4, 5]\nn = 5\nprint(re_arrange_array(arr, n))  # Output: [-1, -3, 2, 4, 5]\n\n\n"], "responses": ["## Algorithms:\n\nThe core concept for solving this problem is **in-place rearrangement** of elements while preserving the **relative order** of elements. Specifically, we need to move all negative numbers to the front of the array, while keeping the relative order of the negative and positive numbers intact. This can be done using a **two-pointer approach** or **in-place partitioning** with order preservation.\n\n## Tutorial:\n\nThe problem requires rearranging the first `n` elements of an array such that all negative numbers come before positive numbers, but without changing the **relative order** of the negatives and positives. This is a variation of the classic **partitioning** problem seen in quicksort, but with an added constraint of preserving order.\n\n### Key Concepts:\n\n1. **In-place rearrangement**: We should not use extra space to store the result, but instead modify the array in-place.\n2. **Relative order preservation**: After rearrangement, the order of negative numbers among themselves and the order of positive numbers among themselves should remain the same.\n3. **Two-pointer technique**:\n   - One pointer to track the position where the next negative number should be placed.\n   - Iterate through the array and whenever a negative number is found, swap it with the position indicated by the first pointer.\n\nThis ensures that the relative order is preserved and the negatives are moved to the front.\n\n---\n\n## Example Problems:\n\n### Problem 1: \"Rearrange Array in Order of Negatives and Positives\"\n\n**Problem Description:**  \nGiven an array of integers, rearrange the array in such a way that all negative numbers appear before positive numbers, while preserving the relative order of negative and positive numbers.\n\n**Solution:**  \nUse a two-pointer approach:\n- One pointer (`i`) tracks the position where the next negative number should be placed.\n- Iterate through the array. For each element:\n  - If it's negative, swap it with the element at index `i` and increment `i`.\n\n**Python3 Code:**\n```python\ndef re_arrange_array(arr: List[int]) -> List[int]:\n    i = 0\n    for j in range(len(arr)):\n        if arr[j] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    return arr\n```\n\n---\n\n### Problem 2: \"Move All Zeros to End of Array\"\n\n**Problem Description:**  \nGiven an array, move all zeros to the end of the array while preserving the order of non-zero elements.\n\n**Solution:**  \nThis is similar to the previous problem but with the condition of moving zeros instead of negatives. We can use the same two-pointer approach:\n- One pointer (`i`) tracks the position where the next non-zero number should be placed.\n- Iterate through the array. For each element:\n  - If it's non-zero, swap it with the element at index `i` and increment `i`.\n\n**Python3 Code:**\n```python\ndef move_zeros_to_end(arr: List[int]) -> List[int]:\n    i = 0\n    for j in range(len(arr)):\n        if arr[j] != 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    return arr\n```\n\n---\n\n### Problem 3: \"Sort Array by Parity\"\n\n**Problem Description:**  \nGiven an array of integers, sort the array such that even numbers appear first, followed by odd numbers. The relative order of even and odd numbers should be preserved.\n\n**Solution:**  \nThis is similar to the previous problems. Use a two-pointer approach:\n- One pointer (`i`) tracks the position where the next even number should be placed.\n- Iterate through the array. For each element:\n  - If it's even, swap it with the element at index `i` and increment `i`.\n\n**Python3 Code:**\n```python\ndef sort_array_by_parity(arr: List[int]) -> List[int]:\n    i = 0\n    for j in range(len(arr)):\n        if arr[j] % 2 == 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    return arr\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe problem asks to rearrange the first `n` elements of the array such that all negative numbers appear before positive ones, while preserving the relative order of negatives and positives.\n\nWe can achieve this using a two-pointer approach:\n- One pointer (`i`) keeps track of where the next negative number should be placed.\n- We iterate through the array up to index `n-1` and whenever we find a negative number, we swap it with the element at index `i` and increment `i`.\n\n### Python3 Code:\n```python\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    i = 0\n    for j in range(n):\n        if arr[j] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    return arr\n```\n\n### Example:\n```python\narr = [-1, 2, -3, 4, 5]\nn = 5\nprint(re_arrange_array(arr, n))  # Output: [-1, -3, 2, 4, 5]\n```\n\nThis code rearranges the first `n` elements so that all negative numbers appear before positive ones, and the relative order of negatives and positives is preserved."], "prompt_tokens": [250], "completion_tokens": [1150], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\nimport math\n\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \"\"\"\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    return math.ceil(wind_chill)\n\n# Example usage:\n# print(wind_chill(20, 5))\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem is **mathematical computation** based on a given formula. Specifically, the problem involves applying the **wind chill formula** to calculate the perceived temperature based on wind speed and actual temperature. This is a straightforward formula-based problem, and the key is to implement it correctly and round the result to the next integer.\n\n## Tutorial:\nThe wind chill index is a measure of how cold it feels when the wind is factored in. The formula used for calculating wind chill is:\n\n$$\n\\text{Wind Chill} = 13.12 + 0.6215 \\times T - 11.37 \\times V^{0.16} + 0.3965 \\times T \\times V^{0.16}\n$$\n\nWhere:\n- $ T $ is the air temperature in degrees Celsius.\n- $ V $ is the wind speed in kilometers per hour.\n- The result is rounded up to the nearest integer.\n\nThe key steps in solving the problem are:\n1. Read the input values (wind speed and temperature).\n2. Apply the formula to calculate the wind chill.\n3. Round the result to the next integer (ceiling).\n4. Return the result.\n\nNote: The formula is valid for wind speeds above 4.8 km/h and temperatures below 10\u00b0C.\n\n## Example Problems:\n\n### 1. **UVA 10184 - Love Calculator**\n**Problem Description**: Calculate the \"love percentage\" between two names by summing the ASCII values of the letters in each name and then using the formula: (sum1 + sum2) % 100 + 1.\n\n**Solution**: \n- Read two strings.\n- Compute the sum of ASCII values of each string.\n- Use the formula to compute the love percentage.\n- Output the result.\n\n**Python Code**:\n```python\ndef love_percentage(name1: str, name2: str) -> int:\n    sum1 = sum(ord(c) for c in name1)\n    sum2 = sum(ord(c) for c in name2)\n    return (sum1 + sum2) % 100 + 1\n\n# Example usage:\n# print(love_percentage(\"Alice\", \"Bob\"))\n```\n\n---\n\n### 2. **Codeforces 71A - Way Too Long Words**\n**Problem Description**: For each word in a list, if the length is more than 10, replace it with the first and last letter and the count of letters in between.\n\n**Solution**: \n- Iterate over the list of words.\n- For each word, check its length.\n- If longer than 10, format it as described.\n- Otherwise, leave it as is.\n\n**Python Code**:\n```python\ndef shorten_words(words: list) -> list:\n    result = []\n    for word in words:\n        if len(word) > 10:\n            result.append(f\"{word[0]}{len(word)-2}{word[-1]}\")\n        else:\n            result.append(word)\n    return result\n\n# Example usage:\n# print(shorten_words([\"hello\", \"world\", \"longword\"]))\n```\n\n---\n\n### 3. **LeetCode 1 - Two Sum**\n**Problem Description**: Given an array of integers and a target, return the indices of the two numbers that add up to the target.\n\n**Solution**:\n- Use a hash map (dictionary) to store the value-to-index mapping.\n- For each element, check if the complement (target - current value) is in the map.\n- If found, return the indices.\n\n**Python Code**:\n```python\ndef two_sum(nums: list, target: int) -> list:\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\n# Example usage:\n# print(two_sum([2, 7, 11, 15], 9))\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe wind chill formula is applied directly using the given wind velocity and temperature. The result is calculated using the formula, and then rounded up to the nearest integer using the `math.ceil()` function.\n\n### Python3 code:\n```python\nimport math\n\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \"\"\"\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    return math.ceil(wind_chill)\n\n# Example usage:\n# print(wind_chill(20, 5))\n```"], "prompt_tokens": [221], "completion_tokens": [1031], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["\nprint(bell_Number(3))  # Output: 5\nprint(bell_Number(5))  # Output: 52\nprint(bell_Number(10)) # Output: 115975\n\n\n"], "responses": ["## Algorithms:\n\nThe core concept used to compute the nth Bell number is **Dynamic Programming**. The Bell number B(n) represents the number of ways to partition a set of n elements. The Bell number can be computed using a **Bell Triangle**, which is built using the following recurrence relation:\n\n```\nB(0) = 1\nB(n) = sum of the previous row in the Bell triangle\n```\n\nAlternatively, the Bell triangle can be built using the recurrence:\n\n```\nbell[0][0] = 1\nbell[i][0] = bell[i-1][i-1]\nbell[i][j] = bell[i][j-1] + bell[i-1][j-1]\n```\n\nThis is a standard approach for computing Bell numbers efficiently using dynamic programming.\n\n---\n\n## Tutorial:\n\n### What is a Bell Number?\n\nA Bell number, B(n), is the number of ways to partition a set of n elements. For example:\n\n- B(0) = 1 (There's 1 way to partition an empty set)\n- B(1) = 1 (Only one way to partition a single-element set)\n- B(2) = 2 (Two ways: {1}, {2} or {1,2})\n- B(3) = 5\n\n### Bell Triangle:\n\nThe Bell triangle is a way to compute Bell numbers. The triangle is constructed as follows:\n\n- The first row has one element: `1`\n- The second row has two elements: `1`, `2`\n- The third row has three elements: `2`, `3`, `5`\n- The fourth row has four elements: `5`, `7`, `10`, `15`\n- And so on...\n\nEach row starts with the last element of the previous row. Each subsequent element is the sum of the previous element in the same row and the element from the previous row at the same position.\n\nFor example:\n- Row 1: [1]\n- Row 2: [1, 2] (1 is the last element of previous row, 1+1=2)\n- Row 3: [2, 3, 5] (2 is the last element of previous row, 2+1=3, 3+2=5)\n- Row 4: [5, 7, 10, 15] (5 is the last element of previous row, 5+2=7, 7+3=10, 10+5=15)\n\nThe Bell number B(n) is the first element of the nth row.\n\n---\n\n## Example Problems:\n\n### 1. **LeetCode 1915. Number of Ways to Split a String into Substrings**\n\n**Problem Description:**  \nGiven a string, count the number of ways to split the string into non-empty substrings such that no two substrings have the same character.\n\n**Solution:**  \nThis is not directly a Bell number problem, but the concept of partitioning and counting ways to split is similar. Bell numbers can be used to count the number of ways to partition a set of elements, which is a similar idea.\n\n**Python3 Code:**\n\n```python\ndef numberOfWays(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    count = [0] * 26\n    for ch in s:\n        count[ord(ch) - ord('a')] += 1\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] != s[j]:\n                res += 1\n    return res % MOD\n```\n\n---\n\n### 2. **Codeforces 1095F. Equalizing Two Strings**\n\n**Problem Description:**  \nGiven two strings s and t, determine if it's possible to make them equal by rearranging the characters in each of them.\n\n**Solution:**  \nThis problem is not about Bell numbers, but it involves counting partitions and permutations, which is related to combinatorics and dynamic programming.\n\n**Python3 Code:**\n\n```python\nfrom collections import Counter\n\ndef canBeEqual(s: str, t: str) -> bool:\n    return Counter(s) == Counter(t)\n```\n\n---\n\n### 3. **SPOJ BELL - Bell Numbers**\n\n**Problem Description:**  \nCompute the nth Bell number modulo 1000000007.\n\n**Solution:**  \nThis is a direct application of the Bell triangle approach with dynamic programming.\n\n**Python3 Code:**\n\n```python\ndef bell_numbers(n: int) -> int:\n    MOD = 10**9 + 7\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = (bell[i][j - 1] + bell[i - 1][j - 1]) % MOD\n    return bell[n][0]\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\n\nWe use a dynamic programming approach to compute the Bell number using a Bell triangle. The Bell triangle is built such that:\n\n- `bell[i][0] = bell[i-1][i-1]`\n- `bell[i][j] = bell[i][j-1] + bell[i-1][j-1]`\n\nThe nth Bell number is the first element of the nth row in the triangle.\n\n### Python3 code:\n\n```python\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Write a python function to find nth bell number.\n    \"\"\"\n    # Initialize a 2D list to store the Bell triangle\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1  # Base case\n\n    for i in range(1, n + 1):\n        # The first element of each row is the last element of the previous row\n        bell[i][0] = bell[i - 1][i - 1]\n\n        # Fill the rest of the elements\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i][j - 1] + bell[i - 1][j - 1]\n\n    return bell[n][0]\n```\n\n### Example usage:\n\n```python\nprint(bell_Number(3))  # Output: 5\nprint(bell_Number(5))  # Output: 52\nprint(bell_Number(10)) # Output: 115975\n```"], "prompt_tokens": [198], "completion_tokens": [1448], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["\ndef sum_div(number: int) -> int:\n    if number == 0:\n        return 0\n    total = 0\n    for i in range(1, int(number ** 0.5) + 1):\n        if number % i == 0:\n            if i * i == number:\n                total += i\n            else:\n                total += i + number // i\n    return total\n\n\n"], "responses": ["## Algorithms:\nThe core concepts involved in solving this problem are:\n- **Finding all divisors of a number**: This involves checking numbers from 1 up to the square root of the given number.\n- **Efficient computation**: Instead of checking every number up to `number`, we can check up to `sqrt(number)` to optimize the solution.\n- **Summing the divisors**: For each divisor found, we add both the divisor and its complement (if they are different) to the sum.\n\n## Tutorial:\nTo compute the sum of all divisors of a number efficiently, we can use the following approach:\n\n1. **Initialize a sum variable** to 0.\n2. **Iterate from 1 to sqrt(number)**:\n   - For each `i` in this range, check if `number % i == 0`.\n   - If it is, then `i` is a divisor, and `number // i` is also a divisor.\n   - Add both `i` and `number // i` to the sum, unless `i == number // i` (i.e., when the number is a perfect square), in which case we only add `i` once.\n3. **Return the sum**.\n\nThis method is efficient and runs in **O(sqrt(n))** time, which is significantly faster than the naive O(n) approach.\n\n## Example Problems:\n\n### 1. **LeetCode - 204. Count Primes**\n- **Problem**: Count the number of prime numbers less than a non-negative number `n`.\n- **Solution**: Use the Sieve of Eratosthenes to efficiently find all primes up to `n`. This is a classic example of using efficient algorithms for divisor-like problems.\n- **Code**:\n```python\ndef countPrimes(n: int) -> int:\n    if n < 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n```\n\n### 2. **HackerRank - Divisors**\n- **Problem**: Find the number of divisors of a given number.\n- **Solution**: Use the same approach as described in the tutorial: iterate up to `sqrt(n)` and count divisors.\n- **Code**:\n```python\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n```\n\n### 3. **Codeforces - 230A. Dragons**\n- **Problem**: Determine if a knight can defeat all dragons by choosing the right order of battle.\n- **Solution**: This problem involves checking conditions and using a greedy approach. While not directly about divisors, it shows how efficient algorithms can be used to solve complex conditions.\n- **Code**:\n```python\ndef can_defeat_dragons(knight_power, dragons):\n    dragons.sort()\n    for power, strength in dragons:\n        if knight_power < power:\n            return \"NO\"\n        knight_power += strength\n    return \"YES\"\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `sum_div` computes the sum of all divisors of a given number efficiently by iterating only up to the square root of the number. For each divisor `i` found, both `i` and `number // i` are added to the sum, unless `i == number // i`, in which case we only add `i` once.\n\n### Python3 code:\n```python\ndef sum_div(number: int) -> int:\n    if number == 0:\n        return 0\n    total = 0\n    for i in range(1, int(number ** 0.5) + 1):\n        if number % i == 0:\n            if i * i == number:\n                total += i\n            else:\n                total += i + number // i\n    return total\n```"], "prompt_tokens": [203], "completion_tokens": [908], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["\nfrom typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    x, y = test_tup\n    directions = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n    return [[dx, dy] for dx, dy in directions]\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem involves **coordinate manipulation and adjacency checks**. The task is to generate all the coordinates that are adjacent to a given coordinate (x, y) in a 2D grid. This is commonly done by checking the 4 or 8 surrounding cells (depending on the problem's requirements).\n\nThis is typically used in grid traversal problems, such as BFS and DFS, and in problems that involve exploring neighboring cells.\n\n## Tutorial:\nIn competitive programming, when working with a grid, it's often necessary to find the adjacent cells of a given position. For a 2D grid, a cell (x, y) can have up to 4 or 8 neighbors:\n\n- **4-directional neighbors**: (x+1, y), (x-1, y), (x, y+1), (x, y-1)\n- **8-directional neighbors**: (x+1, y), (x-1, y), (x, y+1), (x, y-1), (x+1, y+1), (x+1, y-1), (x-1, y+1), (x-1, y-1)\n\nThe function `get_coordinates` is expected to return all these adjacent coordinates. The solution involves generating all 4 or 8 surrounding coordinates, and then returning them in a list of lists.\n\n## Example Problems:\n\n### 1. **LeetCode 200. Number of Islands**\n- **Problem**: Count the number of islands in a 2D grid where '1's represent land and '0's represent water.\n- **Solution**: Use BFS or DFS to explore all connected '1's starting from any unvisited '1'. For each cell, check its 4-directional neighbors.\n- **Code**:\n```python\nfrom collections import deque\n\ndef numIslands(grid: List[List[str]]) -> int:\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    count = 0\n\n    def bfs(r, c):\n        queue = deque()\n        queue.append((r, c))\n        visited[r][c] = True\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == '1':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r][c] and grid[r][c] == '1':\n                bfs(r, c)\n                count += 1\n\n    return count\n```\n\n---\n\n### 2. **LeetCode 127. Word Ladder**\n- **Problem**: Find the length of the shortest transformation sequence from a start word to an end word, where each transformation changes one character and the new word exists in a word list.\n- **Solution**: Use BFS to explore all possible transformations. For each word, generate all 1-letter variations and check if they are in the word list.\n- **Code**:\n```python\nfrom collections import deque\n\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int:\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    queue = deque([(beginWord, 1)])\n    visited = set([beginWord])\n\n    while queue:\n        word, level = queue.popleft()\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = word[:i] + c + word[i+1:]\n                if next_word in word_set and next_word not in visited:\n                    if next_word == endWord:\n                        return level + 1\n                    visited.add(next_word)\n                    queue.append((next_word, level + 1))\n\n    return 0\n```\n\n---\n\n### 3. **AtCoder ABC 123 C \u2013 Yamanote Line**\n- **Problem**: Given a circular train line, find the minimum number of stations to travel between two given stations.\n- **Solution**: Calculate the clockwise and counter-clockwise distances between the two stations and return the minimum.\n- **Code**:\n```python\ndef main():\n    N, A, B = map(int, input().split())\n    clockwise = B - A\n    counter_clockwise = A + N - B\n    print(min(clockwise, counter_clockwise))\n\nmain()\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `get_coordinates` should return all 4-directional adjacent coordinates of the input tuple `(x, y)`. The adjacent coordinates are:\n- (x+1, y)\n- (x-1, y)\n- (x, y+1)\n- (x, y-1)\n\nWe generate these coordinates and return them as a list of lists.\n\n### Python3 code:\n```python\nfrom typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    x, y = test_tup\n    directions = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n    return [[dx, dy] for dx, dy in directions]\n```"], "prompt_tokens": [217], "completion_tokens": [1194], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["\nfrom typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    return tuple(a for a, b in zip(test_tup1, test_tup2) if a != b)\n\n# Example usage\nprint(find_dissimilar((1, 2, 3, 4), (1, 5, 3, 6)))  # Output: (2, 5, 4)\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem is **tuple comparison and element-wise difference**. We need to compare corresponding elements of two tuples and find the elements that are different.\n\nThis is a basic operation in Python, and the solution involves iterating over the elements of both tuples and checking for differences.\n\n## Tutorial:\nIn Python, tuples are ordered and immutable collections of elements. To find dissimilar elements between two tuples, we can iterate through each position (index) of the tuples, compare the elements at the same index, and collect those that are different.\n\nFor example, if `tup1 = (1, 2, 3, 4)` and `tup2 = (1, 5, 3, 6)`, then the dissimilar elements are at index 1 and 3, i.e., 2 and 5, and 4 and 6. The output would be `(2, 5, 4, 6)`.\n\nThis is a simple but useful operation in competitive programming for tasks like checking differences between two sets of data.\n\n## Example Problems:\n\n### 1. **Problem: Compare Two Tuples**\n**Description**: Given two tuples of the same length, return a new tuple containing the elements that are different at each position.\n\n**Solution**: Iterate through each index of the tuples, compare the elements, and collect the differing elements.\n\n**Python Code:**\n```python\ndef compare_tuples(tup1, tup2):\n    return tuple(a for a, b in zip(tup1, tup2) if a != b)\n\n# Example usage\nprint(compare_tuples((1, 2, 3), (1, 4, 3)))  # Output: (2,)\n```\n\n---\n\n### 2. **Problem: Find Mismatched Elements in Two Strings**\n**Description**: Given two strings of equal length, return a string of characters that are different at each position.\n\n**Solution**: Convert the strings to tuples or iterate directly, and compare character by character.\n\n**Python Code:**\n```python\ndef find_mismatched_chars(s1, s2):\n    return ''.join(c for c, d in zip(s1, s2) if c != d)\n\n# Example usage\nprint(find_mismatched_chars(\"abc\", \"adc\"))  # Output: \"b\"\n```\n\n---\n\n### 3. **Problem: Find the Differences Between Two Lists**\n**Description**: Given two lists of the same length, return a list of elements that are different at each index.\n\n**Solution**: Use list comprehension to compare elements at each index and collect the differing ones.\n\n**Python Code:**\n```python\ndef find_differences(list1, list2):\n    return [x for x, y in zip(list1, list2) if x != y]\n\n# Example usage\nprint(find_differences([1, 2, 3], [1, 4, 3]))  # Output: [2]\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `find_dissimilar` takes two 4-element tuples as input. We need to compare the elements at each position and return a new tuple containing the elements that are different.\n\nWe can use a generator expression with `zip` to iterate through the tuples in pairs, check for inequality, and collect the differing elements.\n\n### Python3 code:\n```python\nfrom typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    return tuple(a for a, b in zip(test_tup1, test_tup2) if a != b)\n\n# Example usage\nprint(find_dissimilar((1, 2, 3, 4), (1, 5, 3, 6)))  # Output: (2, 5, 4)\n```"], "prompt_tokens": [241], "completion_tokens": [821], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["\ndef find_length(string: str) -> int:\n    # Convert '0' to +1 and '1' to -1\n    nums = [1 if c == '0' else -1 for c in string]\n    \n    # Apply Kadane's algorithm\n    current_max = max_so_far = nums[0]\n    for num in nums[1:]:\n        current_max = max(num, current_max + num)\n        max_so_far = max(max_so_far, current_max)\n    \n    return max_so_far\n\n\n"], "responses": ["## Algorithms:\nThe core concept used in solving this problem is **Kadane's Algorithm**, which is typically used to find the maximum subarray sum. In this case, we need to find the maximum difference between the number of 0s and 1s in any sub-string. To apply Kadane\u2019s algorithm, we can treat 0s as +1 and 1s as -1, and then find the maximum subarray sum, which will give us the maximum difference between 0s and 1s.\n\n## Tutorial:\nKadane's Algorithm is a dynamic programming approach used to find the maximum sum of a contiguous subarray in a list of integers. The algorithm works by iterating through the array and keeping track of the maximum sum ending at each position. The idea is to maintain a running sum (`current_max`) and update it as we go. If the current sum becomes negative, we reset it to zero, as a negative sum would not help in finding the maximum subarray sum.\n\nIn this problem, we convert the binary string into a list of values where '0' is treated as +1 and '1' as -1. Then, we apply Kadane\u2019s algorithm to find the maximum subarray sum, which corresponds to the maximum difference between the number of 0s and 1s in any sub-string.\n\n## Example Problems:\n\n### Problem 1: Maximum Subarray Sum (LeetCode 53)\n**Description**: Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n**Solution**: Use Kadane\u2019s algorithm. Initialize `current_max` and `max_so_far` to the first element. Iterate through the array, updating `current_max` as `max(nums[i], current_max + nums[i])`, and update `max_so_far` accordingly.\n\n**Python3 Code**:\n```python\ndef maxSubArray(nums):\n    current_max = max_so_far = nums[0]\n    for num in nums[1:]:\n        current_max = max(num, current_max + num)\n        max_so_far = max(max_so_far, current_max)\n    return max_so_far\n```\n\n### Problem 2: Maximum Difference in a Binary String (Similar to this problem)\n**Description**: Given a binary string, find the maximum difference between the number of 0s and 1s in any sub-string.\n\n**Solution**: Convert '0' to +1 and '1' to -1, then apply Kadane\u2019s algorithm to find the maximum subarray sum.\n\n**Python3 Code**:\n```python\ndef max_diff_binary_string(s):\n    nums = [1 if c == '0' else -1 for c in s]\n    current_max = max_so_far = nums[0]\n    for num in nums[1:]:\n        current_max = max(num, current_max + num)\n        max_so_far = max(max_so_far, current_max)\n    return max_so_far\n```\n\n### Problem 3: Maximum Absolute Difference in a Binary String\n**Description**: Given a binary string, find the maximum absolute difference between the number of 0s and 1s in any sub-string.\n\n**Solution**: Convert '0' to +1 and '1' to -1, then apply Kadane\u2019s algorithm to find the maximum subarray sum and also the minimum subarray sum. The maximum absolute difference is the maximum between the absolute value of the max and min.\n\n**Python3 Code**:\n```python\ndef max_abs_diff_binary_string(s):\n    nums = [1 if c == '0' else -1 for c in s]\n    current_max = max_so_far = nums[0]\n    current_min = min_so_far = nums[0]\n    for num in nums[1:]:\n        current_max = max(num, current_max + num)\n        max_so_far = max(max_so_far, current_max)\n        current_min = min(num, current_min + num)\n        min_so_far = min(min_so_far, current_min)\n    return max(abs(max_so_far), abs(min_so_far))\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nWe convert the binary string into a list of integers where '0' is +1 and '1' is -1. Then, we apply Kadane\u2019s algorithm to find the maximum subarray sum. This sum represents the maximum difference between the number of 0s and 1s in any sub-string of the original string.\n\n### Python3 Code:\n```python\ndef find_length(string: str) -> int:\n    # Convert '0' to +1 and '1' to -1\n    nums = [1 if c == '0' else -1 for c in string]\n    \n    # Apply Kadane's algorithm\n    current_max = max_so_far = nums[0]\n    for num in nums[1:]:\n        current_max = max(num, current_max + num)\n        max_so_far = max(max_so_far, current_max)\n    \n    return max_so_far\n```"], "prompt_tokens": [219], "completion_tokens": [1046], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["\nfrom typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    return (list1[:L], list1[L:])\n\n# Example usage\nprint(split_two_parts([1, 2, 3, 4, 5], 2))  # Output: ([1, 2], [3, 4, 5])\n\n\n"], "responses": ["## Algorithms:\nThe core concept used in this problem is **list slicing**, which is a fundamental operation in Python. The task involves dividing a list into two parts, where the first part has a specified length `L`, and the second part contains the remaining elements.\n\n## Tutorial:\nIn Python, list slicing allows you to extract a portion of a list using the syntax `list[start:end]`. Here:\n- `start` is the index from which to begin the slice (inclusive).\n- `end` is the index at which to stop the slice (exclusive).\n\nTo split a list into two parts, where the first part has length `L`, we can:\n- Take the first `L` elements using `list1[:L]`\n- Take the remaining elements using `list1[L:]`\n\nThis is a simple and efficient operation with a time complexity of O(n), where n is the length of the list.\n\n## Example Problems:\n\n### Problem 1: Split Array Into Two Parts\n**Problem Description:**  \nGiven an array and an integer L, split the array into two parts where the first part has length L.\n\n**Solution:**  \nUse list slicing to get the first L elements and the rest.\n\n**Python3 Code:**\n```python\ndef split_array(arr, L):\n    return arr[:L], arr[L:]\n\n# Example usage\nprint(split_array([1, 2, 3, 4, 5], 2))  # Output: ([1, 2], [3, 4, 5])\n```\n\n---\n\n### Problem 2: Split List into Two Equal Parts\n**Problem Description:**  \nGiven a list, split it into two equal parts if the length is even. Otherwise, return the first half and the second half.\n\n**Solution:**  \nCalculate the midpoint using integer division and slice the list accordingly.\n\n**Python3 Code:**\n```python\ndef split_list_even(lst):\n    mid = len(lst) // 2\n    return lst[:mid], lst[mid:]\n\n# Example usage\nprint(split_list_even([1, 2, 3, 4]))  # Output: ([1, 2], [3, 4])\n```\n\n---\n\n### Problem 3: Split a String into Two Parts\n**Problem Description:**  \nGiven a string and an integer L, split the string into two parts where the first part has length L.\n\n**Solution:**  \nConvert the string to a list of characters, slice it, and rejoin the parts.\n\n**Python3 Code:**\n```python\ndef split_string(s, L):\n    return s[:L], s[L:]\n\n# Example usage\nprint(split_string(\"abcdef\", 3))  # Output: ('abc', 'def')\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `split_two_parts` takes a list and an integer `L`. It splits the list into two parts:\n- The first part is the first `L` elements of the list.\n- The second part is the remaining elements of the list.\n\nThis is achieved using Python's list slicing.\n\n### Python3 code:\n```python\nfrom typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    return (list1[:L], list1[L:])\n\n# Example usage\nprint(split_two_parts([1, 2, 3, 4, 5], 2))  # Output: ([1, 2], [3, 4, 5])\n```"], "prompt_tokens": [244], "completion_tokens": [774], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["\nprint(check_expression(\"()\"))          # True\nprint(check_expression(\"([)]\"))        # False\nprint(check_expression(\"{[()]}\"))      # True\nprint(check_expression(\"((()))\"))      # True\nprint(check_expression(\"((())\"))       # False\n\n\n"], "responses": ["## Algorithms:\n\nThe core concept used to solve the problem of checking a balanced expression is **stack-based processing**. The algorithm involves:\n\n- Using a **stack** to keep track of opening brackets.\n- For every **closing bracket**, we check if the top of the stack contains the corresponding opening bracket.\n- If the stack is empty when a closing bracket is encountered, or if the top of the stack does not match the closing bracket, the expression is unbalanced.\n- At the end, the stack should be empty (all opening brackets should have been matched).\n\nThis approach is commonly used in problems involving matching of brackets, such as parentheses, braces, and square brackets.\n\n---\n\n## Tutorial:\n\nA **stack** is a data structure that follows the **Last-In-First-Out (LIFO)** principle. In the context of checking balanced expressions, we use the stack to keep track of the opening brackets.\n\nHere's how the algorithm works:\n\n1. Initialize an empty stack.\n2. Iterate through each character in the expression:\n   - If the character is an opening bracket (`'('`, `'{'`, `'['`), push it onto the stack.\n   - If the character is a closing bracket (`')'`, `'}'`, `']'`), check if the stack is empty. If it is, the expression is unbalanced.\n   - Pop the top element from the stack and check if it matches the corresponding opening bracket. If not, the expression is unbalanced.\n3. After processing all characters, check if the stack is empty. If not, the expression is unbalanced.\n\nThis approach ensures that each opening bracket is matched with the correct closing bracket in the correct order.\n\n---\n\n## Example Problems:\n\n### 1. **Valid Parentheses** (LeetCode 20)\n- **Problem**: Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n- **Solution**: Use a stack to match opening and closing brackets. If at any point the brackets don't match or the stack is empty when a closing bracket is found, return `False`. At the end, return `True` if the stack is empty.\n- **Python3 code**:\n```python\ndef is_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            return False  # invalid character\n    return not stack\n```\n\n---\n\n### 2. **Minimum Number of Swaps to Make the String Balanced** (LeetCode 1816)\n- **Problem**: Given a string consisting of `'['` and `']'`, find the minimum number of swaps needed to make the string balanced.\n- **Solution**: Use a greedy approach with a stack. Count the number of unmatched opening brackets and calculate the required swaps based on the imbalance.\n- **Python3 code**:\n```python\ndef min_swaps(s: str) -> int:\n    stack = []\n    swaps = 0\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n                stack.append('[')\n    return swaps // 2\n```\n\n---\n\n### 3. **Check for Balanced Parentheses in an Expression** (GeeksforGeeks)\n- **Problem**: Check if the given expression has balanced parentheses.\n- **Solution**: Use a stack to match opening and closing brackets.\n- **Python3 code**:\n```python\ndef is_balanced(expr: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in expr:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nWe will use a **stack** to track the opening brackets. For each closing bracket, we check if the top of the stack contains the corresponding opening bracket. If it does, we pop the stack. If it doesn\u2019t, or if the stack is empty, the expression is unbalanced. At the end, the stack should be empty.\n\n### Python3 code:\n```python\ndef check_expression(exp: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack\n```\n\n### Example usage:\n```python\nprint(check_expression(\"()\"))          # True\nprint(check_expression(\"([)]\"))        # False\nprint(check_expression(\"{[()]}\"))      # True\nprint(check_expression(\"((()))\"))      # True\nprint(check_expression(\"((())\"))       # False\n```"], "prompt_tokens": [221], "completion_tokens": [1096], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a Python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "responses": ["## Algorithms:\nThe core concept for this problem is **comparative analysis** of three integers to determine how many are equal. The solution involves checking all possible pairs and counting the occurrences of equal values.\n\nThis problem can be solved using simple conditional checks and counting logic.\n\n## Tutorial:\nThe task is to count how many of the three given integers are equal. The possible cases are:\n- All three are equal (e.g., 5, 5, 5 \u2192 count is 3)\n- Two are equal (e.g., 5, 5, 3 \u2192 count is 2)\n- All are different (e.g., 1, 2, 3 \u2192 count is 0)\n\nTo solve this, you can:\n1. Check if all three values are the same.\n2. If not, check if any two are equal.\n3. If none are equal, return 0.\n\nThis is a basic logic-based problem, often encountered in coding interviews and competitive programming.\n\n## Example Problems:\n\n### Problem 1: \"Equal Numbers\" (Codeforces)\n**Description:** Given three integers, return the number of equal numbers among them.\n\n**Solution:** Check for equality between all three values, and count accordingly.\n\n```python\ndef equal_numbers(a, b, c):\n    if a == b == c:\n        return 3\n    elif a == b or b == c or a == c:\n        return 2\n    else:\n        return 0\n```\n\n### Problem 2: \"Check if All Three Are Equal\" (LeetCode)\n**Description:** Given three integers, return `True` if all are equal, else `False`.\n\n**Solution:** Direct comparison of all three values.\n\n```python\ndef are_equal(a, b, c):\n    return a == b == c\n```\n\n### Problem 3: \"Count Duplicates\" (HackerRank)\n**Description:** Given three integers, count how many duplicates are present (i.e., how many numbers appear more than once).\n\n**Solution:** Use a frequency dictionary or direct comparisons.\n\n```python\ndef count_duplicates(a, b, c):\n    freq = {}\n    for num in [a, b, c]:\n        freq[num] = freq.get(num, 0) + 1\n    return sum(1 for count in freq.values() if count > 1)\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nWe need to count how many of the three input integers are equal. We can do this by:\n- Checking if all three are equal: return 3.\n- If two are equal, return 2.\n- Otherwise, return 0.\n\n### Python3 code to solve the problem:\n\n```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a Python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n```"], "prompt_tokens": [213], "completion_tokens": [644], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["\ndef find_lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n\n"], "responses": ["## Algorithms:\nThe problem involves computing the n-th Lucas number, which is a sequence similar to the Fibonacci sequence. The core concepts include **recursion**, **dynamic programming**, and **iterative computation**. The Lucas sequence is defined as:\n- L(0) = 2\n- L(1) = 1\n- L(n) = L(n-1) + L(n-2) for n \u2265 2\n\nThis is a classic example of a **linear recurrence relation**, and the solution can be implemented using **iterative** or **recursive** methods with memoization.\n\n## Tutorial:\nThe Lucas sequence is similar to the Fibonacci sequence, but with different starting values. The sequence starts with 2 and 1, and each subsequent number is the sum of the two previous ones.\n\n### Key Concepts:\n- **Recursive Approach**: Directly implement the recurrence relation. However, this approach has exponential time complexity and is not efficient for large n.\n- **Iterative Approach**: Use a loop to compute the Lucas numbers up to n. This is efficient and runs in O(n) time.\n- **Dynamic Programming (Memoization)**: Store previously computed values to avoid redundant calculations. This is efficient and can be used for larger n.\n\n### Example:\nFor n = 5, the Lucas sequence is: 2, 1, 3, 4, 7, 11 \u2192 L(5) = 11\n\n## Example Problems:\n\n### 1. Fibonacci Number (LeetCode 509)\n**Problem Description**:\nGiven n, compute the n-th Fibonacci number.\n\n**Solution**:\nUse an iterative approach to compute the Fibonacci numbers. The logic is very similar to the Lucas sequence, with different base cases.\n\n**Python3 Code**:\n```python\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(1, n + 1):\n        a, b = b, a + b\n    return a\n```\n\n### 2. Tribonacci Sequence (LeetCode 1137)\n**Problem Description**:\nGiven n, compute the n-th Tribonacci number, where T(n) = T(n-1) + T(n-2) + T(n-3), with base cases T(0) = 0, T(1) = 1, T(2) = 1.\n\n**Solution**:\nUse an iterative approach to compute the sequence up to n. This is similar to the Lucas sequence, but with three previous terms instead of two.\n\n**Python3 Code**:\n```python\ndef tribonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    a, b, c = 0, 1, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c\n```\n\n### 3. Lucas Numbers (LeetCode 1195)\n**Problem Description**:\nSame as the original problem, but in a more complex context. This is a direct application of the Lucas sequence.\n\n**Solution**:\nUse an iterative approach to compute the n-th Lucas number.\n\n**Python3 Code**:\n```python\ndef lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `find_lucas(n)` computes the n-th Lucas number using an **iterative approach**. We start with the base cases:\n- L(0) = 2\n- L(1) = 1\n\nThen, for each n \u2265 2, we compute L(n) = L(n-1) + L(n-2) iteratively, which ensures an efficient O(n) time complexity and O(1) space complexity.\n\n### Python3 code to solve the problem:\n```python\ndef find_lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```"], "prompt_tokens": [202], "completion_tokens": [981], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    words = word.split('_')\n    if not words:\n        return \"\"\n    result = words[0]\n    for word in words[1:]:\n        result += word.capitalize()\n    return result\n\n\n"], "responses": ["## Algorithms:\nThe core concept for solving this problem is **string manipulation**, specifically **splitting a string based on a delimiter** (in this case, the underscore `_`) and **capitalizing the first letter of each subsequent word** (except the first one) to form a camel case string.\n\nThis problem involves:\n- Splitting a string using `split('_')`\n- Iterating through the resulting list\n- Capitalizing the first letter of each word (except the first)\n- Concatenating all words into a single string\n\n## Tutorial:\nIn programming, especially in competitive programming, string manipulation is a fundamental skill. For converting a snake case string to camel case:\n\n1. **Split the string** using the underscore `_` as the delimiter.\n2. The first word remains in lowercase.\n3. For each subsequent word, **capitalize the first letter** and **append it to the result**.\n4. Concatenate all the words to form the final camel case string.\n\nFor example:\n- Input: `\"hello_world\"`\n- Split: `[\"hello\", \"world\"]`\n- Process: `\"hello\" + \"World\" => \"helloWorld\"`\n\nThis technique is widely used in code generation, API naming, and data transformation.\n\n## Example Problems:\n\n### 1. LeetCode - 1221. Split a String in Balanced Strings\n**Problem Description**:  \nA string `s` is **balanced** if it contains the same number of `'L'` and `'R'` characters. Return the maximum number of **balanced** substrings you can split the string into.\n\n**Solution**:  \nWe can iterate through the string, counting `'L'` and `'R'` characters. Whenever the counts are equal, we increment a result counter.\n\n**Python3 Code**:\n```python\ndef balancedStringSplit(s: str) -> int:\n    count = 0\n    result = 0\n    for char in s:\n        if char == 'L':\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            result += 1\n    return result\n```\n\n---\n\n### 2. LeetCode - 1431. Kids With the Greatest Number of Candies\n**Problem Description**:  \nGiven the number of candies each child has, and a number `extra`, determine which children can have the greatest number of candies after receiving the extra.\n\n**Solution**:  \nWe can calculate the maximum number of candies among the children, then check for each child if adding `extra` to their count would be greater than or equal to that maximum.\n\n**Python3 Code**:\n```python\ndef kidsWithCandies(candies: list[int], extra: int) -> list[bool]:\n    max_candies = max(candies)\n    return [c + extra >= max_candies for c in candies]\n```\n\n---\n\n### 3. LeetCode - 1704. Determine if String Halves Are Alike\n**Problem Description**:  \nA string `s` of even length is **balanced** if the number of vowels in the first half equals the number of vowels in the second half.\n\n**Solution**:  \nWe can split the string into two halves, count the vowels in each, and compare the counts.\n\n**Python3 Code**:\n```python\ndef halvesAreAlike(s: str) -> bool:\n    vowels = set(\"aeiouAEIOU\")\n    n = len(s)\n    first_half = s[:n//2]\n    second_half = s[n//2:]\n    count_first = sum(1 for c in first_half if c in vowels)\n    count_second = sum(1 for c in second_half if c in vowels)\n    return count_first == count_second\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\n- The function `snake_to_camel` takes a string `word` in snake case.\n- It splits the string using the underscore `_` as the delimiter.\n- The first word is kept in lowercase.\n- Each subsequent word is capitalized and appended to the result.\n- The final result is the camel case string.\n\n### Python3 code:\n```python\ndef snake_to_camel(word: str) -> str:\n    words = word.split('_')\n    if not words:\n        return \"\"\n    result = words[0]\n    for word in words[1:]:\n        result += word.capitalize()\n    return result\n```"], "prompt_tokens": [204], "completion_tokens": [920], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(reversed(s.split()))\n\n\n"], "responses": ["## Algorithms:\nThe core concepts involved in this problem are:\n- String manipulation\n- Splitting a string into words\n- Reversing the order of words\n- Joining words back into a string\n\nThis problem primarily uses basic string operations and can be solved with a simple approach using Python's built-in `split()` and `join()` functions.\n\n## Tutorial:\nTo reverse words in a string separated by spaces:\n1. **Split the string** into a list of words using the `split()` method. By default, `split()` splits on whitespace, which is exactly what we need.\n2. **Reverse the list** of words.\n3. **Join the reversed list** of words back into a string using `join()` with a space as the separator.\n\nThis is a straightforward approach and works efficiently for most cases, including handling multiple spaces or leading/trailing spaces, as `split()` automatically ignores those.\n\n## Example Problems:\n\n### 1. **LeetCode 151: Reverse Words in a String**\n**Problem Description**: Given a string, reverse the words in it, ensuring that multiple spaces between words are reduced to a single space, and there is no leading or trailing space.\n\n**Solution**: Use `split()` to split the string into words, reverse the list, and `join()` to form the result.\n\n**Python3 Code**:\n```python\ndef reverse_words(s: str) -> str:\n    return ' '.join(reversed(s.split()))\n```\n\n---\n\n### 2. **HackerRank: Reverse Words in a String**\n**Problem Description**: Reverse the words in a given string, but the input may contain leading, trailing, or multiple spaces between words.\n\n**Solution**: Use `split()` to remove extra spaces, reverse the list of words, and `join()` to reconstruct the string.\n\n**Python3 Code**:\n```python\ndef reverse_words(s):\n    return ' '.join(reversed(s.split()))\n```\n\n---\n\n### 3. **Codeforces: Reverse Words**\n**Problem Description**: Given a string of words separated by spaces, reverse the order of the words.\n\n**Solution**: Split the string into a list of words, reverse the list, and join the words with a space.\n\n**Python3 Code**:\n```python\ndef reverse_words(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n```\n\n---\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `reverse_words` takes a string `s`, splits it into words using `split()`, reverses the list of words, and then joins them back into a string using `join()` with a space as the separator. This handles all cases of extra spaces and ensures a clean output.\n\n### Python3 code:\n```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(reversed(s.split()))\n```"], "prompt_tokens": [203], "completion_tokens": [611], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a Python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "responses": ["## Algorithms:\nThe core concept in this problem is **string manipulation**, specifically **converting characters in a string to uppercase**. In Python, this can be achieved using the built-in `str.upper()` method or by manually converting each character using ASCII values.\n\n## Tutorial:\nIn Python, strings are immutable, so any operation that modifies a string creates a new string. To convert a string to uppercase, you can use the `upper()` method, which returns a new string where all lowercase letters are converted to uppercase. For example:\n\n```python\n\"hello\".upper()  # returns \"HELLO\"\n```\n\nAlternatively, you can manually convert each character by checking if it is lowercase and then converting it using `ord()` and `chr()` functions. For example:\n\n```python\ndef is_upper(string):\n    result = \"\"\n    for char in string:\n        if 'a' <= char <= 'z':\n            result += chr(ord(char) - 32)\n        else:\n            result += char\n    return result\n```\n\nThis approach checks if a character is lowercase (between 'a' and 'z') and converts it to uppercase by subtracting 32 from its ASCII value.\n\n## Example Problems:\n\n### Problem 1: Convert to Uppercase\n**Description:** Given a string, convert all lowercase letters to uppercase and leave other characters unchanged.\n\n**Solution:** Use the `upper()` method or manually convert each character.\n\n**Python Code:**\n```python\ndef convert_to_upper(s: str) -> str:\n    return s.upper()\n```\n\n### Problem 2: Check for Uppercase\n**Description:** Check if a string contains only uppercase letters.\n\n**Solution:** Iterate through the string and verify that each character is uppercase using `isupper()`.\n\n**Python Code:**\n```python\ndef is_all_upper(s: str) -> bool:\n    return all(char.isupper() for char in s)\n```\n\n### Problem 3: Count Uppercase Letters\n**Description:** Count the number of uppercase letters in a given string.\n\n**Solution:** Loop through the string and increment a counter for each uppercase character.\n\n**Python Code:**\n```python\ndef count_uppercase(s: str) -> int:\n    return sum(1 for char in s if char.isupper())\n```\n\n## Python3 code to solve the original problem:\n\n### Explanation of the solution:\nThe function `is_upper` is supposed to convert a given string to uppercase. In Python, the easiest and most efficient way to do this is by using the built-in `str.upper()` method, which handles all the necessary character conversions.\n\n### Python3 code:\n```python\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a Python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n```"], "prompt_tokens": [200], "completion_tokens": [578], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_624_is_upper"}
