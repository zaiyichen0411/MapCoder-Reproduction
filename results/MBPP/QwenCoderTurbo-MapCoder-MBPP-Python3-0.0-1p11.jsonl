{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [749], "completion_tokens": [1112], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["\nimport math\n\ndef prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    max_divisor = math.isqrt(num)\n    for divisor in range(3, max_divisor + 1, 2):\n        if num % divisor == 0:\n            return False\n    return True\n\n\n"], "responses": ["\nimport math\n\ndef prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    max_divisor = math.isqrt(num)\n    for divisor in range(3, max_divisor + 1, 2):\n        if num % divisor == 0:\n            return False\n    return True\n\n\n"], "prompt_tokens": [1403], "completion_tokens": [800], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["\npython\nfrom typing import List\n\ndef merge_two_lists(list1: List[int], list2: List[int]) -> List[int]:\n    merged = []\n    i, j = 0, 0\n    \n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n            \n    while i < len(list1):\n        merged.append(list1[i])\n        i += 1\n        \n    while j < len(list2):\n        merged.append(list2[j])\n        j += 1\n        \n    return merged\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    temp1 = merge_two_lists(num1, num2)\n    temp2 = merge_two_lists(temp1, num3)\n    return temp2\n\n\n"], "responses": ["\npython\nfrom typing import List\n\ndef merge_two_lists(list1: List[int], list2: List[int]) -> List[int]:\n    merged = []\n    i, j = 0, 0\n    \n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n            \n    while i < len(list1):\n        merged.append(list1[i])\n        i += 1\n        \n    while j < len(list2):\n        merged.append(list2[j])\n        j += 1\n        \n    return merged\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    temp1 = merge_two_lists(num1, num2)\n    temp2 = merge_two_lists(temp1, num3)\n    return temp2\n\n\n"], "prompt_tokens": [4156], "completion_tokens": [1616], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n    return sum(len(name) for name in sample_names if not name[0].islower())\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n    return sum(len(name) for name in sample_names if not name[0].islower())\n\n\n"], "prompt_tokens": [1717], "completion_tokens": [966], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    min_product = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    min_product = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n\n\n"], "prompt_tokens": [1498], "completion_tokens": [712], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["\nfrom typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[Any]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n    return tuple(item for item in test_tup if not isinstance(item, tuple))\n\n\n"], "responses": ["\nfrom typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[Any]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n    return tuple(item for item in test_tup if not isinstance(item, tuple))\n\n\n"], "prompt_tokens": [1699], "completion_tokens": [943], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    if len(newList) <= 1:\n        return newList\n    temp = newList[0]\n    newList[0] = newList[-1]\n    newList[-1] = temp\n    return newList\n\n\n"], "responses": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    if len(newList) <= 1:\n        return newList\n    temp = newList[0]\n    newList[0] = newList[-1]\n    newList[-1] = temp\n    return newList\n\n\n"], "prompt_tokens": [1430], "completion_tokens": [647], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    if not all(isinstance(x, (int, float)) for x in list1):\n        raise ValueError(\"List must contain only numbers\")\n    \n    rounded_sum = sum(round(num) for num in list1)\n    return rounded_sum * len(list1)\n\n# Test cases\ndef round_and_sum_test_4():\n    assert round_and_sum([]) == 0, \"Test failed for empty list\"\n\ndef round_and_sum_test_5():\n    try:\n        round_and_sum(['a', 'b', 'c'])\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Test failed for non-numeric elements\")\n\ndef round_and_sum_test_6():\n    assert round_and_sum([1e100, 2e100, 3e100]) == 6e100, \"Test failed for very large numbers\"\n\ndef round_and_sum_test_7():\n    assert round_and_sum([-10.5, -20.7, -30.2]) == -62 * 3, \"Test failed for negative numbers\"\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    if not all(isinstance(x, (int, float)) for x in list1):\n        raise ValueError(\"List must contain only numbers\")\n    \n    rounded_sum = sum(round(num) for num in list1)\n    return rounded_sum * len(list1)\n\n# Test cases\ndef round_and_sum_test_4():\n    assert round_and_sum([]) == 0, \"Test failed for empty list\"\n\ndef round_and_sum_test_5():\n    try:\n        round_and_sum(['a', 'b', 'c'])\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Test failed for non-numeric elements\")\n\ndef round_and_sum_test_6():\n    assert round_and_sum([1e100, 2e100, 3e100]) == 6e100, \"Test failed for very large numbers\"\n\ndef round_and_sum_test_7():\n    assert round_and_sum([-10.5, -20.7, -30.2]) == -62 * 3, \"Test failed for negative numbers\"\n\n\n"], "prompt_tokens": [1819], "completion_tokens": [1389], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["\ndef sequence(n: int) -> int:\n    # Initialize memoization dictionary with base cases\n    memo = {1: 1, 2: 1}\n    \n    def helper(x):\n        if x in memo:\n            return memo[x]\n        else:\n            memo[x] = helper(helper(x - 1)) + helper(x - helper(x - 1))\n            return memo[x]\n    \n    return helper(n)\n\n\n"], "responses": ["\ndef sequence(n: int) -> int:\n    # Initialize memoization dictionary with base cases\n    memo = {1: 1, 2: 1}\n    \n    def helper(x):\n        if x in memo:\n            return memo[x]\n        else:\n            memo[x] = helper(helper(x - 1)) + helper(x - helper(x - 1))\n            return memo[x]\n    \n    return helper(n)\n\n\n"], "prompt_tokens": [1134], "completion_tokens": [557], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["\nfrom typing import List, Any, Optional\n\ndef Find_Max(lst: List[List[Any]]) -> Optional[List[Any]]:\n    if not lst:\n        return None\n    max_len = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n\n\n"], "responses": ["\nfrom typing import List, Any, Optional\n\ndef Find_Max(lst: List[List[Any]]) -> Optional[List[Any]]:\n    if not lst:\n        return None\n    max_len = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n\n\n"], "prompt_tokens": [1350], "completion_tokens": [669], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["\ndef split(word: str) -> List[str]:\n    \"\"\"\n    This function takes a string as input and returns a list containing individual characters from the string.\n\n    Parameters:\n    word (str): The input string to be split into characters.\n\n    Returns:\n    List[str]: A list of characters extracted from the input string.\n    \"\"\"\n    char_list = []  # Initialize an empty list to store the characters\n    for char in word:  # Iterate over each character in the input string\n        char_list.append(char)  # Append the current character to the list\n    return char_list  # Return the list of characters\n\n\n"], "responses": ["\ndef split(word: str) -> List[str]:\n    \"\"\"\n    This function takes a string as input and returns a list containing individual characters from the string.\n\n    Parameters:\n    word (str): The input string to be split into characters.\n\n    Returns:\n    List[str]: A list of characters extracted from the input string.\n    \"\"\"\n    char_list = []  # Initialize an empty list to store the characters\n    for char in word:  # Iterate over each character in the input string\n        char_list.append(char)  # Append the current character to the list\n    return char_list  # Return the list of characters\n\n\n"], "prompt_tokens": [1322], "completion_tokens": [760], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    result = []\n    i = 0\n    while i < len(list1):\n        j = i\n        while j < len(list1) and list1[j] == list1[i]:\n            j += 1\n        result.append(list1[i:j])\n        i = j\n    return result\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    result = []\n    i = 0\n    while i < len(list1):\n        j = i\n        while j < len(list1) and list1[j] == list1[i]:\n            j += 1\n        result.append(list1[i:j])\n        i = j\n    return result\n\n\n"], "prompt_tokens": [1620], "completion_tokens": [855], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    if K == 0:\n        return []\n    if K > len(test_list):\n        return test_list\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    if K == 0:\n        return []\n    if K > len(test_list):\n        return test_list\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n\n\n"], "prompt_tokens": [1956], "completion_tokens": [965], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\nfrom typing import List\n\ndef rotate_right(lst: List[int], m: int) -> List[int]:\n    if not lst:\n        return []\n    \n    n = len(lst)\n    effective_shift = m % n\n    \n    if effective_shift == 0:\n        return lst\n    \n    return lst[-effective_shift:] + lst[:-effective_shift]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef rotate_right(lst: List[int], m: int) -> List[int]:\n    if not lst:\n        return []\n    \n    n = len(lst)\n    effective_shift = m % n\n    \n    if effective_shift == 0:\n        return lst\n    \n    return lst[-effective_shift:] + lst[:-effective_shift]\n\n\n"], "prompt_tokens": [1575], "completion_tokens": [694], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n    abs_number = abs(number)\n    num_digits = len(str(abs_number))\n    sum_of_powers = sum(int(digit) ** num_digits for digit in str(abs_number))\n    return sum_of_powers == abs_number\n\n\n"], "responses": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n    abs_number = abs(number)\n    num_digits = len(str(abs_number))\n    sum_of_powers = sum(int(digit) ** num_digits for digit in str(abs_number))\n    return sum_of_powers == abs_number\n\n\n"], "prompt_tokens": [1585], "completion_tokens": [937], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, int):\n            temp_num = abs(num)\n            while temp_num != 0:\n                digit = temp_num % 10\n                total_sum += digit\n                temp_num //= 10\n    return total_sum\n\n# Test cases\nassert sum_of_digits([]) == 0\nassert sum_of_digits([123, 456, -789, 'abc']) == 45\nassert sum_of_digits([-10, -20, -30]) == 6\nassert sum_of_digits([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 45\nassert sum_of_digits([111, 222, 333]) == 18\nassert sum_of_digits([10, 2, 56]) == 14\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, int):\n            temp_num = abs(num)\n            while temp_num != 0:\n                digit = temp_num % 10\n                total_sum += digit\n                temp_num //= 10\n    return total_sum\n\n# Test cases\nassert sum_of_digits([]) == 0\nassert sum_of_digits([123, 456, -789, 'abc']) == 45\nassert sum_of_digits([-10, -20, -30]) == 6\nassert sum_of_digits([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 45\nassert sum_of_digits([111, 222, 333]) == 18\nassert sum_of_digits([10, 2, 56]) == 14\n\n\n"], "prompt_tokens": [2294], "completion_tokens": [1219], "no_of_try": 1, "api_calls": 5, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    left = 0\n    right = n - 1\n    \n    while left <= right:\n        if arr[left] < 0:\n            left += 1\n        elif arr[right] >= 0:\n            right -= 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return arr\n\n\n"], "responses": ["\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    left = 0\n    right = n - 1\n    \n    while left <= right:\n        if arr[left] < 0:\n            left += 1\n        elif arr[right] >= 0:\n            right -= 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    \n    return arr\n\n\n"], "prompt_tokens": [3447], "completion_tokens": [1316], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\nimport math\n\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    if v < 0:\n        raise ValueError(\"Wind speed cannot be negative.\")\n    \n    wci = 13.12 + 0.6215 * t -  11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)\n\n\n"], "responses": ["\nimport math\n\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    if v < 0:\n        raise ValueError(\"Wind speed cannot be negative.\")\n    \n    wci = 13.12 + 0.6215 * t -  11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16)\n    return round(wci)\n\n\n"], "prompt_tokens": [1511], "completion_tokens": [1024], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["\ndef bell_Number(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Initialize a list to store Bell numbers up to n\n    B = [0] * (n + 1)\n    B[0] = 1  # The 0th Bell number is 1\n    \n    for i in range(1, n + 1):\n        B[i] = 0\n        for k in range(i):\n            B[i] += B[k] * binomial_coefficient(i - 1, k)\n    \n    return B[n]\n\ndef binomial_coefficient(n: int, k: int) -> int:\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - k + i)\n        result //= i\n    return result\n\n# Test cases\nprint(bell_Number(0))  # Expected output: 1\nprint(bell_Number(2))  # Expected output: 2\nprint(bell_Number(4))  # Expected output: 15\nprint(bell_Number(6))  # Expected output: 52\ntry:\n    print(bell_Number(-1))  # Expected output: Raises ValueError\nexcept ValueError as e:\n    print(e)\nprint(bell_Number(1))  # Expected output: 1\n\n\n"], "responses": ["\ndef bell_Number(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Initialize a list to store Bell numbers up to n\n    B = [0] * (n + 1)\n    B[0] = 1  # The 0th Bell number is 1\n    \n    for i in range(1, n + 1):\n        B[i] = 0\n        for k in range(i):\n            B[i] += B[k] * binomial_coefficient(i - 1, k)\n    \n    return B[n]\n\ndef binomial_coefficient(n: int, k: int) -> int:\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - k + i)\n        result //= i\n    return result\n\n# Test cases\nprint(bell_Number(0))  # Expected output: 1\nprint(bell_Number(2))  # Expected output: 2\nprint(bell_Number(4))  # Expected output: 15\nprint(bell_Number(6))  # Expected output: 52\ntry:\n    print(bell_Number(-1))  # Expected output: Raises ValueError\nexcept ValueError as e:\n    print(e)\nprint(bell_Number(1))  # Expected output: 1\n\n\n"], "prompt_tokens": [2251], "completion_tokens": [1809], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["\ndef sum_div(number: int) -> int:\n    if number <= 1:\n        return None\n    total = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            total += i\n    return total\n\n\n"], "responses": ["\ndef sum_div(number: int) -> int:\n    if number <= 1:\n        return None\n    total = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            total += i\n    return total\n\n\n"], "prompt_tokens": [2916], "completion_tokens": [1007], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["\nfrom typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    result = []\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for dx, dy in directions:\n        new_x = test_tup[0] + dx\n        new_y = test_tup[1] + dy\n        result.append([new_x, new_y])\n    return result\n\n\n"], "responses": ["\nfrom typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    result = []\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for dx, dy in directions:\n        new_x = test_tup[0] + dx\n        new_y = test_tup[1] + dy\n        result.append([new_x, new_y])\n    return result\n\n\n"], "prompt_tokens": [3753], "completion_tokens": [1406], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["\nfrom typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    # Use zip to handle tuples of equal length\n    dissimilar_elements = tuple(x1 for x1, x2 in zip(test_tup1, test_tup2) if x1 != x2)\n    \n    return dissimilar_elements\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    # Use zip to handle tuples of equal length\n    dissimilar_elements = tuple(x1 for x1, x2 in zip(test_tup1, test_tup2) if x1 != x2)\n    \n    return dissimilar_elements\n\n\n"], "prompt_tokens": [3639], "completion_tokens": [1585], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["\npython\ndef find_length(s: str) -> int:\n    if not s:\n        return 0\n    \n    max_diff = 0\n    current_diff = 0\n    \n    for char in s:\n        if char == '1':\n            current_diff += 1\n        else:\n            current_diff -= 1\n            \n        if current_diff < 0:\n            current_diff = 0\n        elif current_diff > max_diff:\n            max_diff = current_diff\n            \n    return max_diff\n\n\n"], "responses": ["\npython\ndef find_length(s: str) -> int:\n    if not s:\n        return 0\n    \n    max_diff = 0\n    current_diff = 0\n    \n    for char in s:\n        if char == '1':\n            current_diff += 1\n        else:\n            current_diff -= 1\n            \n        if current_diff < 0:\n            current_diff = 0\n        elif current_diff > max_diff:\n            max_diff = current_diff\n            \n    return max_diff\n\n\n"], "prompt_tokens": [3727], "completion_tokens": [1460], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["\nfrom typing import List, Any, Tuple\n\ndef split_two_parts(list1: List[Any], L: int) -> Tuple[List[Any], List[Any]]:\n    if L < 0 or L > len(list1):\n        return list1[:], []\n    else:\n        return list1[:L], list1[L:]\n\n\n"], "responses": ["\nfrom typing import List, Any, Tuple\n\ndef split_two_parts(list1: List[Any], L: int) -> Tuple[List[Any], List[Any]]:\n    if L < 0 or L > len(list1):\n        return list1[:], []\n    else:\n        return list1[:L], list1[L:]\n\n\n"], "prompt_tokens": [1685], "completion_tokens": [806], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["\ndef check_expression(exp: str) -> bool:\n    stack = []\n    pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        if char in pairs.values():\n            stack.append(char)\n        elif char in pairs:\n            if not stack or stack.pop() != pairs[char]:\n                return False\n    \n    return len(stack) == 0\n\n\n"], "responses": ["\ndef check_expression(exp: str) -> bool:\n    stack = []\n    pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in exp:\n        if char in pairs.values():\n            stack.append(char)\n        elif char in pairs:\n            if not stack or stack.pop() != pairs[char]:\n                return False\n    \n    return len(stack) == 0\n\n\n"], "prompt_tokens": [1655], "completion_tokens": [865], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Counts the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    z (int): The third integer.\n\n    Returns:\n    int: The count of numbers that are equal among the three inputs.\n    \"\"\"\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "responses": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Counts the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    z (int): The third integer.\n\n    Returns:\n    int: The count of numbers that are equal among the three inputs.\n    \"\"\"\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "prompt_tokens": [1943], "completion_tokens": [925], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["\ndef find_lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    lucas_numbers = [2, 1]\n    for i in range(2, n + 1):\n        next_number = lucas_numbers[-1] + lucas_numbers[-2]\n        lucas_numbers.append(next_number)\n    \n    return lucas_numbers[n]\n\n\n"], "responses": ["\ndef find_lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    lucas_numbers = [2, 1]\n    for i in range(2, n + 1):\n        next_number = lucas_numbers[-1] + lucas_numbers[-2]\n        lucas_numbers.append(next_number)\n    \n    return lucas_numbers[n]\n\n\n"], "prompt_tokens": [1248], "completion_tokens": [635], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["\npython\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    words = word.split('_')\n    return ''.join(word.capitalize() for word in words)\n\n\n"], "responses": ["\npython\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    words = word.split('_')\n    return ''.join(word.capitalize() for word in words)\n\n\n"], "prompt_tokens": [2214], "completion_tokens": [814], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["\npython\ndef reverse_words(s: str) -> str:\n    return ' '.join(word.strip()[::-1] for word in s.split())\n\n\n"], "responses": ["\npython\ndef reverse_words(s: str) -> str:\n    return ' '.join(word.strip()[::-1] for word in s.split())\n\n\n"], "prompt_tokens": [2808], "completion_tokens": [1018], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["\ndef is_upper(string: str) -> str:\n    return string.upper()\n\n\n"], "responses": ["\ndef is_upper(string: str) -> str:\n    return string.upper()\n\n\n"], "prompt_tokens": [1145], "completion_tokens": [456], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert numbers to strings and pad the shorter one with leading zeros\n    str_n1 = str(abs(n1)).zfill(max(len(str(abs(n1))), len(str(abs(n2)))))\n    str_n2 = str(abs(n2)).zfill(max(len(str(abs(n1))), len(str(abs(n2)))))\n    \n    # Calculate the sum of the absolute differences of corresponding digits\n    return sum(abs(int(digit1) - int(digit2)) for digit1, digit2 in zip(str_n1, str_n2))\n\n\n"], "responses": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert numbers to strings and pad the shorter one with leading zeros\n    str_n1 = str(abs(n1)).zfill(max(len(str(abs(n1))), len(str(abs(n2)))))\n    str_n2 = str(abs(n2)).zfill(max(len(str(abs(n1))), len(str(abs(n2)))))\n    \n    # Calculate the sum of the absolute differences of corresponding digits\n    return sum(abs(int(digit1) - int(digit2)) for digit1, digit2 in zip(str_n1, str_n2))\n\n\n"], "prompt_tokens": [2515], "completion_tokens": [1326], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["\nfrom typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    def count_lists(lst):\n        count = 0\n        for item in lst:\n            if isinstance(item, list):\n                count += 1 + count_lists(item)\n        return count\n    \n    return count_lists(Input)\n\n# Test cases\nassert find_lists([]) == 0\nassert find_lists([1, 2, [3, 4]]) == 1\nassert find_lists([[1], 2], 3, [4, [5]]) == 4\nassert find_lists([1, \"string\", [True, False], None, {\"key\": \"value\"}]) == 1\nassert find_lists([[1, [2, [3, [4]]]], [5, 6]]) == 3\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    def count_lists(lst):\n        count = 0\n        for item in lst:\n            if isinstance(item, list):\n                count += 1 + count_lists(item)\n        return count\n    \n    return count_lists(Input)\n\n# Test cases\nassert find_lists([]) == 0\nassert find_lists([1, 2, [3, 4]]) == 1\nassert find_lists([[1], 2], 3, [4, [5]]) == 4\nassert find_lists([1, \"string\", [True, False], None, {\"key\": \"value\"}]) == 1\nassert find_lists([[1, [2, [3, [4]]]], [5, 6]]) == 3\n\n\n"], "prompt_tokens": [3125], "completion_tokens": [1403], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_143_find_lists"}
