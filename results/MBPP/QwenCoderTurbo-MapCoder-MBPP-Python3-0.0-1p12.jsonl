{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["\nfrom typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    averages = []\n    for sublist in nums:\n        if sublist:\n            avg = sum(sublist) / len(sublist)\n            averages.append(avg)\n        else:\n            averages.append(None)\n    return averages\n\n\n"], "responses": ["\nfrom typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    averages = []\n    for sublist in nums:\n        if sublist:\n            avg = sum(sublist) / len(sublist)\n            averages.append(avg)\n        else:\n            averages.append(None)\n    return averages\n\n\n"], "prompt_tokens": [3499], "completion_tokens": [1356], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n\n\n"], "prompt_tokens": [1401], "completion_tokens": [982], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) < 0\n\n\n"], "responses": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    return (x ^ y) < 0\n\n\n"], "prompt_tokens": [1441], "completion_tokens": [812], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\nfrom typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    return [sorted(sublist) for sublist in list1]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    return [sorted(sublist) for sublist in list1]\n\n\n"], "prompt_tokens": [1534], "completion_tokens": [862], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    def backtrack(start, path):\n        if len(path) == n:\n            result.append(path)\n            return\n        for i in range(start, len(l)):\n            backtrack(i, path + [l[i]])\n    \n    if not l:\n        return []\n    \n    result = []\n    backtrack(0, [])\n    return result\n\n# Test cases\nprint(combinations_colors([\"red\", \"blue\"], 2))  # [[\"red\", \"red\"], [\"red\", \"blue\"], [\"blue\", \"red\"], [\"blue\", \"blue\"]]\nprint(combinations_colors([\"green\"], 3))     # [[\"green\", \"green\", \"green\"]]\nprint(combinations_colors([], 1))          # []\nprint(combinations_colors([\"yellow\", \"orange\"], 1))  # [[\"yellow\"], [\"orange\"]]\nprint(combinations_colors([\"purple\"], 0))      # [[]]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    def backtrack(start, path):\n        if len(path) == n:\n            result.append(path)\n            return\n        for i in range(start, len(l)):\n            backtrack(i, path + [l[i]])\n    \n    if not l:\n        return []\n    \n    result = []\n    backtrack(0, [])\n    return result\n\n# Test cases\nprint(combinations_colors([\"red\", \"blue\"], 2))  # [[\"red\", \"red\"], [\"red\", \"blue\"], [\"blue\", \"red\"], [\"blue\", \"blue\"]]\nprint(combinations_colors([\"green\"], 3))     # [[\"green\", \"green\", \"green\"]]\nprint(combinations_colors([], 1))          # []\nprint(combinations_colors([\"yellow\", \"orange\"], 1))  # [[\"yellow\"], [\"orange\"]]\nprint(combinations_colors([\"purple\"], 0))      # [[]]\n\n\n"], "prompt_tokens": [1582], "completion_tokens": [853], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["\npython\ndef move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n    left, right = 0, len(test_str) - 1\n    \n    while left < right:\n        if not test_str[left].isdigit():\n            left += 1\n        elif not test_str[right].isdigit():\n            right -= 1\n        else:\n            # Swap the blocks of digits\n            test_str = test_str[:left] + test_str[right] + test_str[left+1:right] + test_str[left] + test_str[right+1:]\n            \n            left += 1\n            right -= 1\n            \n    return test_str\n\n\n"], "responses": ["\npython\ndef move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n    left, right = 0, len(test_str) - 1\n    \n    while left < right:\n        if not test_str[left].isdigit():\n            left += 1\n        elif not test_str[right].isdigit():\n            right -= 1\n        else:\n            # Swap the blocks of digits\n            test_str = test_str[:left] + test_str[right] + test_str[left+1:right] + test_str[left] + test_str[right+1:]\n            \n            left += 1\n            right -= 1\n            \n    return test_str\n\n\n"], "prompt_tokens": [3939], "completion_tokens": [1893], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["\nfrom typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and allow for efficient intersection\n    set_nums1 = set(array_nums1)\n    set_nums2 = set(array_nums2)\n    \n    # Find the intersection of both sets\n    intersection_set = set_nums1.intersection(set_nums2)\n    \n    # Convert the result back to a list\n    return list(intersection_set)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and allow for efficient intersection\n    set_nums1 = set(array_nums1)\n    set_nums2 = set(array_nums2)\n    \n    # Find the intersection of both sets\n    intersection_set = set_nums1.intersection(set_nums2)\n    \n    # Convert the result back to a list\n    return list(intersection_set)\n\n\n"], "prompt_tokens": [3339], "completion_tokens": [1261], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["\nfrom typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    return tup.count(x)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    return tup.count(x)\n\n\n"], "prompt_tokens": [1594], "completion_tokens": [803], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["\nfrom typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size.\n    \"\"\"\n\n    def merge_sorted_arrays(a: List[int], b: List[int]) -> List[int]:\n        result = []\n        i = j = 0\n        \n        while i < len(a) and j < len(b):\n            if a[i] < b[j]:\n                result.append(a[i])\n                i += 1\n            else:\n                result.append(b[j])\n                j += 1\n        \n        result.extend(a[i:])\n        result.extend(b[j:])\n        \n        return result\n    \n    merged_array = merge_sorted_arrays(arr1, arr2)\n    mid_index = n // 2\n    \n    if n % 2 != 0:\n        return float(merged_array[mid_index])\n    else:\n        return (merged_array[mid_index - 1] + merged_array[mid_index]) / 2.0\n\n# Test cases\n\n    # Edge case: Empty arrays\n    assert get_median([], [], 0) == None\n    \n    # Odd number of elements in merged array\n    assert get_median([1, 3], [2], 2) == 2.0\n    \n    # Even number of elements in merged array\n    assert get_median([1, 2], [3, 4], 4) == 2.5\n    \n    # Test with small numbers\n    assert get_median([1, 2], [3, 4], 4) == 2.5\n    \n    # Test with large numbers\n    assert get_median([100, 200], [300, 400], 4) == 250.0\n    \n    # Test with negative numbers\n    assert get_median([-1, -2], [-3, -4], 4) == -2.5\n    \n    # Additional test case from feedback\n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 17.0\n\n\n"], "responses": ["\nfrom typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Write a function to find the median of two sorted lists of the same size.\n    \"\"\"\n\n    def merge_sorted_arrays(a: List[int], b: List[int]) -> List[int]:\n        result = []\n        i = j = 0\n        \n        while i < len(a) and j < len(b):\n            if a[i] < b[j]:\n                result.append(a[i])\n                i += 1\n            else:\n                result.append(b[j])\n                j += 1\n        \n        result.extend(a[i:])\n        result.extend(b[j:])\n        \n        return result\n    \n    merged_array = merge_sorted_arrays(arr1, arr2)\n    mid_index = n // 2\n    \n    if n % 2 != 0:\n        return float(merged_array[mid_index])\n    else:\n        return (merged_array[mid_index - 1] + merged_array[mid_index]) / 2.0\n\n# Test cases\n\n    # Edge case: Empty arrays\n    assert get_median([], [], 0) == None\n    \n    # Odd number of elements in merged array\n    assert get_median([1, 3], [2], 2) == 2.0\n    \n    # Even number of elements in merged array\n    assert get_median([1, 2], [3, 4], 4) == 2.5\n    \n    # Test with small numbers\n    assert get_median([1, 2], [3, 4], 4) == 2.5\n    \n    # Test with large numbers\n    assert get_median([100, 200], [300, 400], 4) == 250.0\n    \n    # Test with negative numbers\n    assert get_median([-1, -2], [-3, -4], 4) == -2.5\n    \n    # Additional test case from feedback\n    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 17.0\n\n\n"], "prompt_tokens": [3813], "completion_tokens": [1889], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["\ndef tetrahedral_number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "responses": ["\ndef tetrahedral_number(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "prompt_tokens": [979], "completion_tokens": [762], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": ["\nfrom typing import List, Tuple\nfrom itertools import product\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n\n    if not test_list:\n        return []\n\n    combinations = set(sum(tup) for tup in product(*test_list))\n    \n    return sorted(list(combinations))\n\n# Test cases\nprint(find_combinations([(2, 3), (4, 5)]))  # Expected output: [6, 7, 8, 9, 10, 11]\nprint(find_combinations([(1, 2), (3, 4), (5, 6)]))  # Expected output: [6, 7, 8, 9, 10, 11, 12, 13, 14]\nprint(find_combinations([]))  # Expected output: []\nprint(find_combinations([(10,)]))  # Expected output: [10]\nprint(find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]))  # Expected output: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\n"], "responses": ["\nfrom typing import List, Tuple\nfrom itertools import product\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Write a function to find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n\n    if not test_list:\n        return []\n\n    combinations = set(sum(tup) for tup in product(*test_list))\n    \n    return sorted(list(combinations))\n\n# Test cases\nprint(find_combinations([(2, 3), (4, 5)]))  # Expected output: [6, 7, 8, 9, 10, 11]\nprint(find_combinations([(1, 2), (3, 4), (5, 6)]))  # Expected output: [6, 7, 8, 9, 10, 11, 12, 13, 14]\nprint(find_combinations([]))  # Expected output: []\nprint(find_combinations([(10,)]))  # Expected output: [10]\nprint(find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]))  # Expected output: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n\n\n"], "prompt_tokens": [3346], "completion_tokens": [1862], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["\nfrom typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            right = mid - 1  # Continue to search in the left half\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            right = mid - 1  # Continue to search in the left half\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "prompt_tokens": [1966], "completion_tokens": [1109], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result.bit_count() == 1\n\n\n"], "responses": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    return xor_result.bit_count() == 1\n\n\n"], "prompt_tokens": [1297], "completion_tokens": [996], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n    \n    Parameters:\n    monthnum3 (int): The month number to check, ranging from 1 to 12.\n    \n    Returns:\n    bool: True if the month has 30 days, False otherwise.\n    \n    Raises:\n    ValueError: If the month number is not within the valid range (1-12).\n    \"\"\"\n    # Validate the month number\n    if not 1 <= monthnum3 <= 12:\n        raise ValueError(\"Month number must be between 1 and 12.\")\n    \n    # List of months with 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the month is in the list of months with 30 days\n    return monthnum3 in months_with_30_days\n\n\n"], "responses": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n    \n    Parameters:\n    monthnum3 (int): The month number to check, ranging from 1 to 12.\n    \n    Returns:\n    bool: True if the month has 30 days, False otherwise.\n    \n    Raises:\n    ValueError: If the month number is not within the valid range (1-12).\n    \"\"\"\n    # Validate the month number\n    if not 1 <= monthnum3 <= 12:\n        raise ValueError(\"Month number must be between 1 and 12.\")\n    \n    # List of months with 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the month is in the list of months with 30 days\n    return monthnum3 in months_with_30_days\n\n\n"], "prompt_tokens": [1409], "completion_tokens": [808], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    if len(newList) > 1:\n        newList[0], newList[-1] = newList[-1], newList[0]\n    return newList\n\n\n"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    if len(newList) > 1:\n        newList[0], newList[-1] = newList[-1], newList[0]\n    return newList\n\n\n"], "prompt_tokens": [1464], "completion_tokens": [786], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["\ndef rearrange_bigger(n: int) -> int:\n    digits = list(str(n))\n    i = len(digits) - 2\n    \n    # Find the first digit that is smaller than the digit next to it\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the largest permutation\n    if i == -1:\n        return -1\n    \n    # Find the smallest digit on the right side of (i-th digit) which is greater than digits[i]\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the above found smallest digit with the (i-th digit)\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after the (i-th digit)\n    digits = digits[:i + 1] + digits[i + 1:][::-1]\n    \n    return int(\"\".join(digits))\n\n\n"], "responses": ["\ndef rearrange_bigger(n: int) -> int:\n    digits = list(str(n))\n    i = len(digits) - 2\n    \n    # Find the first digit that is smaller than the digit next to it\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, the number is already the largest permutation\n    if i == -1:\n        return -1\n    \n    # Find the smallest digit on the right side of (i-th digit) which is greater than digits[i]\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the above found smallest digit with the (i-th digit)\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after the (i-th digit)\n    digits = digits[:i + 1] + digits[i + 1:][::-1]\n    \n    return int(\"\".join(digits))\n\n\n"], "prompt_tokens": [1547], "completion_tokens": [1064], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def helper(x):\n        if x in memo:\n            return memo[x]\n        if x <= 1:\n            return x\n        else:\n            result = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n            memo[x] = result\n            return result\n    \n    return helper(n)\n\n\n"], "responses": ["\ndef get_max_sum(n: int) -> int:\n    memo = {}\n    \n    def helper(x):\n        if x in memo:\n            return memo[x]\n        if x <= 1:\n            return x\n        else:\n            result = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n            memo[x] = result\n            return result\n    \n    return helper(n)\n\n\n"], "prompt_tokens": [687], "completion_tokens": [762], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n    \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return None\n\n\n"], "responses": ["\nfrom typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n    \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return None\n\n\n"], "prompt_tokens": [2326], "completion_tokens": [1265], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    def count_ones(binary_str):\n        return binary_str.count('1')\n    \n    if not s:\n        return 0\n    \n    max_ones = min(n, len(s))\n    result = 0\n    \n    for i in range(max_ones):\n        rotated_s = s[-i:] + s[:-i]\n        ones_count = count_ones(rotated_s)\n        if ones_count % 2 != 0:\n            result = max(result, ones_count)\n    \n    return result\n\n# Test cases\nprint(odd_Equivalent(\"110\", 2))       # Output: 2\nprint(odd_Equivalent(\"1010\", 4))      # Output: 2\nprint(odd_Equivalent(\"\", 5))          # Output: 0\nprint(odd_Equivalent(\"1111\", 1))      # Output: 4\nprint(odd_Equivalent(\"0000\", 1))      # Output: 0\nprint(odd_Equivalent(\"101010\", 3))    # Output: 3\nprint(odd_Equivalent(\"111000\", 7))    # Output: 3\n\n\n"], "responses": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    def count_ones(binary_str):\n        return binary_str.count('1')\n    \n    if not s:\n        return 0\n    \n    max_ones = min(n, len(s))\n    result = 0\n    \n    for i in range(max_ones):\n        rotated_s = s[-i:] + s[:-i]\n        ones_count = count_ones(rotated_s)\n        if ones_count % 2 != 0:\n            result = max(result, ones_count)\n    \n    return result\n\n# Test cases\nprint(odd_Equivalent(\"110\", 2))       # Output: 2\nprint(odd_Equivalent(\"1010\", 4))      # Output: 2\nprint(odd_Equivalent(\"\", 5))          # Output: 0\nprint(odd_Equivalent(\"1111\", 1))      # Output: 4\nprint(odd_Equivalent(\"0000\", 1))      # Output: 0\nprint(odd_Equivalent(\"101010\", 3))    # Output: 3\nprint(odd_Equivalent(\"111000\", 7))    # Output: 3\n\n\n"], "prompt_tokens": [1672], "completion_tokens": [1110], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["\nfrom typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    if not lst:  # Check if the list is empty\n        return 0\n    \n    min_length = float('inf')  # Initialize min_length to infinity\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n\n\n"], "responses": ["\nfrom typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    if not lst:  # Check if the list is empty\n        return 0\n    \n    min_length = float('inf')  # Initialize min_length to infinity\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n\n\n"], "prompt_tokens": [1173], "completion_tokens": [670], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["\nfrom typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    if len(test_tup1) != 4 or len(test_tup2) != 4:\n        return ()\n    \n    result = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return result\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    if len(test_tup1) != 4 or len(test_tup2) != 4:\n        return ()\n    \n    result = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return result\n\n\n"], "prompt_tokens": [1954], "completion_tokens": [1102], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["\ndef is_nonagonal(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return n * (7 * n - 5) // 2\n\n\n"], "responses": ["\ndef is_nonagonal(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return n * (7 * n - 5) // 2\n\n\n"], "prompt_tokens": [1462], "completion_tokens": [754], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": ["\ndef is_octagonal(n: int) -> int:\n    if n <= 0:\n        return None\n    return n * (3 * n - 2)\n\n\n"], "responses": ["\ndef is_octagonal(n: int) -> int:\n    if n <= 0:\n        return None\n    return n * (3 * n - 2)\n\n\n"], "prompt_tokens": [1217], "completion_tokens": [609], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_59_is_octagonal"}
