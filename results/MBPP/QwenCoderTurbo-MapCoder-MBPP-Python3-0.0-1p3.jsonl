{"name": "mbpp_101_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find the kth element in the given array using 1-based indexing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "kth_element", "test": "def check(candidate):\n    assert candidate([12, 3, 5, 7, 19], 2) == 3\n    assert candidate([17, 24, 8, 23], 3) == 8\n    assert candidate([16, 21, 25, 36, 4], 4) == 36\n\ndef test_check():\n    check(kth_element)\n\ntest_check()\n", "sample_io": ["assert kth_element([12, 3, 5, 7, 19], 2) == 3"], "source_codes": ["\nfrom typing import List, Union\n\ndef kth_element(arr: List[int], k: int) -> Union[int, Exception]:\n    if len(arr) == 0:\n        raise IndexError(\"Array is empty\")\n    if k <= 0:\n        raise ValueError(\"k must be greater than 0\")\n    try:\n        return arr[k - 1]\n    except IndexError:\n        raise IndexError(\"Index out of range\")\n\n# Test cases\nassert kth_element([5, 2, 9, 1, 5, 6], 3) == 9\nassert kth_element([4, 8, 2, 7, 5, 1], 1) == 4\nassert kth_element([3, 1, 4, 1, 5, 9], 6) == 9\ntry:\n    kth_element([], 1)\nexcept IndexError as e:\n    assert str(e) == \"Array is empty\"\ntry:\n    kth_element([10, 20, 30], 0)\nexcept ValueError as e:\n    assert str(e) == \"k must be greater than 0\"\ntry:\n    kth_element([1, 2, 3], 4)\nexcept IndexError as e:\n    assert str(e) == \"Index out of range\"\n\n\n"], "responses": ["\nfrom typing import List, Union\n\ndef kth_element(arr: List[int], k: int) -> Union[int, Exception]:\n    if len(arr) == 0:\n        raise IndexError(\"Array is empty\")\n    if k <= 0:\n        raise ValueError(\"k must be greater than 0\")\n    try:\n        return arr[k - 1]\n    except IndexError:\n        raise IndexError(\"Index out of range\")\n\n# Test cases\nassert kth_element([5, 2, 9, 1, 5, 6], 3) == 9\nassert kth_element([4, 8, 2, 7, 5, 1], 1) == 4\nassert kth_element([3, 1, 4, 1, 5, 9], 6) == 9\ntry:\n    kth_element([], 1)\nexcept IndexError as e:\n    assert str(e) == \"Array is empty\"\ntry:\n    kth_element([10, 20, 30], 0)\nexcept ValueError as e:\n    assert str(e) == \"k must be greater than 0\"\ntry:\n    kth_element([1, 2, 3], 4)\nexcept IndexError as e:\n    assert str(e) == \"Index out of range\"\n\n\n"], "prompt_tokens": [1351], "completion_tokens": [832], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_101_kth_element"}
{"name": "mbpp_461_upper_ctr", "language": "Python3", "prompt": "def upper_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the upper case characters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "upper_ctr", "test": "def check(candidate):\n    assert candidate('PYthon') == 1\n    assert candidate('BigData') == 1\n    assert candidate('program') == 0\n\ndef test_check():\n    check(upper_ctr)\n\ntest_check()\n", "sample_io": ["assert upper_ctr('PYthon') == 1"], "source_codes": ["\npython3\ndef upper_ctr(s: str) -> int:\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count\n\n\n"], "responses": ["\npython3\ndef upper_ctr(s: str) -> int:\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [2892], "completion_tokens": [1039], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_461_upper_ctr"}
{"name": "mbpp_593_removezero_ip", "language": "Python3", "prompt": "def removezero_ip(ip: str) -> str:\n    \"\"\"\n\tWrite a function to remove leading zeroes from an ip address.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "removezero_ip", "test": "def check(candidate):\n    assert candidate('216.08.094.196') == '216.8.94.196'\n    assert candidate('12.01.024') == '12.1.24'\n    assert candidate('216.08.094.0196') == '216.8.94.196'\n\ndef test_check():\n    check(removezero_ip)\n\ntest_check()\n", "sample_io": ["assert removezero_ip('216.08.094.196') == '216.8.94.196'"], "source_codes": ["\ndef removezero_ip(ip: str) -> str:\n    segments = ip.split('.')\n    modified_segments = [str(int(segment)) for segment in segments]\n    result = '.'.join(modified_segments)\n    \n    # Handle the edge case where the entire IP address was zeros\n    if result == '0':\n        return '.'\n    \n    return result\n\n\n"], "responses": ["\ndef removezero_ip(ip: str) -> str:\n    segments = ip.split('.')\n    modified_segments = [str(int(segment)) for segment in segments]\n    result = '.'.join(modified_segments)\n    \n    # Handle the edge case where the entire IP address was zeros\n    if result == '0':\n        return '.'\n    \n    return result\n\n\n"], "prompt_tokens": [1530], "completion_tokens": [834], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_593_removezero_ip"}
{"name": "mbpp_788_new_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n\tWrite a function to create a new tuple from the given string and list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "new_tuple", "test": "def check(candidate):\n    assert candidate(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')\n    assert candidate(['We', 'are'], 'Developers') == ('We', 'are', 'Developers')\n    assert candidate(['Part', 'is'], 'Wrong') == ('Part', 'is', 'Wrong')\n\ndef test_check():\n    check(new_tuple)\n\ntest_check()\n", "sample_io": ["assert new_tuple(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    first_element = test_list[0] if len(test_list) > 0 else \"\"\n    second_element = test_list[1] if len(test_list) > 1 else \"\"\n    return (first_element, second_element, test_str)\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    first_element = test_list[0] if len(test_list) > 0 else \"\"\n    second_element = test_list[1] if len(test_list) > 1 else \"\"\n    return (first_element, second_element, test_str)\n\n\n"], "prompt_tokens": [1515], "completion_tokens": [689], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_788_new_tuple"}
{"name": "mbpp_777_find_sum", "language": "Python3", "prompt": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of non-repeated elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    assert candidate([1, 10, 9, 4, 2, 10, 10, 45, 4]) == 71\n    assert candidate([12, 10, 9, 45, 2, 10, 10, 45, 10]) == 78\n\ndef test_check():\n    check(find_sum)\n\ntest_check()\n", "sample_io": ["assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21"], "source_codes": ["\nfrom typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    return sum(num for num, freq in freq_dict.items() if freq == 1)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    return sum(num for num, freq in freq_dict.items() if freq == 1)\n\n\n"], "prompt_tokens": [2501], "completion_tokens": [834], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_777_find_sum"}
{"name": "mbpp_586_split_Arr", "language": "Python3", "prompt": "from typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to split a list at the nth eelment and add the first part to the end.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_Arr", "test": "def check(candidate):\n    assert candidate([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]\n    assert candidate([1, 2, 3, 4], 1) == [2, 3, 4, 1]\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7], 3) == [3, 4, 5, 6, 7, 0, 1, 2]\n\ndef test_check():\n    check(split_Arr)\n\ntest_check()\n", "sample_io": ["assert split_Arr([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]"], "source_codes": ["\nfrom typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    if len(l) <= 1:\n        return l\n    if n < 0 or n >= len(l):\n        return l\n    return l[n:] + l[:n]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    if len(l) <= 1:\n        return l\n    if n < 0 or n >= len(l):\n        return l\n    return l[n:] + l[:n]\n\n\n"], "prompt_tokens": [1523], "completion_tokens": [687], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_586_split_Arr"}
{"name": "mbpp_104_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([[' red ', 'green'], ['blue ', ' black'], [' orange', 'brown']]) == [[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]\n    assert candidate([['zilver', 'gold'], ['magnesium', 'aluminium'], ['steel', 'bronze']]) == [['gold', 'zilver'], ['aluminium', 'magnesium'], ['bronze', 'steel']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\nfrom typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    for i in range(len(input_list)):\n        input_list[i] = sorted(input_list[i])\n    return input_list\n\n\n"], "responses": ["\nfrom typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    for i in range(len(input_list)):\n        input_list[i] = sorted(input_list[i])\n    return input_list\n\n\n"], "prompt_tokens": [1593], "completion_tokens": [837], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_104_sort_sublists"}
{"name": "mbpp_472_check_Consecutive", "language": "Python3", "prompt": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given list contains consecutive numbers or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_Consecutive", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 2, 3, 5, 6]) == False\n    assert candidate([1, 2, 1]) == False\n\ndef test_check():\n    check(check_Consecutive)\n\ntest_check()\n", "sample_io": ["assert check_Consecutive([1, 2, 3, 4, 5]) == True"], "source_codes": ["\nfrom typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if len(l) <= 1:\n        return True\n    sorted_l = sorted(l)\n    for i in range(1, len(sorted_l)):\n        if sorted_l[i] != sorted_l[i - 1] + 1:\n            return False\n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    if len(l) <= 1:\n        return True\n    sorted_l = sorted(l)\n    for i in range(1, len(sorted_l)):\n        if sorted_l[i] != sorted_l[i - 1] + 1:\n            return False\n    return True\n\n\n"], "prompt_tokens": [1243], "completion_tokens": [677], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_472_check_Consecutive"}
{"name": "mbpp_310_string_to_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_tuple", "test": "def check(candidate):\n    assert candidate('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n    assert candidate('item1') == ['i', 't', 'e', 'm', '1']\n    assert candidate('15.10') == ['1', '5', '.', '1', '0']\n\ndef test_check():\n    check(string_to_tuple)\n\ntest_check()\n", "sample_io": ["assert string_to_tuple('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']"], "source_codes": ["\nfrom typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n    return list(str1)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n    return list(str1)\n\n\n"], "prompt_tokens": [1935], "completion_tokens": [938], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_310_string_to_tuple"}
{"name": "mbpp_266_lateralsurface_cube", "language": "Python3", "prompt": "def lateralsurface_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cube", "test": "def check(candidate):\n    assert candidate(5) == 100\n    assert candidate(9) == 324\n    assert candidate(10) == 400\n\ndef test_check():\n    check(lateralsurface_cube)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cube(5) == 100"], "source_codes": ["\ndef lateralsurface_cube(l: int) -> int:\n    if l < 0:\n        raise ValueError(\"Side length cannot be negative\")\n    return 4 * l ** 2\n\n\n"], "responses": ["\ndef lateralsurface_cube(l: int) -> int:\n    if l < 0:\n        raise ValueError(\"Side length cannot be negative\")\n    return 4 * l ** 2\n\n\n"], "prompt_tokens": [1388], "completion_tokens": [841], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_266_lateralsurface_cube"}
{"name": "mbpp_271_even_Power_Sum", "language": "Python3", "prompt": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_Power_Sum", "test": "def check(candidate):\n    assert candidate(2) == 1056\n    assert candidate(3) == 8832\n    assert candidate(1) == 32\n\ndef test_check():\n    check(even_Power_Sum)\n\ntest_check()\n", "sample_io": ["assert even_Power_Sum(2) == 1056"], "source_codes": ["\ndef even_Power_Sum(n: int) -> int:\n    if n <= 0:\n        return 0\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    return total_sum\n\n\n"], "responses": ["\ndef even_Power_Sum(n: int) -> int:\n    if n <= 0:\n        return 0\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    return total_sum\n\n\n"], "prompt_tokens": [1937], "completion_tokens": [1071], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_271_even_Power_Sum"}
{"name": "mbpp_238_number_of_substrings", "language": "Python3", "prompt": "def number_of_substrings(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_of_substrings", "test": "def check(candidate):\n    assert candidate('abc') == 6\n    assert candidate('abcd') == 10\n    assert candidate('abcde') == 15\n\ndef test_check():\n    check(number_of_substrings)\n\ntest_check()\n", "sample_io": ["assert number_of_substrings('abc') == 6"], "source_codes": ["\ndef number_of_substrings(s: str) -> int:\n    if len(s) == 0:\n        return 0\n    n = len(s)\n    return n * (n + 1) // 2\n\n\n"], "responses": ["\ndef number_of_substrings(s: str) -> int:\n    if len(s) == 0:\n        return 0\n    n = len(s)\n    return n * (n + 1) // 2\n\n\n"], "prompt_tokens": [1262], "completion_tokens": [630], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_238_number_of_substrings"}
{"name": "mbpp_592_sum_Of_product", "language": "Python3", "prompt": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the product of consecutive binomial co-efficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_product", "test": "def check(candidate):\n    assert candidate(3) == 15\n    assert candidate(4) == 56\n    assert candidate(1) == 1\n\ndef test_check():\n    check(sum_Of_product)\n\ntest_check()\n", "sample_io": ["assert sum_Of_product(3) == 15"], "source_codes": ["\nfrom math import comb\n\ndef sum_Of_product(n: int) -> int:\n    if n <= 1:\n        return 0\n    total_sum = 0\n    for i in range(1, n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum\n\n\n"], "responses": ["\nfrom math import comb\n\ndef sum_Of_product(n: int) -> int:\n    if n <= 1:\n        return 0\n    total_sum = 0\n    for i in range(1, n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum\n\n\n"], "prompt_tokens": [2495], "completion_tokens": [931], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_592_sum_Of_product"}
{"name": "mbpp_74_is_samepatterns", "language": "Python3", "prompt": "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n\tWrite a function to check whether it follows the sequence given in the patterns array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_samepatterns", "test": "def check(candidate):\n    assert candidate(['red', 'green', 'green'], ['a', 'b', 'b']) == True\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b', 'b']) == False\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b']) == False\n\ndef test_check():\n    check(is_samepatterns)\n\ntest_check()\n", "sample_io": ["assert is_samepatterns(['red', 'green', 'green'], ['a', 'b', 'b']) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if not colors and not patterns:\n        return True\n    if len(colors) != len(patterns):\n        return False\n    \n    color_to_pattern = {}\n    \n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern and color_to_pattern[color] != pattern:\n            return False\n        color_to_pattern[color] = pattern\n    \n    return len(color_to_pattern.keys()) == len(set(color_to_pattern.values()))\n\n\n"], "responses": ["\nfrom typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    if not colors and not patterns:\n        return True\n    if len(colors) != len(patterns):\n        return False\n    \n    color_to_pattern = {}\n    \n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern and color_to_pattern[color] != pattern:\n            return False\n        color_to_pattern[color] = pattern\n    \n    return len(color_to_pattern.keys()) == len(set(color_to_pattern.values()))\n\n\n"], "prompt_tokens": [1428], "completion_tokens": [829], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_74_is_samepatterns"}
{"name": "mbpp_415_max_Product", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n\tWrite a python function to find a pair with highest product from a given array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    assert candidate([0, -1, -2, -4, 5, 0, -6]) == (-4, -6)\n    assert candidate([1, 2, 3]) == (2, 3)\n\ndef test_check():\n    check(max_Product)\n\ntest_check()\n", "sample_io": ["assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"], "source_codes": ["\nfrom typing import List, Tuple, Optional\n\ndef max_Product(arr: List[int]) -> Optional[Tuple[int, int]]:\n    n = len(arr)\n    if n < 2:\n        return None\n    \n    arr.sort()\n    \n    # The maximum product can be either from the two largest positive numbers\n    # or from the two most negative numbers (which could yield a large positive product)\n    max_product_1 = arr[-1] * arr[-2]\n    max_product_2 = arr[0] * arr[1]\n    \n    if max_product_1 > max_product_2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])\n\n\n"], "responses": ["\nfrom typing import List, Tuple, Optional\n\ndef max_Product(arr: List[int]) -> Optional[Tuple[int, int]]:\n    n = len(arr)\n    if n < 2:\n        return None\n    \n    arr.sort()\n    \n    # The maximum product can be either from the two largest positive numbers\n    # or from the two most negative numbers (which could yield a large positive product)\n    max_product_1 = arr[-1] * arr[-2]\n    max_product_2 = arr[0] * arr[1]\n    \n    if max_product_1 > max_product_2:\n        return (arr[-2], arr[-1])\n    else:\n        return (arr[0], arr[1])\n\n\n"], "prompt_tokens": [1821], "completion_tokens": [1084], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_415_max_Product"}
{"name": "mbpp_781_count_divisors", "language": "Python3", "prompt": "def count_divisors(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_divisors", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(100) == False\n    assert candidate(125) == True\n\ndef test_check():\n    check(count_divisors)\n\ntest_check()\n", "sample_io": ["assert count_divisors(10) == True"], "source_codes": ["\ndef count_divisors(n: int) -> bool:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisor_count += 1\n            else:\n                divisor_count += 2\n    \n    return divisor_count % 2 == 0\n\n\n"], "responses": ["\ndef count_divisors(n: int) -> bool:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisor_count += 1\n            else:\n                divisor_count += 2\n    \n    return divisor_count % 2 == 0\n\n\n"], "prompt_tokens": [2014], "completion_tokens": [1192], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_781_count_divisors"}
{"name": "mbpp_441_surfacearea_cube", "language": "Python3", "prompt": "def surfacearea_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the surface area of a cube of a given size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cube", "test": "def check(candidate):\n    assert candidate(5) == 150\n    assert candidate(3) == 54\n    assert candidate(10) == 600\n\ndef test_check():\n    check(surfacearea_cube)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cube(5) == 150"], "source_codes": ["\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Parameters:\n    l (int): The side length of the cube.\n\n    Returns:\n    int or None: The surface area of the cube if the side length is non-negative; otherwise, None.\n    \"\"\"\n    if l < 0:\n        return None\n    return 6 * l**2\n\n# Test cases\nassert surfacearea_cube(1) == 6, \"Test case 1 failed\"\nassert surfacearea_cube(0) == 0, \"Test case 2 failed\"\nassert surfacearea_cube(-1) is None, \"Test case 3 failed\"\nassert surfacearea_cube(10) == 600, \"Test case 4 failed\"\nassert surfacearea_cube(-10) is None, \"Test case 5 failed\"\n\n\n"], "responses": ["\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Calculate the surface area of a cube.\n\n    Parameters:\n    l (int): The side length of the cube.\n\n    Returns:\n    int or None: The surface area of the cube if the side length is non-negative; otherwise, None.\n    \"\"\"\n    if l < 0:\n        return None\n    return 6 * l**2\n\n# Test cases\nassert surfacearea_cube(1) == 6, \"Test case 1 failed\"\nassert surfacearea_cube(0) == 0, \"Test case 2 failed\"\nassert surfacearea_cube(-1) is None, \"Test case 3 failed\"\nassert surfacearea_cube(10) == 600, \"Test case 4 failed\"\nassert surfacearea_cube(-10) is None, \"Test case 5 failed\"\n\n\n"], "prompt_tokens": [1266], "completion_tokens": [695], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_441_surfacearea_cube"}
{"name": "mbpp_396_check_char", "language": "Python3", "prompt": "def check_char(string: str) -> str:\n    \"\"\"\n\tWrite a function to check whether the given string starts and ends with the same character or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_char", "test": "def check(candidate):\n    assert candidate('abba') == 'Valid'\n    assert candidate('a') == 'Valid'\n    assert candidate('abcd') == 'Invalid'\n\ndef test_check():\n    check(check_char)\n\ntest_check()\n", "sample_io": ["assert check_char('abba') == 'Valid'"], "source_codes": ["\npython\ndef check_char(string: str) -> str:\n    if len(string) == 0:\n        return \"False\"\n    elif len(string) == 1:\n        return \"True\"\n    else:\n        return \"True\" if string[0] == string[-1] else \"False\"\n\n\n"], "responses": ["\npython\ndef check_char(string: str) -> str:\n    if len(string) == 0:\n        return \"False\"\n    elif len(string) == 1:\n        return \"True\"\n    else:\n        return \"True\" if string[0] == string[-1] else \"False\"\n\n\n"], "prompt_tokens": [2406], "completion_tokens": [779], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_396_check_char"}
{"name": "mbpp_757_count_reverse_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n\tWrite a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_reverse_pairs", "test": "def check(candidate):\n    assert candidate(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2\n    assert candidate(['geeks', 'best', 'for', 'skeeg']) == 1\n    assert candidate(['makes', 'best', 'sekam', 'for', 'rof']) == 2\n\ndef test_check():\n    check(count_reverse_pairs)\n\ntest_check()\n", "sample_io": ["assert count_reverse_pairs(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2"], "source_codes": ["\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    reverse_pair_count = 0\n    n = len(test_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if test_list[i] == test_list[j][::-1]:\n                reverse_pair_count += 1\n                \n    return reverse_pair_count\n\n\n"], "responses": ["\nfrom typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    reverse_pair_count = 0\n    n = len(test_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if test_list[i] == test_list[j][::-1]:\n                reverse_pair_count += 1\n                \n    return reverse_pair_count\n\n\n"], "prompt_tokens": [1531], "completion_tokens": [718], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_757_count_reverse_pairs"}
{"name": "mbpp_75_find_tuples", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n\tWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_tuples", "test": "def check(candidate):\n    assert candidate([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    assert candidate([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]\n    assert candidate([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]\n\ndef test_check():\n    check(find_tuples)\n\ntest_check()\n", "sample_io": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"], "source_codes": ["\npython\nfrom typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    if K == 0:\n        return []\n    return [tup for tup in test_list if all(x % K == 0 for x in tup)]\n\n# Test cases\ntest_list1 = [(4, 8, 12), (5, 10, 15), (6, 12, 18)]\nK1 = 2\nassert find_tuples(test_list1, K1) == [(4, 8, 12), (6, 12, 18)], \"Test case 1 failed\"\n\ntest_list2 = [(3, 6, 9), (4, 8, 12), (5, 10, 15)]\nK2 = 0\nassert find_tuples(test_list2, K2) == [], \"Test case 2 failed\"\n\ntest_list3 = [(7, 14, 21), (8, 16, 24), (9, 18, 27)]\nK3 = 3\nassert find_tuples(test_list3, K3) == [(7, 14, 21), (9, 18, 27)], \"Test case 3 failed\"\n\ntest_list4 = []\nK4 = 5\nassert find_tuples(test_list4, K4) == [], \"Test case 4 failed\"\n\ntest_list5 = [(5, 10, 15), (25, 50, 75), (35, 70, 105)]\nK5 = 5\nassert find_tuples(test_list5, K5) == [(5, 10, 15), (25, 50, 75), (35, 70, 105)], \"Test case 5 failed\"\n\ntest_list6 = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nK6 = 2\nassert find_tuples(test_list6, K6) == [], \"Test case 6 failed\"\n\ntest_list7 = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nK7 = 6\nassert find_tuples(test_list7, K7) == [(6, 24, 12)], \"Test case 7 failed\"\n\n\n"], "responses": ["\npython\nfrom typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    if K == 0:\n        return []\n    return [tup for tup in test_list if all(x % K == 0 for x in tup)]\n\n# Test cases\ntest_list1 = [(4, 8, 12), (5, 10, 15), (6, 12, 18)]\nK1 = 2\nassert find_tuples(test_list1, K1) == [(4, 8, 12), (6, 12, 18)], \"Test case 1 failed\"\n\ntest_list2 = [(3, 6, 9), (4, 8, 12), (5, 10, 15)]\nK2 = 0\nassert find_tuples(test_list2, K2) == [], \"Test case 2 failed\"\n\ntest_list3 = [(7, 14, 21), (8, 16, 24), (9, 18, 27)]\nK3 = 3\nassert find_tuples(test_list3, K3) == [(7, 14, 21), (9, 18, 27)], \"Test case 3 failed\"\n\ntest_list4 = []\nK4 = 5\nassert find_tuples(test_list4, K4) == [], \"Test case 4 failed\"\n\ntest_list5 = [(5, 10, 15), (25, 50, 75), (35, 70, 105)]\nK5 = 5\nassert find_tuples(test_list5, K5) == [(5, 10, 15), (25, 50, 75), (35, 70, 105)], \"Test case 5 failed\"\n\ntest_list6 = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nK6 = 2\nassert find_tuples(test_list6, K6) == [], \"Test case 6 failed\"\n\ntest_list7 = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nK7 = 6\nassert find_tuples(test_list7, K7) == [(6, 24, 12)], \"Test case 7 failed\"\n\n\n"], "prompt_tokens": [5906], "completion_tokens": [3191], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_75_find_tuples"}
{"name": "mbpp_785_tuple_str_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function to convert tuple string to integer tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_str_int", "test": "def check(candidate):\n    assert candidate('(7, 8, 9)') == (7, 8, 9)\n    assert candidate('(1, 2, 3)') == (1, 2, 3)\n    assert candidate('(4, 5, 6)') == (4, 5, 6)\n    assert candidate('(7, 81, 19)') == (7, 81, 19)\n\ndef test_check():\n    check(tuple_str_int)\n\ntest_check()\n", "sample_io": ["assert tuple_str_int('(7, 8, 9)') == (7, 8, 9)"], "source_codes": ["\nfrom typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    # Remove leading/trailing whitespace and parentheses\n    test_str = test_str.strip().strip('()')\n    \n    # Split the string by commas\n    parts = test_str.split(',')\n    \n    # Initialize an empty list to store integer values\n    result = []\n    \n    # Iterate over each part and try converting it to an integer\n    for part in parts:\n        part = part.strip()\n        if part.isdigit():\n            result.append(int(part))\n        elif part.startswith('-') and part[1:].isdigit():\n            result.append(int(part))\n    \n    # Convert the list to a tuple and return\n    return tuple(result)\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    # Remove leading/trailing whitespace and parentheses\n    test_str = test_str.strip().strip('()')\n    \n    # Split the string by commas\n    parts = test_str.split(',')\n    \n    # Initialize an empty list to store integer values\n    result = []\n    \n    # Iterate over each part and try converting it to an integer\n    for part in parts:\n        part = part.strip()\n        if part.isdigit():\n            result.append(int(part))\n        elif part.startswith('-') and part[1:].isdigit():\n            result.append(int(part))\n    \n    # Convert the list to a tuple and return\n    return tuple(result)\n\n\n"], "prompt_tokens": [1340], "completion_tokens": [663], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_785_tuple_str_int"}
{"name": "mbpp_776_count_vowels", "language": "Python3", "prompt": "def count_vowels(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to count those characters which have vowels as their neighbors in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_vowels", "test": "def check(candidate):\n    assert candidate('bestinstareels') == 7\n    assert candidate('partofthejourneyistheend') == 12\n    assert candidate('amazonprime') == 5\n\ndef test_check():\n    check(count_vowels)\n\ntest_check()\n", "sample_io": ["assert count_vowels('bestinstareels') == 7"], "source_codes": ["\npython\ndef count_vowels(test_str: str) -> int:\n    vowels = 'aeiouAEIOU'\n    count = 0\n    n = len(test_str)\n    \n    for i in range(n):\n        if i == 0:\n            # Check if the first character has a vowel neighbor\n            if n > 1 and test_str[i] in vowels and test_str[i+1] in vowels:\n                count += 1\n        elif i == n - 1:\n            # Check if the last character has a vowel neighbor\n            if test_str[i-1] in vowels and test_str[i] in vowels:\n                count += 1\n        else:\n            # Check if the current character is a vowel and has vowel neighbors\n            if test_str[i] in vowels and (test_str[i-1] in vowels or test_str[i+1] in vowels):\n                count += 1\n                \n    return count\n\n\n"], "responses": ["\npython\ndef count_vowels(test_str: str) -> int:\n    vowels = 'aeiouAEIOU'\n    count = 0\n    n = len(test_str)\n    \n    for i in range(n):\n        if i == 0:\n            # Check if the first character has a vowel neighbor\n            if n > 1 and test_str[i] in vowels and test_str[i+1] in vowels:\n                count += 1\n        elif i == n - 1:\n            # Check if the last character has a vowel neighbor\n            if test_str[i-1] in vowels and test_str[i] in vowels:\n                count += 1\n        else:\n            # Check if the current character is a vowel and has vowel neighbors\n            if test_str[i] in vowels and (test_str[i-1] in vowels or test_str[i+1] in vowels):\n                count += 1\n                \n    return count\n\n\n"], "prompt_tokens": [2852], "completion_tokens": [1270], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_776_count_vowels"}
{"name": "mbpp_277_dict_filter", "language": "Python3", "prompt": "from typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n\tWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dict_filter", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 170) == { 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 180) == { 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 190) == { 'Pierre Cox': 190 }\n\ndef test_check():\n    check(dict_filter)\n\ntest_check()\n", "sample_io": ["assert dict_filter(3) == 27"], "source_codes": ["\npython3\nfrom typing import Dict\n\ndef dict_filter(input_dict: Dict[str, int], threshold: int) -> Dict[str, int]:\n    \"\"\"\n    Filters the input dictionary to include only entries with values greater than or equal to the threshold.\n\n    Parameters:\n    input_dict (Dict[str, int]): The dictionary to filter.\n    threshold (int): The minimum value to include in the output dictionary.\n\n    Returns:\n    Dict[str, int]: A new dictionary containing only the entries with values >= threshold.\n    \"\"\"\n    return {key: value for key, value in input_dict.items() if value >= threshold}\n\n\n"], "responses": ["\npython3\nfrom typing import Dict\n\ndef dict_filter(input_dict: Dict[str, int], threshold: int) -> Dict[str, int]:\n    \"\"\"\n    Filters the input dictionary to include only entries with values greater than or equal to the threshold.\n\n    Parameters:\n    input_dict (Dict[str, int]): The dictionary to filter.\n    threshold (int): The minimum value to include in the output dictionary.\n\n    Returns:\n    Dict[str, int]: A new dictionary containing only the entries with values >= threshold.\n    \"\"\"\n    return {key: value for key, value in input_dict.items() if value >= threshold}\n\n\n"], "prompt_tokens": [3217], "completion_tokens": [1141], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_277_dict_filter"}
{"name": "mbpp_468_max_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product", "test": "def check(candidate):\n    assert candidate([3, 100, 4, 5, 150, 6]) == 3000\n    assert candidate([4, 42, 55, 68, 80]) == 50265600\n    assert candidate([10, 22, 9, 33, 21, 50, 41, 60]) == 2460\n\ndef test_check():\n    check(max_product)\n\ntest_check()\n", "sample_io": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000"], "source_codes": ["\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [arr[i] for i in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    return max(max(dp), 0)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [arr[i] for i in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    return max(max(dp), 0)\n\n\n"], "prompt_tokens": [3691], "completion_tokens": [1327], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_468_max_product"}
{"name": "mbpp_279_is_num_decagonal", "language": "Python3", "prompt": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth decagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_num_decagonal", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(7) == 175\n    assert candidate(10) == 370\n\ndef test_check():\n    check(is_num_decagonal)\n\ntest_check()\n", "sample_io": ["assert is_num_decagonal(3) == 27"], "source_codes": ["\ndef is_num_decagonal(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"Invalid input. n should start from 1.\")\n    return 4 * n ** 2 - 3 * n\n\n\n"], "responses": ["\ndef is_num_decagonal(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"Invalid input. n should start from 1.\")\n    return 4 * n ** 2 - 3 * n\n\n\n"], "prompt_tokens": [1565], "completion_tokens": [837], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_279_is_num_decagonal"}
{"name": "mbpp_3_is_not_prime", "language": "Python3", "prompt": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to identify non-prime numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_not_prime", "test": "def check(candidate):\n    assert candidate(2) == False\n    assert candidate(10) == True\n    assert candidate(35) == True\n    assert candidate(37) == False\n\ndef test_check():\n    check(is_not_prime)\n\ntest_check()\n", "sample_io": ["assert is_not_prime(2) == False"], "source_codes": ["\nimport math\n\ndef is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False\n\n\n"], "responses": ["\nimport math\n\ndef is_not_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False\n\n\n"], "prompt_tokens": [1013], "completion_tokens": [781], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_3_is_not_prime"}
{"name": "mbpp_88_freq_count", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_88_freq_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "freq_count", "test": "def check(candidate):\n    assert candidate([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }\n    assert candidate([1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4]) == { 1: 3, 2: 2, 3: 3, 4: 3 }\n    assert candidate([5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5]) == { 10: 1, 5: 3, 6: 2, 7: 2, 4: 2, 9: 2 }\n\ndef test_check():\n    check(freq_count)\n\ntest_check()\n", "sample_io": ["assert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }"], "source_codes": ["\nfrom typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    freq_dict = {}\n    for item in list1:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n\n\n"], "responses": ["\nfrom typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    freq_dict = {}\n    for item in list1:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n\n\n"], "prompt_tokens": [1339], "completion_tokens": [606], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_88_freq_count"}
{"name": "mbpp_259_maximize_elements", "language": "Python3", "prompt": "from typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to maximize the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximize_elements", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[7, 8], [5, 10], [3, 10], [8, 11]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[8, 9], [6, 11], [4, 11], [9, 12]]\n\ndef test_check():\n    check(maximize_elements)\n\ntest_check()\n", "sample_io": ["assert maximize_elements([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]"], "source_codes": ["\nfrom typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Check if either of the lists is empty\n    if not test_tup1:\n        return test_tup2\n    if not test_tup2:\n        return test_tup1\n    \n    # Use list comprehension to perform element-wise maximization\n    result = [\n        [max(a, b) for a, b in zip(inner_list1, inner_list2)]\n        for inner_list1, inner_list2 in zip(test_tup1, test_tup2)\n    ]\n    \n    # Handle the case where the lists have different lengths\n    if len(test_tup1) > len(test_tup2):\n        result.extend(test_tup1[len(test_tup2):])\n    elif len(test_tup2) > len(test_tup1):\n        result.extend(test_tup2[len(test_tup1):])\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Check if either of the lists is empty\n    if not test_tup1:\n        return test_tup2\n    if not test_tup2:\n        return test_tup1\n    \n    # Use list comprehension to perform element-wise maximization\n    result = [\n        [max(a, b) for a, b in zip(inner_list1, inner_list2)]\n        for inner_list1, inner_list2 in zip(test_tup1, test_tup2)\n    ]\n    \n    # Handle the case where the lists have different lengths\n    if len(test_tup1) > len(test_tup2):\n        result.extend(test_tup1[len(test_tup2):])\n    elif len(test_tup2) > len(test_tup1):\n        result.extend(test_tup2[len(test_tup1):])\n    \n    return result\n\n\n"], "prompt_tokens": [1685], "completion_tokens": [933], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_259_maximize_elements"}
{"name": "mbpp_568_empty_list", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n\tWrite a function to create a list of N empty dictionaries.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "empty_list", "test": "def check(candidate):\n    assert candidate(5) == [{  }, {  }, {  }, {  }, {  }]\n    assert candidate(6) == [{  }, {  }, {  }, {  }, {  }, {  }]\n    assert candidate(7) == [{  }, {  }, {  }, {  }, {  }, {  }, {  }]\n\ndef test_check():\n    check(empty_list)\n\ntest_check()\n", "sample_io": ["assert empty_list(5) == [{  }, {  }, {  }, {  }, {  }]"], "source_codes": ["\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Parameters:\n    length (int): The number of empty dictionaries to generate.\n\n    Returns:\n    List[Dict[None, None]]: A list containing N empty dictionaries.\n\n    Raises:\n    ValueError: If the length is negative.\n    \"\"\"\n    if length < 0:\n        raise ValueError(\"Length cannot be negative\")\n    \n    return [{}] * length\n\n\n"], "responses": ["\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Parameters:\n    length (int): The number of empty dictionaries to generate.\n\n    Returns:\n    List[Dict[None, None]]: A list containing N empty dictionaries.\n\n    Raises:\n    ValueError: If the length is negative.\n    \"\"\"\n    if length < 0:\n        raise ValueError(\"Length cannot be negative\")\n    \n    return [{}] * length\n\n\n"], "prompt_tokens": [1524], "completion_tokens": [824], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_568_empty_list"}
{"name": "mbpp_285_text_match_two_three", "language": "Python3", "prompt": "def text_match_two_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_two_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n\ndef test_check():\n    check(text_match_two_three)\n\ntest_check()\n", "sample_io": ["assert text_match_two_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1611], "completion_tokens": [887], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_285_text_match_two_three"}
{"name": "mbpp_721_maxAverageOfPath", "language": "Python3", "prompt": "from typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maxAverageOfPath", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n    assert candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2\n    assert candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8\n\ndef test_check():\n    check(maxAverageOfPath)\n\ntest_check()\n", "sample_io": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"], "source_codes": ["\npython3\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    if not cost or not cost[0]:\n        return -1\n    \n    n = len(cost)\n    dp = [[float('-inf')] * n for _ in range(n)]\n    \n    def dfs(x, y):\n        if x == 0 and y == 0:\n            return cost[0][0]\n        if x < 0 or y < 0:\n            return float('-inf')\n        if dp[x][y] != float('-inf'):\n            return dp[x][y]\n        \n        left = dfs(x, y - 1)\n        up = dfs(x - 1, y)\n        dp[x][y] = max(left, up) + cost[x][y]\n        return dp[x][y]\n    \n    total_cost = dfs(n - 1, n - 1)\n    num_cells = n * n\n    return total_cost / num_cells\n\n\n"], "responses": ["\npython3\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    if not cost or not cost[0]:\n        return -1\n    \n    n = len(cost)\n    dp = [[float('-inf')] * n for _ in range(n)]\n    \n    def dfs(x, y):\n        if x == 0 and y == 0:\n            return cost[0][0]\n        if x < 0 or y < 0:\n            return float('-inf')\n        if dp[x][y] != float('-inf'):\n            return dp[x][y]\n        \n        left = dfs(x, y - 1)\n        up = dfs(x - 1, y)\n        dp[x][y] = max(left, up) + cost[x][y]\n        return dp[x][y]\n    \n    total_cost = dfs(n - 1, n - 1)\n    num_cells = n * n\n    return total_cost / num_cells\n\n\n"], "prompt_tokens": [5508], "completion_tokens": [2179], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_721_maxAverageOfPath"}
{"name": "mbpp_797_sum_in_range", "language": "Python3", "prompt": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd natural numbers within the range l and r.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_in_range", "test": "def check(candidate):\n    assert candidate(2, 5) == 8\n    assert candidate(5, 7) == 12\n    assert candidate(7, 13) == 40\n\ndef test_check():\n    check(sum_in_range)\n\ntest_check()\n", "sample_io": ["assert sum_in_range(2, 5) == 8"], "source_codes": ["\ndef sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        raise ValueError(\"Lower bound cannot be greater than upper bound\")\n    \n    total_sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            total_sum += num\n    \n    return total_sum\n\n\n"], "responses": ["\ndef sum_in_range(l: int, r: int) -> int:\n    if l > r:\n        raise ValueError(\"Lower bound cannot be greater than upper bound\")\n    \n    total_sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            total_sum += num\n    \n    return total_sum\n\n\n"], "prompt_tokens": [1634], "completion_tokens": [931], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_797_sum_in_range"}
{"name": "mbpp_4_heap_queue_largest", "language": "Python3", "prompt": "from typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_queue_largest", "test": "def check(candidate):\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n\ndef test_check():\n    check(heap_queue_largest)\n\ntest_check()\n", "sample_io": ["assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"], "source_codes": ["\nimport heapq\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    if not nums or n <= 0:\n        return []\n    \n    # Use a max-heap by pushing negative values\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    \n    # Extract the n largest elements\n    result = [-heapq.heappop(max_heap) for _ in range(min(n, len(max_heap)))]\n    \n    return result\n\n\n"], "responses": ["\nimport heapq\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    if not nums or n <= 0:\n        return []\n    \n    # Use a max-heap by pushing negative values\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    \n    # Extract the n largest elements\n    result = [-heapq.heappop(max_heap) for _ in range(min(n, len(max_heap)))]\n    \n    return result\n\n\n"], "prompt_tokens": [2481], "completion_tokens": [931], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_4_heap_queue_largest"}
{"name": "mbpp_120_max_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 200\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 484\n\ndef test_check():\n    check(max_product_tuple)\n\ntest_check()\n", "sample_io": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tup in list1:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n            \n    return max_product\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tup in list1:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n            \n    return max_product\n\n\n"], "prompt_tokens": [1459], "completion_tokens": [795], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_120_max_product_tuple"}
