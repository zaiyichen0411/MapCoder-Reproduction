{"name": "mbpp_230_replace_blank", "language": "Python3", "prompt": "def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n\tWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_blank", "test": "def check(candidate):\n    assert candidate('hello people', '@') == 'hello@people'\n    assert candidate('python program language', '$') == 'python$program$language'\n    assert candidate('blank space', '-') == 'blank-space'\n\ndef test_check():\n    check(replace_blank)\n\ntest_check()\n", "sample_io": ["assert replace_blank('hello people', '@') == 'hello@people'"], "source_codes": ["\ndef replace_blank(str1: str, char: str) -> str:\n    result = []\n    for ch in str1:\n        if ch == ' ':\n            result.append(char)\n        else:\n            result.append(ch)\n    return ''.join(result)\n\n\n"], "responses": ["\ndef replace_blank(str1: str, char: str) -> str:\n    result = []\n    for ch in str1:\n        if ch == ' ':\n            result.append(char)\n        else:\n            result.append(ch)\n    return ''.join(result)\n\n\n"], "prompt_tokens": [1103], "completion_tokens": [472], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_230_replace_blank"}
{"name": "mbpp_600_is_Even", "language": "Python3", "prompt": "def is_Even(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Even", "test": "def check(candidate):\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(3) == False\n\ndef test_check():\n    check(is_Even)\n\ntest_check()\n", "sample_io": ["assert is_Even(1) == False"], "source_codes": ["\ndef is_Even(n: int) -> bool:\n    return n % 2 == 0\n\n\n"], "responses": ["\ndef is_Even(n: int) -> bool:\n    return n % 2 == 0\n\n\n"], "prompt_tokens": [1363], "completion_tokens": [703], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_600_is_Even"}
{"name": "mbpp_440_find_adverb_position", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n\tWrite a function to find the first adverb and their positions in a given sentence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverb_position", "test": "def check(candidate):\n    assert candidate('clearly!! we can see the sky') == (0, 7, 'clearly')\n    assert candidate('seriously!! there are many roses') == (0, 9, 'seriously')\n    assert candidate('unfortunately!! sita is going to home') == (0, 13, 'unfortunately')\n\ndef test_check():\n    check(find_adverb_position)\n\ntest_check()\n", "sample_io": ["assert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')"], "source_codes": ["\npython\nimport re\nimport nltk\nfrom nltk.tokenize import word_tokenize\nfrom nltk.tag import pos_tag\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    # Download necessary NLTK data if not already downloaded\n    nltk.download('punkt', quiet=True)\n    nltk.download('averaged_perceptron_tagger', quiet=True)\n\n    # Tokenize the text\n    tokens = word_tokenize(text)\n\n    # Find the first adverb and its index\n    for i, (word, tag) in enumerate(pos_tag(tokens)):\n        if tag.startswith('RB'):\n            # Adjust the start and end indices to account for punctuation\n            start_index = text.index(word)\n            end_index = start_index + len(word)\n            return (start_index, end_index, word)\n\n    # If no adverb is found, return (-1, -1, '')\n    return (-1, -1, '')\n\n# Test cases\nprint(find_adverb_position(\"He quickly runs to the store.\"))  # Expected Output: (0, 7, 'quickly')\nprint(find_adverb_position(\"She smiled widely and happily.\"))  # Expected Output: (4, 10, 'widely')\nprint(find_adverb_position(\"He quietly entered the room.\"))  # Expected Output: (5, 12, 'quietly')\nprint(find_adverb_position(\"The dog barked loudly at the stranger.\"))  # Expected Output: (6, 12, 'loudly')\nprint(find_adverb_position(\"It was raining heavily when she left.\"))  # Expected Output: (8, 14, 'heavily')\nprint(find_adverb_position(\"They walked silently down the street.\"))  # Expected Output: (7, 13, 'silently')\nprint(find_adverb_position(\"The sky is blue today.\"))  # Expected Output: (-1, -1, '')\nprint(find_adverb_position(\"Surprisingly, she found it easy.\"))  # Expected Output: (0, 13, 'Surprisingly')\nprint(find_adverb_position(\"Happily ever after.\"))  # Expected Output: (0, 7, 'Happily')\nprint(find_adverb_position(\"Quietly and calmly.\"))  # Expected Output: (0, 7, 'Quietly')\n\n# Fix for the failed test case\nassert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')\n\n\n"], "responses": ["\npython\nimport re\nimport nltk\nfrom nltk.tokenize import word_tokenize\nfrom nltk.tag import pos_tag\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    # Download necessary NLTK data if not already downloaded\n    nltk.download('punkt', quiet=True)\n    nltk.download('averaged_perceptron_tagger', quiet=True)\n\n    # Tokenize the text\n    tokens = word_tokenize(text)\n\n    # Find the first adverb and its index\n    for i, (word, tag) in enumerate(pos_tag(tokens)):\n        if tag.startswith('RB'):\n            # Adjust the start and end indices to account for punctuation\n            start_index = text.index(word)\n            end_index = start_index + len(word)\n            return (start_index, end_index, word)\n\n    # If no adverb is found, return (-1, -1, '')\n    return (-1, -1, '')\n\n# Test cases\nprint(find_adverb_position(\"He quickly runs to the store.\"))  # Expected Output: (0, 7, 'quickly')\nprint(find_adverb_position(\"She smiled widely and happily.\"))  # Expected Output: (4, 10, 'widely')\nprint(find_adverb_position(\"He quietly entered the room.\"))  # Expected Output: (5, 12, 'quietly')\nprint(find_adverb_position(\"The dog barked loudly at the stranger.\"))  # Expected Output: (6, 12, 'loudly')\nprint(find_adverb_position(\"It was raining heavily when she left.\"))  # Expected Output: (8, 14, 'heavily')\nprint(find_adverb_position(\"They walked silently down the street.\"))  # Expected Output: (7, 13, 'silently')\nprint(find_adverb_position(\"The sky is blue today.\"))  # Expected Output: (-1, -1, '')\nprint(find_adverb_position(\"Surprisingly, she found it easy.\"))  # Expected Output: (0, 13, 'Surprisingly')\nprint(find_adverb_position(\"Happily ever after.\"))  # Expected Output: (0, 7, 'Happily')\nprint(find_adverb_position(\"Quietly and calmly.\"))  # Expected Output: (0, 7, 'Quietly')\n\n# Fix for the failed test case\nassert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')\n\n\n"], "prompt_tokens": [4575], "completion_tokens": [2662], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_440_find_adverb_position"}
{"name": "mbpp_773_occurance_substring", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "occurance_substring", "test": "def check(candidate):\n    assert candidate('python programming, python language', 'python') == ('python', 0, 6)\n    assert candidate('python programming,programming language', 'programming') == ('programming', 7, 18)\n    assert candidate('python programming,programming language', 'language') == ('language', 31, 39)\n    assert candidate('c++ programming, c++ language', 'python') == None\n\ndef test_check():\n    check(occurance_substring)\n\ntest_check()\n", "sample_io": ["assert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"], "source_codes": ["\nfrom typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n    if not pattern:\n        return (text, 0, len(text))\n    \n    n = len(text)\n    m = len(pattern)\n    lps = [0] * m\n    j = 0\n    \n    # Preprocess the pattern\n    i = 1\n    while i < m:\n        if pattern[i] == pattern[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    \n    # Search for the pattern in the text\n    i = 0\n    while i < n:\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        \n        if j == m:\n            return (pattern, i - j, i)\n        \n        if i < n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    return None\n\n\n"], "responses": ["\nfrom typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n    if not pattern:\n        return (text, 0, len(text))\n    \n    n = len(text)\n    m = len(pattern)\n    lps = [0] * m\n    j = 0\n    \n    # Preprocess the pattern\n    i = 1\n    while i < m:\n        if pattern[i] == pattern[j]:\n            j += 1\n            lps[i] = j\n            i += 1\n        else:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    \n    # Search for the pattern in the text\n    i = 0\n    while i < n:\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        \n        if j == m:\n            return (pattern, i - j, i)\n        \n        if i < n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    \n    return None\n\n\n"], "prompt_tokens": [1913], "completion_tokens": [1403], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_773_occurance_substring"}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "Python3", "prompt": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_total_number_of_sequences", "test": "def check(candidate):\n    assert candidate(10, 4) == 4\n    assert candidate(5, 2) == 6\n    assert candidate(16, 3) == 84\n\ndef test_check():\n    check(get_total_number_of_sequences)\n\ntest_check()\n", "sample_io": ["assert get_total_number_of_sequences(10, 4) == 4"], "source_codes": ["\npython\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if m < n:\n        return 0\n    \n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    for j in range(2, n + 1):\n        for i in range(j, m + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    return sum(dp[i][n] for i in range(n, m + 1))\n\n\n"], "responses": ["\npython\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if m < n:\n        return 0\n    \n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    for j in range(2, n + 1):\n        for i in range(j, m + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    return sum(dp[i][n] for i in range(n, m + 1))\n\n\n"], "prompt_tokens": [4916], "completion_tokens": [1861], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_239_get_total_number_of_sequences"}
{"name": "mbpp_265_list_split", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_split", "test": "def check(candidate):\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]]\n    assert candidate(['python', 'java', 'C', 'C++', 'DBMS', 'SQL'], 2) == [['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]\n\ndef test_check():\n    check(list_split)\n\ntest_check()\n", "sample_io": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"], "source_codes": ["\nfrom typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError(\"Step size must be greater than 0\")\n    \n    result = []\n    for i in range(step):\n        result.append(S[i::step])\n    \n    return result\n\n\n"], "responses": ["\nfrom typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if step <= 0:\n        raise ValueError(\"Step size must be greater than 0\")\n    \n    result = []\n    for i in range(step):\n        result.append(S[i::step])\n    \n    return result\n\n\n"], "prompt_tokens": [2271], "completion_tokens": [817], "no_of_try": 1, "api_calls": 5, "is_solved": true, "task_id": "mbpp_265_list_split"}
{"name": "mbpp_412_remove_odd", "language": "Python3", "prompt": "from typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove odd numbers from a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [2]\n    assert candidate([2, 4, 6]) == [2, 4, 6]\n    assert candidate([10, 20, 3]) == [10, 20]\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd([1, 2, 3]) == [2]"], "source_codes": ["\nfrom typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    return [num for num in l if num % 2 == 0]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    return [num for num in l if num % 2 == 0]\n\n\n"], "prompt_tokens": [1607], "completion_tokens": [805], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_412_remove_odd"}
{"name": "mbpp_414_overlapping", "language": "Python3", "prompt": "from typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "overlapping", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False\n    assert candidate([1, 2, 3], [4, 5, 6]) == False\n    assert candidate([1, 4, 5], [1, 4, 5]) == True\n\ndef test_check():\n    check(overlapping)\n\ntest_check()\n", "sample_io": ["assert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"], "source_codes": ["\nfrom typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    intersection = set1.intersection(set2)\n    return len(intersection) > 0\n\n\n"], "responses": ["\nfrom typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    intersection = set1.intersection(set2)\n    return len(intersection) > 0\n\n\n"], "prompt_tokens": [1840], "completion_tokens": [952], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_414_overlapping"}
{"name": "mbpp_160_find_solution", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_solution", "test": "def check(candidate):\n    assert candidate(2, 3, 7) == (2, 1)\n    assert candidate(4, 2, 7) == None\n    assert candidate(1, 13, 17) == (4, 1)\n\ndef test_check():\n    check(find_solution)\n\ntest_check()\n", "sample_io": ["assert find_solution(2, 3, 7) == (2, 1)"], "source_codes": ["\npython3\nfrom typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    if n % gcd(a, b) != 0:\n        return None\n\n    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n        if a == 0:\n            return b, 0, 1\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return g, y - (b // a) * x, x\n\n    g, x0, y0 = extended_gcd(a, b)\n    x0 //= g\n    y0 //= g\n\n    # Ensure x and y are non-negative\n    k = 0\n    while True:\n        x = x0 + k * b // g\n        y = y0 - k * a // g\n        if x >= 0 and y >= 0:\n            return (x, y)\n        k += 1\n\n\n"], "responses": ["\npython3\nfrom typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    if n % gcd(a, b) != 0:\n        return None\n\n    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n        if a == 0:\n            return b, 0, 1\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return g, y - (b // a) * x, x\n\n    g, x0, y0 = extended_gcd(a, b)\n    x0 //= g\n    y0 //= g\n\n    # Ensure x and y are non-negative\n    k = 0\n    while True:\n        x = x0 + k * b // g\n        y = y0 - k * a // g\n        if x >= 0 and y >= 0:\n            return (x, y)\n        k += 1\n\n\n"], "prompt_tokens": [3731], "completion_tokens": [1581], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_160_find_solution"}
{"name": "mbpp_559_max_sub_array_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of the largest contiguous sublist in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum", "test": "def check(candidate):\n    assert candidate([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    assert candidate([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8\n    assert candidate([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10\n\ndef test_check():\n    check(max_sub_array_sum)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"], "source_codes": ["\nfrom typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return 0\n    \n    max_so_far = float('-inf')\n    max_ending_here = 0\n    \n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n            \n    return max_so_far\n\n\n"], "responses": ["\nfrom typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return 0\n    \n    max_so_far = float('-inf')\n    max_ending_here = 0\n    \n    for i in range(size):\n        max_ending_here += a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n            \n    return max_so_far\n\n\n"], "prompt_tokens": [1565], "completion_tokens": [809], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_559_max_sub_array_sum"}
{"name": "mbpp_809_check_smaller", "language": "Python3", "prompt": "from typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n\tWrite a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_smaller", "test": "def check(candidate):\n    assert candidate((1, 2, 3), (2, 3, 4)) == False\n    assert candidate((4, 5, 6), (3, 4, 5)) == True\n    assert candidate((11, 12, 13), (10, 11, 12)) == True\n\ndef test_check():\n    check(check_smaller)\n\ntest_check()\n", "sample_io": ["assert check_smaller((1, 2, 3), (2, 3, 4)) == False"], "source_codes": ["\nfrom typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    return all(x < y for x, y in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    return all(x < y for x, y in zip(test_tup1, test_tup2))\n\n\n"], "prompt_tokens": [3719], "completion_tokens": [1424], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_809_check_smaller"}
{"name": "mbpp_629_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to find even numbers from a list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [2, 4]\n    assert candidate([4, 5, 6, 7, 8, 0, 1]) == [4, 6, 8, 0]\n    assert candidate([8, 12, 15, 19]) == [8, 12]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5]) == [2, 4]"], "source_codes": ["\nfrom typing import List\n\ndef Split(numbers: List[int]) -> List[int]:\n    return [num for num in numbers if num % 2 == 0]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef Split(numbers: List[int]) -> List[int]:\n    return [num for num in numbers if num % 2 == 0]\n\n\n"], "prompt_tokens": [1374], "completion_tokens": [670], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_629_Split"}
{"name": "mbpp_723_count_same_pair", "language": "Python3", "prompt": "from typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n\tThe input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_same_pair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 11\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 1\n    assert candidate([0, 1, 1, 2], [0, 1, 2, 2]) == 3\n\ndef test_check():\n    check(count_same_pair)\n\ntest_check()\n", "sample_io": ["assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    return sum(1 for a, b in zip(nums1, nums2) if a == b)\n\n\n"], "responses": ["\nfrom typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    return sum(1 for a, b in zip(nums1, nums2) if a == b)\n\n\n"], "prompt_tokens": [1920], "completion_tokens": [982], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_723_count_same_pair"}
{"name": "mbpp_242_count_charac", "language": "Python3", "prompt": "def count_charac(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the total number of characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_charac", "test": "def check(candidate):\n    assert candidate('python programming') == 18\n    assert candidate('language') == 8\n    assert candidate('words') == 5\n\ndef test_check():\n    check(count_charac)\n\ntest_check()\n", "sample_io": ["assert count_charac('python programming') == 18"], "source_codes": ["\ndef count_charac(str1: str) -> int:\n    count = 0\n    for char in str1:\n        count += 1\n    return count\n\n\n"], "responses": ["\ndef count_charac(str1: str) -> int:\n    count = 0\n    for char in str1:\n        count += 1\n    return count\n\n\n"], "prompt_tokens": [1728], "completion_tokens": [821], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_242_count_charac"}
{"name": "mbpp_616_tuple_modulo", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function which takes two tuples of the same length and performs the element wise modulo.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_modulo", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n    assert candidate((11, 5, 6, 7), (6, 7, 8, 6)) == (5, 5, 6, 1)\n    assert candidate((12, 6, 7, 8), (7, 8, 9, 7)) == (5, 6, 7, 1)\n\ndef test_check():\n    check(tuple_modulo)\n\ntest_check()\n", "sample_io": ["assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)"], "source_codes": ["\nfrom typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    if not test_tup1 or not test_tup2:\n        return ()\n    \n    result = []\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        result.append(elem1 % elem2)\n    \n    return tuple(result)\n\n\n"], "responses": ["\nfrom typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    if not test_tup1 or not test_tup2:\n        return ()\n    \n    result = []\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        result.append(elem1 % elem2)\n    \n    return tuple(result)\n\n\n"], "prompt_tokens": [1875], "completion_tokens": [958], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_616_tuple_modulo"}
{"name": "mbpp_583_catalan_number", "language": "Python3", "prompt": "def catalan_number(num: int) -> int:\n    \"\"\"\n\tWrite a function which returns nth catalan number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "catalan_number", "test": "def check(candidate):\n    assert candidate(10) == 16796\n    assert candidate(9) == 4862\n    assert candidate(7) == 429\n\ndef test_check():\n    check(catalan_number)\n\ntest_check()\n", "sample_io": ["assert catalan_number(10) == 16796"], "source_codes": ["\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        return -1\n    elif num <= 1:\n        return 1\n    \n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        catalan[i] = sum(catalan[j] * catalan[i-j-1] for j in range(i))\n    \n    return catalan[num]\n\n\n"], "responses": ["\ndef catalan_number(num: int) -> int:\n    if num < 0:\n        return -1\n    elif num <= 1:\n        return 1\n    \n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        catalan[i] = sum(catalan[j] * catalan[i-j-1] for j in range(i))\n    \n    return catalan[num]\n\n\n"], "prompt_tokens": [1670], "completion_tokens": [1104], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_583_catalan_number"}
{"name": "mbpp_129_magic_square_test", "language": "Python3", "prompt": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to calculate whether the matrix is a magic square.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "magic_square_test", "test": "def check(candidate):\n    assert candidate([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n\ndef test_check():\n    check(magic_square_test)\n\ntest_check()\n", "sample_io": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True"], "source_codes": ["\nfrom typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any(len(row) != n for row in my_matrix):\n        return False\n    \n    if len(set(sum(row) for row in my_matrix)) != 1:\n        return False\n    \n    ref_sum = sum(my_matrix[0])\n    \n    if any(sum(my_matrix[i][j] for i in range(n)) != ref_sum for j in range(n)):\n        return False\n    \n    if any(sum(my_matrix[i][i] for i in range(n)) != ref_sum for _ in range(2)):\n        return False\n    \n    if any(sum(my_matrix[i][n-1-i] for i in range(n)) != ref_sum for _ in range(2)):\n        return False\n    \n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    n = len(my_matrix)\n    if any(len(row) != n for row in my_matrix):\n        return False\n    \n    if len(set(sum(row) for row in my_matrix)) != 1:\n        return False\n    \n    ref_sum = sum(my_matrix[0])\n    \n    if any(sum(my_matrix[i][j] for i in range(n)) != ref_sum for j in range(n)):\n        return False\n    \n    if any(sum(my_matrix[i][i] for i in range(n)) != ref_sum for _ in range(2)):\n        return False\n    \n    if any(sum(my_matrix[i][n-1-i] for i in range(n)) != ref_sum for _ in range(2)):\n        return False\n    \n    return True\n\n\n"], "prompt_tokens": [1881], "completion_tokens": [1105], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_129_magic_square_test"}
{"name": "mbpp_61_count_Substrings", "language": "Python3", "prompt": "def count_Substrings(s: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Substrings", "test": "def check(candidate):\n    assert candidate('112112') == 6\n    assert candidate('111') == 6\n    assert candidate('1101112') == 12\n\ndef test_check():\n    check(count_Substrings)\n\ntest_check()\n", "sample_io": ["assert count_Substrings('112112') == 6"], "source_codes": ["\ndef count_Substrings(s: str) -> int:\n    count = 0\n    prefix_sum = 0\n    prefix_freq = {0: 1}\n    \n    for i, char in enumerate(s):\n        prefix_sum += int(char)\n        target_sum = prefix_sum - (i + 1)\n        \n        if target_sum in prefix_freq:\n            count += prefix_freq[target_sum]\n        \n        prefix_freq[prefix_sum] = prefix_freq.get(prefix_sum, 0) + 1\n    \n    return count\n\n\n"], "responses": ["\ndef count_Substrings(s: str) -> int:\n    count = 0\n    prefix_sum = 0\n    prefix_freq = {0: 1}\n    \n    for i, char in enumerate(s):\n        prefix_sum += int(char)\n        target_sum = prefix_sum - (i + 1)\n        \n        if target_sum in prefix_freq:\n            count += prefix_freq[target_sum]\n        \n        prefix_freq[prefix_sum] = prefix_freq.get(prefix_sum, 0) + 1\n    \n    return count\n\n\n"], "prompt_tokens": [3276], "completion_tokens": [1250], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_61_count_Substrings"}
{"name": "mbpp_287_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 20\n    assert candidate(3) == 56\n    assert candidate(4) == 120\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 20"], "source_codes": ["\npython\ndef square_Sum(n: int) -> int:\n    if n <= 0:\n        return 0\n    return 2 * n * (n + 1) * (2 * n + 1) // 3\n\n\n"], "responses": ["\npython\ndef square_Sum(n: int) -> int:\n    if n <= 0:\n        return 0\n    return 2 * n * (n + 1) * (2 * n + 1) // 3\n\n\n"], "prompt_tokens": [2255], "completion_tokens": [758], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_287_square_Sum"}
{"name": "mbpp_93_power", "language": "Python3", "prompt": "def power(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the value of 'a' to the power 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power", "test": "def check(candidate):\n    assert candidate(3, 4) == 81\n    assert candidate(2, 3) == 8\n    assert candidate(5, 5) == 3125\n\ndef test_check():\n    check(power)\n\ntest_check()\n", "sample_io": ["assert power(3, 4) == 81"], "source_codes": ["\ndef power(a: int, b: int) -> int:\n    if b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    elif b < 0:\n        a = 1 / a\n        b = -b\n    \n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result *= a\n        a *= a\n        b //= 2\n    return result\n\n\n"], "responses": ["\ndef power(a: int, b: int) -> int:\n    if b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    elif b < 0:\n        a = 1 / a\n        b = -b\n    \n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result *= a\n        a *= a\n        b //= 2\n    return result\n\n\n"], "prompt_tokens": [1217], "completion_tokens": [739], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_93_power"}
{"name": "mbpp_607_find_literals", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n\tWrite a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_literals", "test": "def check(candidate):\n    assert candidate('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    assert candidate('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)\n    assert candidate('Hardest choices required strongest will', 'will') == ('will', 35, 39)\n\ndef test_check():\n    check(find_literals)\n\ntest_check()\n", "sample_io": ["assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"], "source_codes": ["\nimport re\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    if not pattern:\n        raise ValueError(\"Pattern cannot be empty\")\n    \n    matches = list(re.finditer(pattern, text))\n    if not matches:\n        return None\n    \n    first_match = matches[0]\n    return first_match.group(0), first_match.start(), first_match.end()\n\n\n"], "responses": ["\nimport re\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    if not pattern:\n        raise ValueError(\"Pattern cannot be empty\")\n    \n    matches = list(re.finditer(pattern, text))\n    if not matches:\n        return None\n    \n    first_match = matches[0]\n    return first_match.group(0), first_match.start(), first_match.end()\n\n\n"], "prompt_tokens": [1658], "completion_tokens": [1348], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_607_find_literals"}
{"name": "mbpp_94_index_minimum", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n\tGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_minimum", "test": "def check(candidate):\n    assert candidate([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    assert candidate([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'\n    assert candidate([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'\n\ndef test_check():\n    check(index_minimum)\n\ntest_check()\n", "sample_io": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    if not test_list:\n        raise ValueError(\"Cannot find minimum in an empty list\")\n    \n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[0][0]\n\n\n"], "responses": ["\nfrom typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    if not test_list:\n        raise ValueError(\"Cannot find minimum in an empty list\")\n    \n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[0][0]\n\n\n"], "prompt_tokens": [1590], "completion_tokens": [721], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_94_index_minimum"}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "Python3", "prompt": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sum_Of_Powers_Of_Two", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(7) == False\n    assert candidate(14) == True\n\ndef test_check():\n    check(is_Sum_Of_Powers_Of_Two)\n\ntest_check()\n", "sample_io": ["assert is_Sum_Of_Powers_Of_Two(10) == True"], "source_codes": ["\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # Handle edge case for 0\n    if n <= 0:\n        return False\n    # Check if n is a power of two by using the bitwise trick\n    return (n & (n - 1)) == 0\n\n\n"], "responses": ["\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # Handle edge case for 0\n    if n <= 0:\n        return False\n    # Check if n is a power of two by using the bitwise trick\n    return (n & (n - 1)) == 0\n\n\n"], "prompt_tokens": [2764], "completion_tokens": [1153], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_138_is_Sum_Of_Powers_Of_Two"}
{"name": "mbpp_594_diff_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the difference of the first even and first odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "diff_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n    assert candidate([1, 5, 7, 9, 10]) == 9\n\ndef test_check():\n    check(diff_even_odd)\n\ntest_check()\n", "sample_io": ["assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"], "source_codes": ["\nfrom typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return first_even - first_odd\n\n\n"], "responses": ["\nfrom typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return first_even - first_odd\n\n\n"], "prompt_tokens": [1468], "completion_tokens": [827], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_594_diff_even_odd"}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "Python3", "prompt": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_binomial_Coeff_Sum", "test": "def check(candidate):\n    assert candidate(4) == 8\n    assert candidate(6) == 32\n    assert candidate(2) == 2\n\ndef test_check():\n    check(even_binomial_Coeff_Sum)\n\ntest_check()\n", "sample_io": ["assert even_binomial_Coeff_Sum(4) == 8"], "source_codes": ["\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    return 2 ** (n - 1)\n\n\n"], "responses": ["\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    return 2 ** (n - 1)\n\n\n"], "prompt_tokens": [1923], "completion_tokens": [1373], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_274_even_binomial_Coeff_Sum"}
{"name": "mbpp_126_sum", "language": "Python3", "prompt": "def sum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of common divisors of two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum", "test": "def check(candidate):\n    assert candidate(10, 15) == 6\n    assert candidate(100, 150) == 93\n    assert candidate(4, 6) == 3\n\ndef test_check():\n    check(sum)\n\ntest_check()\n", "sample_io": ["assert sum(10, 15) == 6"], "source_codes": ["\ndef sum_common_divisors(a: int, b: int) -> int:\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n    \n    if a == 0 or b == 0:\n        return 0\n    \n    common_divisors_sum = 0\n    for i in range(1, min(abs(a), abs(b)) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors_sum += i\n    \n    return common_divisors_sum\n\n# Test cases\nassert sum_common_divisors(12, 18) == 9, \"Test Case 1 Failed\"\nassert sum_common_divisors(5, 7) == 1, \"Test Case 2 Failed\"\nassert sum_common_divisors(0, 5) == 0, \"Test Case 3 Failed\"\nassert sum_common_divisors(10, 10) == 18, \"Test Case 4 Failed\"\nassert sum_common_divisors(-12, -18) == 9, \"Test Case 5 Failed\"\nassert sum_common_divisors(10, 15) == 6, \"Test Case 6 Failed\"\n\n\n"], "responses": ["\ndef sum_common_divisors(a: int, b: int) -> int:\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n    \n    if a == 0 or b == 0:\n        return 0\n    \n    common_divisors_sum = 0\n    for i in range(1, min(abs(a), abs(b)) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors_sum += i\n    \n    return common_divisors_sum\n\n# Test cases\nassert sum_common_divisors(12, 18) == 9, \"Test Case 1 Failed\"\nassert sum_common_divisors(5, 7) == 1, \"Test Case 2 Failed\"\nassert sum_common_divisors(0, 5) == 0, \"Test Case 3 Failed\"\nassert sum_common_divisors(10, 10) == 18, \"Test Case 4 Failed\"\nassert sum_common_divisors(-12, -18) == 9, \"Test Case 5 Failed\"\nassert sum_common_divisors(10, 15) == 6, \"Test Case 6 Failed\"\n\n\n"], "prompt_tokens": [3876], "completion_tokens": [2022], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_126_sum"}
{"name": "mbpp_769_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the difference between two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Diff", "test": "def check(candidate):\n    assert candidate([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 1]) == [2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3], [6, 7, 1]) == [2, 3, 6, 7]\n\ndef test_check():\n    check(Diff)\n\ntest_check()\n", "sample_io": ["assert Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"], "source_codes": ["\nfrom typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    if not all(isinstance(x, int) for x in li1 + li2):\n        raise TypeError(\"Both lists must contain only integers\")\n    \n    return list(set(li1) - set(li2))\n\n\n"], "responses": ["\nfrom typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    if not all(isinstance(x, int) for x in li1 + li2):\n        raise TypeError(\"Both lists must contain only integers\")\n    \n    return list(set(li1) - set(li2))\n\n\n"], "prompt_tokens": [1655], "completion_tokens": [877], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_769_Diff"}
{"name": "mbpp_796_return_sum", "language": "Python3", "prompt": "from typing import Dict\n\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n\tWrite function to find the sum of all items in the given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_796_return_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "return_sum", "test": "def check(candidate):\n    assert candidate({ 'a': 100, 'b': 200, 'c': 300 }) == 600\n    assert candidate({ 'a': 25, 'b': 18, 'c': 45 }) == 88\n    assert candidate({ 'a': 36, 'b': 39, 'c': 49 }) == 124\n\ndef test_check():\n    check(return_sum)\n\ntest_check()\n", "sample_io": ["assert return_sum({ 'a': 100, 'b': 200, 'c': 300 }) == 600"], "source_codes": ["\ndef return_sum(dict: Dict[str, int]) -> int:\n    total = 0\n    for value in dict.values():\n        total += value\n    return total\n\n\n"], "responses": ["\ndef return_sum(dict: Dict[str, int]) -> int:\n    total = 0\n    for value in dict.values():\n        total += value\n    return total\n\n\n"], "prompt_tokens": [1335], "completion_tokens": [670], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_796_return_sum"}
{"name": "mbpp_574_surfacearea_cylinder", "language": "Python3", "prompt": "def surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the surface area of a cylinder.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cylinder", "test": "def check(candidate):\n    assert candidate(10, 5) == 942.45\n    assert candidate(4, 5) == 226.18800000000002\n    assert candidate(4, 10) == 351.848\n\ndef test_check():\n    check(surfacearea_cylinder)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cylinder(10, 5) == 942.45"], "source_codes": ["\nimport math\n\ndef surfacearea_cylinder(r: float, h: float) -> float:\n    if r <= 0:\n        raise ValueError(\"Radius must be positive.\")\n    if h <= 0:\n        raise ValueError(\"Height must be positive.\")\n    \n    base_area = math.pi * r ** 2\n    lateral_surface_area = 2 * math.pi * r * h\n    total_surface_area = 2 * base_area + lateral_surface_area\n    \n    return round(total_surface_area, 4)\n\n# Test Case 1: Basic Usage\nassert abs(surfacearea_cylinder(2, 5) - 141.3716) < 0.0001\n\n# Test Case 2: Edge Case - Non-positive Radius\ntry:\n    surfacearea_cylinder(-2, 5)\nexcept ValueError as e:\n    assert str(e) == \"Radius must be positive.\"\n\n# Test Case 3: Edge Case - Non-positive Height\ntry:\n    surfacearea_cylinder(2, -5)\nexcept ValueError as e:\n    assert str(e) == \"Height must be positive.\"\n\n# Test Case 4: Zero Radius\nassert abs(surfacearea_cylinder(0, 5) - 0) < 0.0001\n\n# Test Case 5: Zero Height\nassert abs(surfacearea_cylinder(2, 0) - 0) < 0.0001\n\n# Test Case 6: Large Numbers\nassert abs(surfacearea_cylinder(100, 100) - 28274.3338) < 0.0001\n\n# Additional Test Case\nassert abs(surfacearea_cylinder(10, 5) - 942.4778) < 0.0001\n\n\n"], "responses": ["\nimport math\n\ndef surfacearea_cylinder(r: float, h: float) -> float:\n    if r <= 0:\n        raise ValueError(\"Radius must be positive.\")\n    if h <= 0:\n        raise ValueError(\"Height must be positive.\")\n    \n    base_area = math.pi * r ** 2\n    lateral_surface_area = 2 * math.pi * r * h\n    total_surface_area = 2 * base_area + lateral_surface_area\n    \n    return round(total_surface_area, 4)\n\n# Test Case 1: Basic Usage\nassert abs(surfacearea_cylinder(2, 5) - 141.3716) < 0.0001\n\n# Test Case 2: Edge Case - Non-positive Radius\ntry:\n    surfacearea_cylinder(-2, 5)\nexcept ValueError as e:\n    assert str(e) == \"Radius must be positive.\"\n\n# Test Case 3: Edge Case - Non-positive Height\ntry:\n    surfacearea_cylinder(2, -5)\nexcept ValueError as e:\n    assert str(e) == \"Height must be positive.\"\n\n# Test Case 4: Zero Radius\nassert abs(surfacearea_cylinder(0, 5) - 0) < 0.0001\n\n# Test Case 5: Zero Height\nassert abs(surfacearea_cylinder(2, 0) - 0) < 0.0001\n\n# Test Case 6: Large Numbers\nassert abs(surfacearea_cylinder(100, 100) - 28274.3338) < 0.0001\n\n# Additional Test Case\nassert abs(surfacearea_cylinder(10, 5) - 942.4778) < 0.0001\n\n\n"], "prompt_tokens": [3687], "completion_tokens": [2471], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_574_surfacearea_cylinder"}
{"name": "mbpp_783_rgb_to_hsv", "language": "Python3", "prompt": "from typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    \"\"\"\n\tWrite a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rgb_to_hsv", "test": "def check(candidate):\n    assert candidate(255, 255, 255) == [0.0, 0.0, 100.0]\n    assert candidate(0, 215, 0) == [120.0, 100.0, 84.31372549019608]\n    assert candidate(10, 215, 110) == [149.26829268292684, 95.34883720930233, 84.31372549019608]\n\ndef test_check():\n    check(rgb_to_hsv)\n\ntest_check()\n", "sample_io": ["assert rgb_to_hsv(255, 255, 255) == [0.0, 0.0, 100.0]"], "source_codes": ["\nfrom typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r - g) / df) + 240) % 360\n    \n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    \n    v = mx * 100\n    return [h, s, v]\n\n\n"], "responses": ["\nfrom typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r - g) / df) + 240) % 360\n    \n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    \n    v = mx * 100\n    return [h, s, v]\n\n\n"], "prompt_tokens": [2069], "completion_tokens": [1385], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_783_rgb_to_hsv"}
{"name": "mbpp_70_get_equal", "language": "Python3", "prompt": "from typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to find whether all the given lists have equal length or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_equal", "test": "def check(candidate):\n    assert candidate([[11, 22, 33], [44, 55, 66]]) == True\n    assert candidate([[1, 2, 3], [4, 5, 6, 7]]) == False\n    assert candidate([[1, 2], [3, 4]]) == True\n\ndef test_check():\n    check(get_equal)\n\ntest_check()\n", "sample_io": ["assert get_equal([[11, 22, 33], [44, 55, 66]]) == True"], "source_codes": ["\nfrom typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    for lst in Input[1:]:\n        if len(lst) != first_length:\n            return False\n    return True\n\n\n"], "responses": ["\nfrom typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    for lst in Input[1:]:\n        if len(lst) != first_length:\n            return False\n    return True\n\n\n"], "prompt_tokens": [1533], "completion_tokens": [708], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_70_get_equal"}
{"name": "mbpp_267_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 10\n    assert candidate(3) == 35\n    assert candidate(4) == 84\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 10"], "source_codes": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the squares of the first n odd natural numbers.\n    \n    Args:\n    n (int): The number of initial odd natural numbers to consider.\n    \n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n    \n    Raises:\n    ValueError: If n is negative.\n    TypeError: If n is not an integer.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Calculate the sum of squares of the first n odd natural numbers\n    return n * (2 * n - 1) * (2 * n + 1) // 3\n\n# Test cases\ndef test_square_sum_normal():\n    assert square_Sum(1) == 1, \"Test case 1 failed\"\n    assert square_Sum(2) == 10, \"Test case 2 failed\"\n    assert square_Sum(3) == 35, \"Test case 3 failed\"\n    assert square_Sum(4) == 84, \"Test case 4 failed\"\n    assert square_Sum(5) == 165, \"Test case 5 failed\"\n\ndef test_square_sum_edge_case():\n    assert square_Sum(0) == 0, \"Test case for n=0 failed\"\n\ndef test_square_sum_negative_input():\n    try:\n        square_Sum(-1)\n    except ValueError:\n        pass\n    else:\n        assert False, \"Negative input did not raise ValueError\"\n\ndef test_square_sum_non_integer_input():\n    try:\n        square_Sum(2.5)\n    except TypeError:\n        pass\n    else:\n        assert False, \"Non-integer input did not raise TypeError\"\n\n\n"], "responses": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the squares of the first n odd natural numbers.\n    \n    Args:\n    n (int): The number of initial odd natural numbers to consider.\n    \n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n    \n    Raises:\n    ValueError: If n is negative.\n    TypeError: If n is not an integer.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Calculate the sum of squares of the first n odd natural numbers\n    return n * (2 * n - 1) * (2 * n + 1) // 3\n\n# Test cases\ndef test_square_sum_normal():\n    assert square_Sum(1) == 1, \"Test case 1 failed\"\n    assert square_Sum(2) == 10, \"Test case 2 failed\"\n    assert square_Sum(3) == 35, \"Test case 3 failed\"\n    assert square_Sum(4) == 84, \"Test case 4 failed\"\n    assert square_Sum(5) == 165, \"Test case 5 failed\"\n\ndef test_square_sum_edge_case():\n    assert square_Sum(0) == 0, \"Test case for n=0 failed\"\n\ndef test_square_sum_negative_input():\n    try:\n        square_Sum(-1)\n    except ValueError:\n        pass\n    else:\n        assert False, \"Negative input did not raise ValueError\"\n\ndef test_square_sum_non_integer_input():\n    try:\n        square_Sum(2.5)\n    except TypeError:\n        pass\n    else:\n        assert False, \"Non-integer input did not raise TypeError\"\n\n\n"], "prompt_tokens": [4043], "completion_tokens": [2377], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_267_square_Sum"}
{"name": "mbpp_171_perimeter_pentagon", "language": "Python3", "prompt": "def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n\tWrite a function to find the perimeter of a regular pentagon from the length of its sides.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perimeter_pentagon", "test": "def check(candidate):\n    assert candidate(5) == 25\n    assert candidate(10) == 50\n    assert candidate(15) == 75\n\ndef test_check():\n    check(perimeter_pentagon)\n\ntest_check()\n", "sample_io": ["assert perimeter_pentagon(5) == 25"], "source_codes": ["\ndef perimeter_pentagon(a: int) -> int:\n    if a <= 0:\n        raise ValueError(\"Side length must be positive\")\n    return 5 * a\n\n\n"], "responses": ["\ndef perimeter_pentagon(a: int) -> int:\n    if a <= 0:\n        raise ValueError(\"Side length must be positive\")\n    return 5 * a\n\n\n"], "prompt_tokens": [1237], "completion_tokens": [629], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_171_perimeter_pentagon"}
{"name": "mbpp_222_check_type", "language": "Python3", "prompt": "from typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if all the elements in tuple have same data type or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_type", "test": "def check(candidate):\n    assert candidate((5, 6, 7, 3, 5, 6)) == True\n    assert candidate((1, 2, '4')) == False\n    assert candidate((3, 2, 1, 4, 5)) == True\n\ndef test_check():\n    check(check_type)\n\ntest_check()\n", "sample_io": ["assert check_type((5, 6, 7, 3, 5, 6)) == True"], "source_codes": ["\nfrom typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    if not test_tuple:\n        return True\n    return len(set(type(element) for element in test_tuple)) == 1\n\n\n"], "responses": ["\nfrom typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    if not test_tuple:\n        return True\n    return len(set(type(element) for element in test_tuple)) == 1\n\n\n"], "prompt_tokens": [1361], "completion_tokens": [626], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_222_check_type"}
