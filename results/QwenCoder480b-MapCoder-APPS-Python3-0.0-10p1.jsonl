{"name": "3554", "description": "Zonk is addictive dice game. In each round player rolls 6 dice. Then (s)he composes combinations from them. Each combination gives certain points. \n\nThen player can take one or more dice combinations to his hand and re-roll remaining dice or save his score. Dice in player's hand won't be taken into account in subsequent rolls.\n\nIf no combinations can be composed - situation is called \"zonk\". Player thrown zonk loses all points in this round and next player moves. So it's player decision when to reroll and when to stop and save his score.\n\nYour task is simple - just evaluate current roll and return maximum number of points can be scored from it. If no combinations can be made - function must return string ``\"Zonk\"`` (without quotes).\n\nThere are different variations of Zonk. In this kata, we will use most common table of combinations:\n\nCombinationExample rollPoints\nStraight (1,2,3,4,5 and 6)6 3 1 2 5 41000 points\nThree pairs of any dice2 2 4 4 1 1750 points\nThree of 11 4 1 11000 points\nThree of 22 3 4 2 2200 points\nThree of 33 4 3 6 3 2300 points\nThree of 44 4 4400 points\nThree of 52 5 5 5 4500 points\nThree of 66 6 2 6600 points\nFour of a kind1 1 1 1 4 62 \u00d7 Three-of-a-kind score (in example, 2000 pts)\nFive of a kind5 5 5 4 5 53 \u00d7 Three-of-a-kind score (in example, 1500 pts)\nSix of a kind4 4 4 4 4 44 \u00d7 Three-of-a-kind score (in example, 1600 pts)\nEvery 14 3 1 2 2100 points\nEvery 55 2 650 points\n\n\nEach die cannot be used in multiple combinations the same time, so three pairs of 2, 3 and 5 will worth you only ``750`` points (for three pairs), not 850 (for three pairs and two fives). But you can select multiple combinations, ``2 2 2 1 6`` will worth you ``300`` points (200 for three-of-kind '2' plus 100 for single '1' die)\n\nExamples:\n```python\n  get_score([1,2,3]) # returns 100 = points from one 1\n  get_score([3,4,1,1,5]) # returns 250 = points from two 1 and one 5\n  get_score([2,3,2,3,3,2]) # returns 500 = three of 2 + three of 3\n  get_score([1,1,1,1,1,5]) # returns 3050 = five 1 + one 5\n  get_score([2,3,4,3,6,6]) # returns \"Zonk\" = no combinations here\n  get_score([2,2,6,6,2,2]) # returns 400 = four 2, this cannot be scored as three pairs\n  get_score([1,3,4,3,4,1]) # returns 750 = three pairs\n  get_score([3,3,3,3]) # returns 600 = four of 3\n  get_score([1,2,3,4,5]) # returns 150 = it's not straight\n```\nOf course, in real Zonk game it's sometimes not worth to collect all combination from roll. Taking less dice and rerolling more remaining may be better, but task is just to calculate maximum possible score from current single roll.\n\nP.S. Inspired by this kata: http://www.codewars.com/kata/5270d0d18625160ada0000e4", "difficulty": "introductory", "id": 3554, "sample_io": [{"input": "[1, 2, 3]", "output": [100]}, {"input": "[3,4,1,1,5]", "output": [250]}, {"input": "[2,3,2,3,3,2]", "output": [500]}, {"input": "[1,1,1,1,1,5]", "output": [3050]}, {"input": "[2,3,4,3,6,6]", "output": ["Zonk"]}, {"input": "[2,2,6,6,2,2]", "output": [400]}, {"input": "[1,3,4,3,4,1]", "output": [750]}, {"input": "[3,3,3,3]", "output": [600]}, {"input": "[1,2,3,4,5]", "output": [150]}], "test_list": [{"input": "[1]", "output": [100]}, {"input": "[5]", "output": [50]}, {"input": "[1, 1]", "output": [200]}, {"input": "[5, 5]", "output": [100]}, {"input": "[5, 1]", "output": [150]}, {"input": "[5, 6]", "output": [50]}, {"input": "[1, 1, 1]", "output": [1000]}, {"input": "[2, 2, 2]", "output": [200]}, {"input": "[3, 3, 3]", "output": [300]}, {"input": "[4, 4, 4]", "output": [400]}, {"input": "[5, 5, 5]", "output": [500]}, {"input": "[6, 6, 6]", "output": [600]}, {"input": "[1, 2, 1]", "output": [200]}, {"input": "[1, 1, 5]", "output": [250]}, {"input": "[5, 5, 6]", "output": [100]}, {"input": "[1, 5, 5]", "output": [200]}, {"input": "[1, 1, 1, 1]", "output": [2000]}, {"input": "[2, 2, 2, 2]", "output": [400]}, {"input": "[3, 3, 3, 3]", "output": [600]}, {"input": "[4, 4, 4, 4]", "output": [800]}, {"input": "[5, 5, 5, 5]", "output": [1000]}, {"input": "[6, 6, 6, 6]", "output": [1200]}, {"input": "[1, 5, 5, 1]", "output": [300]}, {"input": "[2, 3, 4, 5]", "output": [50]}, {"input": "[3, 3, 5, 3]", "output": [350]}, {"input": "[1, 1, 1, 1, 1]", "output": [3000]}, {"input": "[2, 2, 2, 2, 2]", "output": [600]}, {"input": "[3, 3, 3, 3, 3]", "output": [900]}, {"input": "[4, 4, 4, 4, 4]", "output": [1200]}, {"input": "[5, 5, 5, 5, 5]", "output": [1500]}, {"input": "[6, 6, 6, 6, 6]", "output": [1800]}, {"input": "[1, 5, 1, 5, 1]", "output": [1100]}, {"input": "[1, 2, 3, 4, 5]", "output": [150]}, {"input": "[2, 3, 4, 5, 6]", "output": [50]}, {"input": "[1, 3, 4, 5, 2]", "output": [150]}, {"input": "[1, 1, 1, 1, 1, 1]", "output": [4000]}, {"input": "[2, 2, 2, 2, 2, 2]", "output": [800]}, {"input": "[3, 3, 3, 3, 3, 3]", "output": [1200]}, {"input": "[4, 4, 4, 4, 4, 4]", "output": [1600]}, {"input": "[5, 5, 5, 5, 5, 5]", "output": [2000]}, {"input": "[6, 6, 6, 6, 6, 6]", "output": [2400]}, {"input": "[2, 1, 3, 4, 6, 5]", "output": [1000]}, {"input": "[4, 4, 2, 2, 6, 6]", "output": [750]}, {"input": "[1, 2, 3, 4, 5, 5]", "output": [200]}, {"input": "[2, 2, 4, 2, 2, 4]", "output": [400]}, {"input": "[1, 3, 4, 5, 2, 2]", "output": [150]}, {"input": "[1, 5, 2, 1, 2, 5]", "output": [750]}, {"input": "[4, 1, 1, 1, 1, 5]", "output": [2050]}, {"input": "[3, 5, 2, 4, 2, 6]", "output": [50]}, {"input": "[1, 6, 6, 1, 1, 6]", "output": [1600]}], "starter_code": "\ndef get_score(dice):\n\t", "source_codes": ["def get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Work with a copy to track remaining dice\n    remaining = counts.copy()\n    score = 0\n    \n    # Handle six of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 6:\n            if num == 1:\n                score += 4000  # 4 * 1000\n            else:\n                score += num * 100 * 4\n            remaining[num] -= 6\n    \n    # Handle five of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 5:\n            if num == 1:\n                score += 3000  # 3 * 1000\n            else:\n                score += num * 100 * 3\n            remaining[num] -= 5\n    \n    # Handle four of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 4:\n            if num == 1:\n                score += 2000  # 2 * 1000\n            else:\n                score += num * 100 * 2\n            remaining[num] -= 4\n    \n    # Handle three of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            remaining[num] -= 3\n    \n    # Handle remaining 1s and 5s\n    score += remaining.get(1, 0) * 100\n    score += remaining.get(5, 0) * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1-6) - only for exactly 6 dice\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs - only for exactly 6 dice\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Create a copy to work with\n    temp_counts = counts.copy()\n    \n    # Process N-of-a-kind combinations (prioritize higher counts)\n    # Check for 6 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 6:\n            if num == 1:\n                score += 1000 * 4  # 4000\n            else:\n                score += num * 100 * 4  # 4 times three of a kind\n            temp_counts[num] -= 6\n    \n    # Check for 5 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 5:\n            if num == 1:\n                score += 1000 * 3  # 3000\n            else:\n                score += num * 100 * 3  # 3 times three of a kind\n            temp_counts[num] -= 5\n    \n    # Check for 4 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 4:\n            if num == 1:\n                score += 1000 * 2  # 2000\n            else:\n                score += num * 100 * 2  # 2 times three of a kind\n            temp_counts[num] -= 4\n    \n    # Check for 3 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            temp_counts[num] -= 3\n    \n    # Score remaining single dice\n    score += temp_counts.get(1, 0) * 100\n    score += temp_counts.get(5, 0) * 50\n    \n    # Return \"Zonk\" if no points were scored\n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice = eval(input())\nresult = get_score(dice)\nprint(result)", "def get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and list(sorted(counts.values())) == [2, 2, 2]:\n        return 750\n    \n    total_score = 0\n    remaining_counts = counts.copy()\n    \n    # Process four, five, six of a kind first (highest multipliers)\n    for num in list(remaining_counts.keys()):\n        count = remaining_counts[num]\n        if count >= 4:\n            if num == 1:\n                base = 1000\n            else:\n                base = num * 100\n            multiplier = count - 2  # Four=2x, Five=3x, Six=4x\n            total_score += base * multiplier\n            remaining_counts[num] = 0\n    \n    # Process three of a kind\n    for num in list(remaining_counts.keys()):\n        count = remaining_counts[num]\n        if count >= 3:\n            if num == 1:\n                total_score += 1000\n            else:\n                total_score += num * 100\n            remaining_counts[num] -= 3\n    \n    # Single 1s and 5s\n    total_score += remaining_counts.get(1, 0) * 100\n    total_score += remaining_counts.get(5, 0) * 50\n    \n    return total_score if total_score > 0 else \"Zonk\"\n\n# Read input and call function\nif __name__ == \"__main__\":\n    import sys\n    input_str = sys.stdin.read().strip()\n    dice_list = eval(input_str)\n    result = get_score(dice_list)\n    print(result)", "def get_score(dice):\n    counts = Counter(dice)\n    score = 0\n    \n    # Work with a copy of counts\n    temp_counts = counts.copy()\n    \n    # Check for straight (1,2,3,4,5,6) - highest priority\n    if len(dice) == 6 and set(dice) == {1, 2, 3, 4, 5, 6}:\n        return 1000\n    \n    # Check for three pairs - second highest priority\n    if len(dice) == 6 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    # Check for six of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 6:\n            base = 1000 if num == 1 else num * 100\n            score += base * 4  # Six of a kind\n            temp_counts[num] = 0\n            return score\n    \n    # Check for five of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 5:\n            base = 1000 if num == 1 else num * 100\n            score += base * 3  # Five of a kind\n            temp_counts[num] = 0\n            # Add points for the remaining die\n            score += temp_counts[1] * 100 + temp_counts[5] * 50\n            return score if score > 0 else \"Zonk\"\n    \n    # Check for four of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 4:\n            base = 1000 if num == 1 else num * 100\n            score += base * 2  # Four of a kind\n            temp_counts[num] = 0\n            break\n    \n    # Check for three of a kind (can have multiple)\n    for num in range(1, 7):\n        while temp_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            temp_counts[num] -= 3\n    \n    # Add singles\n    score += temp_counts[1] * 100\n    score += temp_counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice = eval(input())\nprint(get_score(dice))", "import sys\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    total_score = 0\n    used_dice = 0\n    \n    # Make a copy of counts to work with\n    working_counts = counts.copy()\n    \n    # Check for straight (1,2,3,4,5,6) - 1000 points\n    if all(working_counts[i] >= 1 for i in range(1, 7)):\n        total_score += 1000\n        for i in range(1, 7):\n            working_counts[i] -= 1\n        used_dice += 6\n    \n    # Check for three pairs - 750 points\n    pairs = sum(count // 2 for count in working_counts.values())\n    if pairs >= 3 and used_dice == 0:  # Only if no dice used yet\n        total_score += 750\n        pairs_removed = 0\n        for face in sorted(working_counts.keys()):\n            while working_counts[face] >= 2 and pairs_removed < 3:\n                working_counts[face] -= 2\n                pairs_removed += 1\n                used_dice += 2\n    \n    # Check for N of a kind (6 down to 3)\n    for n in range(6, 2, -1):\n        for face in range(1, 7):\n            while working_counts[face] >= n:\n                if face == 1:\n                    base = 1000\n                else:\n                    base = face * 100\n                multiplier = n - 2\n                score = base * multiplier\n                total_score += score\n                working_counts[face] -= n\n                used_dice += n\n    \n    # Check for single 1s - 100 points each\n    while working_counts[1] > 0:\n        total_score += 100\n        working_counts[1] -= 1\n        used_dice += 1\n    \n    # Check for single 5s - 50 points each\n    while working_counts[5] > 0:\n        total_score += 50\n        working_counts[5] -= 1\n        used_dice += 1\n    \n    # If no dice were used, it's a Zonk\n    if used_dice == 0:\n        return \"Zonk\"\n    \n    return total_score\n\n# Read input and process\nif __name__ == \"__main__\":\n    input_line = sys.stdin.read().strip()\n    # Parse input like \"[1, 2, 3]\"\n    dice_str = input_line.strip('[]')\n    if not dice_str.strip():\n        dice = []\n    else:\n        dice = [int(x.strip()) for x in dice_str.split(',')]\n    result = get_score(dice)\n    print(result)", "def get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight (only for 6 dice)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs (only for 6 dice)\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    max_score = 0\n    \n    # Try all possible scoring combinations using recursion/backtracking\n    def calculate_max_score(remaining_counts):\n        if not remaining_counts or sum(remaining_counts.values()) == 0:\n            return 0\n        \n        score = 0\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 6:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 6\n                base_score = 4 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for five of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 5:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 5\n                base_score = 3 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for four of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 4:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 4\n                base_score = 2 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 3:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 3\n                base_score = 1000 if num == 1 else num * 100\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Add individual 1s and 5s from remaining dice\n        individual_score = remaining_counts[1] * 100 + remaining_counts[5] * 50\n        score = max(score, score + individual_score)\n        \n        return score\n    \n    # Alternative approach: greedy selection of best combinations\n    def greedy_score(counts_copy):\n        score = 0\n        used = Counter()\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 6:\n                used[num] += 6\n                score += 4 * (1000 if num == 1 else num * 100)\n        \n        # Check for five of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 5:\n                used[num] += 5\n                score += 3 * (1000 if num == 1 else num * 100)\n        \n        # Check for four of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 4:\n                used[num] += 4\n                score += 2 * (1000 if num == 1 else num * 100)\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 3:\n                used[num] += 3\n                score += 1000 if num == 1 else num * 100\n        \n        # Add individual 1s and 5s\n        score += (counts_copy[1] - used[1]) * 100\n        score += (counts_copy[5] - used[5]) * 50\n        \n        return score\n    \n    # Even simpler approach - try different combination orders\n    def try_combinations(counts_copy):\n        scores = []\n        \n        # Strategy 1: Take largest combinations first\n        score1 = 0\n        temp_counts = counts_copy.copy()\n        used = Counter()\n        \n        # Six of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 6:\n                temp_counts[num] -= 6\n                score1 += 4 * (1000 if num == 1 else num * 100)\n        \n        # Five of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 5:\n                temp_counts[num] -= 5\n                score1 += 3 * (1000 if num == 1 else num * 100)\n        \n        # Four of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 4:\n                temp_counts[num] -= 4\n                score1 += 2 * (1000 if num == 1 else num * 100)\n        \n        # Three of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 3:\n                temp_counts[num] -= 3\n                score1 += 1000 if num == 1 else num * 100\n        \n        # Individual 1s and 5s\n        score1 += temp_counts[1] * 100 + temp_counts[5] * 50\n        scores.append(score1)\n        \n        # Strategy 2: Try three of a kind combinations\n        score2 = 0\n        temp_counts = counts_copy.copy()\n        \n        # Find all possible three of a kinds\n        three_kinds = []\n        for num in range(1, 7):\n            while temp_counts[num] >= 3:\n                three_kinds.append(num)\n                temp_counts[num] -= 3\n        \n        # Score three of a kinds\n        for num in three_kinds:\n            score2 += 1000 if num == 1 else num * 100\n        \n        # Add individual 1s and 5s from remaining\n        score2 += temp_counts[1] * 100 + temp_counts[5] * 50\n        scores.append(score2)\n        \n        return max(scores) if scores else 0\n    \n    max_score = try_combinations(counts)\n    \n    # Handle special cases that override normal scoring\n    if len(dice) == 6:\n        # Straight beats everything\n        if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n            return 1000\n        # Three pairs beats normal scoring\n        if len(counts) == 3 and all(count == 2 for count in counts.values()):\n            return 750\n    \n    return max_score if max_score > 0 else \"Zonk\"\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Work with a copy of counts\n    temp_counts = counts.copy()\n    \n    # Check for six of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 6:\n            if num == 1:\n                score += 4 * 1000\n            else:\n                score += 4 * num * 100\n            temp_counts[num] -= 6\n            return score\n    \n    # Check for five of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 5:\n            if num == 1:\n                score += 3 * 1000\n            else:\n                score += 3 * num * 100\n            temp_counts[num] -= 5\n            break\n    \n    # Check for four of a kind\n    if score > 0:\n        pass  # Already scored above\n    else:\n        for num in range(1, 7):\n            if temp_counts[num] >= 4:\n                if num == 1:\n                    score += 2 * 1000\n                else:\n                    score += 2 * num * 100\n                temp_counts[num] -= 4\n                break\n    \n    # Check for three of a kind (can have multiple)\n    three_kinds = []\n    for num in range(1, 7):\n        while temp_counts[num] >= 3:\n            three_kinds.append(num)\n            temp_counts[num] -= 3\n    \n    # Score all three-of-a-kinds\n    for num in three_kinds:\n        if num == 1:\n            score += 1000\n        else:\n            score += num * 100\n    \n    # Add points for remaining 1s and 5s\n    score += temp_counts[1] * 100 + temp_counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice = eval(input())\nresult = get_score(dice)\nprint(result)", "def get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    used_dice = 0\n    \n    # Make a copy to track what we've used\n    remaining_counts = counts.copy()\n    \n    # Check for special combinations first (highest priority)\n    \n    # Six of a kind\n    for num, count in remaining_counts.items():\n        if count >= 6:\n            if num == 1:\n                score += 4000\n            else:\n                score += num * 100 * 4\n            remaining_counts[num] -= 6\n            used_dice += 6\n            break\n    \n    # Five of a kind\n    if score == 0:  # Only check if we haven't scored yet\n        for num, count in remaining_counts.items():\n            if count >= 5:\n                if num == 1:\n                    score += 3000\n                else:\n                    score += num * 100 * 3\n                remaining_counts[num] -= 5\n                used_dice += 5\n                \n                # Score remaining dice\n                for rem_num, rem_count in remaining_counts.items():\n                    if rem_num == 1:\n                        score += 100 * rem_count\n                    elif rem_num == 5:\n                        score += 50 * rem_count\n                used_dice += sum(remaining_counts.values())\n                break\n    \n    # Four of a kind\n    if score == 0:  # Only check if we haven't scored yet\n        for num, count in remaining_counts.items():\n            if count >= 4:\n                if num == 1:\n                    score += 2000\n                else:\n                    score += num * 100 * 2\n                remaining_counts[num] -= 4\n                used_dice += 4\n                \n                # Score remaining dice\n                for rem_num, rem_count in remaining_counts.items():\n                    if rem_num == 1:\n                        score += 100 * rem_count\n                    elif rem_num == 5:\n                        score += 50 * rem_count\n                used_dice += sum(remaining_counts.values())\n                break\n    \n    # Now handle regular scoring if no special combinations were found\n    if score == 0:\n        # Check for straight\n        if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n            return 1000\n        \n        # Check for three pairs\n        if len(dice) == 6 and list(remaining_counts.values()).count(2) == 3:\n            return 750\n        \n        # Handle three of a kinds and singles\n        temp_counts = remaining_counts.copy()\n        \n        # Process three of a kinds\n        for num, count in list(temp_counts.items()):\n            while temp_counts[num] >= 3:\n                if num == 1:\n                    score += 1000\n                else:\n                    score += num * 100\n                temp_counts[num] -= 3\n                used_dice += 3\n        \n        # Score remaining 1s and 5s\n        for num, count in temp_counts.items():\n            if count > 0:\n                if num == 1:\n                    score += 100 * count\n                    used_dice += count\n                elif num == 5:\n                    score += 50 * count\n                    used_dice += count\n    \n    # If we haven't used all dice and have no score, it's Zonk\n    if used_dice == 0 and score == 0:\n        # Special case: check if we have any 1s or 5s\n        has_scoring = any(num in [1, 5] for num in dice)\n        if not has_scoring and len(dice) < 6:\n            return \"Zonk\"\n        elif not has_scoring and len(dice) == 6:\n            # Check if it's a valid combination\n            if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n                return 1000\n            elif list(counts.values()).count(2) == 3:\n                return 750\n            else:\n                return \"Zonk\"\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    if len(dice) == 0:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Calculate score\n    score = 0\n    remaining_counts = counts.copy()\n    \n    # Handle six of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 6:\n            if num == 1:\n                score += 4 * 1000\n            else:\n                score += 4 * num * 100\n            remaining_counts[num] -= 6\n    \n    # Handle five of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 5:\n            if num == 1:\n                score += 3 * 1000\n            else:\n                score += 3 * num * 100\n            remaining_counts[num] -= 5\n    \n    # Handle four of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 4:\n            if num == 1:\n                score += 2 * 1000\n            else:\n                score += 2 * num * 100\n            remaining_counts[num] -= 4\n    \n    # Handle three of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            remaining_counts[num] -= 3\n    \n    # Handle remaining 1s and 5s\n    score += remaining_counts.get(1, 0) * 100\n    score += remaining_counts.get(5, 0) * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "import sys\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    def calculate_max_score(counts):\n        # Base case: no dice left\n        if not counts:\n            return 0\n            \n        max_score = 0\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if counts[num] >= 6:\n                new_counts = counts.copy()\n                new_counts[num] -= 6\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base_score = (1000 if num == 1 else num * 100) * 4\n                score = base_score + calculate_max_score(new_counts)\n                max_score = max(max_score, score)\n                break\n        \n        # Check for five of a kind\n        if max_score == 0:\n            for num in range(1, 7):\n                if counts[num] >= 5:\n                    new_counts = counts.copy()\n                    new_counts[num] -= 5\n                    if new_counts[num] == 0:\n                        del new_counts[num]\n                    base_score = (1000 if num == 1 else num * 100) * 3\n                    score = base_score + calculate_max_score(new_counts)\n                    max_score = max(max_score, score)\n                    break\n        \n        # Check for four of a kind\n        if max_score == 0:\n            for num in range(1, 7):\n                if counts[num] >= 4:\n                    new_counts = counts.copy()\n                    new_counts[num] -= 4\n                    if new_counts[num] == 0:\n                        del new_counts[num]\n                    base_score = (1000 if num == 1 else num * 100) * 2\n                    score = base_score + calculate_max_score(new_counts)\n                    max_score = max(max_score, score)\n                    break\n        \n        # Check for straight\n        if max_score == 0 and len(counts) == 6 and all(count == 1 for count in counts.values()):\n            return 1000\n        \n        # Check for three pairs\n        if max_score == 0 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n            return 750\n            \n        # Check for three pairs (alternative pattern)\n        if max_score == 0 and len(counts) <= 3:\n            pairs = sum(count // 2 for count in counts.values())\n            if pairs >= 3:\n                return 750\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if counts[num] >= 3:\n                new_counts = counts.copy()\n                new_counts[num] -= 3\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base_score = 1000 if num == 1 else num * 100\n                score = base_score + calculate_max_score(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for singles (1s and 5s)\n        score_from_singles = 0\n        new_counts = counts.copy()\n        \n        # Score all 1s\n        if 1 in new_counts:\n            score_from_singles += new_counts[1] * 100\n            del new_counts[1]\n            \n        # Score all 5s\n        if 5 in new_counts:\n            score_from_singles += new_counts[5] * 50\n            del new_counts[5]\n            \n        # Score remaining combinations recursively\n        if score_from_singles > 0:\n            score = score_from_singles + calculate_max_score(new_counts)\n            max_score = max(max_score, score)\n        \n        return max_score\n    \n    # Special handling for three pairs\n    if len(dice) == 6:\n        pairs = sum(count // 2 for count in counts.values())\n        if pairs >= 3:\n            # Try both approaches: three pairs vs individual scoring\n            pair_score = 750\n            individual_score = calculate_max_score(counts)\n            return max(pair_score, individual_score)\n    \n    score = calculate_max_score(counts)\n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\nif __name__ == \"__main__\":\n    input_line = input().strip()\n    # Parse the input line as a list of integers\n    dice = eval(input_line)\n    result = get_score(dice)\n    print(result)"], "responses": ["\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Work with a copy to track remaining dice\n    remaining = counts.copy()\n    score = 0\n    \n    # Handle six of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 6:\n            if num == 1:\n                score += 4000  # 4 * 1000\n            else:\n                score += num * 100 * 4\n            remaining[num] -= 6\n    \n    # Handle five of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 5:\n            if num == 1:\n                score += 3000  # 3 * 1000\n            else:\n                score += num * 100 * 3\n            remaining[num] -= 5\n    \n    # Handle four of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 4:\n            if num == 1:\n                score += 2000  # 2 * 1000\n            else:\n                score += num * 100 * 2\n            remaining[num] -= 4\n    \n    # Handle three of a kind\n    for num in range(1, 7):\n        if remaining[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            remaining[num] -= 3\n    \n    # Handle remaining 1s and 5s\n    score += remaining.get(1, 0) * 100\n    score += remaining.get(5, 0) * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1-6) - only for exactly 6 dice\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs - only for exactly 6 dice\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Create a copy to work with\n    temp_counts = counts.copy()\n    \n    # Process N-of-a-kind combinations (prioritize higher counts)\n    # Check for 6 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 6:\n            if num == 1:\n                score += 1000 * 4  # 4000\n            else:\n                score += num * 100 * 4  # 4 times three of a kind\n            temp_counts[num] -= 6\n    \n    # Check for 5 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 5:\n            if num == 1:\n                score += 1000 * 3  # 3000\n            else:\n                score += num * 100 * 3  # 3 times three of a kind\n            temp_counts[num] -= 5\n    \n    # Check for 4 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 4:\n            if num == 1:\n                score += 1000 * 2  # 2000\n            else:\n                score += num * 100 * 2  # 2 times three of a kind\n            temp_counts[num] -= 4\n    \n    # Check for 3 of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            temp_counts[num] -= 3\n    \n    # Score remaining single dice\n    score += temp_counts.get(1, 0) * 100\n    score += temp_counts.get(5, 0) * 50\n    \n    # Return \"Zonk\" if no points were scored\n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice = eval(input())\nresult = get_score(dice)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and list(sorted(counts.values())) == [2, 2, 2]:\n        return 750\n    \n    total_score = 0\n    remaining_counts = counts.copy()\n    \n    # Process four, five, six of a kind first (highest multipliers)\n    for num in list(remaining_counts.keys()):\n        count = remaining_counts[num]\n        if count >= 4:\n            if num == 1:\n                base = 1000\n            else:\n                base = num * 100\n            multiplier = count - 2  # Four=2x, Five=3x, Six=4x\n            total_score += base * multiplier\n            remaining_counts[num] = 0\n    \n    # Process three of a kind\n    for num in list(remaining_counts.keys()):\n        count = remaining_counts[num]\n        if count >= 3:\n            if num == 1:\n                total_score += 1000\n            else:\n                total_score += num * 100\n            remaining_counts[num] -= 3\n    \n    # Single 1s and 5s\n    total_score += remaining_counts.get(1, 0) * 100\n    total_score += remaining_counts.get(5, 0) * 50\n    \n    return total_score if total_score > 0 else \"Zonk\"\n\n# Read input and call function\nif __name__ == \"__main__\":\n    import sys\n    input_str = sys.stdin.read().strip()\n    dice_list = eval(input_str)\n    result = get_score(dice_list)\n    print(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    score = 0\n    \n    # Work with a copy of counts\n    temp_counts = counts.copy()\n    \n    # Check for straight (1,2,3,4,5,6) - highest priority\n    if len(dice) == 6 and set(dice) == {1, 2, 3, 4, 5, 6}:\n        return 1000\n    \n    # Check for three pairs - second highest priority\n    if len(dice) == 6 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    # Check for six of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 6:\n            base = 1000 if num == 1 else num * 100\n            score += base * 4  # Six of a kind\n            temp_counts[num] = 0\n            return score\n    \n    # Check for five of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 5:\n            base = 1000 if num == 1 else num * 100\n            score += base * 3  # Five of a kind\n            temp_counts[num] = 0\n            # Add points for the remaining die\n            score += temp_counts[1] * 100 + temp_counts[5] * 50\n            return score if score > 0 else \"Zonk\"\n    \n    # Check for four of a kind\n    for num in range(1, 7):\n        if temp_counts[num] == 4:\n            base = 1000 if num == 1 else num * 100\n            score += base * 2  # Four of a kind\n            temp_counts[num] = 0\n            break\n    \n    # Check for three of a kind (can have multiple)\n    for num in range(1, 7):\n        while temp_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            temp_counts[num] -= 3\n    \n    # Add singles\n    score += temp_counts[1] * 100\n    score += temp_counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice = eval(input())\nprint(get_score(dice))\n\n\n", "\nfrom collections import Counter\nimport sys\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    total_score = 0\n    used_dice = 0\n    \n    # Make a copy of counts to work with\n    working_counts = counts.copy()\n    \n    # Check for straight (1,2,3,4,5,6) - 1000 points\n    if all(working_counts[i] >= 1 for i in range(1, 7)):\n        total_score += 1000\n        for i in range(1, 7):\n            working_counts[i] -= 1\n        used_dice += 6\n    \n    # Check for three pairs - 750 points\n    pairs = sum(count // 2 for count in working_counts.values())\n    if pairs >= 3 and used_dice == 0:  # Only if no dice used yet\n        total_score += 750\n        pairs_removed = 0\n        for face in sorted(working_counts.keys()):\n            while working_counts[face] >= 2 and pairs_removed < 3:\n                working_counts[face] -= 2\n                pairs_removed += 1\n                used_dice += 2\n    \n    # Check for N of a kind (6 down to 3)\n    for n in range(6, 2, -1):\n        for face in range(1, 7):\n            while working_counts[face] >= n:\n                if face == 1:\n                    base = 1000\n                else:\n                    base = face * 100\n                multiplier = n - 2\n                score = base * multiplier\n                total_score += score\n                working_counts[face] -= n\n                used_dice += n\n    \n    # Check for single 1s - 100 points each\n    while working_counts[1] > 0:\n        total_score += 100\n        working_counts[1] -= 1\n        used_dice += 1\n    \n    # Check for single 5s - 50 points each\n    while working_counts[5] > 0:\n        total_score += 50\n        working_counts[5] -= 1\n        used_dice += 1\n    \n    # If no dice were used, it's a Zonk\n    if used_dice == 0:\n        return \"Zonk\"\n    \n    return total_score\n\n# Read input and process\nif __name__ == \"__main__\":\n    input_line = sys.stdin.read().strip()\n    # Parse input like \"[1, 2, 3]\"\n    dice_str = input_line.strip('[]')\n    if not dice_str.strip():\n        dice = []\n    else:\n        dice = [int(x.strip()) for x in dice_str.split(',')]\n    result = get_score(dice)\n    print(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight (only for 6 dice)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs (only for 6 dice)\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    max_score = 0\n    \n    # Try all possible scoring combinations using recursion/backtracking\n    def calculate_max_score(remaining_counts):\n        if not remaining_counts or sum(remaining_counts.values()) == 0:\n            return 0\n        \n        score = 0\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 6:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 6\n                base_score = 4 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for five of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 5:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 5\n                base_score = 3 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for four of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 4:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 4\n                base_score = 2 * (1000 if num == 1 else num * 100)\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if remaining_counts[num] >= 3:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 3\n                base_score = 1000 if num == 1 else num * 100\n                score = max(score, base_score + calculate_max_score(new_counts))\n        \n        # Add individual 1s and 5s from remaining dice\n        individual_score = remaining_counts[1] * 100 + remaining_counts[5] * 50\n        score = max(score, score + individual_score)\n        \n        return score\n    \n    # Alternative approach: greedy selection of best combinations\n    def greedy_score(counts_copy):\n        score = 0\n        used = Counter()\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 6:\n                used[num] += 6\n                score += 4 * (1000 if num == 1 else num * 100)\n        \n        # Check for five of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 5:\n                used[num] += 5\n                score += 3 * (1000 if num == 1 else num * 100)\n        \n        # Check for four of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 4:\n                used[num] += 4\n                score += 2 * (1000 if num == 1 else num * 100)\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if counts_copy[num] - used[num] >= 3:\n                used[num] += 3\n                score += 1000 if num == 1 else num * 100\n        \n        # Add individual 1s and 5s\n        score += (counts_copy[1] - used[1]) * 100\n        score += (counts_copy[5] - used[5]) * 50\n        \n        return score\n    \n    # Even simpler approach - try different combination orders\n    def try_combinations(counts_copy):\n        scores = []\n        \n        # Strategy 1: Take largest combinations first\n        score1 = 0\n        temp_counts = counts_copy.copy()\n        used = Counter()\n        \n        # Six of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 6:\n                temp_counts[num] -= 6\n                score1 += 4 * (1000 if num == 1 else num * 100)\n        \n        # Five of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 5:\n                temp_counts[num] -= 5\n                score1 += 3 * (1000 if num == 1 else num * 100)\n        \n        # Four of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 4:\n                temp_counts[num] -= 4\n                score1 += 2 * (1000 if num == 1 else num * 100)\n        \n        # Three of a kind\n        for num in range(1, 7):\n            while temp_counts[num] >= 3:\n                temp_counts[num] -= 3\n                score1 += 1000 if num == 1 else num * 100\n        \n        # Individual 1s and 5s\n        score1 += temp_counts[1] * 100 + temp_counts[5] * 50\n        scores.append(score1)\n        \n        # Strategy 2: Try three of a kind combinations\n        score2 = 0\n        temp_counts = counts_copy.copy()\n        \n        # Find all possible three of a kinds\n        three_kinds = []\n        for num in range(1, 7):\n            while temp_counts[num] >= 3:\n                three_kinds.append(num)\n                temp_counts[num] -= 3\n        \n        # Score three of a kinds\n        for num in three_kinds:\n            score2 += 1000 if num == 1 else num * 100\n        \n        # Add individual 1s and 5s from remaining\n        score2 += temp_counts[1] * 100 + temp_counts[5] * 50\n        scores.append(score2)\n        \n        return max(scores) if scores else 0\n    \n    max_score = try_combinations(counts)\n    \n    # Handle special cases that override normal scoring\n    if len(dice) == 6:\n        # Straight beats everything\n        if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n            return 1000\n        # Three pairs beats normal scoring\n        if len(counts) == 3 and all(count == 2 for count in counts.values()):\n            return 750\n    \n    return max_score if max_score > 0 else \"Zonk\"\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Work with a copy of counts\n    temp_counts = counts.copy()\n    \n    # Check for six of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 6:\n            if num == 1:\n                score += 4 * 1000\n            else:\n                score += 4 * num * 100\n            temp_counts[num] -= 6\n            return score\n    \n    # Check for five of a kind\n    for num in range(1, 7):\n        if temp_counts[num] >= 5:\n            if num == 1:\n                score += 3 * 1000\n            else:\n                score += 3 * num * 100\n            temp_counts[num] -= 5\n            break\n    \n    # Check for four of a kind\n    if score > 0:\n        pass  # Already scored above\n    else:\n        for num in range(1, 7):\n            if temp_counts[num] >= 4:\n                if num == 1:\n                    score += 2 * 1000\n                else:\n                    score += 2 * num * 100\n                temp_counts[num] -= 4\n                break\n    \n    # Check for three of a kind (can have multiple)\n    three_kinds = []\n    for num in range(1, 7):\n        while temp_counts[num] >= 3:\n            three_kinds.append(num)\n            temp_counts[num] -= 3\n    \n    # Score all three-of-a-kinds\n    for num in three_kinds:\n        if num == 1:\n            score += 1000\n        else:\n            score += num * 100\n    \n    # Add points for remaining 1s and 5s\n    score += temp_counts[1] * 100 + temp_counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice = eval(input())\nresult = get_score(dice)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    used_dice = 0\n    \n    # Make a copy to track what we've used\n    remaining_counts = counts.copy()\n    \n    # Check for special combinations first (highest priority)\n    \n    # Six of a kind\n    for num, count in remaining_counts.items():\n        if count >= 6:\n            if num == 1:\n                score += 4000\n            else:\n                score += num * 100 * 4\n            remaining_counts[num] -= 6\n            used_dice += 6\n            break\n    \n    # Five of a kind\n    if score == 0:  # Only check if we haven't scored yet\n        for num, count in remaining_counts.items():\n            if count >= 5:\n                if num == 1:\n                    score += 3000\n                else:\n                    score += num * 100 * 3\n                remaining_counts[num] -= 5\n                used_dice += 5\n                \n                # Score remaining dice\n                for rem_num, rem_count in remaining_counts.items():\n                    if rem_num == 1:\n                        score += 100 * rem_count\n                    elif rem_num == 5:\n                        score += 50 * rem_count\n                used_dice += sum(remaining_counts.values())\n                break\n    \n    # Four of a kind\n    if score == 0:  # Only check if we haven't scored yet\n        for num, count in remaining_counts.items():\n            if count >= 4:\n                if num == 1:\n                    score += 2000\n                else:\n                    score += num * 100 * 2\n                remaining_counts[num] -= 4\n                used_dice += 4\n                \n                # Score remaining dice\n                for rem_num, rem_count in remaining_counts.items():\n                    if rem_num == 1:\n                        score += 100 * rem_count\n                    elif rem_num == 5:\n                        score += 50 * rem_count\n                used_dice += sum(remaining_counts.values())\n                break\n    \n    # Now handle regular scoring if no special combinations were found\n    if score == 0:\n        # Check for straight\n        if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n            return 1000\n        \n        # Check for three pairs\n        if len(dice) == 6 and list(remaining_counts.values()).count(2) == 3:\n            return 750\n        \n        # Handle three of a kinds and singles\n        temp_counts = remaining_counts.copy()\n        \n        # Process three of a kinds\n        for num, count in list(temp_counts.items()):\n            while temp_counts[num] >= 3:\n                if num == 1:\n                    score += 1000\n                else:\n                    score += num * 100\n                temp_counts[num] -= 3\n                used_dice += 3\n        \n        # Score remaining 1s and 5s\n        for num, count in temp_counts.items():\n            if count > 0:\n                if num == 1:\n                    score += 100 * count\n                    used_dice += count\n                elif num == 5:\n                    score += 50 * count\n                    used_dice += count\n    \n    # If we haven't used all dice and have no score, it's Zonk\n    if used_dice == 0 and score == 0:\n        # Special case: check if we have any 1s or 5s\n        has_scoring = any(num in [1, 5] for num in dice)\n        if not has_scoring and len(dice) < 6:\n            return \"Zonk\"\n        elif not has_scoring and len(dice) == 6:\n            # Check if it's a valid combination\n            if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n                return 1000\n            elif list(counts.values()).count(2) == 3:\n                return 750\n            else:\n                return \"Zonk\"\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if len(dice) == 0:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Calculate score\n    score = 0\n    remaining_counts = counts.copy()\n    \n    # Handle six of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 6:\n            if num == 1:\n                score += 4 * 1000\n            else:\n                score += 4 * num * 100\n            remaining_counts[num] -= 6\n    \n    # Handle five of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 5:\n            if num == 1:\n                score += 3 * 1000\n            else:\n                score += 3 * num * 100\n            remaining_counts[num] -= 5\n    \n    # Handle four of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 4:\n            if num == 1:\n                score += 2 * 1000\n            else:\n                score += 2 * num * 100\n            remaining_counts[num] -= 4\n    \n    # Handle three of a kind\n    for num in list(remaining_counts.keys()):\n        if remaining_counts[num] >= 3:\n            if num == 1:\n                score += 1000\n            else:\n                score += num * 100\n            remaining_counts[num] -= 3\n    \n    # Handle remaining 1s and 5s\n    score += remaining_counts.get(1, 0) * 100\n    score += remaining_counts.get(5, 0) * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\nimport sys\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    def calculate_max_score(counts):\n        # Base case: no dice left\n        if not counts:\n            return 0\n            \n        max_score = 0\n        \n        # Check for six of a kind\n        for num in range(1, 7):\n            if counts[num] >= 6:\n                new_counts = counts.copy()\n                new_counts[num] -= 6\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base_score = (1000 if num == 1 else num * 100) * 4\n                score = base_score + calculate_max_score(new_counts)\n                max_score = max(max_score, score)\n                break\n        \n        # Check for five of a kind\n        if max_score == 0:\n            for num in range(1, 7):\n                if counts[num] >= 5:\n                    new_counts = counts.copy()\n                    new_counts[num] -= 5\n                    if new_counts[num] == 0:\n                        del new_counts[num]\n                    base_score = (1000 if num == 1 else num * 100) * 3\n                    score = base_score + calculate_max_score(new_counts)\n                    max_score = max(max_score, score)\n                    break\n        \n        # Check for four of a kind\n        if max_score == 0:\n            for num in range(1, 7):\n                if counts[num] >= 4:\n                    new_counts = counts.copy()\n                    new_counts[num] -= 4\n                    if new_counts[num] == 0:\n                        del new_counts[num]\n                    base_score = (1000 if num == 1 else num * 100) * 2\n                    score = base_score + calculate_max_score(new_counts)\n                    max_score = max(max_score, score)\n                    break\n        \n        # Check for straight\n        if max_score == 0 and len(counts) == 6 and all(count == 1 for count in counts.values()):\n            return 1000\n        \n        # Check for three pairs\n        if max_score == 0 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n            return 750\n            \n        # Check for three pairs (alternative pattern)\n        if max_score == 0 and len(counts) <= 3:\n            pairs = sum(count // 2 for count in counts.values())\n            if pairs >= 3:\n                return 750\n        \n        # Check for three of a kind\n        for num in range(1, 7):\n            if counts[num] >= 3:\n                new_counts = counts.copy()\n                new_counts[num] -= 3\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base_score = 1000 if num == 1 else num * 100\n                score = base_score + calculate_max_score(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for singles (1s and 5s)\n        score_from_singles = 0\n        new_counts = counts.copy()\n        \n        # Score all 1s\n        if 1 in new_counts:\n            score_from_singles += new_counts[1] * 100\n            del new_counts[1]\n            \n        # Score all 5s\n        if 5 in new_counts:\n            score_from_singles += new_counts[5] * 50\n            del new_counts[5]\n            \n        # Score remaining combinations recursively\n        if score_from_singles > 0:\n            score = score_from_singles + calculate_max_score(new_counts)\n            max_score = max(max_score, score)\n        \n        return max_score\n    \n    # Special handling for three pairs\n    if len(dice) == 6:\n        pairs = sum(count // 2 for count in counts.values())\n        if pairs >= 3:\n            # Try both approaches: three pairs vs individual scoring\n            pair_score = 750\n            individual_score = calculate_max_score(counts)\n            return max(pair_score, individual_score)\n    \n    score = calculate_max_score(counts)\n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\nif __name__ == \"__main__\":\n    input_line = input().strip()\n    # Parse the input line as a list of integers\n    dice = eval(input_line)\n    result = get_score(dice)\n    print(result)\n\n\n"], "prompt_tokens": [18312, 19216, 18731, 21196, 20512, 19942, 18443, 19549, 18416, 20346], "completion_tokens": [5009, 5627, 5646, 5571, 6969, 7777, 5865, 6926, 5384, 7263], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 3554}
{"name": "4724", "description": "DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.", "difficulty": "introductory", "id": 4724, "sample_io": [{"input": "apple of banana", "output": ["Apple of Banana"]}, {"input": "apple", "output": ["Apple"]}, {"input": "one   space", "output": ["One   Space"]}, {"input": "   space WALK   ", "output": ["   Space Walk   "]}], "test_list": [{"input": "Apple Banana", "output": ["Apple Banana"]}, {"input": "Apple", "output": ["Apple"]}, {"input": "", "output": [""]}, {"input": "of", "output": ["of"]}, {"input": "Revelation of the contents outraged American public opinion, and helped generate", "output": ["Revelation of The Contents Outraged American Public Opinion, And Helped Generate"]}, {"input": "more  than    one space between words", "output": ["More  Than    One Space Between Words"]}, {"input": "  leading spaces", "output": ["  Leading Spaces"]}, {"input": "trailing spaces   ", "output": ["Trailing Spaces   "]}, {"input": "ALL CAPS CRAZINESS", "output": ["All Caps Craziness"]}, {"input": "rAnDoM CaPs CrAzInEsS", "output": ["Random Caps Craziness"]}], "starter_code": "\ndef drop_cap(str_):\n\t", "source_codes": ["def drop_cap(s):\n    result = []\n    current_word = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            current_word += char\n        else:\n            # Process the current word if it exists\n            if current_word:\n                if len(current_word) > 2:\n                    result.append(current_word.capitalize())\n                else:\n                    result.append(current_word)\n                current_word = \"\"\n            # Add the non-alphabetic character (space, etc.)\n            result.append(char)\n    \n    # Don't forget the last word if the string doesn't end with a space\n    if current_word:\n        if len(current_word) > 2:\n            result.append(current_word.capitalize())\n        else:\n            result.append(current_word)\n    \n    return [''.join(result)]\n\ns = input()\nprint(drop_cap(s))", "def drop_cap(s):\n    words = s.split(' ')\n    result = []\n    \n    for word in words:\n        if len(word) > 2:\n            result.append(word.capitalize())\n        else:\n            result.append(word)\n    \n    return ' '.join(result)\n\ns = input()\nprint(drop_cap(s))"], "responses": ["\ndef drop_cap(s):\n    result = []\n    current_word = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            current_word += char\n        else:\n            # Process the current word if it exists\n            if current_word:\n                if len(current_word) > 2:\n                    result.append(current_word.capitalize())\n                else:\n                    result.append(current_word)\n                current_word = \"\"\n            # Add the non-alphabetic character (space, etc.)\n            result.append(char)\n    \n    # Don't forget the last word if the string doesn't end with a space\n    if current_word:\n        if len(current_word) > 2:\n            result.append(current_word.capitalize())\n        else:\n            result.append(current_word)\n    \n    return [''.join(result)]\n\ns = input()\nprint(drop_cap(s))\n\n\n", "\ndef drop_cap(s):\n    words = s.split(' ')\n    result = []\n    \n    for word in words:\n        if len(word) > 2:\n            result.append(word.capitalize())\n        else:\n            result.append(word)\n    \n    return ' '.join(result)\n\ns = input()\nprint(drop_cap(s))\n\n\n"], "prompt_tokens": [4730, 4458], "completion_tokens": [2169, 1852], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 4724}
{"name": "4561", "description": "Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st):\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!", "difficulty": "introductory", "id": 4561, "sample_io": [{"input": "adfa", "output": [true]}, {"input": "bd", "output": [true]}], "test_list": [{"input": "abba", "output": [true]}, {"input": "abaazaba", "output": [false]}, {"input": "abccba", "output": [true]}, {"input": "adfa", "output": [true]}, {"input": "ae", "output": [false]}, {"input": "abzy", "output": [false]}, {"input": "ababbaba", "output": [true]}, {"input": "sq", "output": [true]}, {"input": "kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm", "output": [true]}], "starter_code": "\ndef solve(st):\n\t", "source_codes": ["def solve(st):\n    n = len(st)\n    for i in range(n // 2 + 1):\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        # Calculate the difference in ASCII values\n        diff = abs(ord(left_char) - ord(right_char))\n        \n        # If characters are the same, they can match as-is\n        if diff == 0:\n            continue\n            \n        # If difference is 1, they can match (one can transform to the other)\n        elif diff == 1:\n            continue\n            \n        # If difference is 2, they can both transform to a middle character\n        # e.g., 'b' and 'd' can both become 'c'\n        elif diff == 2:\n            continue\n            \n        # Special problematic cases\n        else:\n            return False\n    \n    return True\n\n# Read input and solve\nst = input().strip()\nprint(solve(st))"], "responses": ["\ndef solve(st):\n    n = len(st)\n    for i in range(n // 2 + 1):\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        # Calculate the difference in ASCII values\n        diff = abs(ord(left_char) - ord(right_char))\n        \n        # If characters are the same, they can match as-is\n        if diff == 0:\n            continue\n            \n        # If difference is 1, they can match (one can transform to the other)\n        elif diff == 1:\n            continue\n            \n        # If difference is 2, they can both transform to a middle character\n        # e.g., 'b' and 'd' can both become 'c'\n        elif diff == 2:\n            continue\n            \n        # Special problematic cases\n        else:\n            return False\n    \n    return True\n\n# Read input and solve\nst = input().strip()\nprint(solve(st))\n\n\n"], "prompt_tokens": [7818], "completion_tokens": [4114], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4561}
{"name": "4468", "description": "## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`", "difficulty": "introductory", "id": 4468, "sample_io": [{"input": "0", "output": [""]}, {"input": "56", "output": ["5*10+6"]}, {"input": "60", "output": ["6*10"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "10004", "output": ["1*10000+4"]}], "test_list": [{"input": "8964631", "output": ["8*1000000+9*100000+6*10000+4*1000+6*100+3*10+1"]}, {"input": "56", "output": ["5*10+6"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "11", "output": ["1*10+1"]}, {"input": "991", "output": ["9*100+9*10+1"]}, {"input": "47", "output": ["4*10+7"]}, {"input": "234", "output": ["2*100+3*10+4"]}, {"input": "196587", "output": ["1*100000+9*10000+6*1000+5*100+8*10+7"]}, {"input": "660", "output": ["6*100+6*10"]}, {"input": "600", "output": ["6*100"]}, {"input": "9090", "output": ["9*1000+9*10"]}, {"input": "10104", "output": ["1*10000+1*100+4"]}, {"input": "80008", "output": ["8*10000+8"]}, {"input": "90000", "output": ["9*10000"]}, {"input": "0", "output": [""]}], "starter_code": "\ndef simplify(n):\n\t", "source_codes": ["def expanded_form(num):\n    if num == 0:\n        return \"\"\n    \n    num_str = str(num)\n    length = len(num_str)\n    parts = []\n    \n    for i, digit in enumerate(num_str):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                parts.append(digit)\n            else:\n                parts.append(f\"{digit}*1{'0' * power}\")\n    \n    return \"+\".join(parts)\n\n# Read input and print output\nnum = int(input())\nprint(expanded_form(num))"], "responses": ["\ndef expanded_form(num):\n    if num == 0:\n        return \"\"\n    \n    num_str = str(num)\n    length = len(num_str)\n    parts = []\n    \n    for i, digit in enumerate(num_str):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                parts.append(digit)\n            else:\n                parts.append(f\"{digit}*1{'0' * power}\")\n    \n    return \"+\".join(parts)\n\n# Read input and print output\nnum = int(input())\nprint(expanded_form(num))\n\n\n"], "prompt_tokens": [7661], "completion_tokens": [3052], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4468}
{"name": "3613", "description": "# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 \u2264 string1.length \u2264 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value", "difficulty": "introductory", "id": 3613, "sample_io": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}], "test_list": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}, {"input": "aaxxaaz\naazzaay", "output": [true]}, {"input": "aaxyaa\naazzaa", "output": [false]}, {"input": "aazzaa\naaxyaa", "output": [false]}, {"input": "jpeuizmi\nmxxcwriq", "output": [false]}], "starter_code": "\ndef is_substitution_cipher(s1, s2):\n\t", "source_codes": ["def canObtainFromEachOther(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    # Create mapping dictionaries\n    map1to2 = {}\n    map2to1 = {}\n    \n    # Check each character pair\n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check if there's already a mapping for char1\n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            map1to2[char1] = char2\n            \n        # Check if there's already a mapping for char2\n        if char2 in map2to1:\n            if map2to1[char2] != char1:\n                return False\n        else:\n            map2to1[char2] = char1\n    \n    return True\n\n# Read inputs\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Check and print result\nresult = canObtainFromEachOther(string1, string2)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")"], "responses": ["\ndef canObtainFromEachOther(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    # Create mapping dictionaries\n    map1to2 = {}\n    map2to1 = {}\n    \n    # Check each character pair\n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check if there's already a mapping for char1\n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            map1to2[char1] = char2\n            \n        # Check if there's already a mapping for char2\n        if char2 in map2to1:\n            if map2to1[char2] != char1:\n                return False\n        else:\n            map2to1[char2] = char1\n    \n    return True\n\n# Read inputs\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Check and print result\nresult = canObtainFromEachOther(string1, string2)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")\n\n\n"], "prompt_tokens": [8182], "completion_tokens": [5233], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3613}
{"name": "4465", "description": "Write a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.", "difficulty": "introductory", "id": 4465, "sample_io": [{"input": "123456", "output": [654321]}, {"input": "105", "output": [510]}, {"input": "12", "output": [21]}], "test_list": [{"input": "69", "output": [96]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [7210]}, {"input": "414", "output": [441]}, {"input": "608719", "output": [987610]}, {"input": "123456789", "output": [987654321]}, {"input": "700000000001", "output": [710000000000]}, {"input": "666666", "output": [666666]}, {"input": "2", "output": [2]}, {"input": "0", "output": [0]}], "starter_code": "\ndef super_size(n):\n\t", "source_codes": ["def super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)"], "responses": ["\ndef super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)\n\n\n"], "prompt_tokens": [6598], "completion_tokens": [2211], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4465}
{"name": "3045", "description": "Given 2 elevators (named \"left\" and \"right\") in a building with 3 floors (numbered `0` to `2`), write a function `elevator` accepting 3 arguments (in order):\n\n- `left` - The current floor of the left elevator\n- `right` - The current floor of the right elevator\n- `call` -  The floor that called an elevator\n\nIt should return the name of the elevator closest to the called floor (`\"left\"`/`\"right\"`).\n\nIn the case where both elevators are equally distant from the called floor, choose the elevator to the right.\n\nYou can assume that the inputs will always be valid integers between 0-2.\n\nExamples:\n\n```python\nelevator(0, 1, 0) # => \"left\"\nelevator(0, 1, 1) # => \"right\"\nelevator(0, 1, 2) # => \"right\"\nelevator(0, 0, 0) # => \"right\"\nelevator(0, 2, 1) # => \"right\"\n```", "difficulty": "introductory", "id": 3045, "sample_io": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}], "test_list": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}, {"input": "0\n0\n1", "output": ["right"]}, {"input": "0\n0\n2", "output": ["right"]}, {"input": "0\n2\n0", "output": ["left"]}, {"input": "0\n2\n2", "output": ["right"]}, {"input": "1\n0\n0", "output": ["right"]}, {"input": "1\n0\n1", "output": ["left"]}, {"input": "1\n0\n2", "output": ["left"]}, {"input": "1\n1\n0", "output": ["right"]}, {"input": "1\n1\n1", "output": ["right"]}, {"input": "1\n1\n2", "output": ["right"]}, {"input": "1\n2\n0", "output": ["left"]}, {"input": "1\n2\n1", "output": ["left"]}, {"input": "1\n2\n2", "output": ["right"]}, {"input": "2\n0\n0", "output": ["right"]}, {"input": "2\n0\n1", "output": ["right"]}, {"input": "2\n0\n2", "output": ["left"]}, {"input": "2\n1\n0", "output": ["right"]}, {"input": "2\n1\n1", "output": ["right"]}, {"input": "2\n1\n2", "output": ["left"]}, {"input": "2\n2\n0", "output": ["right"]}, {"input": "2\n2\n1", "output": ["right"]}, {"input": "2\n2\n2", "output": ["right"]}], "starter_code": "\ndef elevator(left, right, call):\n\t", "source_codes": ["def elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    elif right_distance < left_distance:\n        return \"right\"\n    else:\n        # Equal distance, choose right\n        return \"right\"", "def elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    else:  # right_distance <= left_distance, choose right\n        return \"right\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))"], "responses": ["\ndef elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    elif right_distance < left_distance:\n        return \"right\"\n    else:\n        # Equal distance, choose right\n        return \"right\"\n\n\n", "\ndef elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    else:  # right_distance <= left_distance, choose right\n        return \"right\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))\n\n\n"], "prompt_tokens": [8945, 8350], "completion_tokens": [4425, 3109], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 3045}
{"name": "4276", "description": "Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```", "difficulty": "introductory", "id": 4276, "sample_io": [{"input": "4.2", "output": [4]}, {"input": "4.3", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.8", "output": [5]}, {"input": "4.75", "output": [5]}], "test_list": [{"input": "4.2", "output": [4]}, {"input": "4.25", "output": [4.5]}, {"input": "4.4", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.75", "output": [5]}, {"input": "4.8", "output": [5]}, {"input": "4.5", "output": [4.5]}, {"input": "4.55", "output": [4.5]}, {"input": "4.74", "output": [4.5]}, {"input": "4.74999999999", "output": [4.5]}, {"input": "4.74999999991", "output": [4.5]}], "starter_code": "\ndef solution(n):\n\t", "source_codes": ["import math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Check if it's exactly halfway between two integers\n    fractional_part = doubled - math.floor(doubled)\n    \n    if fractional_part < 0.5:\n        # Closer to lower integer\n        rounded = math.floor(doubled)\n    elif fractional_part > 0.5:\n        # Closer to higher integer\n        rounded = math.ceil(doubled)\n    else:\n        # Exactly halfway - round away from zero\n        if doubled >= 0:\n            rounded = math.ceil(doubled)\n        else:\n            rounded = math.floor(doubled)\n    \n    # Divide by 2 to get back to original scale\n    result = rounded / 2\n    \n    # Format output: no decimal places if whole number\n    if result == int(result):\n        return int(result)\n    else:\n        return result\n\n# Read input and process\nnumber = float(input())\nresult = solution(number)\nprint(result)"], "responses": ["\nimport math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Check if it's exactly halfway between two integers\n    fractional_part = doubled - math.floor(doubled)\n    \n    if fractional_part < 0.5:\n        # Closer to lower integer\n        rounded = math.floor(doubled)\n    elif fractional_part > 0.5:\n        # Closer to higher integer\n        rounded = math.ceil(doubled)\n    else:\n        # Exactly halfway - round away from zero\n        if doubled >= 0:\n            rounded = math.ceil(doubled)\n        else:\n            rounded = math.floor(doubled)\n    \n    # Divide by 2 to get back to original scale\n    result = rounded / 2\n    \n    # Format output: no decimal places if whole number\n    if result == int(result):\n        return int(result)\n    else:\n        return result\n\n# Read input and process\nnumber = float(input())\nresult = solution(number)\nprint(result)\n\n\n"], "prompt_tokens": [6794], "completion_tokens": [3137], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4276}
{"name": "2882", "description": "Imagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000", "difficulty": "introductory", "id": 2882, "sample_io": [{"input": "4", "output": [34]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [15]}, {"input": "4", "output": [34]}, {"input": "15", "output": [1695]}, {"input": "150", "output": [1687575]}, {"input": "100", "output": [500050]}, {"input": "500", "output": [62500250]}, {"input": "1000", "output": [500000500]}, {"input": "10000", "output": [500000005000]}], "starter_code": "\ndef cumulative_triangle(n):\n\t", "source_codes": ["n = int(input())\nfirst = (n - 1) * n // 2 + 1\nlast = n * (n + 1) // 2\nresult = n * (first + last) // 2\nprint(result)"], "responses": ["\nn = int(input())\nfirst = (n - 1) * n // 2 + 1\nlast = n * (n + 1) // 2\nresult = n * (first + last) // 2\nprint(result)\n\n\n"], "prompt_tokens": [6476], "completion_tokens": [2680], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2882}
{"name": "4440", "description": "ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but **exactly** 4 digits or exactly 6 digits. \n\nIf the function is passed a valid PIN string, return `true`, else return `false`.\n\n## Examples \n```\n\"1234\"   -->  true\n\"12345\"  -->  false\n\"a234\"   -->  false\n```", "difficulty": "introductory", "id": 4440, "sample_io": [{"input": "1234", "output": [true]}, {"input": "12345", "output": [false]}, {"input": "a234", "output": [false]}], "test_list": [{"input": "1", "output": [false]}, {"input": "12", "output": [false]}, {"input": "123", "output": [false]}, {"input": "12345", "output": [false]}, {"input": "1234567", "output": [false]}, {"input": "-1234", "output": [false]}, {"input": "-12345", "output": [false]}, {"input": "1.234", "output": [false]}, {"input": "00000000", "output": [false]}, {"input": "a234", "output": [false]}, {"input": ".234", "output": [false]}, {"input": "1234", "output": [true]}, {"input": "0000", "output": [true]}, {"input": "1111", "output": [true]}, {"input": "123456", "output": [true]}, {"input": "098765", "output": [true]}, {"input": "000000", "output": [true]}, {"input": "090909", "output": [true]}], "starter_code": "\ndef validate_pin(pin):\n\t", "source_codes": ["def validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) == 4 or len(pin) == 6:\n        # Check if all characters are digits\n        if pin.isdigit():\n            return True\n    return False\n\n# Read input from standard input\npin = input().strip()\n\n# Call the function and print the result\nresult = validate_pin(pin)\nprint(str(result).capitalize())"], "responses": ["\ndef validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) == 4 or len(pin) == 6:\n        # Check if all characters are digits\n        if pin.isdigit():\n            return True\n    return False\n\n# Read input from standard input\npin = input().strip()\n\n# Call the function and print the result\nresult = validate_pin(pin)\nprint(str(result).capitalize())\n\n\n"], "prompt_tokens": [6273], "completion_tokens": [2038], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4440}
{"name": "2771", "description": "Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book G\u00f6del, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!", "difficulty": "introductory", "id": 2771, "sample_io": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}], "test_list": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}, {"input": "100", "output": [56]}, {"input": "1000", "output": [502]}], "starter_code": "\ndef hofstadter_Q(n):\n\t", "source_codes": ["import sys\n\ndef hofstadter_q(n):\n    if n <= 2:\n        return 1\n    \n    # Initialize memoization array with base cases\n    q = [0] * (n + 1)\n    q[1] = 1\n    q[2] = 1\n    \n    # Compute values iteratively\n    for i in range(3, n + 1):\n        q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n    \n    return q[n]\n\n# Read input and compute result\nn = int(input().strip())\nresult = hofstadter_q(n)\nprint(result)"], "responses": ["\nimport sys\n\ndef hofstadter_q(n):\n    if n <= 2:\n        return 1\n    \n    # Initialize memoization array with base cases\n    q = [0] * (n + 1)\n    q[1] = 1\n    q[2] = 1\n    \n    # Compute values iteratively\n    for i in range(3, n + 1):\n        q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n    \n    return q[n]\n\n# Read input and compute result\nn = int(input().strip())\nresult = hofstadter_q(n)\nprint(result)\n\n\n"], "prompt_tokens": [7804], "completion_tokens": [2943], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2771}
{"name": "4335", "description": "What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:\n\n```\n'abba' & 'baab' == true\n\n'abba' & 'bbaa' == true\n\n'abba' & 'abbba' == false\n\n'abba' & 'abca' == false\n```\n\nWrite a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:\n\nanagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']\n\nanagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']\n\nanagrams('laser', ['lazing', 'lazy',  'lacer']) => []", "difficulty": "introductory", "id": 4335, "sample_io": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "laser\n['lazing', 'lazy', 'lacer']", "output": [[]]}], "test_list": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "a\n['a', 'b', 'c', 'd']", "output": [["a"]]}, {"input": "ab\n['cc', 'ac', 'bc', 'cd', 'ab', 'ba', 'racar', 'caers', 'racer']", "output": [["ab", "ba"]]}, {"input": "abba\n['a', 'b', 'c', 'd', 'aabb', 'bbaa', 'abab', 'baba', 'baab', 'abcd', 'abbba', 'baaab', 'abbab', 'abbaa', 'babaa']", "output": [["aabb", "bbaa", "abab", "baba", "baab"]]}, {"input": "big\n['gig', 'dib', 'bid', 'biig']", "output": [[]]}], "starter_code": "\ndef anagrams(word, words):\n\t", "source_codes": ["def anagrams(word, candidates):\n    sorted_word = sorted(word)\n    result = []\n    for candidate in candidates:\n        if sorted(candidate) == sorted_word:\n            result.append(candidate)\n    return result\n\n# Read input\nword = input().strip()\ncandidates_str = input().strip()\n# Parse the candidates list\ncandidates = eval(candidates_str)\n\n# Find anagrams\nresult = anagrams(word, candidates)\n\n# Print result in required format\nprint(result)"], "responses": ["\ndef anagrams(word, candidates):\n    sorted_word = sorted(word)\n    result = []\n    for candidate in candidates:\n        if sorted(candidate) == sorted_word:\n            result.append(candidate)\n    return result\n\n# Read input\nword = input().strip()\ncandidates_str = input().strip()\n# Parse the candidates list\ncandidates = eval(candidates_str)\n\n# Find anagrams\nresult = anagrams(word, candidates)\n\n# Print result in required format\nprint(result)\n\n\n"], "prompt_tokens": [8198], "completion_tokens": [3192], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4335}
{"name": "3512", "description": "Just like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```", "difficulty": "introductory", "id": 3512, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "1000", "output": [5]}, {"input": "1000000", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "21", "output": [6]}, {"input": "302", "output": [1]}, {"input": "4003", "output": [7]}, {"input": "50004", "output": [8]}, {"input": "600005", "output": [5]}, {"input": "7000006", "output": [3]}, {"input": "80000007", "output": [8]}, {"input": "900000008", "output": [1]}, {"input": "1000000009", "output": [9]}], "starter_code": "\ndef last_fib_digit(n):\n\t", "source_codes": ["def last_fib_digit(n):\n    # Pisano period for mod 10 is 60\n    n = n % 60\n    if n == 0:\n        n = 60\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, (a + b) % 10\n    \n    return b\n\nn = int(input())\nprint(last_fib_digit(n))"], "responses": ["\ndef last_fib_digit(n):\n    # Pisano period for mod 10 is 60\n    n = n % 60\n    if n == 0:\n        n = 60\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, (a + b) % 10\n    \n    return b\n\nn = int(input())\nprint(last_fib_digit(n))\n\n\n"], "prompt_tokens": [7780], "completion_tokens": [2850], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3512}
{"name": "3435", "description": "# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters called airstrike to help them in war - dashes and dots are spreaded everywhere on the battlefield.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and `*` which means a bomb drop place. Return who wins the fight after bombs are exploded. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3 \n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3 \n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.  \nThe `*` bombs kills the adjacent letters ( i.e. `aa*aa` => `a___a`, `**aa**` => `______` );\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war", "difficulty": "introductory", "id": 3435, "sample_io": [], "test_list": [{"input": "z", "output": ["Right side wins!"]}, {"input": "z*dq*mw*pb*s", "output": ["Let's fight again!"]}, {"input": "zdqmwpbs", "output": ["Let's fight again!"]}, {"input": "zz*zzs", "output": ["Right side wins!"]}, {"input": "sz**z**zs", "output": ["Left side wins!"]}, {"input": "z*z*z*zs", "output": ["Left side wins!"]}, {"input": "*wwwwww*z*", "output": ["Left side wins!"]}], "starter_code": "\ndef alphabet_war(fight):\n\t", "source_codes": ["def alphabet_war(fight):\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Define powers for each side\n    left_powers = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_powers = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Mark positions destroyed by bombs\n    destroyed = [False] * len(fight)\n    for i in range(len(fight)):\n        if fight[i] == '*':\n            # Destroy left adjacent position\n            if i > 0:\n                destroyed[i-1] = True\n            # Destroy current position (bomb itself)\n            destroyed[i] = True\n            # Destroy right adjacent position\n            if i < len(fight) - 1:\n                destroyed[i+1] = True\n    \n    # Calculate scores\n    left_score = 0\n    right_score = 0\n    \n    for i in range(len(fight)):\n        if not destroyed[i]:\n            char = fight[i]\n            if char in left_powers:\n                left_score += left_powers[char]\n            elif char in right_powers:\n                right_score += right_powers[char]\n    \n    # Determine winner\n    if left_score > right_score:\n        return \"Left side wins!\"\n    elif right_score > left_score:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and execute\nfight = input().strip()\nresult = alphabet_war(fight)\nprint(result)"], "responses": ["\ndef alphabet_war(fight):\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Define powers for each side\n    left_powers = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_powers = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Mark positions destroyed by bombs\n    destroyed = [False] * len(fight)\n    for i in range(len(fight)):\n        if fight[i] == '*':\n            # Destroy left adjacent position\n            if i > 0:\n                destroyed[i-1] = True\n            # Destroy current position (bomb itself)\n            destroyed[i] = True\n            # Destroy right adjacent position\n            if i < len(fight) - 1:\n                destroyed[i+1] = True\n    \n    # Calculate scores\n    left_score = 0\n    right_score = 0\n    \n    for i in range(len(fight)):\n        if not destroyed[i]:\n            char = fight[i]\n            if char in left_powers:\n                left_score += left_powers[char]\n            elif char in right_powers:\n                right_score += right_powers[char]\n    \n    # Determine winner\n    if left_score > right_score:\n        return \"Left side wins!\"\n    elif right_score > left_score:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and execute\nfight = input().strip()\nresult = alphabet_war(fight)\nprint(result)\n\n\n"], "prompt_tokens": [8733], "completion_tokens": [5330], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3435}
{"name": "3387", "description": "What's in a name?\n..Or rather, what's a name in? For us, a particular string is where we are looking for a name.\n\nTask\n\nTest whether or not the string contains all of the letters which spell a given name, in order.\n\nThe format\nA function passing two strings, searching for one (the name) within the other.\n``function nameInStr(str, name){ return true || false }``\n\nExamples\n\n    nameInStr(\"Across the rivers\", \"chris\") --> true\n                ^      ^  ^^   ^\n                c      h  ri   s\n                \n    Contains all of the letters in \"chris\", in order.\n----------------------------------------------------------\n    nameInStr(\"Next to a lake\", \"chris\") --> false\n    \n    Contains none of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"Under a sea\", \"chris\") --> false\n                   ^   ^\n                   r   s\n                   \n    Contains only some of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"A crew that boards the ship\", \"chris\") --> false\n                 cr    h              s i\n                 cr                h  s i  \n                 c     h      r       s i\n                 ...\n                 \n    Contains all of the letters in \"chris\", but not in order.\n--------------------------------------------------------------------\n    nameInStr(\"A live son\", \"Allison\") --> false\n               ^ ^^   ^^^\n               A li   son\n                 \n    Contains all of the correct letters in \"Allison\", in order, \n    but not enough of all of them (missing an 'l').\n    \n\nNote: testing will _not_ be case-sensitive.", "difficulty": "introductory", "id": 3387, "sample_io": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}], "test_list": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}, {"input": "Just enough nice friends\nJennifer", "output": [false]}, {"input": "thomas\nThomas", "output": [true]}, {"input": "pippippi\nPippi", "output": [true]}, {"input": "pipipp\nPippi", "output": [false]}, {"input": "ppipip\nPippi", "output": [false]}], "starter_code": "\ndef name_in_str(str, name):\n\t", "source_codes": ["def nameInStr(str, name):\n    str = str.lower()\n    name = name.lower()\n    \n    i = 0  # pointer for str\n    j = 0  # pointer for name\n    \n    while i < len(str) and j < len(name):\n        if str[i] == name[j]:\n            j += 1\n        i += 1\n    \n    return j == len(name)\n\n# Read inputs\nstr_input = input()\nname_input = input()\n\n# Call function and print result\nresult = nameInStr(str_input, name_input)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")"], "responses": ["\ndef nameInStr(str, name):\n    str = str.lower()\n    name = name.lower()\n    \n    i = 0  # pointer for str\n    j = 0  # pointer for name\n    \n    while i < len(str) and j < len(name):\n        if str[i] == name[j]:\n            j += 1\n        i += 1\n    \n    return j == len(name)\n\n# Read inputs\nstr_input = input()\nname_input = input()\n\n# Call function and print result\nresult = nameInStr(str_input, name_input)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")\n\n\n"], "prompt_tokens": [9969], "completion_tokens": [3218], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3387}
{"name": "4024", "description": "# Definition \n\nA number is a **_Special Number_** *if it\u2019s digits only consist 0, 1, 2, 3, 4 or 5*\n\n**_Given_** a number *determine if it special number or not* .  \n\n\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_The number_** passed will be **_positive_** (N > 0) .\n\n* All **single-digit numbers** with in the interval **_[0:5]_** are considered as **_special number_**. \n___\n\n# Input >> Output Examples\n\n```\nspecialNumber(2) ==> return \"Special!!\"\n```\n## Explanation: \n\nIt's **_a single-digit number_** within the interval **_[0:5]_** . \n\n```\nspecialNumber(9) ==> return \"NOT!!\"\n```\n## Explanation:\n\nAlthough, it's a single-digit number but **_Outside the interval [0:5]_** .\n\n```\nspecialNumber(23) ==> return \"Special!!\"\n```\n## Explanation: \n\nAll **_the number's digits_** formed from the interval **_[0:5]_** digits .\n\n```\nspecialNumber(39) ==> return \"NOT!!\"\n```\n## Explanation: \n\nAlthough, *there is a digit (3) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(59) ==> return \"NOT!!\"\n```\n## Explanation:  \n\nAlthough, *there is a digit (5) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(513) ==> return \"Special!!\"\n```\n___\n```\nspecialNumber(709) ==> return \"NOT!!\"\n```\n___\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)          \n\n### ALL translation are welcomed\n\n## Enjoy Learning !!\n# Zizou", "difficulty": "introductory", "id": 4024, "sample_io": [{"input": "2", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "59", "output": ["NOT!!"]}, {"input": "513", "output": ["Special!!"]}, {"input": "709", "output": ["NOT!!"]}], "test_list": [{"input": "2", "output": ["Special!!"]}, {"input": "3", "output": ["Special!!"]}, {"input": "5", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "7", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "79", "output": ["NOT!!"]}, {"input": "32", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "55", "output": ["Special!!"]}, {"input": "11350224", "output": ["Special!!"]}], "starter_code": "\ndef special_number(number):\n\t", "source_codes": ["def specialNumber(n):\n    allowed_digits = {'0', '1', '2', '3', '4', '5'}\n    for digit in str(n):\n        if digit not in allowed_digits:\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input().strip())\nprint(specialNumber(n))"], "responses": ["\ndef specialNumber(n):\n    allowed_digits = {'0', '1', '2', '3', '4', '5'}\n    for digit in str(n):\n        if digit not in allowed_digits:\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input().strip())\nprint(specialNumber(n))\n\n\n"], "prompt_tokens": [10235], "completion_tokens": [2464], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4024}
{"name": "3478", "description": "Magic The Gathering is a collectible card game that features wizards battling against each other with spells and creature summons. The game itself can be quite complicated to learn. In this series of katas, we'll be solving some of the situations that arise during gameplay. You won't need any prior knowledge of the game to solve these contrived problems, as I will provide you with enough information.\n\n## Creatures\n\nEach creature has a power and toughness. We will represent this in an array. [2, 3] means this creature has a power of 2 and a toughness of 3.\n\nWhen two creatures square off, they each deal damage equal to their power to each other at the same time. If a creature takes on damage greater than or equal to their toughness, they die.\n\nExamples:\n\n- Creature 1 - [2, 3]\n- Creature 2 - [3, 3]\n- Creature 3 - [1, 4]\n- Creature 4 - [4, 1]\n\nIf creature 1 battles creature 2, creature 1 dies, while 2 survives. If creature 3 battles creature 4, they both die, as 3 deals 1 damage to 4, but creature 4 only has a toughness of 1.\n\nWrite a function `battle(player1, player2)` that takes in 2 arrays of creatures. Each players' creatures battle each other in order (player1[0] battles the creature in player2[0]) and so on. If one list of creatures is longer than the other, those creatures are considered unblocked, and do not battle.\n\nYour function should return an object (a hash in Ruby) with the keys player1 and player2 that contain the power and toughness of the surviving creatures.\n\nExample:\n```\nGood luck with your battles!\n\n\nCheck out my other Magic The Gathering katas:\n\n\nMagic The Gathering #1: Creatures\nMagic The Gathering #2: Mana", "difficulty": "introductory", "id": 3478, "sample_io": [], "test_list": [{"input": "[[2, 3], [1, 4]]\n[[3, 3], [4, 1]]", "output": [{"player1": [], "player2": [[3, 3]]}]}, {"input": "[]\n[]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 1]]\n[[1, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 1]]\n[[2, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 2]]\n[[1, 2]]", "output": [{"player1": [[1, 2]], "player2": [[1, 2]]}]}, {"input": "[[2, 3]]\n[[3, 2]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 7]]\n[[3, 5]]", "output": [{"player1": [[2, 7]], "player2": [[3, 5]]}]}, {"input": "[[2, 5]]\n[[6, 6]]", "output": [{"player1": [], "player2": [[6, 6]]}]}, {"input": "[[6, 6]]\n[[2, 5]]", "output": [{"player1": [[6, 6]], "player2": []}]}, {"input": "[]\n[[1, 1], [2, 2]]", "output": [{"player1": [], "player2": [[1, 1], [2, 2]]}]}, {"input": "[[1, 1], [2, 2]]\n[]", "output": [{"player1": [[1, 1], [2, 2]], "player2": []}]}, {"input": "[[1, 3], [3, 5], [4, 6], [5, 2]]\n[[2, 4], [6, 1], [4, 4], [3, 7], [3, 1]]", "output": [{"player1": [[1, 3], [4, 6]], "player2": [[2, 4], [3, 7], [3, 1]]}]}], "starter_code": "\ndef battle(player1, player2):\n\t", "source_codes": ["def battle(player1, player2):\n    result = {'player1': [], 'player2': []}\n    \n    # Battle paired creatures\n    min_len = min(len(player1), len(player2))\n    for i in range(min_len):\n        p1_power, p1_toughness = player1[i]\n        p2_power, p2_toughness = player2[i]\n        \n        # A creature survives if damage taken is less than its toughness\n        p1_survives = p1_toughness > p2_power  # p1 survives if p1's toughness > p2's power\n        p2_survives = p2_toughness > p1_power  # p2 survives if p2's toughness > p1's power\n        \n        if p1_survives:\n            result['player1'].append(player1[i])\n        if p2_survives:\n            result['player2'].append(player2[i])\n    \n    # Add remaining unblocked creatures\n    if len(player1) > min_len:\n        result['player1'].extend(player1[min_len:])\n    if len(player2) > min_len:\n        result['player2'].extend(player2[min_len:])\n        \n    return result\n\n# Read input and call function\nif __name__ == \"__main__\":\n    try:\n        # Try to read direct list format\n        player1 = eval(input().strip())\n        player2 = eval(input().strip())\n    except:\n        # Fallback for assignment format\n        line = input().strip()\n        exec(line)\n        line2 = input().strip()\n        exec(line2)\n    \n    result = battle(player1, player2)\n    print(result)"], "responses": ["\ndef battle(player1, player2):\n    result = {'player1': [], 'player2': []}\n    \n    # Battle paired creatures\n    min_len = min(len(player1), len(player2))\n    for i in range(min_len):\n        p1_power, p1_toughness = player1[i]\n        p2_power, p2_toughness = player2[i]\n        \n        # A creature survives if damage taken is less than its toughness\n        p1_survives = p1_toughness > p2_power  # p1 survives if p1's toughness > p2's power\n        p2_survives = p2_toughness > p1_power  # p2 survives if p2's toughness > p1's power\n        \n        if p1_survives:\n            result['player1'].append(player1[i])\n        if p2_survives:\n            result['player2'].append(player2[i])\n    \n    # Add remaining unblocked creatures\n    if len(player1) > min_len:\n        result['player1'].extend(player1[min_len:])\n    if len(player2) > min_len:\n        result['player2'].extend(player2[min_len:])\n        \n    return result\n\n# Read input and call function\nif __name__ == \"__main__\":\n    try:\n        # Try to read direct list format\n        player1 = eval(input().strip())\n        player2 = eval(input().strip())\n    except:\n        # Fallback for assignment format\n        line = input().strip()\n        exec(line)\n        line2 = input().strip()\n        exec(line2)\n    \n    result = battle(player1, player2)\n    print(result)\n\n\n"], "prompt_tokens": [11352], "completion_tokens": [4998], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3478}
{"name": "3766", "description": "~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)", "difficulty": "introductory", "id": 3766, "sample_io": [{"input": "100", "output": [[2, 2, 5, 5]]}], "test_list": [{"input": "10", "output": [[2, 5]]}, {"input": "100", "output": [[2, 2, 5, 5]]}, {"input": "1000", "output": [[2, 2, 2, 5, 5, 5]]}, {"input": "1000001", "output": [[101, 9901]]}, {"input": "0", "output": [[]]}, {"input": "1", "output": [[1]]}, {"input": "2", "output": [[2]]}, {"input": "a", "output": [[]]}, {"input": "1.1", "output": [[]]}, {"input": "-1", "output": [[]]}], "starter_code": "\ndef getAllPrimeFactors(n):\n\t", "source_codes": ["import sys\n\ndef getAllPrimeFactors(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    if n == 1:\n        return [1]\n    \n    factors = []\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    \n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n    \n    unique_primes = []\n    counts = []\n    for factor in factors:\n        if not unique_primes or factor != unique_primes[-1]:\n            unique_primes.append(factor)\n            counts.append(1)\n        else:\n            counts[-1] += 1\n    \n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    if n == 1:\n        return [1]\n    \n    unique_factors_with_count = getUniquePrimeFactorsWithCount(n)\n    if not unique_factors_with_count[0]:\n        return []\n    \n    primes, counts = unique_factors_with_count\n    products = []\n    for i in range(len(primes)):\n        products.append(primes[i] ** counts[i])\n    return products\n\n# Read input\ntry:\n    n = int(input())\nexcept:\n    n = None\n\n# Process and output only getAllPrimeFactors\nresult1 = getAllPrimeFactors(n) if isinstance(n, int) else []\nprint(result1)"], "responses": ["\nimport sys\n\ndef getAllPrimeFactors(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    if n == 1:\n        return [1]\n    \n    factors = []\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    \n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n    \n    unique_primes = []\n    counts = []\n    for factor in factors:\n        if not unique_primes or factor != unique_primes[-1]:\n            unique_primes.append(factor)\n            counts.append(1)\n        else:\n            counts[-1] += 1\n    \n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    if n == 1:\n        return [1]\n    \n    unique_factors_with_count = getUniquePrimeFactorsWithCount(n)\n    if not unique_factors_with_count[0]:\n        return []\n    \n    primes, counts = unique_factors_with_count\n    products = []\n    for i in range(len(primes)):\n        products.append(primes[i] ** counts[i])\n    return products\n\n# Read input\ntry:\n    n = int(input())\nexcept:\n    n = None\n\n# Process and output only getAllPrimeFactors\nresult1 = getAllPrimeFactors(n) if isinstance(n, int) else []\nprint(result1)\n\n\n"], "prompt_tokens": [15296], "completion_tokens": [4931], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3766}
{"name": "3292", "description": "Given a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```", "difficulty": "introductory", "id": 3292, "sample_io": [{"input": "ABC", "output": [6]}], "test_list": [{"input": "abcdef", "output": [6]}, {"input": "ifkhchlhfd", "output": [6]}, {"input": "aaaaaddddr", "output": [30]}, {"input": "jfmgklf8hglbe", "output": [6]}, {"input": "jaam", "output": [12]}, {"input": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "output": [96]}], "starter_code": "\ndef calc(x):\n\t", "source_codes": ["s = input().strip()\n\n# Step 1: Convert each character to ASCII and concatenate to form total1\ntotal1 = ''.join(str(ord(char)) for char in s)\n\n# Step 2: Replace all occurrences of '7' with '1' to form total2\ntotal2 = total1.replace('7', '1')\n\n# Step 3: Calculate sum of digits in total1 and total2\nsum1 = sum(int(digit) for digit in total1)\nsum2 = sum(int(digit) for digit in total2)\n\n# Step 4: Output the difference\nprint(sum1 - sum2)"], "responses": ["\ns = input().strip()\n\n# Step 1: Convert each character to ASCII and concatenate to form total1\ntotal1 = ''.join(str(ord(char)) for char in s)\n\n# Step 2: Replace all occurrences of '7' with '1' to form total2\ntotal2 = total1.replace('7', '1')\n\n# Step 3: Calculate sum of digits in total1 and total2\nsum1 = sum(int(digit) for digit in total1)\nsum2 = sum(int(digit) for digit in total2)\n\n# Step 4: Output the difference\nprint(sum1 - sum2)\n\n\n"], "prompt_tokens": [6850], "completion_tokens": [2637], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3292}
{"name": "2886", "description": "# Description:\n\n Find the longest successive exclamation marks and question marks combination in the string. A successive exclamation marks and question marks combination must contains two part: a substring of \"!\" and a substring \"?\", they are adjacent. \n \n If more than one result are found, return the one which at left side; If no such a combination found, return `\"\"`.\n\n# Examples\n\n```\nfind(\"!!\") === \"\"\nfind(\"!??\") === \"!??\"\nfind(\"!?!!\") === \"?!!\"\nfind(\"!!???!????\") === \"!!???\"\nfind(\"!!???!?????\") === \"!?????\"\nfind(\"!????!!!?\") === \"????!!!\" \nfind(\"!?!!??!!!?\") === \"??!!!\"\n```\n\n# Note\nPlease don't post issue about difficulty or duplicate. Because:\n>[That's unfair on the kata creator. This is a valid kata and introduces new people to javascript some regex or loops, depending on how they tackle this problem.  --matt c](https://www.codewars.com/kata/remove-exclamation-marks/discuss#57fabb625c9910c73000024e)", "difficulty": "introductory", "id": 2886, "sample_io": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "test_list": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "starter_code": "\ndef find(s):\n\t", "source_codes": ["def find(s):\n    if len(s) < 2:\n        return \"\"\n    \n    max_len = 0\n    result_start = -1\n    \n    i = 0\n    while i < len(s) - 1:\n        # Look for a transition point between ! and ?\n        if (s[i] == '!' and s[i+1] == '?') or (s[i] == '?' and s[i+1] == '!'):\n            # Found a transition, now expand both ways\n            # First, expand backwards to find the start of the first group\n            start = i\n            target_char = s[i]\n            while start > 0 and s[start-1] == target_char:\n                start -= 1\n            \n            # Then, expand forwards to find the end of the second group\n            end = i + 1\n            target_char = s[i+1]\n            while end < len(s) - 1 and s[end+1] == target_char:\n                end += 1\n            \n            # Calculate the length of this combination\n            combo_length = end - start + 1\n            \n            # Update if this is longer than our current max\n            if combo_length > max_len:\n                max_len = combo_length\n                result_start = start\n            \n            # Move past this combination\n            i = end + 1\n        else:\n            i += 1\n    \n    if max_len == 0:\n        return \"\"\n    else:\n        return s[result_start:result_start + max_len]\n\n# Read input and call function\ninput_str = input().strip()\nprint(find(input_str))", "def find(s):\n    if len(s) < 2:\n        return \"\"\n    \n    max_len = 0\n    result = \"\"\n    \n    i = 0\n    while i < len(s) - 1:\n        # Check for pattern: !+?+ \n        if s[i] == '!':\n            # Count consecutive !\n            j = i\n            while j < len(s) and s[j] == '!':\n                j += 1\n            excl_count = j - i\n            \n            # Check if followed by at least one ?\n            if j < len(s) and s[j] == '?':\n                # Count consecutive ?\n                k = j\n                while k < len(s) and s[k] == '?':\n                    k += 1\n                ques_count = k - j\n                \n                # This is a valid combination\n                if excl_count >= 1 and ques_count >= 1:\n                    combo = s[i:k]\n                    combo_len = len(combo)\n                    if combo_len > max_len:\n                        max_len = combo_len\n                        result = combo\n                    elif combo_len == max_len and result == \"\":\n                        result = combo\n        \n        # Check for pattern: ?+!+\n        elif s[i] == '?':\n            # Count consecutive ?\n            j = i\n            while j < len(s) and s[j] == '?':\n                j += 1\n            ques_count = j - i\n            \n            # Check if followed by at least one !\n            if j < len(s) and s[j] == '!':\n                # Count consecutive !\n                k = j\n                while k < len(s) and s[k] == '!':\n                    k += 1\n                excl_count = k - j\n                \n                # This is a valid combination\n                if ques_count >= 1 and excl_count >= 1:\n                    combo = s[i:k]\n                    combo_len = len(combo)\n                    if combo_len > max_len:\n                        max_len = combo_len\n                        result = combo\n                    elif combo_len == max_len and result == \"\":\n                        result = combo\n        \n        i += 1\n    \n    return result\n\n# Read input and print output\ns = input().strip()\nprint(find(s))"], "responses": ["\ndef find(s):\n    if len(s) < 2:\n        return \"\"\n    \n    max_len = 0\n    result_start = -1\n    \n    i = 0\n    while i < len(s) - 1:\n        # Look for a transition point between ! and ?\n        if (s[i] == '!' and s[i+1] == '?') or (s[i] == '?' and s[i+1] == '!'):\n            # Found a transition, now expand both ways\n            # First, expand backwards to find the start of the first group\n            start = i\n            target_char = s[i]\n            while start > 0 and s[start-1] == target_char:\n                start -= 1\n            \n            # Then, expand forwards to find the end of the second group\n            end = i + 1\n            target_char = s[i+1]\n            while end < len(s) - 1 and s[end+1] == target_char:\n                end += 1\n            \n            # Calculate the length of this combination\n            combo_length = end - start + 1\n            \n            # Update if this is longer than our current max\n            if combo_length > max_len:\n                max_len = combo_length\n                result_start = start\n            \n            # Move past this combination\n            i = end + 1\n        else:\n            i += 1\n    \n    if max_len == 0:\n        return \"\"\n    else:\n        return s[result_start:result_start + max_len]\n\n# Read input and call function\ninput_str = input().strip()\nprint(find(input_str))\n\n\n", "\ndef find(s):\n    if len(s) < 2:\n        return \"\"\n    \n    max_len = 0\n    result = \"\"\n    \n    i = 0\n    while i < len(s) - 1:\n        # Check for pattern: !+?+ \n        if s[i] == '!':\n            # Count consecutive !\n            j = i\n            while j < len(s) and s[j] == '!':\n                j += 1\n            excl_count = j - i\n            \n            # Check if followed by at least one ?\n            if j < len(s) and s[j] == '?':\n                # Count consecutive ?\n                k = j\n                while k < len(s) and s[k] == '?':\n                    k += 1\n                ques_count = k - j\n                \n                # This is a valid combination\n                if excl_count >= 1 and ques_count >= 1:\n                    combo = s[i:k]\n                    combo_len = len(combo)\n                    if combo_len > max_len:\n                        max_len = combo_len\n                        result = combo\n                    elif combo_len == max_len and result == \"\":\n                        result = combo\n        \n        # Check for pattern: ?+!+\n        elif s[i] == '?':\n            # Count consecutive ?\n            j = i\n            while j < len(s) and s[j] == '?':\n                j += 1\n            ques_count = j - i\n            \n            # Check if followed by at least one !\n            if j < len(s) and s[j] == '!':\n                # Count consecutive !\n                k = j\n                while k < len(s) and s[k] == '!':\n                    k += 1\n                excl_count = k - j\n                \n                # This is a valid combination\n                if ques_count >= 1 and excl_count >= 1:\n                    combo = s[i:k]\n                    combo_len = len(combo)\n                    if combo_len > max_len:\n                        max_len = combo_len\n                        result = combo\n                    elif combo_len == max_len and result == \"\":\n                        result = combo\n        \n        i += 1\n    \n    return result\n\n# Read input and print output\ns = input().strip()\nprint(find(s))\n\n\n"], "prompt_tokens": [9256, 9990], "completion_tokens": [4509, 3745], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 2886}
{"name": "4515", "description": "Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.", "difficulty": "introductory", "id": 4515, "sample_io": [{"input": "['56-23','1-100']", "output": ["1-100"]}, {"input": "['1-3', '5-7', '2-3']", "output": ["1-3"]}, {"input": "['11-11', '344-344']", "output": [false]}], "test_list": [{"input": "['43-45', '1021-55', '000-18888', '92-34', '76-32', '99-1', '1020-54']", "output": ["000-18888"]}, {"input": "['1-2', '2-4', '5-7', '8-9', '44-45']", "output": ["2-4"]}, {"input": "['1-1000', '2-1000', '100-67', '98-45', '8-9']", "output": ["1-1000"]}, {"input": "['33-33', '77-77']", "output": [false]}, {"input": "['23-67', '67-23', '88-88', '45-46']", "output": ["23-67"]}, {"input": "['45896-2354', '4654-556767', '2455-423522', '3455-355', '34-34', '2524522-0']", "output": ["2524522-0"]}, {"input": "['1-1', '2-2', '1-0', '77-77']", "output": ["1-0"]}, {"input": "['0-0']", "output": [false]}, {"input": "[]", "output": [false]}], "starter_code": "\ndef diff(arr):\n\t", "source_codes": ["import sys\n\ndef find_greatest_difference_couple(couples):\n    max_diff = 0\n    result_couple = None\n    \n    for couple in couples:\n        num1, num2 = map(int, couple.split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_couple = couple\n    \n    return result_couple if max_diff > 0 else False\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\ncouples = eval(input_str)\n\n# Find and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "def find_greatest_difference(couples):\n    max_diff = -1\n    result_index = -1\n    \n    for i, couple in enumerate(couples):\n        num1, num2 = map(int, couple.split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_index = i\n    \n    if max_diff == 0:\n        return False\n    \n    return couples[result_index]\n\n# Read input and process\ninput_str = input().strip()\ncouples = eval(input_str)\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import ast\nimport sys\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result\n\n# Read input from stdin\ninput_str = input().strip()\n# Parse the input string using ast.literal_eval for safe evaluation\ncouples = ast.literal_eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)", "import sys\nimport ast\n\ndef find_greatest_difference_couple(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result_index = -1\n    \n    for i, couple in enumerate(couples):\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_index = i\n    \n    if max_diff == 0:\n        return False\n    \n    return couples[result_index]\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n\n# Parse the input string using ast.literal_eval to safely evaluate the list\ntry:\n    couples = ast.literal_eval(input_str)\nexcept:\n    couples = []\n\n# Call the function and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import sys\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result = None\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n# Parse the input string to list\ncouples = eval(input_str) if input_str else []\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import sys\nimport re\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    all_same = True\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > 0:\n            all_same = False\n            \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if all_same:\n        return False\n    \n    return result\n\n# Read input from stdin\ninput_line = sys.stdin.read().strip()\n\n# Parse the input string into a list manually\n# Remove the square brackets and split by comma\ninput_line = input_line.strip()[1:-1]  # Remove [ and ]\ncouples = []\nif input_line:\n    # Split by comma and process each element\n    parts = input_line.split(',')\n    for part in parts:\n        # Remove quotes and whitespace\n        couple = part.strip().strip(\"'\\\"\")\n        couples.append(couple)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import sys\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result\n\n# Read input from stdin\ninput_str = input().strip()\n# Parse the input string into a list\ncouples = eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import sys\nimport ast\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return \"false\"\n    else:\n        return result\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\ncouples = ast.literal_eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result == \"false\":\n    print(\"false\")\nelse:\n    print(result)", "import sys\n\ndef find_greatest_difference_couple(couples):\n    max_diff = 0\n    result = None\n    \n    for couple in couples:\n        a, b = map(int, couple.split('-'))\n        diff = abs(a - b)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff > 0:\n        return result\n    else:\n        return False\n\n# Read input from stdin\ninput_line = sys.stdin.readline().strip()\n# Parse the input string into a list\ncouples = eval(input_line)\n\n# Find and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)", "import ast\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result_index = -1\n    has_nonzero_diff = False\n    \n    for i, couple in enumerate(couples):\n        a, b = map(int, couple.split('-'))\n        diff = abs(a - b)\n        \n        if diff > 0:\n            has_nonzero_diff = True\n            if diff > max_diff:\n                max_diff = diff\n                result_index = i\n    \n    if not has_nonzero_diff:\n        return False\n    \n    return couples[result_index]\n\n# Read input and process\ninput_str = input().strip()\n# Parse the string representation of list properly\ncouples = ast.literal_eval(input_str)\n\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)"], "responses": ["\nimport sys\n\ndef find_greatest_difference_couple(couples):\n    max_diff = 0\n    result_couple = None\n    \n    for couple in couples:\n        num1, num2 = map(int, couple.split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_couple = couple\n    \n    return result_couple if max_diff > 0 else False\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\ncouples = eval(input_str)\n\n# Find and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result_index = -1\n    \n    for i, couple in enumerate(couples):\n        num1, num2 = map(int, couple.split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_index = i\n    \n    if max_diff == 0:\n        return False\n    \n    return couples[result_index]\n\n# Read input and process\ninput_str = input().strip()\ncouples = eval(input_str)\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport ast\nimport sys\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result\n\n# Read input from stdin\ninput_str = input().strip()\n# Parse the input string using ast.literal_eval for safe evaluation\ncouples = ast.literal_eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)\n\n\n", "\nimport sys\nimport ast\n\ndef find_greatest_difference_couple(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result_index = -1\n    \n    for i, couple in enumerate(couples):\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_index = i\n    \n    if max_diff == 0:\n        return False\n    \n    return couples[result_index]\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n\n# Parse the input string using ast.literal_eval to safely evaluate the list\ntry:\n    couples = ast.literal_eval(input_str)\nexcept:\n    couples = []\n\n# Call the function and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport sys\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result = None\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n# Parse the input string to list\ncouples = eval(input_str) if input_str else []\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport sys\nimport re\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    all_same = True\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > 0:\n            all_same = False\n            \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if all_same:\n        return False\n    \n    return result\n\n# Read input from stdin\ninput_line = sys.stdin.read().strip()\n\n# Parse the input string into a list manually\n# Remove the square brackets and split by comma\ninput_line = input_line.strip()[1:-1]  # Remove [ and ]\ncouples = []\nif input_line:\n    # Split by comma and process each element\n    parts = input_line.split(',')\n    for part in parts:\n        # Remove quotes and whitespace\n        couple = part.strip().strip(\"'\\\"\")\n        couples.append(couple)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport sys\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result\n\n# Read input from stdin\ninput_str = input().strip()\n# Parse the input string into a list\ncouples = eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport sys\nimport ast\n\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return \"false\"\n    else:\n        return result\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\ncouples = ast.literal_eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nif result == \"false\":\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport sys\n\ndef find_greatest_difference_couple(couples):\n    max_diff = 0\n    result = None\n    \n    for couple in couples:\n        a, b = map(int, couple.split('-'))\n        diff = abs(a - b)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff > 0:\n        return result\n    else:\n        return False\n\n# Read input from stdin\ninput_line = sys.stdin.readline().strip()\n# Parse the input string into a list\ncouples = eval(input_line)\n\n# Find and print the result\nresult = find_greatest_difference_couple(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n", "\nimport ast\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return False\n    \n    max_diff = -1\n    result_index = -1\n    has_nonzero_diff = False\n    \n    for i, couple in enumerate(couples):\n        a, b = map(int, couple.split('-'))\n        diff = abs(a - b)\n        \n        if diff > 0:\n            has_nonzero_diff = True\n            if diff > max_diff:\n                max_diff = diff\n                result_index = i\n    \n    if not has_nonzero_diff:\n        return False\n    \n    return couples[result_index]\n\n# Read input and process\ninput_str = input().strip()\n# Parse the string representation of list properly\ncouples = ast.literal_eval(input_str)\n\nresult = find_greatest_difference(couples)\nif result is False:\n    print(\"false\")\nelse:\n    print(result)\n\n\n"], "prompt_tokens": [7741, 7990, 7917, 8879, 7453, 7019, 7853, 7661, 7398, 8629], "completion_tokens": [2368, 2608, 3212, 2912, 3011, 2505, 2330, 2262, 2403, 2627], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 4515}
{"name": "3068", "description": "You need to play around with the provided string (s).\n\nMove consonants forward 9 places through the alphabet.\nIf they pass 'z', start again at 'a'.\n\nMove vowels back 5 places through the alphabet.\nIf they pass 'a', start again at 'z'.\nFor our Polish friends this kata does not count 'y' as a vowel.\n\nExceptions:\n\nIf the character is 'c' or 'o', move it back 1 place.\nFor 'd' move it back 3, and for 'e', move it back 4.\n\nIf a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.\n\nProvided string will always be lower case, won't be empty and will have no special characters.", "difficulty": "introductory", "id": 3068, "sample_io": [], "test_list": [{"input": "testcase", "output": ["tabtbvba"]}, {"input": "codewars", "output": ["bnaafvab"]}, {"input": "exampletesthere", "output": ["agvvyuatabtqaaa"]}, {"input": "returnofthespacecamel", "output": ["aatpawnftqabyvbabvvau"]}, {"input": "bringonthebootcamp", "output": ["kaiwpnwtqaknntbvvy"]}, {"input": "weneedanofficedog", "output": ["fawaaavwnffibaanp"]}], "starter_code": "\ndef vowel_back(st):\n\t", "source_codes": ["def solve(s):\n    vowels = set('aeiou')\n    exceptions = set('code')\n    \n    def move_char(c, shift):\n        # Move character by shift positions with wraparound\n        new_pos = (ord(c) - ord('a') + shift) % 26\n        return chr(ord('a') + new_pos)\n    \n    result = []\n    for char in s:\n        original = char\n        new_char = char\n        \n        # Apply exceptions first\n        if char in exceptions:\n            if char == 'c':\n                new_char = move_char(char, -1)\n            elif char == 'o':\n                new_char = move_char(char, -1)\n            elif char == 'd':\n                new_char = move_char(char, -3)\n            elif char == 'e':\n                new_char = move_char(char, -4)\n        # Apply general rules\n        elif char in vowels:\n            # Move vowels back 5 places\n            new_char = move_char(char, -5)\n        else:\n            # Move consonants forward 9 places\n            new_char = move_char(char, 9)\n        \n        # Check if the new character is an exception and revert if needed\n        if new_char in exceptions:\n            new_char = original\n            \n        result.append(new_char)\n    \n    return ''.join(result)\n\n# Read input and print output\ns = input().strip()\nprint(solve(s))"], "responses": ["\ndef solve(s):\n    vowels = set('aeiou')\n    exceptions = set('code')\n    \n    def move_char(c, shift):\n        # Move character by shift positions with wraparound\n        new_pos = (ord(c) - ord('a') + shift) % 26\n        return chr(ord('a') + new_pos)\n    \n    result = []\n    for char in s:\n        original = char\n        new_char = char\n        \n        # Apply exceptions first\n        if char in exceptions:\n            if char == 'c':\n                new_char = move_char(char, -1)\n            elif char == 'o':\n                new_char = move_char(char, -1)\n            elif char == 'd':\n                new_char = move_char(char, -3)\n            elif char == 'e':\n                new_char = move_char(char, -4)\n        # Apply general rules\n        elif char in vowels:\n            # Move vowels back 5 places\n            new_char = move_char(char, -5)\n        else:\n            # Move consonants forward 9 places\n            new_char = move_char(char, 9)\n        \n        # Check if the new character is an exception and revert if needed\n        if new_char in exceptions:\n            new_char = original\n            \n        result.append(new_char)\n    \n    return ''.join(result)\n\n# Read input and print output\ns = input().strip()\nprint(solve(s))\n\n\n"], "prompt_tokens": [7109], "completion_tokens": [6338], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3068}
{"name": "4214", "description": "In this kata you will have to modify a sentence so it meets the following rules:\n\nconvert every word backwards that is:\n\n    longer than 6 characters\n\n  OR\n\n    has 2 or more 'T' or 't' in it\n\nconvert every word uppercase that is:\n\n    exactly 2 characters long\n\n  OR\n\n    before a comma\n\nconvert every word to a \"0\" that is:\n\n    exactly one character long\n \n\n NOTES: \n\n      Punctuation must not be touched. if a word is 6 characters long, and a \".\" is behind it,\n      it counts as 6 characters so it must not be flipped, but if a word is 7 characters long,\n      it must be flipped but the \".\" must stay at the end of the word.\n      -----------------------------------------------------------------------------------------\n      Only the first transformation applies to a given word, for example 'companions,'\n      will be 'snoinapmoc,' and not 'SNOINAPMOC,'.\n      -----------------------------------------------------------------------------------------\n      As for special characters like apostrophes or dashes, they count as normal characters, \n      so e.g 'sand-colored' must be transformed to 'deroloc-dnas'.", "difficulty": "introductory", "id": 4214, "sample_io": [{"input": "companions,", "output": ["snoinapmoc,"]}, {"input": "sand-colored", "output": ["deroloc-dnas"]}], "test_list": [{"input": "Welcome.", "output": ["emocleW."]}, {"input": "If a man does not keep pace with his companions, perhaps it is because he hears a different drummer.", "output": ["IF 0 man does not keep pace with his snoinapmoc, spahrep IT IS esuaceb HE hears 0 tnereffid remmurd."]}, {"input": "As Grainier drove along in the wagon behind a wide, slow, sand-colored mare, clusters of orange butterflies exploded off the purple blackish piles of bear sign and winked and winked and fluttered magically like leaves without trees.", "output": ["AS reiniarG drove along IN the wagon behind 0 WIDE, SLOW, deroloc-dnas MARE, sretsulc OF orange seilfrettub dedolpxe off the purple hsikcalb piles OF bear sign and winked and winked and derettulf yllacigam like leaves tuohtiw trees."]}, {"input": "You should check the mileage on your car since you've been driving it so much, and because it's starting to make weird noises.", "output": ["You should check the egaelim ON your car since you've been gnivird IT SO MUCH, and esuaceb it's gnitrats TO make weird noises."]}, {"input": "Wherever you go, you can always find beauty.", "output": ["reverehW you GO, you can always find beauty."]}, {"input": "Action is indeed, commmmmmmming.", "output": ["Action IS INDEED, gnimmmmmmmmoc."]}, {"input": "Mother, please, help, me.", "output": ["MOTHER, PLEASE, HELP, ME."]}, {"input": "Jojojo, jojo, tata man kata.", "output": ["JOJOJO, JOJO, atat man kata."]}], "starter_code": "\ndef spin_solve(sentence):\n\t", "source_codes": ["import re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation) keeping spaces\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i in range(len(tokens)):\n        token = tokens[i]\n        if re.match(r'\\s+', token):  # If token is whitespace, keep as is\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part (without trailing punctuation) and punctuation part\n        match = re.match(r\"([a-zA-Z0-9'-]*)([^a-zA-Z0-9'-]*)\", token)\n        if not match:\n            result_tokens.append(token)\n            continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # If there's no word part, just append the token\n        if not word_part:\n            result_tokens.append(token)\n            continue\n        \n        # Rule 1: Convert word backwards if longer than 6 chars or has 2+ T/t\n        # Note: we check the total length (word + punctuation) for the > 6 rule\n        total_length = len(token.rstrip())  # Remove trailing whitespace for length check\n        if total_length > 6 or word_part.lower().count('t') >= 2:\n            transformed = word_part[::-1] + punct_part\n        # Rule 2: Convert to uppercase if exactly 2 chars or before a comma\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and ',' in tokens[i+1]):\n            transformed = word_part.upper() + punct_part\n        # Rule 3: Convert to \"0\" if exactly 1 char\n        elif len(word_part) == 1:\n            transformed = '0' + punct_part\n        else:\n            transformed = token\n            \n        result_tokens.append(transformed)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)", "import re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words with attached punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace tokens\n        if token.isspace() or not token:\n            result_tokens.append(token)\n            continue\n            \n        # Separate word from trailing punctuation\n        # This pattern captures the main word part (including internal punctuation) and trailing punctuation\n        match = re.match(r'^([a-zA-Z][\\w\\'-]*[a-zA-Z]|[a-zA-Z])([^\\w\\s]*)$', token)\n        if not match:\n            # Try simpler pattern for single letters with punctuation\n            match = re.match(r'^([a-zA-Z])([^\\w\\s]*)$', token)\n            if not match:\n                result_tokens.append(token)\n                continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # Rule 1: Convert backwards if >6 chars OR has 2+ T/t\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            transformed = word_part[::-1] + punct_part\n        # Rule 2: Convert uppercase if exactly 2 chars OR before comma\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and ',' in tokens[i+1]):\n            transformed = word_part.upper() + punct_part\n        # Rule 3: Convert to \"0\" if exactly 1 char\n        elif len(word_part) == 1:\n            transformed = '0' + punct_part\n        else:\n            transformed = token\n            \n        result_tokens.append(transformed)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)", "import re\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation) while keeping track of their positions\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    i = 0\n    while i < len(tokens):\n        token = tokens[i]\n        # Skip whitespace\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            i += 1\n            continue\n            \n        # Extract the actual word part (without trailing punctuation for length checks)\n        word_match = re.match(r'(\\w.*?)(\\W*)$', token)\n        if not word_match:\n            result_tokens.append(token)\n            i += 1\n            continue\n            \n        word_part = word_match.group(1)\n        punct_part = word_match.group(2)\n        \n        # Rule 1: Convert word backwards if:\n        # - longer than 6 characters OR\n        # - has 2 or more 'T' or 't' in it\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result_tokens.append(word_part[::-1] + punct_part)\n            i += 1\n            continue\n            \n        # Rule 2: Convert word uppercase if:\n        # - exactly 2 characters long OR\n        # - before a comma (word ends with comma or next token starts with comma)\n        is_before_comma = False\n        if punct_part.startswith(','):\n            is_before_comma = True\n        elif i + 1 < len(tokens):\n            # Check if next token starts with comma\n            next_token = tokens[i + 1]\n            if next_token.startswith(','):\n                is_before_comma = True\n        \n        if len(word_part) == 2 or is_before_comma:\n            result_tokens.append(word_part.upper() + punct_part)\n            i += 1\n            continue\n            \n        # Rule 3: Convert word to \"0\" if exactly one character long\n        if len(word_part) == 1:\n            result_tokens.append('0' + punct_part)\n            i += 1\n            continue\n            \n        # Default: keep the word as is\n        result_tokens.append(token)\n        i += 1\n        \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)"], "responses": ["\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation) keeping spaces\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i in range(len(tokens)):\n        token = tokens[i]\n        if re.match(r'\\s+', token):  # If token is whitespace, keep as is\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part (without trailing punctuation) and punctuation part\n        match = re.match(r\"([a-zA-Z0-9'-]*)([^a-zA-Z0-9'-]*)\", token)\n        if not match:\n            result_tokens.append(token)\n            continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # If there's no word part, just append the token\n        if not word_part:\n            result_tokens.append(token)\n            continue\n        \n        # Rule 1: Convert word backwards if longer than 6 chars or has 2+ T/t\n        # Note: we check the total length (word + punctuation) for the > 6 rule\n        total_length = len(token.rstrip())  # Remove trailing whitespace for length check\n        if total_length > 6 or word_part.lower().count('t') >= 2:\n            transformed = word_part[::-1] + punct_part\n        # Rule 2: Convert to uppercase if exactly 2 chars or before a comma\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and ',' in tokens[i+1]):\n            transformed = word_part.upper() + punct_part\n        # Rule 3: Convert to \"0\" if exactly 1 char\n        elif len(word_part) == 1:\n            transformed = '0' + punct_part\n        else:\n            transformed = token\n            \n        result_tokens.append(transformed)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n", "\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words with attached punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace tokens\n        if token.isspace() or not token:\n            result_tokens.append(token)\n            continue\n            \n        # Separate word from trailing punctuation\n        # This pattern captures the main word part (including internal punctuation) and trailing punctuation\n        match = re.match(r'^([a-zA-Z][\\w\\'-]*[a-zA-Z]|[a-zA-Z])([^\\w\\s]*)$', token)\n        if not match:\n            # Try simpler pattern for single letters with punctuation\n            match = re.match(r'^([a-zA-Z])([^\\w\\s]*)$', token)\n            if not match:\n                result_tokens.append(token)\n                continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # Rule 1: Convert backwards if >6 chars OR has 2+ T/t\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            transformed = word_part[::-1] + punct_part\n        # Rule 2: Convert uppercase if exactly 2 chars OR before comma\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and ',' in tokens[i+1]):\n            transformed = word_part.upper() + punct_part\n        # Rule 3: Convert to \"0\" if exactly 1 char\n        elif len(word_part) == 1:\n            transformed = '0' + punct_part\n        else:\n            transformed = token\n            \n        result_tokens.append(transformed)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n", "\nimport re\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation) while keeping track of their positions\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    i = 0\n    while i < len(tokens):\n        token = tokens[i]\n        # Skip whitespace\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            i += 1\n            continue\n            \n        # Extract the actual word part (without trailing punctuation for length checks)\n        word_match = re.match(r'(\\w.*?)(\\W*)$', token)\n        if not word_match:\n            result_tokens.append(token)\n            i += 1\n            continue\n            \n        word_part = word_match.group(1)\n        punct_part = word_match.group(2)\n        \n        # Rule 1: Convert word backwards if:\n        # - longer than 6 characters OR\n        # - has 2 or more 'T' or 't' in it\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result_tokens.append(word_part[::-1] + punct_part)\n            i += 1\n            continue\n            \n        # Rule 2: Convert word uppercase if:\n        # - exactly 2 characters long OR\n        # - before a comma (word ends with comma or next token starts with comma)\n        is_before_comma = False\n        if punct_part.startswith(','):\n            is_before_comma = True\n        elif i + 1 < len(tokens):\n            # Check if next token starts with comma\n            next_token = tokens[i + 1]\n            if next_token.startswith(','):\n                is_before_comma = True\n        \n        if len(word_part) == 2 or is_before_comma:\n            result_tokens.append(word_part.upper() + punct_part)\n            i += 1\n            continue\n            \n        # Rule 3: Convert word to \"0\" if exactly one character long\n        if len(word_part) == 1:\n            result_tokens.append('0' + punct_part)\n            i += 1\n            continue\n            \n        # Default: keep the word as is\n        result_tokens.append(token)\n        i += 1\n        \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n"], "prompt_tokens": [10076, 9767, 10206], "completion_tokens": [4905, 3893, 5225], "no_of_try": 3, "api_calls": 30, "is_solved": true, "language": "Python3", "task_id": 4214}
{"name": "3884", "description": "# RegExp Fun #1 - When I miss few days of gym\n\n## Disclaimer\n\nThe background story of this Kata is 100% fiction.  Any resemblance to real people or real events is **nothing more than a coincidence** and should be regarded as such.\n\n## Background Story\n\nYou are a person who loves to go to the gym everyday with the squad of people that you've known since early childhood.  However, you recently contracted a sickness that forced you to stay at home for over a week.  As you see your body getting weaker and weaker every day and as you see your biceps and triceps disappearing, you can't help but lay in bed and cry.  You're usually an optimistic person but this time negative thoughts come to your head ... \n\n![When I miss few days of gym](https://pics.onsizzle.com/Instagram-faf8c9.png)\n\n\n## Task\n\nAs can be seen from the funny image above (or am I the only person to find the picture above hilarious?) there is lots of slang.  Your task is to define a function ```gymSlang``` which accepts a string argument and does the following:\n\n1. Replace *all* instances of ```\"probably\"``` to ```\"prolly\"```\n2. Replace *all* instances of ```\"i am\"``` to ```\"i'm\"```\n3. Replace *all* instances of ```\"instagram\"``` to ```\"insta\"```\n4. Replace *all* instances of ```\"do not\"``` to ```\"don't\"```\n5. Replace *all* instances of ```\"going to\"``` to ```\"gonna\"```\n6. Replace *all* instances of ```\"combination\"``` to ```\"combo\"```\n\nYour replacement regexes **should be case-sensitive**, only replacing the words above with slang if the detected pattern is in **lowercase**.  However, please note that apart from 100% lowercase matches, you will **also have to replace matches that are correctly capitalized** (e.g. ```\"Probably\" => \"Prolly\"``` or ```\"Instagram\" => \"Insta\"```).\n\nFinally, your code will be tested to make sure that you have used **RegExp** replace in your code.\n\nEnjoy :D", "difficulty": "introductory", "id": 3884, "sample_io": [{"input": "Probably", "output": ["Prolly"]}, {"input": "Instagram", "output": ["Insta"]}], "test_list": [{"input": "When I miss few days of gym", "output": ["When I miss few days of gym"]}, {"input": "Squad probably think I am fake", "output": ["Squad prolly think I'm fake"]}, {"input": "Whole squad probably bigger than me now", "output": ["Whole squad prolly bigger than me now"]}, {"input": "No selfie to post on Instagram either", "output": ["No selfie to post on Insta either"]}, {"input": "Gym crush probably found someone else", "output": ["Gym crush prolly found someone else"]}, {"input": "What if I die fat", "output": ["What if I die fat"]}, {"input": "What if I do not fit in my clothes now", "output": ["What if I don't fit in my clothes now"]}, {"input": "Going to feel like a new gym member", "output": ["Gonna feel like a new gym member"]}, {"input": "wait what was my lock combination", "output": ["wait what was my lock combo"]}, {"input": "that skinny girl can probably outlift me now", "output": ["that skinny girl can prolly outlift me now"]}, {"input": "probably Probably", "output": ["prolly Prolly"]}, {"input": "i am I am", "output": ["i'm I'm"]}, {"input": "instagram Instagram", "output": ["insta Insta"]}, {"input": "do not Do not", "output": ["don't Don't"]}, {"input": "going to Going to", "output": ["gonna Gonna"]}, {"input": "combination Combination", "output": ["combo Combo"]}, {"input": "probably Probably probably Probably probably Probably probably Probably probably Probably", "output": ["prolly Prolly prolly Prolly prolly Prolly prolly Prolly prolly Prolly"]}, {"input": "i am I am i am I am i am I am i am I am i am I am i am I am", "output": ["i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm"]}, {"input": "instagram Instagram instagram Instagram instagram Instagram instagram Instagram instagram Instagram", "output": ["insta Insta insta Insta insta Insta insta Insta insta Insta"]}, {"input": "do not Do not do not Do not do not Do not do not Do not", "output": ["don't Don't don't Don't don't Don't don't Don't"]}, {"input": "Going to going to Going to Going to going to Going to Going to going to Going to", "output": ["Gonna gonna Gonna Gonna gonna Gonna Gonna gonna Gonna"]}, {"input": "combination combination Combination combination Combination", "output": ["combo combo Combo combo Combo"]}], "starter_code": "\ndef gym_slang(phrase):\n\t", "source_codes": ["import re\nimport sys\n\ndef gymSlang(phrase):\n    # Define the replacements mapping\n    replacements = {\n        'probably': 'prolly',\n        'i am': \"i'm\",\n        'instagram': 'insta',\n        'do not': \"don't\",\n        'going to': 'gonna',\n        'combination': 'combo'\n    }\n    \n    # Function to handle capitalization properly\n    def replace_word(match):\n        original = match.group(0)\n        lower_original = original.lower()\n        replacement = replacements[lower_original]\n        \n        # Handle capitalization\n        if original[0].isupper():\n            return replacement.capitalize()\n        else:\n            return replacement\n    \n    # Apply replacements in order, using word boundaries\n    for word, replacement in replacements.items():\n        # Create pattern that matches the word with proper word boundaries\n        pattern = r'\\b' + re.escape(word) + r'\\b'\n        phrase = re.sub(pattern, replace_word, phrase, flags=re.IGNORECASE)\n        \n    return phrase\n\n# Read input and process\ninput_phrase = sys.stdin.read().strip()\nresult = gymSlang(input_phrase)\nprint(result)"], "responses": ["\nimport re\nimport sys\n\ndef gymSlang(phrase):\n    # Define the replacements mapping\n    replacements = {\n        'probably': 'prolly',\n        'i am': \"i'm\",\n        'instagram': 'insta',\n        'do not': \"don't\",\n        'going to': 'gonna',\n        'combination': 'combo'\n    }\n    \n    # Function to handle capitalization properly\n    def replace_word(match):\n        original = match.group(0)\n        lower_original = original.lower()\n        replacement = replacements[lower_original]\n        \n        # Handle capitalization\n        if original[0].isupper():\n            return replacement.capitalize()\n        else:\n            return replacement\n    \n    # Apply replacements in order, using word boundaries\n    for word, replacement in replacements.items():\n        # Create pattern that matches the word with proper word boundaries\n        pattern = r'\\b' + re.escape(word) + r'\\b'\n        phrase = re.sub(pattern, replace_word, phrase, flags=re.IGNORECASE)\n        \n    return phrase\n\n# Read input and process\ninput_phrase = sys.stdin.read().strip()\nresult = gymSlang(input_phrase)\nprint(result)\n\n\n"], "prompt_tokens": [10060], "completion_tokens": [2980], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3884}
{"name": "3732", "description": "A Madhav array has the following property:\n\n```a[0] = a[1] + a[2] = a[3] + a[4] + a[5] = a[6] + a[7] + a[8] + a[9] = ...```\n\nComplete the function/method that returns `true` if the given array is a Madhav array, otherwise it returns `false`.\n\n*Edge cases: An array of length* `0` *or* `1` *should not be considered a Madhav array as there is nothing to compare.*", "difficulty": "introductory", "id": 3732, "sample_io": [], "test_list": [{"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, -100]", "output": [false]}, {"input": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, -2, -1]", "output": [true]}, {"input": "[-6, -3, -3, 8, -5, -4]", "output": [false]}, {"input": "[-6, -3, -3, 8, -10, -4]", "output": [true]}, {"input": "[3, 1, 2, 3, 0]", "output": [false]}, {"input": "[3, 3]", "output": [false]}, {"input": "[]", "output": [false]}, {"input": "[1]", "output": [false]}, {"input": "[5, 2, 4, 1, 0, 3]", "output": [false]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 6]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 1]", "output": [false]}, {"input": "[2, 1, 1]", "output": [true]}, {"input": "[2, 1, 1, 4, -1, -1]", "output": [true]}], "starter_code": "\ndef is_madhav_array(arr):\n\t", "source_codes": ["import math\n\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Check if length is 0 or 1\n    if n <= 1:\n        return False\n    \n    # Check if n is a triangular number: n = k(k+1)/2 for some positive integer k\n    # This means 8*n + 1 must be a perfect square\n    discriminant = 8 * n + 1\n    sqrt_discriminant = int(math.sqrt(discriminant))\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    \n    k = (sqrt_discriminant - 1) // 2\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # The target sum is the first element\n    target_sum = arr[0]\n    \n    # Check groups: group sizes 1, 2, 3, 4, ..., k\n    # All group sums should equal the target sum\n    index = 0\n    \n    for group_size in range(1, k + 1):\n        if index + group_size > n:\n            return False\n            \n        group_sum = sum(arr[index:index + group_size])\n        \n        # Check if this group sum equals the target\n        if group_sum != target_sum:\n            return False\n        \n        index += group_size\n    \n    return True\n\n# Read input and process\nif __name__ == \"__main__\":\n    try:\n        line = input().strip()\n        if line == \"[]\":\n            arr = []\n        else:\n            # Remove brackets and split by comma\n            content = line[1:-1]\n            if content.strip() == \"\":\n                arr = []\n            else:\n                arr = [int(x.strip()) for x in content.split(\",\")]\n        \n        result = is_madhav_array(arr)\n        print(\"true\" if result else \"false\")\n    except EOFError:\n        print(\"false\")", "def is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases: arrays of length 0 or 1 are not Madhav arrays\n    if n <= 1:\n        return False\n    \n    # Check if length is a triangular number > 1\n    # Triangular numbers: 1, 3, 6, 10, 15, ...\n    # We need to find if there exists k such that k(k+1)/2 = n and k > 1\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Now check the Madhav property\n    target_sum = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        current_sum = 0\n        for _ in range(group_size):\n            if index >= n:\n                return False\n            current_sum += arr[index]\n            index += 1\n        \n        if current_sum != target_sum:\n            return False\n    \n    return True\n\n# Read input\ntry:\n    line = input().strip()\n    if line == \"[]\" or line == \"\":\n        arr = []\n    else:\n        # Remove brackets if present\n        if line.startswith('[') and line.endswith(']'):\n            line = line[1:-1]\n        # Split by comma and convert to integers\n        arr = [int(x.strip()) for x in line.split(',') if x.strip()]\nexcept:\n    arr = []\n\n# Call function and print result\nresult = is_madhav_array(arr)\nprint(str(result).lower())", "import math\n\ndef is_triangular(n):\n    if n <= 0:\n        return False\n    # A number n is triangular if 8n+1 is a perfect square\n    val = 8 * n + 1\n    sqrt_val = int(math.sqrt(val))\n    return sqrt_val * sqrt_val == val\n\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases: length 0 or 1\n    if n <= 1:\n        return False\n        \n    # Check if length is a triangular number\n    if not is_triangular(n):\n        return False\n    \n    # Find the number of groups k such that 1+2+...+k = n\n    # This means k(k+1)/2 = n => k^2 + k - 2n = 0\n    # Using quadratic formula: k = (-1 + sqrt(1 + 8n)) / 2\n    k = int((-1 + math.sqrt(1 + 8 * n)) / 2)\n    \n    # Verify that k(k+1)/2 = n\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    index = 0\n    # Get the sum of the first group (which should be the target sum)\n    target_sum = arr[0]\n    \n    # Check each group\n    for group_size in range(1, k + 1):\n        current_sum = 0\n        for _ in range(group_size):\n            current_sum += arr[index]\n            index += 1\n        if current_sum != target_sum:\n            return False\n            \n    return True\n\n# Read input\ntry:\n    line = input().strip()\n    if line == \"\":\n        arr = []\n    else:\n        # Remove brackets if present\n        if line.startswith('[') and line.endswith(']'):\n            line = line[1:-1]\n        # Split by comma and convert to integers\n        if line.strip() == \"\":\n            arr = []\n        else:\n            arr = [int(x.strip()) for x in line.split(',') if x.strip()]\nexcept:\n    arr = []\n\n# Output result\nprint(is_madhav_array(arr))"], "responses": ["\nimport math\n\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Check if length is 0 or 1\n    if n <= 1:\n        return False\n    \n    # Check if n is a triangular number: n = k(k+1)/2 for some positive integer k\n    # This means 8*n + 1 must be a perfect square\n    discriminant = 8 * n + 1\n    sqrt_discriminant = int(math.sqrt(discriminant))\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    \n    k = (sqrt_discriminant - 1) // 2\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # The target sum is the first element\n    target_sum = arr[0]\n    \n    # Check groups: group sizes 1, 2, 3, 4, ..., k\n    # All group sums should equal the target sum\n    index = 0\n    \n    for group_size in range(1, k + 1):\n        if index + group_size > n:\n            return False\n            \n        group_sum = sum(arr[index:index + group_size])\n        \n        # Check if this group sum equals the target\n        if group_sum != target_sum:\n            return False\n        \n        index += group_size\n    \n    return True\n\n# Read input and process\nif __name__ == \"__main__\":\n    try:\n        line = input().strip()\n        if line == \"[]\":\n            arr = []\n        else:\n            # Remove brackets and split by comma\n            content = line[1:-1]\n            if content.strip() == \"\":\n                arr = []\n            else:\n                arr = [int(x.strip()) for x in content.split(\",\")]\n        \n        result = is_madhav_array(arr)\n        print(\"true\" if result else \"false\")\n    except EOFError:\n        print(\"false\")\n\n\n", "\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases: arrays of length 0 or 1 are not Madhav arrays\n    if n <= 1:\n        return False\n    \n    # Check if length is a triangular number > 1\n    # Triangular numbers: 1, 3, 6, 10, 15, ...\n    # We need to find if there exists k such that k(k+1)/2 = n and k > 1\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Now check the Madhav property\n    target_sum = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        current_sum = 0\n        for _ in range(group_size):\n            if index >= n:\n                return False\n            current_sum += arr[index]\n            index += 1\n        \n        if current_sum != target_sum:\n            return False\n    \n    return True\n\n# Read input\ntry:\n    line = input().strip()\n    if line == \"[]\" or line == \"\":\n        arr = []\n    else:\n        # Remove brackets if present\n        if line.startswith('[') and line.endswith(']'):\n            line = line[1:-1]\n        # Split by comma and convert to integers\n        arr = [int(x.strip()) for x in line.split(',') if x.strip()]\nexcept:\n    arr = []\n\n# Call function and print result\nresult = is_madhav_array(arr)\nprint(str(result).lower())\n\n\n", "\nimport math\n\ndef is_triangular(n):\n    if n <= 0:\n        return False\n    # A number n is triangular if 8n+1 is a perfect square\n    val = 8 * n + 1\n    sqrt_val = int(math.sqrt(val))\n    return sqrt_val * sqrt_val == val\n\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases: length 0 or 1\n    if n <= 1:\n        return False\n        \n    # Check if length is a triangular number\n    if not is_triangular(n):\n        return False\n    \n    # Find the number of groups k such that 1+2+...+k = n\n    # This means k(k+1)/2 = n => k^2 + k - 2n = 0\n    # Using quadratic formula: k = (-1 + sqrt(1 + 8n)) / 2\n    k = int((-1 + math.sqrt(1 + 8 * n)) / 2)\n    \n    # Verify that k(k+1)/2 = n\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    index = 0\n    # Get the sum of the first group (which should be the target sum)\n    target_sum = arr[0]\n    \n    # Check each group\n    for group_size in range(1, k + 1):\n        current_sum = 0\n        for _ in range(group_size):\n            current_sum += arr[index]\n            index += 1\n        if current_sum != target_sum:\n            return False\n            \n    return True\n\n# Read input\ntry:\n    line = input().strip()\n    if line == \"\":\n        arr = []\n    else:\n        # Remove brackets if present\n        if line.startswith('[') and line.endswith(']'):\n            line = line[1:-1]\n        # Split by comma and convert to integers\n        if line.strip() == \"\":\n            arr = []\n        else:\n            arr = [int(x.strip()) for x in line.split(',') if x.strip()]\nexcept:\n    arr = []\n\n# Output result\nprint(is_madhav_array(arr))\n\n\n"], "prompt_tokens": [8423, 8518, 8927], "completion_tokens": [5310, 5096, 5157], "no_of_try": 3, "api_calls": 30, "is_solved": true, "language": "Python3", "task_id": 3732}
{"name": "3569", "description": "In Russia regular bus tickets usually consist of 6 digits. The ticket is called lucky when the sum of the first three digits equals to the sum of the last three digits. Write a function to find out whether the ticket is lucky or not. Return true if so, otherwise return false. Consider that input is always a string. Watch examples below.", "difficulty": "introductory", "id": 3569, "sample_io": [], "test_list": [{"input": "123321", "output": [true]}, {"input": "12341234", "output": [false]}, {"input": "100001", "output": [true]}, {"input": "100200", "output": [false]}, {"input": "912435", "output": [true]}, {"input": "12a12a", "output": [false]}, {"input": "999999", "output": [true]}, {"input": "1111", "output": [false]}, {"input": "000000", "output": [true]}, {"input": "", "output": [false]}], "starter_code": "\ndef is_lucky(ticket):\n\t", "source_codes": ["def is_lucky_ticket(ticket):\n    # Extract first three and last three digits\n    first_three = ticket[:3]\n    last_three = ticket[3:]\n    \n    # Calculate sums\n    sum_first = sum(int(digit) for digit in first_three)\n    sum_last = sum(int(digit) for digit in last_three)\n    \n    # Return whether sums are equal\n    return sum_first == sum_last\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(\"true\" if result else \"false\")", "def is_lucky_ticket(ticket):\n    # Check if ticket has exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Split into first and second half\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits in each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return whether sums are equal\n    return sum_first == sum_second\n\n# Read input and process\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)", "def is_lucky_ticket(ticket):\n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    # Return whether the sums are equal\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)", "def is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal as boolean\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())", "def is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result))", "def is_lucky_ticket(ticket):\n    # Split the ticket into first three and last three digits\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits for each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return True if sums are equal, False otherwise\n    return sum_first == sum_second\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)", "def is_lucky_ticket(ticket):\n    # Validate input length\n    if len(ticket) != 6:\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == second_sum\n\n# Read input and call function\nticket_number = input().strip()\nresult = is_lucky_ticket(ticket_number)\nprint(\"true\" if result else \"false\")", "def is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == second_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())", "def is_lucky_ticket(ticket):\n    if len(ticket) != 6:\n        return False\n    \n    first_half = sum(int(digit) for digit in ticket[:3])\n    second_half = sum(int(digit) for digit in ticket[3:])\n    \n    return first_half == second_half\n\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())", "def is_lucky_ticket(ticket):\n    # Check if ticket is exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return \"false\"\n    \n    # Calculate sum of first three digits\n    first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return \"true\" if first_half == second_half else \"false\"\n\n# Read input and test the function\nticket_number = input().strip()\nresult = is_lucky_ticket(ticket_number)\nprint(result)"], "responses": ["\ndef is_lucky_ticket(ticket):\n    # Extract first three and last three digits\n    first_three = ticket[:3]\n    last_three = ticket[3:]\n    \n    # Calculate sums\n    sum_first = sum(int(digit) for digit in first_three)\n    sum_last = sum(int(digit) for digit in last_three)\n    \n    # Return whether sums are equal\n    return sum_first == sum_last\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(\"true\" if result else \"false\")\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Check if ticket has exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Split into first and second half\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits in each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return whether sums are equal\n    return sum_first == sum_second\n\n# Read input and process\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    # Return whether the sums are equal\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal as boolean\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    last_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == last_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result))\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Split the ticket into first three and last three digits\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits for each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return True if sums are equal, False otherwise\n    return sum_first == sum_second\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(result)\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Validate input length\n    if len(ticket) != 6:\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == second_sum\n\n# Read input and call function\nticket_number = input().strip()\nresult = is_lucky_ticket(ticket_number)\nprint(\"true\" if result else \"false\")\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Validate input\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Calculate sum of first three digits\n    first_sum = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return first_sum == second_sum\n\n# Read input and call function\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())\n\n\n", "\ndef is_lucky_ticket(ticket):\n    if len(ticket) != 6:\n        return False\n    \n    first_half = sum(int(digit) for digit in ticket[:3])\n    second_half = sum(int(digit) for digit in ticket[3:])\n    \n    return first_half == second_half\n\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())\n\n\n", "\ndef is_lucky_ticket(ticket):\n    # Check if ticket is exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return \"false\"\n    \n    # Calculate sum of first three digits\n    first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate sum of last three digits\n    second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Return whether the sums are equal\n    return \"true\" if first_half == second_half else \"false\"\n\n# Read input and test the function\nticket_number = input().strip()\nresult = is_lucky_ticket(ticket_number)\nprint(result)\n\n\n"], "prompt_tokens": [5702, 5541, 4846, 5843, 5710, 5110, 5449, 5361, 4906, 5919], "completion_tokens": [1998, 2232, 2559, 1983, 2367, 2382, 2127, 1919, 1739, 2111], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 3569}
{"name": "2755", "description": "Return a new array consisting of elements which are multiple of their own index in input array (length > 1).\n\nSome cases: \n\n```\n[22, -6, 32, 82, 9, 25] =>  [-6, 32, 25]\n\n[68, -1, 1, -7, 10, 10] => [-1, 10]\n\n[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68] => [-85, 72, 0, 68]\n```", "difficulty": "introductory", "id": 2755, "sample_io": [{"input": "[22, -6, 32, 82, 9, 25]", "output": [[-6, 32, 25]]}, {"input": "[68, -1, 1, -7, 10, 10]", "output": [[-1, 10]]}, {"input": "[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68]", "output": [[-85, 72, 0, 68]]}], "test_list": [{"input": "[22, -6, 32, 82, 9, 25]", "output": [[-6, 32, 25]]}, {"input": "[68, -1, 1, -7, 10, 10]", "output": [[-1, 10]]}, {"input": "[11, -11]", "output": [[-11]]}, {"input": "[-56, -85, 72, -26, -14, 76, -27, 72, 35, -21, -67, 87, 0, 21, 59, 27, -92, 68]", "output": [[-85, 72, 0, 68]]}, {"input": "[28, 38, -44, -99, -13, -54, 77, -51]", "output": [[38, -44, -99]]}, {"input": "[-1, -49, -1, 67, 8, -60, 39, 35]", "output": [[-49, 8, -60, 35]]}], "starter_code": "\ndef multiple_of_index(arr):\n\t", "source_codes": ["import sys\n\ndef multiple_of_index(arr):\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] % i == 0:\n            result.append(arr[i])\n    return result\n\n# Read input\narr = eval(input())\n# Process and get result\nresult = multiple_of_index(arr)\n# Print result\nprint(result)"], "responses": ["\nimport sys\n\ndef multiple_of_index(arr):\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] % i == 0:\n            result.append(arr[i])\n    return result\n\n# Read input\narr = eval(input())\n# Process and get result\nresult = multiple_of_index(arr)\n# Print result\nprint(result)\n\n\n"], "prompt_tokens": [8602], "completion_tokens": [3235], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2755}
{"name": "4168", "description": "Implement a function which takes a string, and returns its hash value.\n\nAlgorithm steps:\n\n* `a` := sum of the ascii values of the input characters\n* `b` := sum of every difference between the consecutive characters of the input (second char minus first char, third minus second, ...)\n* `c` := (`a` OR `b`) AND ((NOT `a`) shift left by 2 bits)\n* `d` := `c` XOR (32 * (`total_number_of_spaces` + 1))\n* return `d`\n\n**Note**: OR, AND, NOT, XOR are bitwise operations.\n\n___\n\n### Examples\n\n```\ninput = \"a\"\na = 97\nb = 0\nresult = 64\n\ninput = \"ca\"\na = 196\nb = -2\nresult = -820\n```\n\n___\n\nGive an example why this hashing algorithm is bad?", "difficulty": "introductory", "id": 4168, "sample_io": [{"input": "a", "output": [64]}, {"input": "ca", "output": [-820]}], "test_list": [{"input": "int main(int argc, char *argv[]) { return 0; }", "output": [188]}, {"input": " Yo - What's Good?! ", "output": [460]}, {"input": " df af asd ", "output": [744]}, {"input": "global hash", "output": [1120]}, {"input": "section .text", "output": [328]}, {"input": "hash:", "output": [-1884]}, {"input": "    xor eax, eax", "output": [1080]}, {"input": "    ret", "output": [112]}, {"input": "; -----> end of hash <-----", "output": [-7136]}, {"input": "int hash(const char *str);", "output": [-9232]}, {"input": "", "output": [32]}, {"input": " ", "output": [96]}, {"input": "  ", "output": [32]}, {"input": "   ", "output": [224]}, {"input": "    ", "output": [32]}], "starter_code": "\ndef string_hash(s):\n\t", "source_codes": ["def compute_hash(s):\n    if not s:\n        a = 0\n        b = 0\n        num_spaces = 0\n    else:\n        a = sum(ord(c) for c in s)\n        b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n        num_spaces = s.count(' ')\n    \n    # Calculate c: (a OR b) AND ((NOT a) << 2)\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate d: c XOR (32 * (num_spaces + 1))\n    d = c ^ (32 * (num_spaces + 1))\n    \n    return d\n\n# Read input and compute hash\ninput_string = input()\nresult = compute_hash(input_string)\nprint(result)", "def compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c := (a OR b) AND ((NOT a) shift left by 2 bits)\n    not_a = ~a\n    not_a_shifted = not_a << 2\n    c = (a | b) & not_a_shifted\n    \n    # Step 4: Calculate 'd' with space count adjustment\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input().strip()\nprint(compute_hash(s))", "def compute_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = 0\n    if len(s) > 1:\n        b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with space count\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))", "def calculate_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(char) for char in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with 32 times (number of spaces + 1)\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input().strip()\nresult = calculate_hash(input_string)\nprint(result)", "def compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive differences\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s))) if len(s) > 1 else 0\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & (~a << 2)\n    \n    # Step 4: Calculate 'd'\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))", "def compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive character differences\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' with space count adjustment\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))", "def calculate_hash(s):\n    # Calculate 'a' as the sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as the sum of differences between consecutive characters\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Calculate 'c' using bitwise operations\n    # In Python, ~a gives -(a+1), which is the correct two's complement NOT for signed integers\n    c = (a | b) & ((~a) << 2)\n    \n    # Count spaces in the string\n    space_count = s.count(' ')\n    \n    # Calculate 'd' using XOR operation\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_str = input().strip()\nresult = calculate_hash(input_str)\nprint(result)", "def compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive character differences\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c := (a OR b) AND ((NOT a) shift left by 2 bits)\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' using XOR with space count factor\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input()\nprint(compute_hash(input_string))", "def compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' with XOR and number of spaces\n    num_spaces = s.count(' ')\n    d = c ^ (32 * (num_spaces + 1))\n    \n    return d\n\n# Read input and print result\ns = input().strip()\nprint(compute_hash(s))", "def calculate_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with spaces count\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input().strip()\nresult = calculate_hash(input_string)\nprint(result)"], "responses": ["\ndef compute_hash(s):\n    if not s:\n        a = 0\n        b = 0\n        num_spaces = 0\n    else:\n        a = sum(ord(c) for c in s)\n        b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n        num_spaces = s.count(' ')\n    \n    # Calculate c: (a OR b) AND ((NOT a) << 2)\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate d: c XOR (32 * (num_spaces + 1))\n    d = c ^ (32 * (num_spaces + 1))\n    \n    return d\n\n# Read input and compute hash\ninput_string = input()\nresult = compute_hash(input_string)\nprint(result)\n\n\n", "\ndef compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c := (a OR b) AND ((NOT a) shift left by 2 bits)\n    not_a = ~a\n    not_a_shifted = not_a << 2\n    c = (a | b) & not_a_shifted\n    \n    # Step 4: Calculate 'd' with space count adjustment\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input().strip()\nprint(compute_hash(s))\n\n\n", "\ndef compute_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = 0\n    if len(s) > 1:\n        b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with space count\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))\n\n\n", "\ndef calculate_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(char) for char in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with 32 times (number of spaces + 1)\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input().strip()\nresult = calculate_hash(input_string)\nprint(result)\n\n\n", "\ndef compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive differences\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s))) if len(s) > 1 else 0\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & (~a << 2)\n    \n    # Step 4: Calculate 'd'\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))\n\n\n", "\ndef compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive character differences\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' with space count adjustment\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))\n\n\n", "\ndef calculate_hash(s):\n    # Calculate 'a' as the sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as the sum of differences between consecutive characters\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Calculate 'c' using bitwise operations\n    # In Python, ~a gives -(a+1), which is the correct two's complement NOT for signed integers\n    c = (a | b) & ((~a) << 2)\n    \n    # Count spaces in the string\n    space_count = s.count(' ')\n    \n    # Calculate 'd' using XOR operation\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_str = input().strip()\nresult = calculate_hash(input_str)\nprint(result)\n\n\n", "\ndef compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of consecutive character differences\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c := (a OR b) AND ((NOT a) shift left by 2 bits)\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' using XOR with space count factor\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input()\nprint(compute_hash(input_string))\n\n\n", "\ndef compute_hash(s):\n    # Step 1: Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' as sum of differences between consecutive characters\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Calculate 'd' with XOR and number of spaces\n    num_spaces = s.count(' ')\n    d = c ^ (32 * (num_spaces + 1))\n    \n    return d\n\n# Read input and print result\ns = input().strip()\nprint(compute_hash(s))\n\n\n", "\ndef calculate_hash(s):\n    # Calculate 'a' as sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Calculate 'b' as sum of differences between consecutive characters\n    b = 0\n    for i in range(1, len(s)):\n        b += ord(s[i]) - ord(s[i-1])\n    \n    # Calculate 'c' using bitwise operations\n    c = (a | b) & ((~a) << 2)\n    \n    # Calculate 'd' using XOR with spaces count\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ninput_string = input().strip()\nresult = calculate_hash(input_string)\nprint(result)\n\n\n"], "prompt_tokens": [8044, 7855, 6965, 6716, 7692, 6986, 7914, 8190, 7211, 6718], "completion_tokens": [5452, 4785, 5306, 6570, 6851, 6489, 4380, 6155, 5241, 6829], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 4168}
{"name": "4391", "description": "## The Story\nGreen Lantern's long hours of study and practice with his ring have really paid off -- his skills, focus, and control have improved so much that now he can even use his ring to update and redesign his web site. Earlier today he was focusing his will and a beam from his ring upon the Justice League web server, while intensely brainstorming and visualizing in minute detail different looks and ideas for his web site, and when he finished and reloaded his home page, he was absolutely thrilled to see that among other things it now displayed\n\n~~~~\nIn brightest day, in blackest night,\nThere's nothing cooler than my site!\n~~~~\n\nin his favorite font in very large blinking green letters.\n\nThe problem is, Green Lantern's ring has no power over anything yellow, so if he's experimenting with his web site and accidentally changes some text or background color to yellow, he will no longer be able to make any changes to those parts of the content or presentation (because he doesn't actually know any HTML, CSS, programming languages, frameworks, etc.) until he gets a more knowledgable friend to edit the code for him.\n\n## Your Mission\nYou can help Green Lantern by writing a function that will replace any color property values that are too yellow with shades of green or blue-green. Presumably at a later time the two of you will be doing some testing to find out at exactly which RGB values yellow stops being yellow and starts being off-white, orange, brown, etc. as far as his ring is concerned, but here's the plan to get version 1.0 up and running as soon as possible:\n\nYour function will receive either an HTML color name or a six-digit hex color code. (You're not going to bother with other types of color codes just now because you don't think they will come up.) If the color is too yellow, your function needs to return a green or blue-green shade instead, but if it is not too yellow, it needs to return the original color name or hex color code unchanged.\n\n### HTML Color Names\n(If don't know what HTML color names are, take a look at this HTML colors names reference.)\n\nFor HMTL color names, you are going to start out trying a pretty strict definition of yellow, replacing any of the following colors as specified:\n\n~~~~\nGold => ForestGreen\nKhaki => LimeGreen\nLemonChiffon => PaleGreen\nLightGoldenRodYellow => SpringGreen\nLightYellow => MintCream\nPaleGoldenRod => LightGreen\nYellow => Lime\n~~~~\n\nHTML color names are case-insensitive, so your function will need to be able to identify the above yellow shades regardless of the cases used, but should output the green shades as capitalized above.\n\nSome examples:\n```\n\"lemonchiffon\"    \"PaleGreen\"\n\"GOLD\"            \"ForestGreen\"\n\"pAlEgOlDeNrOd\"   \"LightGreen\"\n\"BlueViolet\"      \"BlueViolet\"\n```\n\n### Hex Color Codes\n(If you don't know what six-digit hex color codes are, take a look at this Wikipedia description. Basically the six digits are made up of three two-digit numbers in base 16, known as hexidecimal or hex, from 00 to FF (equivalent to 255 in base 10, also known as decimal), with the first two-digit number specifying the color's red value, the second the green value, and the third blue.)\n\nWith six-digit color hex codes, you are going to start out going really overboard, interpreting as \"yellow\" any hex code where the red (R) value and the green (G) value are each greater than the blue (B) value. When you find one of these \"yellow\" hex codes, your function will take the three hex values and rearrange them that the largest goes to G, the middle goes to B, and the smallest to R. \n\nFor example, with the six-digit hex color code `#FFD700`, which has an R value of hex FF (decimal 255), a G value of hex D7 (decimal 215), and a B value of hex 00 (decimal 0), as the R and G values are each larger than the B value, you would return it as `#00FFD7` -- the FF reassigned to G, the D7 to B, and the 00 to R. \n\nHex color codes are also case-insensitive, but your function should output them in the same case they were received in, just for consistency with whatever style is being used.\n\nSome examples:\n```\n\"#000000\"   \"#000000\"\n\"#b8860b\"   \"#0bb886\"\n\"#8FBC8F\"   \"#8FBC8F\"\n\"#C71585\"   \"#C71585\"\n```", "difficulty": "introductory", "id": 4391, "sample_io": [{"input": "lemonchiffon", "output": ["PaleGreen"]}, {"input": "GOLD", "output": ["ForestGreen"]}, {"input": "pAlEgOlDeNrOd", "output": ["LightGreen"]}, {"input": "BlueViolet", "output": ["BlueViolet"]}, {"input": "#000000", "output": ["#000000"]}, {"input": "#b8860b", "output": ["#0bb886"]}, {"input": "#8FBC8F", "output": ["#8FBC8F"]}, {"input": "#C71585", "output": ["#C71585"]}], "test_list": [{"input": "lemonchiffon", "output": ["PaleGreen"]}, {"input": "GOLD", "output": ["ForestGreen"]}, {"input": "pAlEgOlDeNrOd", "output": ["LightGreen"]}, {"input": "BlueViolet", "output": ["BlueViolet"]}, {"input": "#000000", "output": ["#000000"]}, {"input": "#b8860b", "output": ["#0bb886"]}, {"input": "#8FBC8F", "output": ["#8FBC8F"]}, {"input": "#C71585", "output": ["#C71585"]}], "starter_code": "\ndef yellow_be_gone(s):\n\t", "source_codes": ["def convert_yellow_color(color):\n    # Dictionary mapping yellow colors to green replacements\n    yellow_to_green = {\n        'gold': 'ForestGreen',\n        'khaki': 'LimeGreen',\n        'lemonchiffon': 'PaleGreen',\n        'lightgoldenrodyellow': 'SpringGreen',\n        'lightyellow': 'MintCream',\n        'palegoldenrod': 'LightGreen',\n        'yellow': 'Lime'\n    }\n    \n    # Check if it's a hex color code\n    if color.startswith('#'):\n        # Extract RGB components\n        r_hex = color[1:3]\n        g_hex = color[3:5]\n        b_hex = color[5:7]\n        \n        # Convert hex to decimal\n        r = int(r_hex, 16)\n        g = int(g_hex, 16)\n        b = int(b_hex, 16)\n        \n        # Check if it's \"yellow\" (R > B and G > B)\n        if r > b and g > b:\n            # Sort the values\n            sorted_values = sorted([r, g, b])\n            # Reassign: smallest to R, middle to B, largest to G\n            new_r = sorted_values[0]\n            new_b = sorted_values[1]\n            new_g = sorted_values[2]\n            \n            # Convert back to hex with proper padding\n            new_r_hex = format(new_r, '02x')\n            new_g_hex = format(new_g, '02x')\n            new_b_hex = format(new_b, '02x')\n            \n            # Preserve original case for each pair of characters\n            result_hex_chars = new_r_hex + new_g_hex + new_b_hex\n            original_hex_chars = r_hex + g_hex + b_hex\n            \n            result = '#'\n            for i, orig_char in enumerate(original_hex_chars):\n                if orig_char.isupper():\n                    result += result_hex_chars[i].upper()\n                else:\n                    result += result_hex_chars[i].lower()\n            \n            return result\n        else:\n            return color\n    else:\n        # Handle HTML color names (case-insensitive)\n        color_lower = color.lower()\n        if color_lower in yellow_to_green:\n            return yellow_to_green[color_lower]\n        else:\n            return color\n\n# Read input and process\ninput_color = input().strip()\nresult = convert_yellow_color(input_color)\nprint(result)"], "responses": ["\ndef convert_yellow_color(color):\n    # Dictionary mapping yellow colors to green replacements\n    yellow_to_green = {\n        'gold': 'ForestGreen',\n        'khaki': 'LimeGreen',\n        'lemonchiffon': 'PaleGreen',\n        'lightgoldenrodyellow': 'SpringGreen',\n        'lightyellow': 'MintCream',\n        'palegoldenrod': 'LightGreen',\n        'yellow': 'Lime'\n    }\n    \n    # Check if it's a hex color code\n    if color.startswith('#'):\n        # Extract RGB components\n        r_hex = color[1:3]\n        g_hex = color[3:5]\n        b_hex = color[5:7]\n        \n        # Convert hex to decimal\n        r = int(r_hex, 16)\n        g = int(g_hex, 16)\n        b = int(b_hex, 16)\n        \n        # Check if it's \"yellow\" (R > B and G > B)\n        if r > b and g > b:\n            # Sort the values\n            sorted_values = sorted([r, g, b])\n            # Reassign: smallest to R, middle to B, largest to G\n            new_r = sorted_values[0]\n            new_b = sorted_values[1]\n            new_g = sorted_values[2]\n            \n            # Convert back to hex with proper padding\n            new_r_hex = format(new_r, '02x')\n            new_g_hex = format(new_g, '02x')\n            new_b_hex = format(new_b, '02x')\n            \n            # Preserve original case for each pair of characters\n            result_hex_chars = new_r_hex + new_g_hex + new_b_hex\n            original_hex_chars = r_hex + g_hex + b_hex\n            \n            result = '#'\n            for i, orig_char in enumerate(original_hex_chars):\n                if orig_char.isupper():\n                    result += result_hex_chars[i].upper()\n                else:\n                    result += result_hex_chars[i].lower()\n            \n            return result\n        else:\n            return color\n    else:\n        # Handle HTML color names (case-insensitive)\n        color_lower = color.lower()\n        if color_lower in yellow_to_green:\n            return yellow_to_green[color_lower]\n        else:\n            return color\n\n# Read input and process\ninput_color = input().strip()\nresult = convert_yellow_color(input_color)\nprint(result)\n\n\n"], "prompt_tokens": [18515], "completion_tokens": [4993], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4391}
{"name": "4344", "description": "# Task\nImagine `n` horizontal lines and `m` vertical lines.\n\nSome of these lines intersect, creating rectangles.\n\nHow many rectangles are there?\n\n# Examples\n\nFor `n=2, m=2,` the result should be `1`.\n\nthere is only one 1x1 rectangle.\n\nFor `n=2, m=3`, the result should be `3`.\n\nthere are two 1x1 rectangles and one 1x2 rectangle. So `2 + 1 = 3`.\n\nFor n=3, m=3, the result should be `9`.\n\nthere are four 1x1 rectangles, two 1x2 rectangles, two 2x1 rectangles and one 2x2 rectangle. So `4 + 2 + 2 + 1 = 9`.\n\n\n\n# Input & Output\n\n\n- `[input]` integer `n`\n\nNumber of horizontal lines.\n\nConstraints: `0 <= n <= 100`\n\n\n- `[input]` integer `m`\n\nNumber of vertical lines.\n\nConstraints: `0 <= m <= 100`\n\n\n- `[output]` an integer\n\nNumber of rectangles.", "difficulty": "introductory", "id": 4344, "sample_io": [{"input": "2\n3", "output": [3]}, {"input": "2\n2", "output": [1]}, {"input": "3\n3", "output": [9]}], "test_list": [{"input": "2\n3", "output": [3]}, {"input": "2\n2", "output": [1]}, {"input": "1\n1", "output": [0]}, {"input": "0\n1", "output": [0]}, {"input": "3\n3", "output": [9]}, {"input": "100\n100", "output": [24502500]}], "starter_code": "\ndef rectangles(n, m):\n\t", "source_codes": ["n = int(input())\nm = int(input())\n\n# We need at least 2 horizontal lines and 2 vertical lines to form a rectangle\nif n < 2 or m < 2:\n    print(0)\nelse:\n    # Number of ways to choose 2 lines from n horizontal lines: C(n,2) = n*(n-1)/2\n    horizontal_pairs = n * (n - 1) // 2\n    # Number of ways to choose 2 lines from m vertical lines: C(m,2) = m*(m-1)/2\n    vertical_pairs = m * (m - 1) // 2\n    # Total rectangles = horizontal_pairs * vertical_pairs\n    print(horizontal_pairs * vertical_pairs)"], "responses": ["\nn = int(input())\nm = int(input())\n\n# We need at least 2 horizontal lines and 2 vertical lines to form a rectangle\nif n < 2 or m < 2:\n    print(0)\nelse:\n    # Number of ways to choose 2 lines from n horizontal lines: C(n,2) = n*(n-1)/2\n    horizontal_pairs = n * (n - 1) // 2\n    # Number of ways to choose 2 lines from m vertical lines: C(m,2) = m*(m-1)/2\n    vertical_pairs = m * (m - 1) // 2\n    # Total rectangles = horizontal_pairs * vertical_pairs\n    print(horizontal_pairs * vertical_pairs)\n\n\n"], "prompt_tokens": [8026], "completion_tokens": [3591], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4344}
{"name": "3856", "description": "The prime number sequence starts with: `2,3,5,7,11,13,17,19...`. Notice that `2` is in position `one`. \n\n`3` occupies position `two`, which is a prime-numbered position. Similarly, `5`, `11` and `17` also occupy prime-numbered positions. We shall call primes such as `3,5,11,17` dominant primes because they occupy prime-numbered positions in the prime number sequence. Let's call this `listA`. \n\nAs you can see from listA, for the prime range `range(0,10)`, there are `only two` dominant primes (`3` and `5`) and the sum of these primes is: `3 + 5 = 8`. \n\nSimilarly, as shown in listA, in the `range (6,20)`, the dominant primes in this range are `11` and `17`, with a sum of `28`.\n\nGiven a `range (a,b)`, what is the sum of dominant primes within that range? Note that  `a <= range <= b` and `b` will not exceed `500000`.\n\nGood luck!\n\nIf you like this Kata, you will enjoy:\n\n[Simple Prime Streaming](https://www.codewars.com/kata/5a908da30025e995880000e3)\n\n[Sum of prime-indexed elements](https://www.codewars.com/kata/59f38b033640ce9fc700015b)\n\n[Divisor harmony](https://www.codewars.com/kata/59bf97cd4f98a8b1cd00007e)", "difficulty": "introductory", "id": 3856, "sample_io": [{"input": "0\n10", "output": [8]}, {"input": "6\n20", "output": [28]}], "test_list": [{"input": "0\n10", "output": [8]}, {"input": "2\n200", "output": [1080]}, {"input": "200\n2000", "output": [48132]}, {"input": "500\n10000", "output": [847039]}, {"input": "1000\n100000", "output": [52114889]}, {"input": "2000\n200000", "output": [183035206]}, {"input": "3000\n400000", "output": [650120994]}, {"input": "4000\n500000", "output": [972664400]}], "starter_code": "\ndef solve(a,b):\n\t", "source_codes": ["def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    return [i for i in range(2, limit + 1) if is_prime[i]], is_prime\n\ndef main():\n    # Generate primes up to 500000\n    primes, is_prime_bool = sieve_of_eratosthenes(500000)\n    \n    # Find dominant primes - primes that are at prime-numbered positions\n    dominant_primes = []\n    for index, prime in enumerate(primes):\n        position = index + 1  # 1-indexed position\n        # Check if the position itself is a prime number\n        if position < len(is_prime_bool) and is_prime_bool[position]:\n            dominant_primes.append(prime)\n    \n    # Read input range\n    a = int(input())\n    b = int(input())\n    \n    # Sum dominant primes in range [a, b]\n    result = sum(p for p in dominant_primes if a <= p <= b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    return [i for i in range(2, limit + 1) if is_prime[i]], is_prime\n\ndef main():\n    # Generate primes up to 500000\n    primes, is_prime_bool = sieve_of_eratosthenes(500000)\n    \n    # Find dominant primes - primes that are at prime-numbered positions\n    dominant_primes = []\n    for index, prime in enumerate(primes):\n        position = index + 1  # 1-indexed position\n        # Check if the position itself is a prime number\n        if position < len(is_prime_bool) and is_prime_bool[position]:\n            dominant_primes.append(prime)\n    \n    # Read input range\n    a = int(input())\n    b = int(input())\n    \n    # Sum dominant primes in range [a, b]\n    result = sum(p for p in dominant_primes if a <= p <= b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [11482], "completion_tokens": [5296], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3856}
{"name": "3698", "description": "In this exercise, you will have to create a function named tiyFizzBuzz. This function will take on a string parameter and will return that string with some characters replaced, depending on the value:\n\n- If a letter is a upper case consonants, replace that character with \"Iron\".\n- If a letter is a lower case consonants or a non-alpha character, do nothing to that character\n- If a letter is a upper case vowel, replace that character with \"Iron Yard\".\n- If a letter is a lower case vowel, replace that character with \"Yard\".\n\nReady?", "difficulty": "introductory", "id": 3698, "sample_io": [], "test_list": [{"input": " ", "output": [" "]}, {"input": "H", "output": ["Iron"]}, {"input": "b", "output": ["b"]}, {"input": "A", "output": ["Iron Yard"]}, {"input": "a", "output": ["Yard"]}, {"input": "Hello WORLD!", "output": ["IronYardllYard IronIron YardIronIronIron!"]}, {"input": "H6H4Na ./?U", "output": ["Iron6Iron4IronYard ./?Iron Yard"]}], "starter_code": "\ndef tiy_fizz_buzz(string):\n\t", "source_codes": ["def tiyFizzBuzz(s):\n    vowels = set('aeiou')\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                if char.lower() in vowels:\n                    result.append(\"Iron Yard\")\n                else:\n                    result.append(\"Iron\")\n            elif char in vowels:\n                result.append(\"Yard\")\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n# Read input and process\ninput_str = input()\noutput_str = tiyFizzBuzz(input_str)\nprint(output_str)"], "responses": ["\ndef tiyFizzBuzz(s):\n    vowels = set('aeiou')\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                if char.lower() in vowels:\n                    result.append(\"Iron Yard\")\n                else:\n                    result.append(\"Iron\")\n            elif char in vowels:\n                result.append(\"Yard\")\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n# Read input and process\ninput_str = input()\noutput_str = tiyFizzBuzz(input_str)\nprint(output_str)\n\n\n"], "prompt_tokens": [7196], "completion_tokens": [6024], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3698}
{"name": "4268", "description": "Given a non-negative number, return the next bigger polydivisible number, or an empty value like `null` or `Nothing`.\n\nA number is polydivisible if its first digit is cleanly divisible by `1`, its first two digits by `2`, its first three by `3`, and so on. There are finitely many polydivisible numbers.", "difficulty": "introductory", "id": 4268, "sample_io": [], "test_list": [{"input": "0", "output": [1]}, {"input": "10", "output": [12]}, {"input": "11", "output": [12]}, {"input": "1234", "output": [1236]}, {"input": "123220", "output": [123252]}, {"input": "998", "output": [1020]}, {"input": "999", "output": [1020]}, {"input": "1234567890", "output": [1236004020]}, {"input": "3608528850368400786036724", "output": [3608528850368400786036725]}, {"input": "3608528850368400786036725", "output": [null]}], "starter_code": "\ndef next_num(n):\n\t", "source_codes": ["def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    # There are only finitely many polydivisible numbers\n    # The largest known polydivisible number has 25 digits\n    while current < 10**25:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    return None\n\n# Read input and produce output as required\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"None\")\nelse:\n    print(result)", "def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    while True:\n        if is_polydivisible(current):\n            return current\n        current += 1\n\nn = int(input())\nresult = next_polydivisible(n)\nprint(result)", "def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef find_next_polydivisible(start):\n    # Generate all polydivisible numbers and find the first one greater than start\n    def generate_polydivisible(prefix, length):\n        if length > 25:  # Maximum possible length for polydivisible numbers\n            return []\n        \n        results = []\n        if length == 0:\n            # Start with single digits 1-9 (0 is not typically considered)\n            for digit in range(1, 10):\n                results.extend(generate_polydivisible(str(digit), 1))\n        else:\n            # Check if current prefix is polydivisible\n            prefix_num = int(prefix)\n            if prefix_num % length == 0:\n                results.append(prefix_num)\n                # Try adding each digit 0-9\n                for digit in range(0, 10):\n                    new_prefix = prefix + str(digit)\n                    new_num = int(new_prefix)\n                    if new_num % (length + 1) == 0:\n                        results.extend(generate_polydivisible(new_prefix, length + 1))\n        \n        return results\n    \n    # Generate all polydivisible numbers\n    all_polydivisible = []\n    \n    # Start with single digits\n    for digit in range(1, 10):\n        all_polydivisible.append(digit)\n        # Build longer numbers\n        stack = [(str(digit), 1)]\n        while stack:\n            prefix, length = stack.pop()\n            if length >= 25:\n                continue\n            prefix_num = int(prefix)\n            for next_digit in range(0, 10):\n                new_prefix = prefix + str(next_digit)\n                new_num = int(new_prefix)\n                if new_num % (length + 1) == 0:\n                    all_polydivisible.append(new_num)\n                    stack.append((new_prefix, length + 1))\n    \n    # Sort them\n    all_polydivisible.sort()\n    \n    # Find the first one greater than start\n    for num in all_polydivisible:\n        if num > start:\n            return num\n    \n    return None\n\ndef next_polydivisible_optimized(n):\n    # More efficient approach - build candidates digit by digit\n    def build_from_prefix(prefix_str, target_length):\n        \"\"\"Build all polydivisible numbers with given prefix\"\"\"\n        if len(prefix_str) == target_length:\n            return [int(prefix_str)]\n        \n        results = []\n        prefix_num = int(prefix_str)\n        current_length = len(prefix_str)\n        \n        # Add next digit\n        for digit in range(0, 10):\n            new_number_str = prefix_str + str(digit)\n            new_number = int(new_number_str)\n            if new_number % (current_length + 1) == 0:\n                results.extend(build_from_prefix(new_number_str, target_length))\n        \n        return results\n    \n    # Search systematically\n    current = n + 1\n    \n    # Precompute some bounds for efficiency\n    length = len(str(current))\n    \n    # For smaller numbers, direct search is OK\n    if length <= 10:\n        upper_limit = max(current + 1000000, 3608528850368400786036725)\n        for i in range(current, min(upper_limit, 3608528850368400786036725)):\n            if is_polydivisible(i):\n                return i\n    \n    # For larger numbers, try a smarter approach\n    # Generate candidates of same length first\n    str_current = str(current)\n    current_len = len(str_current)\n    \n    # Try building numbers of same or greater length\n    for target_len in range(current_len, 26):\n        # Try prefixes that could lead to solutions\n        if target_len == current_len:\n            # For same length, start from current\n            start_prefix = str_current\n        else:\n            # For longer lengths, start from smallest\n            start_prefix = \"1\" + \"0\" * (target_len - 1)\n        \n        # Build candidates systematically\n        candidates = []\n        \n        # Simple but more targeted search\n        test_start = max(current + 1, int(start_prefix))\n        test_end = min(test_start + 100000, 3608528850368400786036725)\n        \n        for i in range(test_start, test_end):\n            if is_polydivisible(i):\n                return i\n        \n        # If not found in small range, try building properly\n        if target_len <= 15:  # Reasonable limit for construction\n            # Build from valid prefixes\n            def build_valid_numbers(length_remaining, prefix=\"\"):\n                if length_remaining == 0:\n                    num_val = int(prefix) if prefix else 0\n                    if num_val > n:\n                        return [num_val]\n                    return []\n                \n                results = []\n                current_pos = len(prefix) + 1\n                \n                if not prefix:\n                    # First digit can be 1-9\n                    for digit in range(1, 10):\n                        if digit % 1 == 0:  # Always true\n                            results.extend(build_valid_numbers(length_remaining - 1, str(digit)))\n                else:\n                    # Subsequent digits\n                    prefix_val = int(prefix)\n                    for digit in range(0, 10):\n                        new_prefix = prefix + str(digit)\n                        new_val = int(new_prefix)\n                        if new_val % current_pos == 0:\n                            results.extend(build_valid_numbers(length_remaining - 1, new_prefix))\n                \n                return results\n            \n            candidates = build_valid_numbers(target_len)\n            candidates = [c for c in candidates if c > n]\n            if candidates:\n                return min(candidates)\n    \n    return None\n\n# Most practical approach - optimized search\ndef next_polydivisible(n):\n    current = n + 1\n    \n    # Known large polydivisible numbers to avoid excessive computation\n    # The sequence is finite and we know the maximum\n    max_polydivisible = 3608528850368400786036725\n    \n    # Smart increment based on length to avoid checking every number\n    while current <= max_polydivisible * 10:\n        if is_polydivisible(current):\n            return current\n        \n        # Optimization: for large numbers, skip ahead intelligently\n        current_str = str(current)\n        length = len(current_str)\n        \n        if length >= 12:\n            # For very long numbers, if we're checking many and failing,\n            # jump to next length to avoid timeout\n            if length < 25:\n                # Jump to beginning of next length\n                next_length_start = 10 ** length\n                if current < next_length_start:\n                    current = next_length_start\n                    continue\n        \n        current += 1\n    \n    return None\n\n# Read input\nn = int(input())\n\n# Find and print the next polydivisible number\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print(\"\")  # Print empty string as per problem description for empty value", "def is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Start checking from n+1\n    candidate = n + 1\n    \n    # The largest known polydivisible number has 25 digits\n    # http://en.wikipedia.org/wiki/Polydivisible_number\n    max_digits = 25\n    \n    while len(str(candidate)) <= max_digits:\n        if is_polydivisible(str(candidate)):\n            return candidate\n        candidate += 1\n    \n    return None\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"null\")\nelse:\n    print(result)", "def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    # The largest known polydivisible number has 25 digits\n    limit = 10**25\n    while current < limit:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    return None\n\n# Read input from standard input\nn = int(input())\n# Find and print the next polydivisible number\nresult = next_polydivisible(n)\nif result is None:\n    print(\"\")\nelse:\n    print(result)", "def is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    candidate = n + 1\n    \n    while True:\n        s = str(candidate)\n        \n        # Check if this number is polydivisible\n        if is_polydivisible(s):\n            return candidate\n            \n        # If we've exceeded reasonable limits, return None\n        if len(s) > 25:\n            return None\n            \n        # Optimization: try to build the next potential candidate\n        # rather than checking every single number\n        valid = True\n        for i in range(1, len(s) + 1):\n            prefix = s[:i]\n            if int(prefix) % i != 0:\n                # Find the next valid prefix\n                current_prefix_val = int(prefix)\n                remainder = current_prefix_val % i\n                next_prefix_val = current_prefix_val + (i - remainder)\n                \n                # Check if the next valid prefix has the same number of digits\n                next_prefix_str = str(next_prefix_val)\n                if len(next_prefix_str) == len(prefix):\n                    # Replace the prefix and set remaining digits to 0\n                    candidate = int(next_prefix_str + '0' * (len(s) - i))\n                else:\n                    # Need more digits, start over with the new length\n                    candidate = 10 ** len(s)\n                valid = False\n                break\n        \n        if valid:\n            # If we get here, the number should be polydivisible\n            # But let's double-check to be safe\n            if is_polydivisible(str(candidate)):\n                return candidate\n            else:\n                candidate += 1\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print()", "def generate_polydivisible_numbers():\n    \"\"\"Generate all polydivisible numbers using BFS and return them as a sorted list.\"\"\"\n    from collections import deque\n    \n    polydivisibles = []\n    queue = deque(range(1, 10))  # Start with digits 1-9\n    \n    while queue:\n        num_str = queue.popleft()\n        if isinstance(num_str, int):\n            num_str = str(num_str)\n            \n        polydivisibles.append(int(num_str))\n        \n        # Try appending each digit 0-9\n        for digit in range(10):\n            new_num_str = num_str + str(digit)\n            # Check if the new number is polydivisible\n            if int(new_num_str) % len(new_num_str) == 0:\n                queue.append(new_num_str)\n                \n    return sorted(set(polydivisibles))\n\n# Precompute all polydivisible numbers\nPOLYDIVISIBLE_NUMBERS = generate_polydivisible_numbers()\n\ndef next_polydivisible(n):\n    \"\"\"Find the next polydivisible number greater than n.\"\"\"\n    # Linear search for the first polydivisible number > n\n    for num in POLYDIVISIBLE_NUMBERS:\n        if num > n:\n            return num\n    return None\n\n# Read input and solve\ntry:\n    n = int(input().strip())\n    result = next_polydivisible(n)\n    if result is not None:\n        print(result)\n    else:\n        print(\"null\")\nexcept:\n    print(\"null\")", "def is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    candidate = n + 1\n    # Upper bound for polydivisible numbers\n    upper_bound = 3608528850368400786036725\n    \n    while candidate <= upper_bound:\n        if is_polydivisible(str(candidate)):\n            return candidate\n        candidate += 1\n    \n    return None\n\n# Read input and produce output as required\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"null\")\nelse:\n    print(result)", "def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    if n == 0:\n        return 1\n    \n    # Try incrementing from n+1\n    current = n + 1\n    \n    # There's a finite number of polydivisible numbers, so we don't need an arbitrary limit\n    # But we'll set a reasonable one to avoid infinite loops in case of bugs\n    limit = 10**15  # This should be enough for most practical purposes\n    \n    while current <= limit:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    \n    return None\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print(\"None\")", "def is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Start with the next number\n    current = n + 1\n    \n    # Try to find the next polydivisible number\n    while True:\n        s = str(current)\n        if is_polydivisible(s):\n            return current\n        \n        current += 1\n        \n        # Polydivisible numbers have a finite limit\n        # The maximum length of a polydivisible number is 25 digits\n        if len(str(current)) > 25:\n            return None\n\ndef main():\n    try:\n        n = int(input().strip())\n        result = next_polydivisible(n)\n        if result is not None:\n            print(result)\n        else:\n            print(\"\")\n    except:\n        print(\"\")\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    # There are only finitely many polydivisible numbers\n    # The largest known polydivisible number has 25 digits\n    while current < 10**25:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    return None\n\n# Read input and produce output as required\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"None\")\nelse:\n    print(result)\n\n\n", "\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    while True:\n        if is_polydivisible(current):\n            return current\n        current += 1\n\nn = int(input())\nresult = next_polydivisible(n)\nprint(result)\n\n\n", "\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef find_next_polydivisible(start):\n    # Generate all polydivisible numbers and find the first one greater than start\n    def generate_polydivisible(prefix, length):\n        if length > 25:  # Maximum possible length for polydivisible numbers\n            return []\n        \n        results = []\n        if length == 0:\n            # Start with single digits 1-9 (0 is not typically considered)\n            for digit in range(1, 10):\n                results.extend(generate_polydivisible(str(digit), 1))\n        else:\n            # Check if current prefix is polydivisible\n            prefix_num = int(prefix)\n            if prefix_num % length == 0:\n                results.append(prefix_num)\n                # Try adding each digit 0-9\n                for digit in range(0, 10):\n                    new_prefix = prefix + str(digit)\n                    new_num = int(new_prefix)\n                    if new_num % (length + 1) == 0:\n                        results.extend(generate_polydivisible(new_prefix, length + 1))\n        \n        return results\n    \n    # Generate all polydivisible numbers\n    all_polydivisible = []\n    \n    # Start with single digits\n    for digit in range(1, 10):\n        all_polydivisible.append(digit)\n        # Build longer numbers\n        stack = [(str(digit), 1)]\n        while stack:\n            prefix, length = stack.pop()\n            if length >= 25:\n                continue\n            prefix_num = int(prefix)\n            for next_digit in range(0, 10):\n                new_prefix = prefix + str(next_digit)\n                new_num = int(new_prefix)\n                if new_num % (length + 1) == 0:\n                    all_polydivisible.append(new_num)\n                    stack.append((new_prefix, length + 1))\n    \n    # Sort them\n    all_polydivisible.sort()\n    \n    # Find the first one greater than start\n    for num in all_polydivisible:\n        if num > start:\n            return num\n    \n    return None\n\ndef next_polydivisible_optimized(n):\n    # More efficient approach - build candidates digit by digit\n    def build_from_prefix(prefix_str, target_length):\n        \"\"\"Build all polydivisible numbers with given prefix\"\"\"\n        if len(prefix_str) == target_length:\n            return [int(prefix_str)]\n        \n        results = []\n        prefix_num = int(prefix_str)\n        current_length = len(prefix_str)\n        \n        # Add next digit\n        for digit in range(0, 10):\n            new_number_str = prefix_str + str(digit)\n            new_number = int(new_number_str)\n            if new_number % (current_length + 1) == 0:\n                results.extend(build_from_prefix(new_number_str, target_length))\n        \n        return results\n    \n    # Search systematically\n    current = n + 1\n    \n    # Precompute some bounds for efficiency\n    length = len(str(current))\n    \n    # For smaller numbers, direct search is OK\n    if length <= 10:\n        upper_limit = max(current + 1000000, 3608528850368400786036725)\n        for i in range(current, min(upper_limit, 3608528850368400786036725)):\n            if is_polydivisible(i):\n                return i\n    \n    # For larger numbers, try a smarter approach\n    # Generate candidates of same length first\n    str_current = str(current)\n    current_len = len(str_current)\n    \n    # Try building numbers of same or greater length\n    for target_len in range(current_len, 26):\n        # Try prefixes that could lead to solutions\n        if target_len == current_len:\n            # For same length, start from current\n            start_prefix = str_current\n        else:\n            # For longer lengths, start from smallest\n            start_prefix = \"1\" + \"0\" * (target_len - 1)\n        \n        # Build candidates systematically\n        candidates = []\n        \n        # Simple but more targeted search\n        test_start = max(current + 1, int(start_prefix))\n        test_end = min(test_start + 100000, 3608528850368400786036725)\n        \n        for i in range(test_start, test_end):\n            if is_polydivisible(i):\n                return i\n        \n        # If not found in small range, try building properly\n        if target_len <= 15:  # Reasonable limit for construction\n            # Build from valid prefixes\n            def build_valid_numbers(length_remaining, prefix=\"\"):\n                if length_remaining == 0:\n                    num_val = int(prefix) if prefix else 0\n                    if num_val > n:\n                        return [num_val]\n                    return []\n                \n                results = []\n                current_pos = len(prefix) + 1\n                \n                if not prefix:\n                    # First digit can be 1-9\n                    for digit in range(1, 10):\n                        if digit % 1 == 0:  # Always true\n                            results.extend(build_valid_numbers(length_remaining - 1, str(digit)))\n                else:\n                    # Subsequent digits\n                    prefix_val = int(prefix)\n                    for digit in range(0, 10):\n                        new_prefix = prefix + str(digit)\n                        new_val = int(new_prefix)\n                        if new_val % current_pos == 0:\n                            results.extend(build_valid_numbers(length_remaining - 1, new_prefix))\n                \n                return results\n            \n            candidates = build_valid_numbers(target_len)\n            candidates = [c for c in candidates if c > n]\n            if candidates:\n                return min(candidates)\n    \n    return None\n\n# Most practical approach - optimized search\ndef next_polydivisible(n):\n    current = n + 1\n    \n    # Known large polydivisible numbers to avoid excessive computation\n    # The sequence is finite and we know the maximum\n    max_polydivisible = 3608528850368400786036725\n    \n    # Smart increment based on length to avoid checking every number\n    while current <= max_polydivisible * 10:\n        if is_polydivisible(current):\n            return current\n        \n        # Optimization: for large numbers, skip ahead intelligently\n        current_str = str(current)\n        length = len(current_str)\n        \n        if length >= 12:\n            # For very long numbers, if we're checking many and failing,\n            # jump to next length to avoid timeout\n            if length < 25:\n                # Jump to beginning of next length\n                next_length_start = 10 ** length\n                if current < next_length_start:\n                    current = next_length_start\n                    continue\n        \n        current += 1\n    \n    return None\n\n# Read input\nn = int(input())\n\n# Find and print the next polydivisible number\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print(\"\")  # Print empty string as per problem description for empty value\n\n\n", "\ndef is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Start checking from n+1\n    candidate = n + 1\n    \n    # The largest known polydivisible number has 25 digits\n    # http://en.wikipedia.org/wiki/Polydivisible_number\n    max_digits = 25\n    \n    while len(str(candidate)) <= max_digits:\n        if is_polydivisible(str(candidate)):\n            return candidate\n        candidate += 1\n    \n    return None\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"null\")\nelse:\n    print(result)\n\n\n", "\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    current = n + 1\n    # The largest known polydivisible number has 25 digits\n    limit = 10**25\n    while current < limit:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    return None\n\n# Read input from standard input\nn = int(input())\n# Find and print the next polydivisible number\nresult = next_polydivisible(n)\nif result is None:\n    print(\"\")\nelse:\n    print(result)\n\n\n", "\ndef is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    candidate = n + 1\n    \n    while True:\n        s = str(candidate)\n        \n        # Check if this number is polydivisible\n        if is_polydivisible(s):\n            return candidate\n            \n        # If we've exceeded reasonable limits, return None\n        if len(s) > 25:\n            return None\n            \n        # Optimization: try to build the next potential candidate\n        # rather than checking every single number\n        valid = True\n        for i in range(1, len(s) + 1):\n            prefix = s[:i]\n            if int(prefix) % i != 0:\n                # Find the next valid prefix\n                current_prefix_val = int(prefix)\n                remainder = current_prefix_val % i\n                next_prefix_val = current_prefix_val + (i - remainder)\n                \n                # Check if the next valid prefix has the same number of digits\n                next_prefix_str = str(next_prefix_val)\n                if len(next_prefix_str) == len(prefix):\n                    # Replace the prefix and set remaining digits to 0\n                    candidate = int(next_prefix_str + '0' * (len(s) - i))\n                else:\n                    # Need more digits, start over with the new length\n                    candidate = 10 ** len(s)\n                valid = False\n                break\n        \n        if valid:\n            # If we get here, the number should be polydivisible\n            # But let's double-check to be safe\n            if is_polydivisible(str(candidate)):\n                return candidate\n            else:\n                candidate += 1\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print()\n\n\n", "\ndef generate_polydivisible_numbers():\n    \"\"\"Generate all polydivisible numbers using BFS and return them as a sorted list.\"\"\"\n    from collections import deque\n    \n    polydivisibles = []\n    queue = deque(range(1, 10))  # Start with digits 1-9\n    \n    while queue:\n        num_str = queue.popleft()\n        if isinstance(num_str, int):\n            num_str = str(num_str)\n            \n        polydivisibles.append(int(num_str))\n        \n        # Try appending each digit 0-9\n        for digit in range(10):\n            new_num_str = num_str + str(digit)\n            # Check if the new number is polydivisible\n            if int(new_num_str) % len(new_num_str) == 0:\n                queue.append(new_num_str)\n                \n    return sorted(set(polydivisibles))\n\n# Precompute all polydivisible numbers\nPOLYDIVISIBLE_NUMBERS = generate_polydivisible_numbers()\n\ndef next_polydivisible(n):\n    \"\"\"Find the next polydivisible number greater than n.\"\"\"\n    # Linear search for the first polydivisible number > n\n    for num in POLYDIVISIBLE_NUMBERS:\n        if num > n:\n            return num\n    return None\n\n# Read input and solve\ntry:\n    n = int(input().strip())\n    result = next_polydivisible(n)\n    if result is not None:\n        print(result)\n    else:\n        print(\"null\")\nexcept:\n    print(\"null\")\n\n\n", "\ndef is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    candidate = n + 1\n    # Upper bound for polydivisible numbers\n    upper_bound = 3608528850368400786036725\n    \n    while candidate <= upper_bound:\n        if is_polydivisible(str(candidate)):\n            return candidate\n        candidate += 1\n    \n    return None\n\n# Read input and produce output as required\nn = int(input())\nresult = next_polydivisible(n)\nif result is None:\n    print(\"null\")\nelse:\n    print(result)\n\n\n", "\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    if n == 0:\n        return 1\n    \n    # Try incrementing from n+1\n    current = n + 1\n    \n    # There's a finite number of polydivisible numbers, so we don't need an arbitrary limit\n    # But we'll set a reasonable one to avoid infinite loops in case of bugs\n    limit = 10**15  # This should be enough for most practical purposes\n    \n    while current <= limit:\n        if is_polydivisible(current):\n            return current\n        current += 1\n    \n    return None\n\n# Read input and produce output\nn = int(input())\nresult = next_polydivisible(n)\nif result is not None:\n    print(result)\nelse:\n    print(\"None\")\n\n\n", "\ndef is_polydivisible(s):\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Start with the next number\n    current = n + 1\n    \n    # Try to find the next polydivisible number\n    while True:\n        s = str(current)\n        if is_polydivisible(s):\n            return current\n        \n        current += 1\n        \n        # Polydivisible numbers have a finite limit\n        # The maximum length of a polydivisible number is 25 digits\n        if len(str(current)) > 25:\n            return None\n\ndef main():\n    try:\n        n = int(input().strip())\n        result = next_polydivisible(n)\n        if result is not None:\n            print(result)\n        else:\n            print(\"\")\n    except:\n        print(\"\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [5953, 5507, 6515, 7218, 5612, 6676, 7548, 8228, 7043, 6733], "completion_tokens": [2601, 1688, 4104, 3095, 2221, 3622, 3509, 3561, 3797, 2974], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 4268}
{"name": "2704", "description": "# Task\n Given a `sequence` of integers, check whether it is possible to obtain a strictly increasing sequence by erasing no more than one element from it.\n\n# Example\n\n For `sequence = [1, 3, 2, 1]`, the output should be `false`;\n \n For `sequence = [1, 3, 2]`, the output should be `true`.\n\n# Input/Output\n\n\n - `[input]` integer array `sequence`\n\n    Constraints: `2 \u2264 sequence.length \u2264 1000, -10000 \u2264 sequence[i] \u2264 10000.`\n\n\n - `[output]` a boolean value\n\n    `true` if it is possible, `false` otherwise.", "difficulty": "introductory", "id": 2704, "sample_io": [{"input": "[1, 3, 2, 1]", "output": [false]}, {"input": "[1, 3, 2]", "output": [true]}], "test_list": [{"input": "[1, 3, 2, 1]", "output": [false]}, {"input": "[1, 3, 2]", "output": [true]}, {"input": "[1, 2, 3]", "output": [true]}, {"input": "[1, 2, 3, 1]", "output": [true]}, {"input": "[1, 4, 10, 4, 2]", "output": [false]}, {"input": "[10, 1, 2, 3, 4, 5]", "output": [true]}, {"input": "[1, 1, 1, 2, 3]", "output": [false]}, {"input": "[0, -2, 5, 6]", "output": [true]}, {"input": "[1, 1]", "output": [true]}, {"input": "[4, 5, 6, 1, 2, 3]", "output": [false]}, {"input": "[149, 15, 23, 32, 41, 48, 58, 66, 69, 75, 81, 91, 178, 100, 109, 118, 128, 134, 143]", "output": [false]}], "starter_code": "\ndef almost_increasing_sequence(sequence):\n\t", "source_codes": ["def almostIncreasingSequence(sequence):\n    def is_strictly_increasing(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] >= arr[i + 1]:\n                return False\n        return True\n    \n    n = len(sequence)\n    \n    # Check if already strictly increasing\n    if is_strictly_increasing(sequence):\n        return True\n    \n    # Try removing each element one by one\n    for i in range(n):\n        # Create new sequence without element at index i\n        new_sequence = sequence[:i] + sequence[i+1:]\n        if is_strictly_increasing(new_sequence):\n            return True\n    \n    return False\n\n# Read input and process\nsequence_str = input().strip()\nif sequence_str.startswith('[') and sequence_str.endswith(']'):\n    sequence_str = sequence_str[1:-1]\nsequence = list(map(int, sequence_str.split(',')))\nresult = almostIncreasingSequence(sequence)\nprint(result)"], "responses": ["\ndef almostIncreasingSequence(sequence):\n    def is_strictly_increasing(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] >= arr[i + 1]:\n                return False\n        return True\n    \n    n = len(sequence)\n    \n    # Check if already strictly increasing\n    if is_strictly_increasing(sequence):\n        return True\n    \n    # Try removing each element one by one\n    for i in range(n):\n        # Create new sequence without element at index i\n        new_sequence = sequence[:i] + sequence[i+1:]\n        if is_strictly_increasing(new_sequence):\n            return True\n    \n    return False\n\n# Read input and process\nsequence_str = input().strip()\nif sequence_str.startswith('[') and sequence_str.endswith(']'):\n    sequence_str = sequence_str[1:-1]\nsequence = list(map(int, sequence_str.split(',')))\nresult = almostIncreasingSequence(sequence)\nprint(result)\n\n\n"], "prompt_tokens": [8816], "completion_tokens": [2963], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2704}
{"name": "3978", "description": "This function should test if the `factor` is a factor of `base`.\n\nReturn `true` if it is a factor or `false` if it is not.\n\n## About factors\nFactors are numbers you can multiply together to get another number.\n\n2 and 3 are factors of 6 because: `2 * 3 = 6`\n\n- You can find a factor by dividing numbers. If the remainder is 0 then the number is a factor.\n- You can use the mod operator (`%`) in most languages to check for a remainder\n\nFor example 2 is not a factor of 7 because: `7 % 2 = 1`\n\nNote: `base` is a non-negative number, `factor` is a positive number.", "difficulty": "introductory", "id": 3978, "sample_io": [{"input": "7\n2", "output": [false]}, {"input": "6\n2", "output": [true]}, {"input": "6\n3", "output": [true]}], "test_list": [{"input": "10\n2", "output": [true]}, {"input": "63\n7", "output": [true]}, {"input": "2450\n5", "output": [true]}, {"input": "24612\n3", "output": [true]}, {"input": "9\n2", "output": [false]}, {"input": "653\n7", "output": [false]}, {"input": "2453\n5", "output": [false]}, {"input": "24617\n3", "output": [false]}], "starter_code": "\ndef check_for_factor(base, factor):\n\t", "source_codes": ["def is_factor(base, factor):\n    if factor == 0:\n        return False\n    return base % factor == 0\n\nbase = int(input())\nfactor = int(input())\nresult = is_factor(base, factor)\nprint(result)"], "responses": ["\ndef is_factor(base, factor):\n    if factor == 0:\n        return False\n    return base % factor == 0\n\nbase = int(input())\nfactor = int(input())\nresult = is_factor(base, factor)\nprint(result)\n\n\n"], "prompt_tokens": [6088], "completion_tokens": [1679], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3978}
{"name": "4262", "description": "Dee is lazy but she's kind and she likes to eat out at all the nice restaurants and gastropubs in town. To make paying quick and easy she uses a simple mental algorithm she's called The Fair %20 Rule. She's gotten so good she can do this in a few seconds and it always impresses her dates but she's perplexingly still single. Like you probably. \n\nThis is how she does it:\n\n - She rounds the price `P` at the tens place e.g:\n   - 25 becomes 30\n   - 24 becomes 20\n   - 5 becomes 10\n   - 4 becomes 0\n - She figures out the base tip `T` by dropping the singles place digit e.g:\n   - when `P = 24` she rounds to 20 drops 0 `T = 2`\n   - `P = 115` rounds to 120 drops 0 `T = 12`\n   - `P = 25` rounds to 30 drops 0 `T = 3`\n   - `P = 5` rounds to 10 drops 0 `T = 1`\n   - `P = 4` rounds to 0 `T = 0`\n - She then applies a 3 point satisfaction rating `R` to `T` i.e:\n   - When she's satisfied: `R = 1` and she'll add 1 to `T`\n   - Unsatisfied: `R = 0` and she'll subtract 1 from `T`\n   - Appalled: `R = -1` she'll divide `T` by 2, **rounds down** and subtracts 1\n \n## Your Task\n\nImplement a method `calc_tip` that takes two integer arguments for price `p` \n\nwhere `1 <= p <= 1000` and a rating `r` which is one of `-1, 0, 1`.\n\nThe return value `T` should be a non negative integer.\n\n*Note: each step should be done in the order listed.*\n\nDee always politely smiles and says \"Thank you\" on her way out. Dee is nice. Be like Dee.", "difficulty": "introductory", "id": 4262, "sample_io": [], "test_list": [{"input": "4\n1", "output": [1]}, {"input": "4\n0", "output": [0]}, {"input": "4\n-1", "output": [0]}, {"input": "5\n1", "output": [2]}, {"input": "5\n0", "output": [0]}, {"input": "5\n-1", "output": [0]}, {"input": "14\n1", "output": [2]}, {"input": "14\n0", "output": [0]}, {"input": "14\n-1", "output": [0]}, {"input": "15\n1", "output": [3]}, {"input": "15\n0", "output": [1]}, {"input": "15\n-1", "output": [0]}, {"input": "24\n1", "output": [3]}, {"input": "24\n0", "output": [1]}, {"input": "24\n-1", "output": [0]}, {"input": "25\n1", "output": [4]}, {"input": "25\n0", "output": [2]}, {"input": "25\n-1", "output": [0]}, {"input": "125\n1", "output": [14]}, {"input": "125\n0", "output": [12]}, {"input": "125\n-1", "output": [5]}, {"input": "144\n1", "output": [15]}, {"input": "144\n0", "output": [13]}, {"input": "144\n-1", "output": [6]}], "starter_code": "\ndef calc_tip(p, r):\n\t", "source_codes": ["def calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure T is non-negative\n    if T < 0:\n        T = 0\n        \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)", "def calc_tip(p, r):\n    # Step 1: Round price to the nearest tens place\n    # If ones digit >= 5, round up; otherwise round down\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:  # Satisfied\n        T += 1\n    elif r == 0:  # Unsatisfied\n        T = max(0, T - 1)\n    else:  # Appalled (r == -1)\n        T = max(0, T // 2 - 1)\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nprint(calc_tip(p, r))", "def calc_tip(p, r):\n    # Step 1: Round price to nearest tens place (with .5 rounding up)\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure non-negative result\n    return max(0, T)\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)", "def calc_tip(p, r):\n    # Step 1: Round the price to the tens place\n    ones_digit = p % 10\n    if ones_digit >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = max(0, T - 1)\n    elif r == -1:\n        T = max(0, (T // 2) - 1)\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)", "def calc_tip(p, r):\n    # Step 1: Round price to nearest ten\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure non-negative tip\n    return max(T, 0)\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)", "def calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = max(0, T - 1)\n    elif r == -1:\n        T = max(0, (T // 2) - 1)\n    \n    return T\n\n# Read inputs\np, r = map(int, input().split())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))", "def calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    ones_digit = p % 10\n    if ones_digit >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure T is non-negative\n    if T < 0:\n        T = 0\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)", "def calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    # Round to nearest 10 (with ties going up)\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input\np, r = map(int, input().split())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))", "def calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    if p % 10 >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    elif r == -1:\n        T = T // 2 - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read inputs\np = int(input())\nr = int(input())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))"], "responses": ["\ndef calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure T is non-negative\n    if T < 0:\n        T = 0\n        \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round price to the nearest tens place\n    # If ones digit >= 5, round up; otherwise round down\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:  # Satisfied\n        T += 1\n    elif r == 0:  # Unsatisfied\n        T = max(0, T - 1)\n    else:  # Appalled (r == -1)\n        T = max(0, T // 2 - 1)\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nprint(calc_tip(p, r))\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round price to nearest tens place (with .5 rounding up)\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure non-negative result\n    return max(0, T)\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round the price to the tens place\n    ones_digit = p % 10\n    if ones_digit >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = max(0, T - 1)\n    elif r == -1:\n        T = max(0, (T // 2) - 1)\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round price to nearest ten\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating adjustment\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure non-negative tip\n    return max(T, 0)\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = max(0, T - 1)\n    elif r == -1:\n        T = max(0, (T // 2) - 1)\n    \n    return T\n\n# Read inputs\np, r = map(int, input().split())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    ones_digit = p % 10\n    if ones_digit >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T = T + 1\n    elif r == 0:\n        T = T - 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Step 4: Ensure T is non-negative\n    if T < 0:\n        T = 0\n    \n    return T\n\n# Read input and call function\np, r = map(int, input().split())\nresult = calc_tip(p, r)\nprint(result)\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round the price P at the tens place\n    # Round to nearest 10 (with ties going up)\n    rounded_p = ((p + 5) // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    elif r == -1:\n        T = (T // 2) - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input\np, r = map(int, input().split())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))\n\n\n", "\ndef calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    if p % 10 >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Calculate base tip T by dropping the singles digit\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    elif r == -1:\n        T = T // 2 - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read inputs\np = int(input())\nr = int(input())\n\n# Calculate and print the tip\nprint(calc_tip(p, r))\n\n\n"], "prompt_tokens": [10450, 12919, 10701, 11469, 10627, 10444, 10957, 10585, 10599], "completion_tokens": [7811, 5173, 8554, 5322, 6169, 4506, 6575, 5953, 8312], "no_of_try": 9, "api_calls": 90, "is_solved": true, "language": "Python3", "task_id": 4262}
{"name": "2798", "description": "# altERnaTIng cAsE <=> ALTerNAtiNG CaSe\n\nDefine `String.prototype.toAlternatingCase` (or a similar function/method *such as* `to_alternating_case`/`toAlternatingCase`/`ToAlternatingCase` in your selected language; **see the initial solution for details**) such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase. For example:\n``` haskell\ntoAlternatingCase \"hello world\" `shouldBe` \"HELLO WORLD\"\ntoAlternatingCase \"HELLO WORLD\" `shouldBe` \"hello world\"\ntoAlternatingCase \"hello WORLD\" `shouldBe` \"HELLO world\"\ntoAlternatingCase \"HeLLo WoRLD\" `shouldBe` \"hEllO wOrld\"\ntoAlternatingCase \"12345\"       `shouldBe` \"12345\"\ntoAlternatingCase \"1a2b3c4d5e\"  `shouldBe` \"1A2B3C4D5E\"\n```\n```C++\nstring source = \"HeLLo WoRLD\";\nstring upperCase = to_alternating_case(source);\ncout << upperCase << endl; // outputs: hEllO wOrld\n```\nAs usual, your function/method should be pure, i.e. it should **not** mutate the original string.", "difficulty": "introductory", "id": 2798, "sample_io": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}], "test_list": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}, {"input": "String.prototype.toAlternatingCase", "output": ["sTRING.PROTOTYPE.TOaLTERNATINGcASE"]}], "starter_code": "\ndef to_alternating_case(string):\n\t", "source_codes": ["def toAlternatingCase(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Read input and process\ninput_string = input()\noutput_string = toAlternatingCase(input_string)\nprint(output_string)"], "responses": ["\ndef toAlternatingCase(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Read input and process\ninput_string = input()\noutput_string = toAlternatingCase(input_string)\nprint(output_string)\n\n\n"], "prompt_tokens": [8854], "completion_tokens": [1993], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2798}
