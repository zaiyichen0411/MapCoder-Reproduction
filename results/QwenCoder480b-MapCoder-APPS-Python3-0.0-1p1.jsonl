{"name": "3554", "description": "Zonk is addictive dice game. In each round player rolls 6 dice. Then (s)he composes combinations from them. Each combination gives certain points. \n\nThen player can take one or more dice combinations to his hand and re-roll remaining dice or save his score. Dice in player's hand won't be taken into account in subsequent rolls.\n\nIf no combinations can be composed - situation is called \"zonk\". Player thrown zonk loses all points in this round and next player moves. So it's player decision when to reroll and when to stop and save his score.\n\nYour task is simple - just evaluate current roll and return maximum number of points can be scored from it. If no combinations can be made - function must return string ``\"Zonk\"`` (without quotes).\n\nThere are different variations of Zonk. In this kata, we will use most common table of combinations:\n\nCombinationExample rollPoints\nStraight (1,2,3,4,5 and 6)6 3 1 2 5 41000 points\nThree pairs of any dice2 2 4 4 1 1750 points\nThree of 11 4 1 11000 points\nThree of 22 3 4 2 2200 points\nThree of 33 4 3 6 3 2300 points\nThree of 44 4 4400 points\nThree of 52 5 5 5 4500 points\nThree of 66 6 2 6600 points\nFour of a kind1 1 1 1 4 62 \u00d7 Three-of-a-kind score (in example, 2000 pts)\nFive of a kind5 5 5 4 5 53 \u00d7 Three-of-a-kind score (in example, 1500 pts)\nSix of a kind4 4 4 4 4 44 \u00d7 Three-of-a-kind score (in example, 1600 pts)\nEvery 14 3 1 2 2100 points\nEvery 55 2 650 points\n\n\nEach die cannot be used in multiple combinations the same time, so three pairs of 2, 3 and 5 will worth you only ``750`` points (for three pairs), not 850 (for three pairs and two fives). But you can select multiple combinations, ``2 2 2 1 6`` will worth you ``300`` points (200 for three-of-kind '2' plus 100 for single '1' die)\n\nExamples:\n```python\n  get_score([1,2,3]) # returns 100 = points from one 1\n  get_score([3,4,1,1,5]) # returns 250 = points from two 1 and one 5\n  get_score([2,3,2,3,3,2]) # returns 500 = three of 2 + three of 3\n  get_score([1,1,1,1,1,5]) # returns 3050 = five 1 + one 5\n  get_score([2,3,4,3,6,6]) # returns \"Zonk\" = no combinations here\n  get_score([2,2,6,6,2,2]) # returns 400 = four 2, this cannot be scored as three pairs\n  get_score([1,3,4,3,4,1]) # returns 750 = three pairs\n  get_score([3,3,3,3]) # returns 600 = four of 3\n  get_score([1,2,3,4,5]) # returns 150 = it's not straight\n```\nOf course, in real Zonk game it's sometimes not worth to collect all combination from roll. Taking less dice and rerolling more remaining may be better, but task is just to calculate maximum possible score from current single roll.\n\nP.S. Inspired by this kata: http://www.codewars.com/kata/5270d0d18625160ada0000e4", "difficulty": "introductory", "id": 3554, "sample_io": [{"input": "[1, 2, 3]", "output": [100]}, {"input": "[3,4,1,1,5]", "output": [250]}, {"input": "[2,3,2,3,3,2]", "output": [500]}, {"input": "[1,1,1,1,1,5]", "output": [3050]}, {"input": "[2,3,4,3,6,6]", "output": ["Zonk"]}, {"input": "[2,2,6,6,2,2]", "output": [400]}, {"input": "[1,3,4,3,4,1]", "output": [750]}, {"input": "[3,3,3,3]", "output": [600]}, {"input": "[1,2,3,4,5]", "output": [150]}], "test_list": [{"input": "[1]", "output": [100]}, {"input": "[5]", "output": [50]}, {"input": "[1, 1]", "output": [200]}, {"input": "[5, 5]", "output": [100]}, {"input": "[5, 1]", "output": [150]}, {"input": "[5, 6]", "output": [50]}, {"input": "[1, 1, 1]", "output": [1000]}, {"input": "[2, 2, 2]", "output": [200]}, {"input": "[3, 3, 3]", "output": [300]}, {"input": "[4, 4, 4]", "output": [400]}, {"input": "[5, 5, 5]", "output": [500]}, {"input": "[6, 6, 6]", "output": [600]}, {"input": "[1, 2, 1]", "output": [200]}, {"input": "[1, 1, 5]", "output": [250]}, {"input": "[5, 5, 6]", "output": [100]}, {"input": "[1, 5, 5]", "output": [200]}, {"input": "[1, 1, 1, 1]", "output": [2000]}, {"input": "[2, 2, 2, 2]", "output": [400]}, {"input": "[3, 3, 3, 3]", "output": [600]}, {"input": "[4, 4, 4, 4]", "output": [800]}, {"input": "[5, 5, 5, 5]", "output": [1000]}, {"input": "[6, 6, 6, 6]", "output": [1200]}, {"input": "[1, 5, 5, 1]", "output": [300]}, {"input": "[2, 3, 4, 5]", "output": [50]}, {"input": "[3, 3, 5, 3]", "output": [350]}, {"input": "[1, 1, 1, 1, 1]", "output": [3000]}, {"input": "[2, 2, 2, 2, 2]", "output": [600]}, {"input": "[3, 3, 3, 3, 3]", "output": [900]}, {"input": "[4, 4, 4, 4, 4]", "output": [1200]}, {"input": "[5, 5, 5, 5, 5]", "output": [1500]}, {"input": "[6, 6, 6, 6, 6]", "output": [1800]}, {"input": "[1, 5, 1, 5, 1]", "output": [1100]}, {"input": "[1, 2, 3, 4, 5]", "output": [150]}, {"input": "[2, 3, 4, 5, 6]", "output": [50]}, {"input": "[1, 3, 4, 5, 2]", "output": [150]}, {"input": "[1, 1, 1, 1, 1, 1]", "output": [4000]}, {"input": "[2, 2, 2, 2, 2, 2]", "output": [800]}, {"input": "[3, 3, 3, 3, 3, 3]", "output": [1200]}, {"input": "[4, 4, 4, 4, 4, 4]", "output": [1600]}, {"input": "[5, 5, 5, 5, 5, 5]", "output": [2000]}, {"input": "[6, 6, 6, 6, 6, 6]", "output": [2400]}, {"input": "[2, 1, 3, 4, 6, 5]", "output": [1000]}, {"input": "[4, 4, 2, 2, 6, 6]", "output": [750]}, {"input": "[1, 2, 3, 4, 5, 5]", "output": [200]}, {"input": "[2, 2, 4, 2, 2, 4]", "output": [400]}, {"input": "[1, 3, 4, 5, 2, 2]", "output": [150]}, {"input": "[1, 5, 2, 1, 2, 5]", "output": [750]}, {"input": "[4, 1, 1, 1, 1, 5]", "output": [2050]}, {"input": "[3, 5, 2, 4, 2, 6]", "output": [50]}, {"input": "[1, 6, 6, 1, 1, 6]", "output": [1600]}], "starter_code": "\ndef get_score(dice):\n\t", "source_codes": ["def get_score(dice):\n    counts = Counter(dice)\n    total_points = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Make a copy to work with\n    working_counts = counts.copy()\n    \n    # Check for N of a kind (N >= 3)\n    for num in range(1, 7):\n        count = working_counts[num]\n        if count >= 3:\n            base_points = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}\n            if count == 3:\n                total_points += base_points[num]\n                working_counts[num] -= 3\n            elif count == 4:\n                total_points += base_points[num] * 2\n                working_counts[num] -= 4\n            elif count == 5:\n                total_points += base_points[num] * 3\n                working_counts[num] -= 5\n            elif count == 6:\n                total_points += base_points[num] * 4\n                working_counts[num] -= 6\n    \n    # Score remaining 1s and 5s\n    total_points += working_counts[1] * 100\n    total_points += working_counts[5] * 50\n    \n    # Check if we scored anything\n    if total_points == 0:\n        return \"Zonk\"\n    \n    return total_points\n\n# Read input and process\nif __name__ == \"__main__\":\n    dice_input = eval(input())\n    result = get_score(dice_input)\n    print(result)"], "responses": ["\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    total_points = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Make a copy to work with\n    working_counts = counts.copy()\n    \n    # Check for N of a kind (N >= 3)\n    for num in range(1, 7):\n        count = working_counts[num]\n        if count >= 3:\n            base_points = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}\n            if count == 3:\n                total_points += base_points[num]\n                working_counts[num] -= 3\n            elif count == 4:\n                total_points += base_points[num] * 2\n                working_counts[num] -= 4\n            elif count == 5:\n                total_points += base_points[num] * 3\n                working_counts[num] -= 5\n            elif count == 6:\n                total_points += base_points[num] * 4\n                working_counts[num] -= 6\n    \n    # Score remaining 1s and 5s\n    total_points += working_counts[1] * 100\n    total_points += working_counts[5] * 50\n    \n    # Check if we scored anything\n    if total_points == 0:\n        return \"Zonk\"\n    \n    return total_points\n\n# Read input and process\nif __name__ == \"__main__\":\n    dice_input = eval(input())\n    result = get_score(dice_input)\n    print(result)\n\n\n"], "prompt_tokens": [18158], "completion_tokens": [5058], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 3554}
{"name": "4724", "description": "DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.", "difficulty": "introductory", "id": 4724, "sample_io": [{"input": "apple of banana", "output": ["Apple of Banana"]}, {"input": "apple", "output": ["Apple"]}, {"input": "one   space", "output": ["One   Space"]}, {"input": "   space WALK   ", "output": ["   Space Walk   "]}], "test_list": [{"input": "Apple Banana", "output": ["Apple Banana"]}, {"input": "Apple", "output": ["Apple"]}, {"input": "", "output": [""]}, {"input": "of", "output": ["of"]}, {"input": "Revelation of the contents outraged American public opinion, and helped generate", "output": ["Revelation of The Contents Outraged American Public Opinion, And Helped Generate"]}, {"input": "more  than    one space between words", "output": ["More  Than    One Space Between Words"]}, {"input": "  leading spaces", "output": ["  Leading Spaces"]}, {"input": "trailing spaces   ", "output": ["Trailing Spaces   "]}, {"input": "ALL CAPS CRAZINESS", "output": ["All Caps Craziness"]}, {"input": "rAnDoM CaPs CrAzInEsS", "output": ["Random Caps Craziness"]}], "starter_code": "\ndef drop_cap(str_):\n\t", "source_codes": ["def drop_cap(s):\n    import re\n    \n    # Split the string into words and spaces separately\n    # This pattern captures both words and sequences of spaces\n    parts = re.split(r'(\\s+)', s)\n    \n    result = []\n    \n    for part in parts:\n        # If part is whitespace, keep it as is\n        if re.match(r'^\\s+$', part):\n            result.append(part)\n        # If part is a word\n        elif len(part) > 2:\n            # Capitalize first letter, lowercase the rest\n            result.append(part[0].upper() + part[1:].lower())\n        else:\n            # Keep small words as they are\n            result.append(part)\n    \n    return ''.join(result)\n\n# Read input and process\ninput_string = input()\noutput_string = drop_cap(input_string)\nprint([output_string])"], "responses": ["\ndef drop_cap(s):\n    import re\n    \n    # Split the string into words and spaces separately\n    # This pattern captures both words and sequences of spaces\n    parts = re.split(r'(\\s+)', s)\n    \n    result = []\n    \n    for part in parts:\n        # If part is whitespace, keep it as is\n        if re.match(r'^\\s+$', part):\n            result.append(part)\n        # If part is a word\n        elif len(part) > 2:\n            # Capitalize first letter, lowercase the rest\n            result.append(part[0].upper() + part[1:].lower())\n        else:\n            # Keep small words as they are\n            result.append(part)\n    \n    return ''.join(result)\n\n# Read input and process\ninput_string = input()\noutput_string = drop_cap(input_string)\nprint([output_string])\n\n\n"], "prompt_tokens": [4618], "completion_tokens": [2063], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4724}
{"name": "4561", "description": "Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st):\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!", "difficulty": "introductory", "id": 4561, "sample_io": [{"input": "adfa", "output": [true]}, {"input": "bd", "output": [true]}], "test_list": [{"input": "abba", "output": [true]}, {"input": "abaazaba", "output": [false]}, {"input": "abccba", "output": [true]}, {"input": "adfa", "output": [true]}, {"input": "ae", "output": [false]}, {"input": "abzy", "output": [false]}, {"input": "ababbaba", "output": [true]}, {"input": "sq", "output": [true]}, {"input": "kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm", "output": [true]}], "starter_code": "\ndef solve(st):\n\t", "source_codes": ["def solve(st):\n    n = len(st)\n    for i in range(n // 2 + 1):\n        # Get the character and its symmetric counterpart\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        # For the middle character in odd-length strings, it can always form a palindrome with itself\n        if i == n - 1 - i:\n            continue\n            \n        # Calculate the absolute difference in ASCII values\n        diff = abs(ord(left_char) - ord(right_char))\n        \n        # Check if the difference allows for a palindrome possibility\n        if diff not in [0, 1, 2]:\n            return False\n            \n    return True\n\n# Read input and solve\nst = input().strip()\nprint(solve(st))"], "responses": ["\ndef solve(st):\n    n = len(st)\n    for i in range(n // 2 + 1):\n        # Get the character and its symmetric counterpart\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        # For the middle character in odd-length strings, it can always form a palindrome with itself\n        if i == n - 1 - i:\n            continue\n            \n        # Calculate the absolute difference in ASCII values\n        diff = abs(ord(left_char) - ord(right_char))\n        \n        # Check if the difference allows for a palindrome possibility\n        if diff not in [0, 1, 2]:\n            return False\n            \n    return True\n\n# Read input and solve\nst = input().strip()\nprint(solve(st))\n\n\n"], "prompt_tokens": [8000], "completion_tokens": [3607], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4561}
{"name": "4468", "description": "## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`", "difficulty": "introductory", "id": 4468, "sample_io": [{"input": "0", "output": [""]}, {"input": "56", "output": ["5*10+6"]}, {"input": "60", "output": ["6*10"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "10004", "output": ["1*10000+4"]}], "test_list": [{"input": "8964631", "output": ["8*1000000+9*100000+6*10000+4*1000+6*100+3*10+1"]}, {"input": "56", "output": ["5*10+6"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "11", "output": ["1*10+1"]}, {"input": "991", "output": ["9*100+9*10+1"]}, {"input": "47", "output": ["4*10+7"]}, {"input": "234", "output": ["2*100+3*10+4"]}, {"input": "196587", "output": ["1*100000+9*10000+6*1000+5*100+8*10+7"]}, {"input": "660", "output": ["6*100+6*10"]}, {"input": "600", "output": ["6*100"]}, {"input": "9090", "output": ["9*1000+9*10"]}, {"input": "10104", "output": ["1*10000+1*100+4"]}, {"input": "80008", "output": ["8*10000+8"]}, {"input": "90000", "output": ["9*10000"]}, {"input": "0", "output": [""]}], "starter_code": "\ndef simplify(n):\n\t", "source_codes": ["def expanded_form(num):\n    if num == 0:\n        return \"\"\n    \n    num_str = str(num)\n    length = len(num_str)\n    result = []\n    \n    for i, digit in enumerate(num_str):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                result.append(digit)\n            elif power == 1:\n                result.append(f\"{digit}*10\")\n            else:\n                result.append(f\"{digit}*{'1' + '0' * power}\")\n    \n    return \"+\".join(result)\n\n# Read input and print output\nnum = int(input())\nprint(expanded_form(num))"], "responses": ["\ndef expanded_form(num):\n    if num == 0:\n        return \"\"\n    \n    num_str = str(num)\n    length = len(num_str)\n    result = []\n    \n    for i, digit in enumerate(num_str):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                result.append(digit)\n            elif power == 1:\n                result.append(f\"{digit}*10\")\n            else:\n                result.append(f\"{digit}*{'1' + '0' * power}\")\n    \n    return \"+\".join(result)\n\n# Read input and print output\nnum = int(input())\nprint(expanded_form(num))\n\n\n"], "prompt_tokens": [7733], "completion_tokens": [3034], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4468}
{"name": "3613", "description": "# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 \u2264 string1.length \u2264 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value", "difficulty": "introductory", "id": 3613, "sample_io": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}], "test_list": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}, {"input": "aaxxaaz\naazzaay", "output": [true]}, {"input": "aaxyaa\naazzaa", "output": [false]}, {"input": "aazzaa\naaxyaa", "output": [false]}, {"input": "jpeuizmi\nmxxcwriq", "output": [false]}], "starter_code": "\ndef is_substitution_cipher(s1, s2):\n\t", "source_codes": ["def canBeObtainedFromEachOther(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    map1to2 = {}\n    map2to1 = {}\n    \n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            map1to2[char1] = char2\n            \n        if char2 in map2to1:\n            if map2to1[char2] != char1:\n                return False\n        else:\n            map2to1[char2] = char1\n    \n    return True\n\nstring1 = input().strip()\nstring2 = input().strip()\n\nresult = canBeObtainedFromEachOther(string1, string2)\nprint(str(result).lower())"], "responses": ["\ndef canBeObtainedFromEachOther(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    map1to2 = {}\n    map2to1 = {}\n    \n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            map1to2[char1] = char2\n            \n        if char2 in map2to1:\n            if map2to1[char2] != char1:\n                return False\n        else:\n            map2to1[char2] = char1\n    \n    return True\n\nstring1 = input().strip()\nstring2 = input().strip()\n\nresult = canBeObtainedFromEachOther(string1, string2)\nprint(str(result).lower())\n\n\n"], "prompt_tokens": [8705], "completion_tokens": [3249], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 3613}
{"name": "4465", "description": "Write a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.", "difficulty": "introductory", "id": 4465, "sample_io": [{"input": "123456", "output": [654321]}, {"input": "105", "output": [510]}, {"input": "12", "output": [21]}], "test_list": [{"input": "69", "output": [96]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [7210]}, {"input": "414", "output": [441]}, {"input": "608719", "output": [987610]}, {"input": "123456789", "output": [987654321]}, {"input": "700000000001", "output": [710000000000]}, {"input": "666666", "output": [666666]}, {"input": "2", "output": [2]}, {"input": "0", "output": [0]}], "starter_code": "\ndef super_size(n):\n\t", "source_codes": ["def super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)"], "responses": ["\ndef super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)\n\n\n"], "prompt_tokens": [6325], "completion_tokens": [1894], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4465}
{"name": "3045", "description": "Given 2 elevators (named \"left\" and \"right\") in a building with 3 floors (numbered `0` to `2`), write a function `elevator` accepting 3 arguments (in order):\n\n- `left` - The current floor of the left elevator\n- `right` - The current floor of the right elevator\n- `call` -  The floor that called an elevator\n\nIt should return the name of the elevator closest to the called floor (`\"left\"`/`\"right\"`).\n\nIn the case where both elevators are equally distant from the called floor, choose the elevator to the right.\n\nYou can assume that the inputs will always be valid integers between 0-2.\n\nExamples:\n\n```python\nelevator(0, 1, 0) # => \"left\"\nelevator(0, 1, 1) # => \"right\"\nelevator(0, 1, 2) # => \"right\"\nelevator(0, 0, 0) # => \"right\"\nelevator(0, 2, 1) # => \"right\"\n```", "difficulty": "introductory", "id": 3045, "sample_io": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}], "test_list": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}, {"input": "0\n0\n1", "output": ["right"]}, {"input": "0\n0\n2", "output": ["right"]}, {"input": "0\n2\n0", "output": ["left"]}, {"input": "0\n2\n2", "output": ["right"]}, {"input": "1\n0\n0", "output": ["right"]}, {"input": "1\n0\n1", "output": ["left"]}, {"input": "1\n0\n2", "output": ["left"]}, {"input": "1\n1\n0", "output": ["right"]}, {"input": "1\n1\n1", "output": ["right"]}, {"input": "1\n1\n2", "output": ["right"]}, {"input": "1\n2\n0", "output": ["left"]}, {"input": "1\n2\n1", "output": ["left"]}, {"input": "1\n2\n2", "output": ["right"]}, {"input": "2\n0\n0", "output": ["right"]}, {"input": "2\n0\n1", "output": ["right"]}, {"input": "2\n0\n2", "output": ["left"]}, {"input": "2\n1\n0", "output": ["right"]}, {"input": "2\n1\n1", "output": ["right"]}, {"input": "2\n1\n2", "output": ["left"]}, {"input": "2\n2\n0", "output": ["right"]}, {"input": "2\n2\n1", "output": ["right"]}, {"input": "2\n2\n2", "output": ["right"]}], "starter_code": "\ndef elevator(left, right, call):\n\t", "source_codes": ["def elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    elif right_distance < left_distance:\n        return \"right\"\n    else:  # distances are equal\n        return \"right\"\n\n# Read input\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))"], "responses": ["\ndef elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    elif right_distance < left_distance:\n        return \"right\"\n    else:  # distances are equal\n        return \"right\"\n\n# Read input\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))\n\n\n"], "prompt_tokens": [7658], "completion_tokens": [3602], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3045}
{"name": "4276", "description": "Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```", "difficulty": "introductory", "id": 4276, "sample_io": [{"input": "4.2", "output": [4]}, {"input": "4.3", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.8", "output": [5]}, {"input": "4.75", "output": [5]}], "test_list": [{"input": "4.2", "output": [4]}, {"input": "4.25", "output": [4.5]}, {"input": "4.4", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.75", "output": [5]}, {"input": "4.8", "output": [5]}, {"input": "4.5", "output": [4.5]}, {"input": "4.55", "output": [4.5]}, {"input": "4.74", "output": [4.5]}, {"input": "4.74999999999", "output": [4.5]}, {"input": "4.74999999991", "output": [4.5]}], "starter_code": "\ndef solution(n):\n\t", "source_codes": ["import math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Get the fractional part\n    fractional_part = doubled - math.floor(doubled)\n    \n    # Round based on fractional part\n    if fractional_part < 0.5:\n        # Round down\n        rounded = math.floor(doubled)\n    else:\n        # Round up (this handles both > 0.5 and exactly 0.5)\n        rounded = math.ceil(doubled)\n    \n    # Divide by 2 to get back to original scale\n    return rounded / 2\n\n# Read input and call solution\nnumber = float(input())\nresult = solution(number)\nprint(result)"], "responses": ["\nimport math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Get the fractional part\n    fractional_part = doubled - math.floor(doubled)\n    \n    # Round based on fractional part\n    if fractional_part < 0.5:\n        # Round down\n        rounded = math.floor(doubled)\n    else:\n        # Round up (this handles both > 0.5 and exactly 0.5)\n        rounded = math.ceil(doubled)\n    \n    # Divide by 2 to get back to original scale\n    return rounded / 2\n\n# Read input and call solution\nnumber = float(input())\nresult = solution(number)\nprint(result)\n\n\n"], "prompt_tokens": [6726], "completion_tokens": [2677], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4276}
{"name": "2882", "description": "Imagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000", "difficulty": "introductory", "id": 2882, "sample_io": [{"input": "4", "output": [34]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [15]}, {"input": "4", "output": [34]}, {"input": "15", "output": [1695]}, {"input": "150", "output": [1687575]}, {"input": "100", "output": [500050]}, {"input": "500", "output": [62500250]}, {"input": "1000", "output": [500000500]}, {"input": "10000", "output": [500000005000]}], "starter_code": "\ndef cumulative_triangle(n):\n\t", "source_codes": ["def triangle_sum(n):\n    # Calculate the starting number of the nth row\n    # Sum of first (n-1) natural numbers = (n-1)*n/2\n    start = (n - 1) * n // 2 + 1\n    \n    # Calculate the sum of n consecutive numbers starting from 'start'\n    # Using arithmetic sequence sum formula: n * (first + last) / 2\n    # Where last = start + n - 1\n    end = start + n - 1\n    return n * (start + end) // 2\n\n# Read input and solve\nn = int(input())\nresult = triangle_sum(n)\nprint(result)"], "responses": ["\ndef triangle_sum(n):\n    # Calculate the starting number of the nth row\n    # Sum of first (n-1) natural numbers = (n-1)*n/2\n    start = (n - 1) * n // 2 + 1\n    \n    # Calculate the sum of n consecutive numbers starting from 'start'\n    # Using arithmetic sequence sum formula: n * (first + last) / 2\n    # Where last = start + n - 1\n    end = start + n - 1\n    return n * (start + end) // 2\n\n# Read input and solve\nn = int(input())\nresult = triangle_sum(n)\nprint(result)\n\n\n"], "prompt_tokens": [6368], "completion_tokens": [2737], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2882}
{"name": "4440", "description": "ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but **exactly** 4 digits or exactly 6 digits. \n\nIf the function is passed a valid PIN string, return `true`, else return `false`.\n\n## Examples \n```\n\"1234\"   -->  true\n\"12345\"  -->  false\n\"a234\"   -->  false\n```", "difficulty": "introductory", "id": 4440, "sample_io": [{"input": "1234", "output": [true]}, {"input": "12345", "output": [false]}, {"input": "a234", "output": [false]}], "test_list": [{"input": "1", "output": [false]}, {"input": "12", "output": [false]}, {"input": "123", "output": [false]}, {"input": "12345", "output": [false]}, {"input": "1234567", "output": [false]}, {"input": "-1234", "output": [false]}, {"input": "-12345", "output": [false]}, {"input": "1.234", "output": [false]}, {"input": "00000000", "output": [false]}, {"input": "a234", "output": [false]}, {"input": ".234", "output": [false]}, {"input": "1234", "output": [true]}, {"input": "0000", "output": [true]}, {"input": "1111", "output": [true]}, {"input": "123456", "output": [true]}, {"input": "098765", "output": [true]}, {"input": "000000", "output": [true]}, {"input": "090909", "output": [true]}], "starter_code": "\ndef validate_pin(pin):\n\t", "source_codes": ["def validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) != 4 and len(pin) != 6:\n        return False\n    \n    # Check if all characters are digits\n    for char in pin:\n        if not char.isdigit():\n            return False\n    \n    return True\n\n# Read input from standard input\npin = input().strip()\n\n# Validate the PIN and print the result\nresult = validate_pin(pin)\nprint(result)"], "responses": ["\ndef validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) != 4 and len(pin) != 6:\n        return False\n    \n    # Check if all characters are digits\n    for char in pin:\n        if not char.isdigit():\n            return False\n    \n    return True\n\n# Read input from standard input\npin = input().strip()\n\n# Validate the PIN and print the result\nresult = validate_pin(pin)\nprint(result)\n\n\n"], "prompt_tokens": [6439], "completion_tokens": [1831], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4440}
{"name": "2771", "description": "Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book G\u00f6del, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!", "difficulty": "introductory", "id": 2771, "sample_io": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}], "test_list": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}, {"input": "100", "output": [56]}, {"input": "1000", "output": [502]}], "starter_code": "\ndef hofstadter_Q(n):\n\t", "source_codes": ["import sys\n\ndef hofstadter_q(n):\n    if n <= 0:\n        return None\n    if n <= 2:\n        return 1\n    \n    # Memoization array - using 1-based indexing\n    q = [0] * (n + 1)\n    q[1] = 1\n    q[2] = 1\n    \n    # Calculate values iteratively\n    for i in range(3, n + 1):\n        q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n    \n    return q[n]\n\n# Read input and produce output\nif __name__ == \"__main__\":\n    n = int(input())\n    result = hofstadter_q(n)\n    print(result)"], "responses": ["\nimport sys\n\ndef hofstadter_q(n):\n    if n <= 0:\n        return None\n    if n <= 2:\n        return 1\n    \n    # Memoization array - using 1-based indexing\n    q = [0] * (n + 1)\n    q[1] = 1\n    q[2] = 1\n    \n    # Calculate values iteratively\n    for i in range(3, n + 1):\n        q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]\n    \n    return q[n]\n\n# Read input and produce output\nif __name__ == \"__main__\":\n    n = int(input())\n    result = hofstadter_q(n)\n    print(result)\n\n\n"], "prompt_tokens": [7688], "completion_tokens": [2798], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2771}
{"name": "4335", "description": "What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:\n\n```\n'abba' & 'baab' == true\n\n'abba' & 'bbaa' == true\n\n'abba' & 'abbba' == false\n\n'abba' & 'abca' == false\n```\n\nWrite a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:\n\nanagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']\n\nanagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']\n\nanagrams('laser', ['lazing', 'lazy',  'lacer']) => []", "difficulty": "introductory", "id": 4335, "sample_io": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "laser\n['lazing', 'lazy', 'lacer']", "output": [[]]}], "test_list": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "a\n['a', 'b', 'c', 'd']", "output": [["a"]]}, {"input": "ab\n['cc', 'ac', 'bc', 'cd', 'ab', 'ba', 'racar', 'caers', 'racer']", "output": [["ab", "ba"]]}, {"input": "abba\n['a', 'b', 'c', 'd', 'aabb', 'bbaa', 'abab', 'baba', 'baab', 'abcd', 'abbba', 'baaab', 'abbab', 'abbaa', 'babaa']", "output": [["aabb", "bbaa", "abab", "baba", "baab"]]}, {"input": "big\n['gig', 'dib', 'bid', 'biig']", "output": [[]]}], "starter_code": "\ndef anagrams(word, words):\n\t", "source_codes": ["def anagrams(word, words):\n    sorted_word = sorted(word)\n    result = []\n    for w in words:\n        if sorted(w) == sorted_word:\n            result.append(w)\n    return result\n\n# Read input from stdin\nword = input().strip()\nwords_input = input().strip()\n\n# Safely parse the list input\nimport ast\nwords = ast.literal_eval(words_input)\n\n# Find anagrams and print result\nresult = anagrams(word, words)\nprint(result)"], "responses": ["\ndef anagrams(word, words):\n    sorted_word = sorted(word)\n    result = []\n    for w in words:\n        if sorted(w) == sorted_word:\n            result.append(w)\n    return result\n\n# Read input from stdin\nword = input().strip()\nwords_input = input().strip()\n\n# Safely parse the list input\nimport ast\nwords = ast.literal_eval(words_input)\n\n# Find anagrams and print result\nresult = anagrams(word, words)\nprint(result)\n\n\n"], "prompt_tokens": [7933], "completion_tokens": [2684], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4335}
{"name": "3512", "description": "Just like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```", "difficulty": "introductory", "id": 3512, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "1000", "output": [5]}, {"input": "1000000", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "21", "output": [6]}, {"input": "302", "output": [1]}, {"input": "4003", "output": [7]}, {"input": "50004", "output": [8]}, {"input": "600005", "output": [5]}, {"input": "7000006", "output": [3]}, {"input": "80000007", "output": [8]}, {"input": "900000008", "output": [1]}, {"input": "1000000009", "output": [9]}], "starter_code": "\ndef last_fib_digit(n):\n\t", "source_codes": ["def last_fib_digit(n):\n    # Precompute last digits of first 60 Fibonacci numbers (Pisano period for mod 10 is 60)\n    fib_last_digits = [0] * 60\n    fib_last_digits[0] = 1\n    fib_last_digits[1] = 1\n    \n    for i in range(2, 60):\n        fib_last_digits[i] = (fib_last_digits[i-1] + fib_last_digits[i-2]) % 10\n    \n    # For 1-based indexing, we use (n-1) % 60\n    return fib_last_digits[(n - 1) % 60]\n\n# Read input and print result\nn = int(input())\nprint(last_fib_digit(n))"], "responses": ["\ndef last_fib_digit(n):\n    # Precompute last digits of first 60 Fibonacci numbers (Pisano period for mod 10 is 60)\n    fib_last_digits = [0] * 60\n    fib_last_digits[0] = 1\n    fib_last_digits[1] = 1\n    \n    for i in range(2, 60):\n        fib_last_digits[i] = (fib_last_digits[i-1] + fib_last_digits[i-2]) % 10\n    \n    # For 1-based indexing, we use (n-1) % 60\n    return fib_last_digits[(n - 1) % 60]\n\n# Read input and print result\nn = int(input())\nprint(last_fib_digit(n))\n\n\n"], "prompt_tokens": [7727], "completion_tokens": [3035], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3512}
{"name": "3435", "description": "# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters called airstrike to help them in war - dashes and dots are spreaded everywhere on the battlefield.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and `*` which means a bomb drop place. Return who wins the fight after bombs are exploded. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3 \n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3 \n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.  \nThe `*` bombs kills the adjacent letters ( i.e. `aa*aa` => `a___a`, `**aa**` => `______` );\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war", "difficulty": "introductory", "id": 3435, "sample_io": [], "test_list": [{"input": "z", "output": ["Right side wins!"]}, {"input": "z*dq*mw*pb*s", "output": ["Let's fight again!"]}, {"input": "zdqmwpbs", "output": ["Let's fight again!"]}, {"input": "zz*zzs", "output": ["Right side wins!"]}, {"input": "sz**z**zs", "output": ["Left side wins!"]}, {"input": "z*z*z*zs", "output": ["Left side wins!"]}, {"input": "*wwwwww*z*", "output": ["Left side wins!"]}], "starter_code": "\ndef alphabet_war(fight):\n\t", "source_codes": ["def alphabet_war(fight):\n    left_power = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_power = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Handle empty string\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Convert string to list for easier manipulation\n    chars = list(fight)\n    n = len(chars)\n    \n    # Mark positions to be removed due to bomb explosions\n    to_remove = [False] * n\n    \n    # Process bombs and mark affected positions\n    for i in range(n):\n        if chars[i] == '*':\n            # Mark the bomb position itself\n            to_remove[i] = True\n            # Mark left neighbor if exists\n            if i > 0:\n                to_remove[i-1] = True\n            # Mark right neighbor if exists\n            if i < n-1:\n                to_remove[i+1] = True\n    \n    # Calculate powers of surviving letters\n    left_sum = 0\n    right_sum = 0\n    \n    for i in range(n):\n        if not to_remove[i]:  # If character survives\n            char = chars[i]\n            if char in left_power:\n                left_sum += left_power[char]\n            elif char in right_power:\n                right_sum += right_power[char]\n    \n    # Determine winner\n    if left_sum > right_sum:\n        return \"Left side wins!\"\n    elif right_sum > left_sum:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and execute\nfight = input().strip()\nprint(alphabet_war(fight))"], "responses": ["\ndef alphabet_war(fight):\n    left_power = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_power = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Handle empty string\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Convert string to list for easier manipulation\n    chars = list(fight)\n    n = len(chars)\n    \n    # Mark positions to be removed due to bomb explosions\n    to_remove = [False] * n\n    \n    # Process bombs and mark affected positions\n    for i in range(n):\n        if chars[i] == '*':\n            # Mark the bomb position itself\n            to_remove[i] = True\n            # Mark left neighbor if exists\n            if i > 0:\n                to_remove[i-1] = True\n            # Mark right neighbor if exists\n            if i < n-1:\n                to_remove[i+1] = True\n    \n    # Calculate powers of surviving letters\n    left_sum = 0\n    right_sum = 0\n    \n    for i in range(n):\n        if not to_remove[i]:  # If character survives\n            char = chars[i]\n            if char in left_power:\n                left_sum += left_power[char]\n            elif char in right_power:\n                right_sum += right_power[char]\n    \n    # Determine winner\n    if left_sum > right_sum:\n        return \"Left side wins!\"\n    elif right_sum > left_sum:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and execute\nfight = input().strip()\nprint(alphabet_war(fight))\n\n\n"], "prompt_tokens": [9714], "completion_tokens": [7934], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3435}
{"name": "3387", "description": "What's in a name?\n..Or rather, what's a name in? For us, a particular string is where we are looking for a name.\n\nTask\n\nTest whether or not the string contains all of the letters which spell a given name, in order.\n\nThe format\nA function passing two strings, searching for one (the name) within the other.\n``function nameInStr(str, name){ return true || false }``\n\nExamples\n\n    nameInStr(\"Across the rivers\", \"chris\") --> true\n                ^      ^  ^^   ^\n                c      h  ri   s\n                \n    Contains all of the letters in \"chris\", in order.\n----------------------------------------------------------\n    nameInStr(\"Next to a lake\", \"chris\") --> false\n    \n    Contains none of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"Under a sea\", \"chris\") --> false\n                   ^   ^\n                   r   s\n                   \n    Contains only some of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"A crew that boards the ship\", \"chris\") --> false\n                 cr    h              s i\n                 cr                h  s i  \n                 c     h      r       s i\n                 ...\n                 \n    Contains all of the letters in \"chris\", but not in order.\n--------------------------------------------------------------------\n    nameInStr(\"A live son\", \"Allison\") --> false\n               ^ ^^   ^^^\n               A li   son\n                 \n    Contains all of the correct letters in \"Allison\", in order, \n    but not enough of all of them (missing an 'l').\n    \n\nNote: testing will _not_ be case-sensitive.", "difficulty": "introductory", "id": 3387, "sample_io": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}], "test_list": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}, {"input": "Just enough nice friends\nJennifer", "output": [false]}, {"input": "thomas\nThomas", "output": [true]}, {"input": "pippippi\nPippi", "output": [true]}, {"input": "pipipp\nPippi", "output": [false]}, {"input": "ppipip\nPippi", "output": [false]}], "starter_code": "\ndef name_in_str(str, name):\n\t", "source_codes": ["def nameInStr(str, name):\n    str = str.lower()\n    name = name.lower()\n    \n    i = 0  # pointer for str\n    j = 0  # pointer for name\n    \n    while i < len(str) and j < len(name):\n        if str[i] == name[j]:\n            j += 1\n        i += 1\n    \n    return j == len(name)\n\n# Read input from stdin\nstr_input = input()\nname_input = input()\n\n# Call the function and print the result\nresult = nameInStr(str_input, name_input)\nprint(str(result))"], "responses": ["\ndef nameInStr(str, name):\n    str = str.lower()\n    name = name.lower()\n    \n    i = 0  # pointer for str\n    j = 0  # pointer for name\n    \n    while i < len(str) and j < len(name):\n        if str[i] == name[j]:\n            j += 1\n        i += 1\n    \n    return j == len(name)\n\n# Read input from stdin\nstr_input = input()\nname_input = input()\n\n# Call the function and print the result\nresult = nameInStr(str_input, name_input)\nprint(str(result))\n\n\n"], "prompt_tokens": [10212], "completion_tokens": [2997], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3387}
{"name": "4024", "description": "# Definition \n\nA number is a **_Special Number_** *if it\u2019s digits only consist 0, 1, 2, 3, 4 or 5*\n\n**_Given_** a number *determine if it special number or not* .  \n\n\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_The number_** passed will be **_positive_** (N > 0) .\n\n* All **single-digit numbers** with in the interval **_[0:5]_** are considered as **_special number_**. \n___\n\n# Input >> Output Examples\n\n```\nspecialNumber(2) ==> return \"Special!!\"\n```\n## Explanation: \n\nIt's **_a single-digit number_** within the interval **_[0:5]_** . \n\n```\nspecialNumber(9) ==> return \"NOT!!\"\n```\n## Explanation:\n\nAlthough, it's a single-digit number but **_Outside the interval [0:5]_** .\n\n```\nspecialNumber(23) ==> return \"Special!!\"\n```\n## Explanation: \n\nAll **_the number's digits_** formed from the interval **_[0:5]_** digits .\n\n```\nspecialNumber(39) ==> return \"NOT!!\"\n```\n## Explanation: \n\nAlthough, *there is a digit (3) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(59) ==> return \"NOT!!\"\n```\n## Explanation:  \n\nAlthough, *there is a digit (5) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(513) ==> return \"Special!!\"\n```\n___\n```\nspecialNumber(709) ==> return \"NOT!!\"\n```\n___\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)          \n\n### ALL translation are welcomed\n\n## Enjoy Learning !!\n# Zizou", "difficulty": "introductory", "id": 4024, "sample_io": [{"input": "2", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "59", "output": ["NOT!!"]}, {"input": "513", "output": ["Special!!"]}, {"input": "709", "output": ["NOT!!"]}], "test_list": [{"input": "2", "output": ["Special!!"]}, {"input": "3", "output": ["Special!!"]}, {"input": "5", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "7", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "79", "output": ["NOT!!"]}, {"input": "32", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "55", "output": ["Special!!"]}, {"input": "11350224", "output": ["Special!!"]}], "starter_code": "\ndef special_number(number):\n\t", "source_codes": ["def specialNumber(n):\n    valid_digits = {'0', '1', '2', '3', '4', '5'}\n    for digit in str(n):\n        if digit not in valid_digits:\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input())\nprint(specialNumber(n))"], "responses": ["\ndef specialNumber(n):\n    valid_digits = {'0', '1', '2', '3', '4', '5'}\n    for digit in str(n):\n        if digit not in valid_digits:\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input())\nprint(specialNumber(n))\n\n\n"], "prompt_tokens": [10274], "completion_tokens": [2562], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4024}
{"name": "3478", "description": "Magic The Gathering is a collectible card game that features wizards battling against each other with spells and creature summons. The game itself can be quite complicated to learn. In this series of katas, we'll be solving some of the situations that arise during gameplay. You won't need any prior knowledge of the game to solve these contrived problems, as I will provide you with enough information.\n\n## Creatures\n\nEach creature has a power and toughness. We will represent this in an array. [2, 3] means this creature has a power of 2 and a toughness of 3.\n\nWhen two creatures square off, they each deal damage equal to their power to each other at the same time. If a creature takes on damage greater than or equal to their toughness, they die.\n\nExamples:\n\n- Creature 1 - [2, 3]\n- Creature 2 - [3, 3]\n- Creature 3 - [1, 4]\n- Creature 4 - [4, 1]\n\nIf creature 1 battles creature 2, creature 1 dies, while 2 survives. If creature 3 battles creature 4, they both die, as 3 deals 1 damage to 4, but creature 4 only has a toughness of 1.\n\nWrite a function `battle(player1, player2)` that takes in 2 arrays of creatures. Each players' creatures battle each other in order (player1[0] battles the creature in player2[0]) and so on. If one list of creatures is longer than the other, those creatures are considered unblocked, and do not battle.\n\nYour function should return an object (a hash in Ruby) with the keys player1 and player2 that contain the power and toughness of the surviving creatures.\n\nExample:\n```\nGood luck with your battles!\n\n\nCheck out my other Magic The Gathering katas:\n\n\nMagic The Gathering #1: Creatures\nMagic The Gathering #2: Mana", "difficulty": "introductory", "id": 3478, "sample_io": [], "test_list": [{"input": "[[2, 3], [1, 4]]\n[[3, 3], [4, 1]]", "output": [{"player1": [], "player2": [[3, 3]]}]}, {"input": "[]\n[]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 1]]\n[[1, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 1]]\n[[2, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 2]]\n[[1, 2]]", "output": [{"player1": [[1, 2]], "player2": [[1, 2]]}]}, {"input": "[[2, 3]]\n[[3, 2]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 7]]\n[[3, 5]]", "output": [{"player1": [[2, 7]], "player2": [[3, 5]]}]}, {"input": "[[2, 5]]\n[[6, 6]]", "output": [{"player1": [], "player2": [[6, 6]]}]}, {"input": "[[6, 6]]\n[[2, 5]]", "output": [{"player1": [[6, 6]], "player2": []}]}, {"input": "[]\n[[1, 1], [2, 2]]", "output": [{"player1": [], "player2": [[1, 1], [2, 2]]}]}, {"input": "[[1, 1], [2, 2]]\n[]", "output": [{"player1": [[1, 1], [2, 2]], "player2": []}]}, {"input": "[[1, 3], [3, 5], [4, 6], [5, 2]]\n[[2, 4], [6, 1], [4, 4], [3, 7], [3, 1]]", "output": [{"player1": [[1, 3], [4, 6]], "player2": [[2, 4], [3, 7], [3, 1]]}]}], "starter_code": "\ndef battle(player1, player2):\n\t", "source_codes": ["def battle(player1, player2):\n    # Create copies to avoid modifying original arrays\n    p1_creatures = [list(creature) for creature in player1]\n    p2_creatures = [list(creature) for creature in player2]\n    \n    # Determine number of battles (paired creatures)\n    num_battles = min(len(p1_creatures), len(p2_creatures))\n    \n    # Process battles\n    p1_survivors = []\n    p2_survivors = []\n    \n    for i in range(num_battles):\n        p1_creature = p1_creatures[i]\n        p2_creature = p2_creatures[i]\n        \n        p1_power, p1_toughness = p1_creature\n        p2_power, p2_toughness = p2_creature\n        \n        # Both creatures deal damage simultaneously\n        p1_damage_taken = p2_power\n        p2_damage_taken = p1_power\n        \n        # Check if creatures survive (damage taken < toughness)\n        p1_survives = p1_damage_taken < p1_toughness\n        p2_survives = p2_damage_taken < p2_toughness\n        \n        if p1_survives:\n            p1_survivors.append(p1_creature)\n        if p2_survives:\n            p2_survivors.append(p2_creature)\n    \n    # Add unblocked creatures (those beyond the minimum length)\n    p1_survivors.extend(p1_creatures[num_battles:])\n    p2_survivors.extend(p2_creatures[num_battles:])\n    \n    return {\"player1\": p1_survivors, \"player2\": p2_survivors}\n\n# Read input\nline = input()\n# Parse the input line to extract player1 and player2\n# Expected format: \"player1 = [[...]], player2 = [[...]]\"\nparts = line.split(\", player2 = \")\nplayer1_str = parts[0].split(\" = \")[1]\nplayer2_str = parts[1]\n\n# Convert string representations to actual lists\nimport ast\nplayer1 = ast.literal_eval(player1_str)\nplayer2 = ast.literal_eval(player2_str)\n\n# Call the function and print result\nresult = battle(player1, player2)\nprint(result)"], "responses": ["\ndef battle(player1, player2):\n    # Create copies to avoid modifying original arrays\n    p1_creatures = [list(creature) for creature in player1]\n    p2_creatures = [list(creature) for creature in player2]\n    \n    # Determine number of battles (paired creatures)\n    num_battles = min(len(p1_creatures), len(p2_creatures))\n    \n    # Process battles\n    p1_survivors = []\n    p2_survivors = []\n    \n    for i in range(num_battles):\n        p1_creature = p1_creatures[i]\n        p2_creature = p2_creatures[i]\n        \n        p1_power, p1_toughness = p1_creature\n        p2_power, p2_toughness = p2_creature\n        \n        # Both creatures deal damage simultaneously\n        p1_damage_taken = p2_power\n        p2_damage_taken = p1_power\n        \n        # Check if creatures survive (damage taken < toughness)\n        p1_survives = p1_damage_taken < p1_toughness\n        p2_survives = p2_damage_taken < p2_toughness\n        \n        if p1_survives:\n            p1_survivors.append(p1_creature)\n        if p2_survives:\n            p2_survivors.append(p2_creature)\n    \n    # Add unblocked creatures (those beyond the minimum length)\n    p1_survivors.extend(p1_creatures[num_battles:])\n    p2_survivors.extend(p2_creatures[num_battles:])\n    \n    return {\"player1\": p1_survivors, \"player2\": p2_survivors}\n\n# Read input\nline = input()\n# Parse the input line to extract player1 and player2\n# Expected format: \"player1 = [[...]], player2 = [[...]]\"\nparts = line.split(\", player2 = \")\nplayer1_str = parts[0].split(\" = \")[1]\nplayer2_str = parts[1]\n\n# Convert string representations to actual lists\nimport ast\nplayer1 = ast.literal_eval(player1_str)\nplayer2 = ast.literal_eval(player2_str)\n\n# Call the function and print result\nresult = battle(player1, player2)\nprint(result)\n\n\n"], "prompt_tokens": [11984], "completion_tokens": [7907], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 3478}
{"name": "3766", "description": "~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)", "difficulty": "introductory", "id": 3766, "sample_io": [{"input": "100", "output": [[2, 2, 5, 5]]}], "test_list": [{"input": "10", "output": [[2, 5]]}, {"input": "100", "output": [[2, 2, 5, 5]]}, {"input": "1000", "output": [[2, 2, 2, 5, 5, 5]]}, {"input": "1000001", "output": [[101, 9901]]}, {"input": "0", "output": [[]]}, {"input": "1", "output": [[1]]}, {"input": "2", "output": [[2]]}, {"input": "a", "output": [[]]}, {"input": "1.1", "output": [[]]}, {"input": "-1", "output": [[]]}], "starter_code": "\ndef getAllPrimeFactors(n):\n\t", "source_codes": ["import sys\n\ndef getAllPrimeFactors(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    # Edge cases\n    if n == 1:\n        return [1]\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n        \n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    \n    # Edge cases\n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n    \n    unique_primes = []\n    counts = []\n    \n    for factor in factors:\n        if not unique_primes or factor != unique_primes[-1]:\n            unique_primes.append(factor)\n            counts.append(1)\n        else:\n            counts[-1] += 1\n            \n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    # Edge cases\n    if n == 1:\n        return [1]\n    \n    primes, counts = getUniquePrimeFactorsWithCount(n)\n    if not primes:\n        return []\n    \n    products = []\n    for i in range(len(primes)):\n        products.append(primes[i] ** counts[i])\n        \n    return products\n\n# Read input and process\ntry:\n    n = int(input())\n    result = getAllPrimeFactors(n)\n    print(result)\nexcept (ValueError, TypeError):\n    print([])"], "responses": ["\nimport sys\n\ndef getAllPrimeFactors(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    # Edge cases\n    if n == 1:\n        return [1]\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n        \n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    \n    # Edge cases\n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n    \n    unique_primes = []\n    counts = []\n    \n    for factor in factors:\n        if not unique_primes or factor != unique_primes[-1]:\n            unique_primes.append(factor)\n            counts.append(1)\n        else:\n            counts[-1] += 1\n            \n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    # Edge cases\n    if n == 1:\n        return [1]\n    \n    primes, counts = getUniquePrimeFactorsWithCount(n)\n    if not primes:\n        return []\n    \n    products = []\n    for i in range(len(primes)):\n        products.append(primes[i] ** counts[i])\n        \n    return products\n\n# Read input and process\ntry:\n    n = int(input())\n    result = getAllPrimeFactors(n)\n    print(result)\nexcept (ValueError, TypeError):\n    print([])\n\n\n"], "prompt_tokens": [13467], "completion_tokens": [7018], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3766}
{"name": "3292", "description": "Given a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```", "difficulty": "introductory", "id": 3292, "sample_io": [{"input": "ABC", "output": [6]}], "test_list": [{"input": "abcdef", "output": [6]}, {"input": "ifkhchlhfd", "output": [6]}, {"input": "aaaaaddddr", "output": [30]}, {"input": "jfmgklf8hglbe", "output": [6]}, {"input": "jaam", "output": [12]}, {"input": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "output": [96]}], "starter_code": "\ndef calc(x):\n\t", "source_codes": ["def solve(s):\n    # Step 1: Convert each character to ASCII and concatenate\n    total1 = ''.join(str(ord(c)) for c in s)\n    \n    # Step 2: Replace all '7' with '1' to get total2\n    total2 = total1.replace('7', '1')\n    \n    # Step 3: Calculate sum of digits for both\n    sum1 = sum(int(digit) for digit in total1)\n    sum2 = sum(int(digit) for digit in total2)\n    \n    # Step 4: Return the difference\n    return sum1 - sum2\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))"], "responses": ["\ndef solve(s):\n    # Step 1: Convert each character to ASCII and concatenate\n    total1 = ''.join(str(ord(c)) for c in s)\n    \n    # Step 2: Replace all '7' with '1' to get total2\n    total2 = total1.replace('7', '1')\n    \n    # Step 3: Calculate sum of digits for both\n    sum1 = sum(int(digit) for digit in total1)\n    sum2 = sum(int(digit) for digit in total2)\n    \n    # Step 4: Return the difference\n    return sum1 - sum2\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))\n\n\n"], "prompt_tokens": [7190], "completion_tokens": [3138], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3292}
{"name": "2886", "description": "# Description:\n\n Find the longest successive exclamation marks and question marks combination in the string. A successive exclamation marks and question marks combination must contains two part: a substring of \"!\" and a substring \"?\", they are adjacent. \n \n If more than one result are found, return the one which at left side; If no such a combination found, return `\"\"`.\n\n# Examples\n\n```\nfind(\"!!\") === \"\"\nfind(\"!??\") === \"!??\"\nfind(\"!?!!\") === \"?!!\"\nfind(\"!!???!????\") === \"!!???\"\nfind(\"!!???!?????\") === \"!?????\"\nfind(\"!????!!!?\") === \"????!!!\" \nfind(\"!?!!??!!!?\") === \"??!!!\"\n```\n\n# Note\nPlease don't post issue about difficulty or duplicate. Because:\n>[That's unfair on the kata creator. This is a valid kata and introduces new people to javascript some regex or loops, depending on how they tackle this problem.  --matt c](https://www.codewars.com/kata/remove-exclamation-marks/discuss#57fabb625c9910c73000024e)", "difficulty": "introductory", "id": 2886, "sample_io": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "test_list": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "starter_code": "\ndef find(s):\n\t", "source_codes": ["import re\n\ndef find(s):\n    max_len = 0\n    result = \"\"\n    \n    # Find all valid combinations: !+?+ or ?+!+\n    combinations = []\n    \n    # Pattern 1: one or more ! followed by one or more ?\n    pattern1 = r'!+\\?+'\n    # Pattern 2: one or more ? followed by one or more !\n    pattern2 = r'\\?+!+'\n    \n    # Find all matches for both patterns\n    for match in re.finditer(pattern1, s):\n        combinations.append((match.start(), match.group()))\n    \n    for match in re.finditer(pattern2, s):\n        combinations.append((match.start(), match.group()))\n    \n    # Sort by position to ensure leftmost comes first\n    combinations.sort(key=lambda x: x[0])\n    \n    # Find the longest combination\n    for _, combo in combinations:\n        if len(combo) > max_len:\n            max_len = len(combo)\n            result = combo\n    \n    return result\n\n# Read input and print result\ns = input().strip()\nresult = find(s)\nprint(result)"], "responses": ["\nimport re\n\ndef find(s):\n    max_len = 0\n    result = \"\"\n    \n    # Find all valid combinations: !+?+ or ?+!+\n    combinations = []\n    \n    # Pattern 1: one or more ! followed by one or more ?\n    pattern1 = r'!+\\?+'\n    # Pattern 2: one or more ? followed by one or more !\n    pattern2 = r'\\?+!+'\n    \n    # Find all matches for both patterns\n    for match in re.finditer(pattern1, s):\n        combinations.append((match.start(), match.group()))\n    \n    for match in re.finditer(pattern2, s):\n        combinations.append((match.start(), match.group()))\n    \n    # Sort by position to ensure leftmost comes first\n    combinations.sort(key=lambda x: x[0])\n    \n    # Find the longest combination\n    for _, combo in combinations:\n        if len(combo) > max_len:\n            max_len = len(combo)\n            result = combo\n    \n    return result\n\n# Read input and print result\ns = input().strip()\nresult = find(s)\nprint(result)\n\n\n"], "prompt_tokens": [8924], "completion_tokens": [3202], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2886}
{"name": "4515", "description": "Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.", "difficulty": "introductory", "id": 4515, "sample_io": [{"input": "['56-23','1-100']", "output": ["1-100"]}, {"input": "['1-3', '5-7', '2-3']", "output": ["1-3"]}, {"input": "['11-11', '344-344']", "output": [false]}], "test_list": [{"input": "['43-45', '1021-55', '000-18888', '92-34', '76-32', '99-1', '1020-54']", "output": ["000-18888"]}, {"input": "['1-2', '2-4', '5-7', '8-9', '44-45']", "output": ["2-4"]}, {"input": "['1-1000', '2-1000', '100-67', '98-45', '8-9']", "output": ["1-1000"]}, {"input": "['33-33', '77-77']", "output": [false]}, {"input": "['23-67', '67-23', '88-88', '45-46']", "output": ["23-67"]}, {"input": "['45896-2354', '4654-556767', '2455-423522', '3455-355', '34-34', '2524522-0']", "output": ["2524522-0"]}, {"input": "['1-1', '2-2', '1-0', '77-77']", "output": ["1-0"]}, {"input": "['0-0']", "output": [false]}, {"input": "[]", "output": [false]}], "starter_code": "\ndef diff(arr):\n\t", "source_codes": ["import sys\nimport ast\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return [False]\n    \n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return [False]\n    \n    return [result]\n\n# Read input from stdin\ninput_str = input().strip()\n\n# Parse the input string into a list using ast.literal_eval for safety\ntry:\n    couples = ast.literal_eval(input_str) if input_str else []\nexcept:\n    # Handle case where input might be empty or malformed\n    couples = []\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)"], "responses": ["\nimport sys\nimport ast\n\ndef find_greatest_difference(couples):\n    if not couples:\n        return [False]\n    \n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return [False]\n    \n    return [result]\n\n# Read input from stdin\ninput_str = input().strip()\n\n# Parse the input string into a list using ast.literal_eval for safety\ntry:\n    couples = ast.literal_eval(input_str) if input_str else []\nexcept:\n    # Handle case where input might be empty or malformed\n    couples = []\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)\n\n\n"], "prompt_tokens": [7891], "completion_tokens": [3391], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4515}
{"name": "3068", "description": "You need to play around with the provided string (s).\n\nMove consonants forward 9 places through the alphabet.\nIf they pass 'z', start again at 'a'.\n\nMove vowels back 5 places through the alphabet.\nIf they pass 'a', start again at 'z'.\nFor our Polish friends this kata does not count 'y' as a vowel.\n\nExceptions:\n\nIf the character is 'c' or 'o', move it back 1 place.\nFor 'd' move it back 3, and for 'e', move it back 4.\n\nIf a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.\n\nProvided string will always be lower case, won't be empty and will have no special characters.", "difficulty": "introductory", "id": 3068, "sample_io": [], "test_list": [{"input": "testcase", "output": ["tabtbvba"]}, {"input": "codewars", "output": ["bnaafvab"]}, {"input": "exampletesthere", "output": ["agvvyuatabtqaaa"]}, {"input": "returnofthespacecamel", "output": ["aatpawnftqabyvbabvvau"]}, {"input": "bringonthebootcamp", "output": ["kaiwpnwtqaknntbvvy"]}, {"input": "weneedanofficedog", "output": ["fawaaavwnffibaanp"]}], "starter_code": "\ndef vowel_back(st):\n\t", "source_codes": ["def transform_string(s):\n    vowels = set('aeiou')\n    exceptions = {'c': -1, 'o': -1, 'd': -3, 'e': -4}\n    revert_set = set('code')\n    \n    def move_char(c, shift):\n        # Calculate new position with proper wrapping\n        new_pos = (ord(c) - ord('a') + shift) % 26\n        return chr(new_pos + ord('a'))\n    \n    result = []\n    for char in s:\n        original_char = char\n        if char in exceptions:\n            new_char = move_char(char, exceptions[char])\n        elif char in vowels:\n            new_char = move_char(char, -5)\n        else:  # consonant\n            new_char = move_char(char, 9)\n        \n        # If the transformed character is in revert set, revert to original\n        if new_char in revert_set:\n            new_char = original_char\n        result.append(new_char)\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(transform_string(s))"], "responses": ["\ndef transform_string(s):\n    vowels = set('aeiou')\n    exceptions = {'c': -1, 'o': -1, 'd': -3, 'e': -4}\n    revert_set = set('code')\n    \n    def move_char(c, shift):\n        # Calculate new position with proper wrapping\n        new_pos = (ord(c) - ord('a') + shift) % 26\n        return chr(new_pos + ord('a'))\n    \n    result = []\n    for char in s:\n        original_char = char\n        if char in exceptions:\n            new_char = move_char(char, exceptions[char])\n        elif char in vowels:\n            new_char = move_char(char, -5)\n        else:  # consonant\n            new_char = move_char(char, 9)\n        \n        # If the transformed character is in revert set, revert to original\n        if new_char in revert_set:\n            new_char = original_char\n        result.append(new_char)\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(transform_string(s))\n\n\n"], "prompt_tokens": [7107], "completion_tokens": [6337], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3068}
{"name": "4214", "description": "In this kata you will have to modify a sentence so it meets the following rules:\n\nconvert every word backwards that is:\n\n    longer than 6 characters\n\n  OR\n\n    has 2 or more 'T' or 't' in it\n\nconvert every word uppercase that is:\n\n    exactly 2 characters long\n\n  OR\n\n    before a comma\n\nconvert every word to a \"0\" that is:\n\n    exactly one character long\n \n\n NOTES: \n\n      Punctuation must not be touched. if a word is 6 characters long, and a \".\" is behind it,\n      it counts as 6 characters so it must not be flipped, but if a word is 7 characters long,\n      it must be flipped but the \".\" must stay at the end of the word.\n      -----------------------------------------------------------------------------------------\n      Only the first transformation applies to a given word, for example 'companions,'\n      will be 'snoinapmoc,' and not 'SNOINAPMOC,'.\n      -----------------------------------------------------------------------------------------\n      As for special characters like apostrophes or dashes, they count as normal characters, \n      so e.g 'sand-colored' must be transformed to 'deroloc-dnas'.", "difficulty": "introductory", "id": 4214, "sample_io": [{"input": "companions,", "output": ["snoinapmoc,"]}, {"input": "sand-colored", "output": ["deroloc-dnas"]}], "test_list": [{"input": "Welcome.", "output": ["emocleW."]}, {"input": "If a man does not keep pace with his companions, perhaps it is because he hears a different drummer.", "output": ["IF 0 man does not keep pace with his snoinapmoc, spahrep IT IS esuaceb HE hears 0 tnereffid remmurd."]}, {"input": "As Grainier drove along in the wagon behind a wide, slow, sand-colored mare, clusters of orange butterflies exploded off the purple blackish piles of bear sign and winked and winked and fluttered magically like leaves without trees.", "output": ["AS reiniarG drove along IN the wagon behind 0 WIDE, SLOW, deroloc-dnas MARE, sretsulc OF orange seilfrettub dedolpxe off the purple hsikcalb piles OF bear sign and winked and winked and derettulf yllacigam like leaves tuohtiw trees."]}, {"input": "You should check the mileage on your car since you've been driving it so much, and because it's starting to make weird noises.", "output": ["You should check the egaelim ON your car since you've been gnivird IT SO MUCH, and esuaceb it's gnitrats TO make weird noises."]}, {"input": "Wherever you go, you can always find beauty.", "output": ["reverehW you GO, you can always find beauty."]}, {"input": "Action is indeed, commmmmmmming.", "output": ["Action IS INDEED, gnimmmmmmmmoc."]}, {"input": "Mother, please, help, me.", "output": ["MOTHER, PLEASE, HELP, ME."]}, {"input": "Jojojo, jojo, tata man kata.", "output": ["JOJOJO, JOJO, atat man kata."]}], "starter_code": "\ndef spin_solve(sentence):\n\t", "source_codes": ["import re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part (without trailing punctuation)\n        match = re.match(r'^(\\w*)(\\W*)$', token)\n        if not match:\n            result_tokens.append(token)\n            continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # Rule 1: Convert backwards if longer than 6 chars OR has 2+ 'T'/'t'\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result_tokens.append(word_part[::-1] + punct_part)\n        # Rule 2: Convert uppercase if exactly 2 chars OR before a comma\n        elif len(word_part) == 2 or (i + 1 < len(tokens) and tokens[i+1].strip() == ','):\n            result_tokens.append(word_part.upper() + punct_part)\n        # Rule 3: Convert to \"0\" if exactly 1 character\n        elif len(word_part) == 1:\n            result_tokens.append('0' + punct_part)\n        else:\n            result_tokens.append(token)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)"], "responses": ["\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part (without trailing punctuation)\n        match = re.match(r'^(\\w*)(\\W*)$', token)\n        if not match:\n            result_tokens.append(token)\n            continue\n            \n        word_part = match.group(1)\n        punct_part = match.group(2)\n        \n        # Rule 1: Convert backwards if longer than 6 chars OR has 2+ 'T'/'t'\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result_tokens.append(word_part[::-1] + punct_part)\n        # Rule 2: Convert uppercase if exactly 2 chars OR before a comma\n        elif len(word_part) == 2 or (i + 1 < len(tokens) and tokens[i+1].strip() == ','):\n            result_tokens.append(word_part.upper() + punct_part)\n        # Rule 3: Convert to \"0\" if exactly 1 character\n        elif len(word_part) == 1:\n            result_tokens.append('0' + punct_part)\n        else:\n            result_tokens.append(token)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n"], "prompt_tokens": [8964], "completion_tokens": [3844], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4214}
{"name": "3884", "description": "# RegExp Fun #1 - When I miss few days of gym\n\n## Disclaimer\n\nThe background story of this Kata is 100% fiction.  Any resemblance to real people or real events is **nothing more than a coincidence** and should be regarded as such.\n\n## Background Story\n\nYou are a person who loves to go to the gym everyday with the squad of people that you've known since early childhood.  However, you recently contracted a sickness that forced you to stay at home for over a week.  As you see your body getting weaker and weaker every day and as you see your biceps and triceps disappearing, you can't help but lay in bed and cry.  You're usually an optimistic person but this time negative thoughts come to your head ... \n\n![When I miss few days of gym](https://pics.onsizzle.com/Instagram-faf8c9.png)\n\n\n## Task\n\nAs can be seen from the funny image above (or am I the only person to find the picture above hilarious?) there is lots of slang.  Your task is to define a function ```gymSlang``` which accepts a string argument and does the following:\n\n1. Replace *all* instances of ```\"probably\"``` to ```\"prolly\"```\n2. Replace *all* instances of ```\"i am\"``` to ```\"i'm\"```\n3. Replace *all* instances of ```\"instagram\"``` to ```\"insta\"```\n4. Replace *all* instances of ```\"do not\"``` to ```\"don't\"```\n5. Replace *all* instances of ```\"going to\"``` to ```\"gonna\"```\n6. Replace *all* instances of ```\"combination\"``` to ```\"combo\"```\n\nYour replacement regexes **should be case-sensitive**, only replacing the words above with slang if the detected pattern is in **lowercase**.  However, please note that apart from 100% lowercase matches, you will **also have to replace matches that are correctly capitalized** (e.g. ```\"Probably\" => \"Prolly\"``` or ```\"Instagram\" => \"Insta\"```).\n\nFinally, your code will be tested to make sure that you have used **RegExp** replace in your code.\n\nEnjoy :D", "difficulty": "introductory", "id": 3884, "sample_io": [{"input": "Probably", "output": ["Prolly"]}, {"input": "Instagram", "output": ["Insta"]}], "test_list": [{"input": "When I miss few days of gym", "output": ["When I miss few days of gym"]}, {"input": "Squad probably think I am fake", "output": ["Squad prolly think I'm fake"]}, {"input": "Whole squad probably bigger than me now", "output": ["Whole squad prolly bigger than me now"]}, {"input": "No selfie to post on Instagram either", "output": ["No selfie to post on Insta either"]}, {"input": "Gym crush probably found someone else", "output": ["Gym crush prolly found someone else"]}, {"input": "What if I die fat", "output": ["What if I die fat"]}, {"input": "What if I do not fit in my clothes now", "output": ["What if I don't fit in my clothes now"]}, {"input": "Going to feel like a new gym member", "output": ["Gonna feel like a new gym member"]}, {"input": "wait what was my lock combination", "output": ["wait what was my lock combo"]}, {"input": "that skinny girl can probably outlift me now", "output": ["that skinny girl can prolly outlift me now"]}, {"input": "probably Probably", "output": ["prolly Prolly"]}, {"input": "i am I am", "output": ["i'm I'm"]}, {"input": "instagram Instagram", "output": ["insta Insta"]}, {"input": "do not Do not", "output": ["don't Don't"]}, {"input": "going to Going to", "output": ["gonna Gonna"]}, {"input": "combination Combination", "output": ["combo Combo"]}, {"input": "probably Probably probably Probably probably Probably probably Probably probably Probably", "output": ["prolly Prolly prolly Prolly prolly Prolly prolly Prolly prolly Prolly"]}, {"input": "i am I am i am I am i am I am i am I am i am I am i am I am", "output": ["i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm"]}, {"input": "instagram Instagram instagram Instagram instagram Instagram instagram Instagram instagram Instagram", "output": ["insta Insta insta Insta insta Insta insta Insta insta Insta"]}, {"input": "do not Do not do not Do not do not Do not do not Do not", "output": ["don't Don't don't Don't don't Don't don't Don't"]}, {"input": "Going to going to Going to Going to going to Going to Going to going to Going to", "output": ["Gonna gonna Gonna Gonna gonna Gonna Gonna gonna Gonna"]}, {"input": "combination combination Combination combination Combination", "output": ["combo combo Combo combo Combo"]}], "starter_code": "\ndef gym_slang(phrase):\n\t", "source_codes": ["import re\nimport sys\n\ndef gymSlang(phrase):\n    # Define replacements with their regex patterns\n    replacements = [\n        (r'\\bprobably\\b', 'prolly'),\n        (r'\\bi am\\b', \"i'm\"),\n        (r'\\binstagram\\b', 'insta'),\n        (r'\\bdo not\\b', \"don't\"),\n        (r'\\bgoing to\\b', 'gonna'),\n        (r'\\bcombination\\b', 'combo')\n    ]\n    \n    result = phrase\n    for pattern, replacement in replacements:\n        # Function to handle capitalization\n        def replace_func(match):\n            matched_word = match.group(0)\n            # If the matched word is all lowercase\n            if matched_word.islower():\n                return replacement\n            # If the matched word has first letter capitalized\n            elif matched_word[0].isupper() and matched_word[1:].islower():\n                return replacement.capitalize()\n            # Otherwise, return unchanged\n            else:\n                return matched_word\n        \n        result = re.sub(pattern, replace_func, result, flags=re.IGNORECASE)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_phrase = sys.stdin.read().strip()\n    output_phrase = gymSlang(input_phrase)\n    print(output_phrase)"], "responses": ["\nimport re\nimport sys\n\ndef gymSlang(phrase):\n    # Define replacements with their regex patterns\n    replacements = [\n        (r'\\bprobably\\b', 'prolly'),\n        (r'\\bi am\\b', \"i'm\"),\n        (r'\\binstagram\\b', 'insta'),\n        (r'\\bdo not\\b', \"don't\"),\n        (r'\\bgoing to\\b', 'gonna'),\n        (r'\\bcombination\\b', 'combo')\n    ]\n    \n    result = phrase\n    for pattern, replacement in replacements:\n        # Function to handle capitalization\n        def replace_func(match):\n            matched_word = match.group(0)\n            # If the matched word is all lowercase\n            if matched_word.islower():\n                return replacement\n            # If the matched word has first letter capitalized\n            elif matched_word[0].isupper() and matched_word[1:].islower():\n                return replacement.capitalize()\n            # Otherwise, return unchanged\n            else:\n                return matched_word\n        \n        result = re.sub(pattern, replace_func, result, flags=re.IGNORECASE)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_phrase = sys.stdin.read().strip()\n    output_phrase = gymSlang(input_phrase)\n    print(output_phrase)\n\n\n"], "prompt_tokens": [11328], "completion_tokens": [3648], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3884}
{"name": "3732", "description": "A Madhav array has the following property:\n\n```a[0] = a[1] + a[2] = a[3] + a[4] + a[5] = a[6] + a[7] + a[8] + a[9] = ...```\n\nComplete the function/method that returns `true` if the given array is a Madhav array, otherwise it returns `false`.\n\n*Edge cases: An array of length* `0` *or* `1` *should not be considered a Madhav array as there is nothing to compare.*", "difficulty": "introductory", "id": 3732, "sample_io": [], "test_list": [{"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, -100]", "output": [false]}, {"input": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, -2, -1]", "output": [true]}, {"input": "[-6, -3, -3, 8, -5, -4]", "output": [false]}, {"input": "[-6, -3, -3, 8, -10, -4]", "output": [true]}, {"input": "[3, 1, 2, 3, 0]", "output": [false]}, {"input": "[3, 3]", "output": [false]}, {"input": "[]", "output": [false]}, {"input": "[1]", "output": [false]}, {"input": "[5, 2, 4, 1, 0, 3]", "output": [false]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 6]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 1]", "output": [false]}, {"input": "[2, 1, 1]", "output": [true]}, {"input": "[2, 1, 1, 4, -1, -1]", "output": [true]}], "starter_code": "\ndef is_madhav_array(arr):\n\t", "source_codes": ["def is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Find the number of groups k such that 1 + 2 + 3 + ... + k = n\n    # This means k(k+1)/2 = n\n    # So k^2 + k - 2n = 0\n    # k = (-1 + sqrt(1 + 8n)) / 2\n    \n    # But we need to check if such an integer k exists\n    k = 1\n    total_length = 0\n    \n    # Keep adding groups until we reach or exceed n\n    while total_length < n:\n        if total_length == 0:\n            total_length += 1  # First element\n        else:\n            total_length += k   # k-th group has k elements\n        k += 1\n    \n    # Check if we have exact fit\n    if total_length != n:\n        return False\n    \n    # Now check the sums\n    target_sum = arr[0]\n    index = 1\n    \n    # Check groups of size 1, 2, 3, ..., (k-1)\n    for group_size in range(1, k-1):\n        if index + group_size > n:\n            return False\n        \n        group_sum = sum(arr[index:index + group_size])\n        if group_sum != target_sum:\n            return False\n        index += group_size\n    \n    return True\n\n# Read input and process\ninput_str = input().strip()\nif input_str == \"[]\":\n    arr = []\nelse:\n    arr = [int(x.strip()) for x in input_str[1:-1].split(\",\") if x.strip()]\n\nresult = is_madhav_array(arr)\nprint(str(result).lower())"], "responses": ["\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Find the number of groups k such that 1 + 2 + 3 + ... + k = n\n    # This means k(k+1)/2 = n\n    # So k^2 + k - 2n = 0\n    # k = (-1 + sqrt(1 + 8n)) / 2\n    \n    # But we need to check if such an integer k exists\n    k = 1\n    total_length = 0\n    \n    # Keep adding groups until we reach or exceed n\n    while total_length < n:\n        if total_length == 0:\n            total_length += 1  # First element\n        else:\n            total_length += k   # k-th group has k elements\n        k += 1\n    \n    # Check if we have exact fit\n    if total_length != n:\n        return False\n    \n    # Now check the sums\n    target_sum = arr[0]\n    index = 1\n    \n    # Check groups of size 1, 2, 3, ..., (k-1)\n    for group_size in range(1, k-1):\n        if index + group_size > n:\n            return False\n        \n        group_sum = sum(arr[index:index + group_size])\n        if group_sum != target_sum:\n            return False\n        index += group_size\n    \n    return True\n\n# Read input and process\ninput_str = input().strip()\nif input_str == \"[]\":\n    arr = []\nelse:\n    arr = [int(x.strip()) for x in input_str[1:-1].split(\",\") if x.strip()]\n\nresult = is_madhav_array(arr)\nprint(str(result).lower())\n\n\n"], "prompt_tokens": [8496], "completion_tokens": [6896], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 3732}
{"name": "3569", "description": "In Russia regular bus tickets usually consist of 6 digits. The ticket is called lucky when the sum of the first three digits equals to the sum of the last three digits. Write a function to find out whether the ticket is lucky or not. Return true if so, otherwise return false. Consider that input is always a string. Watch examples below.", "difficulty": "introductory", "id": 3569, "sample_io": [], "test_list": [{"input": "123321", "output": [true]}, {"input": "12341234", "output": [false]}, {"input": "100001", "output": [true]}, {"input": "100200", "output": [false]}, {"input": "912435", "output": [true]}, {"input": "12a12a", "output": [false]}, {"input": "999999", "output": [true]}, {"input": "1111", "output": [false]}, {"input": "000000", "output": [true]}, {"input": "", "output": [false]}], "starter_code": "\ndef is_lucky(ticket):\n\t", "source_codes": ["def is_lucky_ticket(ticket):\n    # Check if ticket has exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Split into first and second half\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits in each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return whether sums are equal\n    return sum_first == sum_second\n\n# Read input and process\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())"], "responses": ["\ndef is_lucky_ticket(ticket):\n    # Check if ticket has exactly 6 digits\n    if len(ticket) != 6 or not ticket.isdigit():\n        return False\n    \n    # Split into first and second half\n    first_half = ticket[:3]\n    second_half = ticket[3:]\n    \n    # Calculate sum of digits in each half\n    sum_first = sum(int(digit) for digit in first_half)\n    sum_second = sum(int(digit) for digit in second_half)\n    \n    # Return whether sums are equal\n    return sum_first == sum_second\n\n# Read input and process\nticket = input().strip()\nresult = is_lucky_ticket(ticket)\nprint(str(result).lower())\n\n\n"], "prompt_tokens": [4869], "completion_tokens": [2331], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 3569}
{"name": "2755", "description": "Return a new array consisting of elements which are multiple of their own index in input array (length > 1).\n\nSome cases: \n\n```\n[22, -6, 32, 82, 9, 25] =>  [-6, 32, 25]\n\n[68, -1, 1, -7, 10, 10] => [-1, 10]\n\n[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68] => [-85, 72, 0, 68]\n```", "difficulty": "introductory", "id": 2755, "sample_io": [{"input": "[22, -6, 32, 82, 9, 25]", "output": [[-6, 32, 25]]}, {"input": "[68, -1, 1, -7, 10, 10]", "output": [[-1, 10]]}, {"input": "[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68]", "output": [[-85, 72, 0, 68]]}], "test_list": [{"input": "[22, -6, 32, 82, 9, 25]", "output": [[-6, 32, 25]]}, {"input": "[68, -1, 1, -7, 10, 10]", "output": [[-1, 10]]}, {"input": "[11, -11]", "output": [[-11]]}, {"input": "[-56, -85, 72, -26, -14, 76, -27, 72, 35, -21, -67, 87, 0, 21, 59, 27, -92, 68]", "output": [[-85, 72, 0, 68]]}, {"input": "[28, 38, -44, -99, -13, -54, 77, -51]", "output": [[38, -44, -99]]}, {"input": "[-1, -49, -1, 67, 8, -60, 39, 35]", "output": [[-49, 8, -60, 35]]}], "starter_code": "\ndef multiple_of_index(arr):\n\t", "source_codes": ["def solution(arr):\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] % i == 0:\n            result.append(arr[i])\n    return result\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    arr = eval(input_str)\n    result = solution(arr)\n    print(result)"], "responses": ["\ndef solution(arr):\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] % i == 0:\n            result.append(arr[i])\n    return result\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    arr = eval(input_str)\n    result = solution(arr)\n    print(result)\n\n\n"], "prompt_tokens": [8850], "completion_tokens": [2681], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2755}
{"name": "4168", "description": "Implement a function which takes a string, and returns its hash value.\n\nAlgorithm steps:\n\n* `a` := sum of the ascii values of the input characters\n* `b` := sum of every difference between the consecutive characters of the input (second char minus first char, third minus second, ...)\n* `c` := (`a` OR `b`) AND ((NOT `a`) shift left by 2 bits)\n* `d` := `c` XOR (32 * (`total_number_of_spaces` + 1))\n* return `d`\n\n**Note**: OR, AND, NOT, XOR are bitwise operations.\n\n___\n\n### Examples\n\n```\ninput = \"a\"\na = 97\nb = 0\nresult = 64\n\ninput = \"ca\"\na = 196\nb = -2\nresult = -820\n```\n\n___\n\nGive an example why this hashing algorithm is bad?", "difficulty": "introductory", "id": 4168, "sample_io": [{"input": "a", "output": [64]}, {"input": "ca", "output": [-820]}], "test_list": [{"input": "int main(int argc, char *argv[]) { return 0; }", "output": [188]}, {"input": " Yo - What's Good?! ", "output": [460]}, {"input": " df af asd ", "output": [744]}, {"input": "global hash", "output": [1120]}, {"input": "section .text", "output": [328]}, {"input": "hash:", "output": [-1884]}, {"input": "    xor eax, eax", "output": [1080]}, {"input": "    ret", "output": [112]}, {"input": "; -----> end of hash <-----", "output": [-7136]}, {"input": "int hash(const char *str);", "output": [-9232]}, {"input": "", "output": [32]}, {"input": " ", "output": [96]}, {"input": "  ", "output": [32]}, {"input": "   ", "output": [224]}, {"input": "    ", "output": [32]}], "starter_code": "\ndef string_hash(s):\n\t", "source_codes": ["def compute_hash(s):\n    # Step 1: Calculate 'a' - sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' - sum of consecutive character differences\n    b = 0\n    for i in range(len(s) - 1):\n        b += ord(s[i + 1]) - ord(s[i])\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c = (a OR b) AND ((NOT a) << 2)\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Count spaces and calculate 'd'\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))"], "responses": ["\ndef compute_hash(s):\n    # Step 1: Calculate 'a' - sum of ASCII values\n    a = sum(ord(c) for c in s)\n    \n    # Step 2: Calculate 'b' - sum of consecutive character differences\n    b = 0\n    for i in range(len(s) - 1):\n        b += ord(s[i + 1]) - ord(s[i])\n    \n    # Step 3: Calculate 'c' using bitwise operations\n    # c = (a OR b) AND ((NOT a) << 2)\n    c = (a | b) & ((~a) << 2)\n    \n    # Step 4: Count spaces and calculate 'd'\n    space_count = s.count(' ')\n    d = c ^ (32 * (space_count + 1))\n    \n    return d\n\n# Read input and print result\ns = input()\nprint(compute_hash(s))\n\n\n"], "prompt_tokens": [8431], "completion_tokens": [5502], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4168}
{"name": "4391", "description": "## The Story\nGreen Lantern's long hours of study and practice with his ring have really paid off -- his skills, focus, and control have improved so much that now he can even use his ring to update and redesign his web site. Earlier today he was focusing his will and a beam from his ring upon the Justice League web server, while intensely brainstorming and visualizing in minute detail different looks and ideas for his web site, and when he finished and reloaded his home page, he was absolutely thrilled to see that among other things it now displayed\n\n~~~~\nIn brightest day, in blackest night,\nThere's nothing cooler than my site!\n~~~~\n\nin his favorite font in very large blinking green letters.\n\nThe problem is, Green Lantern's ring has no power over anything yellow, so if he's experimenting with his web site and accidentally changes some text or background color to yellow, he will no longer be able to make any changes to those parts of the content or presentation (because he doesn't actually know any HTML, CSS, programming languages, frameworks, etc.) until he gets a more knowledgable friend to edit the code for him.\n\n## Your Mission\nYou can help Green Lantern by writing a function that will replace any color property values that are too yellow with shades of green or blue-green. Presumably at a later time the two of you will be doing some testing to find out at exactly which RGB values yellow stops being yellow and starts being off-white, orange, brown, etc. as far as his ring is concerned, but here's the plan to get version 1.0 up and running as soon as possible:\n\nYour function will receive either an HTML color name or a six-digit hex color code. (You're not going to bother with other types of color codes just now because you don't think they will come up.) If the color is too yellow, your function needs to return a green or blue-green shade instead, but if it is not too yellow, it needs to return the original color name or hex color code unchanged.\n\n### HTML Color Names\n(If don't know what HTML color names are, take a look at this HTML colors names reference.)\n\nFor HMTL color names, you are going to start out trying a pretty strict definition of yellow, replacing any of the following colors as specified:\n\n~~~~\nGold => ForestGreen\nKhaki => LimeGreen\nLemonChiffon => PaleGreen\nLightGoldenRodYellow => SpringGreen\nLightYellow => MintCream\nPaleGoldenRod => LightGreen\nYellow => Lime\n~~~~\n\nHTML color names are case-insensitive, so your function will need to be able to identify the above yellow shades regardless of the cases used, but should output the green shades as capitalized above.\n\nSome examples:\n```\n\"lemonchiffon\"    \"PaleGreen\"\n\"GOLD\"            \"ForestGreen\"\n\"pAlEgOlDeNrOd\"   \"LightGreen\"\n\"BlueViolet\"      \"BlueViolet\"\n```\n\n### Hex Color Codes\n(If you don't know what six-digit hex color codes are, take a look at this Wikipedia description. Basically the six digits are made up of three two-digit numbers in base 16, known as hexidecimal or hex, from 00 to FF (equivalent to 255 in base 10, also known as decimal), with the first two-digit number specifying the color's red value, the second the green value, and the third blue.)\n\nWith six-digit color hex codes, you are going to start out going really overboard, interpreting as \"yellow\" any hex code where the red (R) value and the green (G) value are each greater than the blue (B) value. When you find one of these \"yellow\" hex codes, your function will take the three hex values and rearrange them that the largest goes to G, the middle goes to B, and the smallest to R. \n\nFor example, with the six-digit hex color code `#FFD700`, which has an R value of hex FF (decimal 255), a G value of hex D7 (decimal 215), and a B value of hex 00 (decimal 0), as the R and G values are each larger than the B value, you would return it as `#00FFD7` -- the FF reassigned to G, the D7 to B, and the 00 to R. \n\nHex color codes are also case-insensitive, but your function should output them in the same case they were received in, just for consistency with whatever style is being used.\n\nSome examples:\n```\n\"#000000\"   \"#000000\"\n\"#b8860b\"   \"#0bb886\"\n\"#8FBC8F\"   \"#8FBC8F\"\n\"#C71585\"   \"#C71585\"\n```", "difficulty": "introductory", "id": 4391, "sample_io": [{"input": "lemonchiffon", "output": ["PaleGreen"]}, {"input": "GOLD", "output": ["ForestGreen"]}, {"input": "pAlEgOlDeNrOd", "output": ["LightGreen"]}, {"input": "BlueViolet", "output": ["BlueViolet"]}, {"input": "#000000", "output": ["#000000"]}, {"input": "#b8860b", "output": ["#0bb886"]}, {"input": "#8FBC8F", "output": ["#8FBC8F"]}, {"input": "#C71585", "output": ["#C71585"]}], "test_list": [{"input": "lemonchiffon", "output": ["PaleGreen"]}, {"input": "GOLD", "output": ["ForestGreen"]}, {"input": "pAlEgOlDeNrOd", "output": ["LightGreen"]}, {"input": "BlueViolet", "output": ["BlueViolet"]}, {"input": "#000000", "output": ["#000000"]}, {"input": "#b8860b", "output": ["#0bb886"]}, {"input": "#8FBC8F", "output": ["#8FBC8F"]}, {"input": "#C71585", "output": ["#C71585"]}], "starter_code": "\ndef yellow_be_gone(s):\n\t", "source_codes": ["def convert_yellow_color(color):\n    # Dictionary mapping yellow HTML color names to green replacements\n    yellow_to_green = {\n        'gold': 'ForestGreen',\n        'khaki': 'LimeGreen',\n        'lemonchiffon': 'PaleGreen',\n        'lightgoldenrodyellow': 'SpringGreen',\n        'lightyellow': 'MintCream',\n        'palegoldenrod': 'LightGreen',\n        'yellow': 'Lime'\n    }\n    \n    # Check if it's a hex color code\n    if color.startswith('#'):\n        # Extract RGB components\n        r_hex = color[1:3]\n        g_hex = color[3:5]\n        b_hex = color[5:7]\n        \n        # Convert hex to decimal\n        r = int(r_hex, 16)\n        g = int(g_hex, 16)\n        b = int(b_hex, 16)\n        \n        # Check if it's \"yellow\" (R > B and G > B)\n        if r > b and g > b:\n            # Sort the values\n            sorted_vals = sorted([r, g, b])\n            # Reassign: smallest to R, middle to B, largest to G\n            new_r = sorted_vals[0]\n            new_b = sorted_vals[1]\n            new_g = sorted_vals[2]\n            \n            # Convert back to hex\n            new_r_hex = format(new_r, '02x')\n            new_g_hex = format(new_g, '02x')\n            new_b_hex = format(new_b, '02x')\n            \n            # Preserve the original case format\n            result = '#'\n            hex_pairs = [r_hex, g_hex, b_hex]\n            new_hex_pairs = [new_r_hex, new_g_hex, new_b_hex]\n            \n            for i in range(3):\n                if hex_pairs[i].isupper():\n                    result += new_hex_pairs[i].upper()\n                else:\n                    result += new_hex_pairs[i].lower()\n            \n            return result\n        else:\n            return color\n    else:\n        # Handle HTML color names (case-insensitive)\n        color_lower = color.lower()\n        if color_lower in yellow_to_green:\n            return yellow_to_green[color_lower]\n        else:\n            return color\n\n# Read input and process\ninput_color = input().strip()\nresult = convert_yellow_color(input_color)\nprint(result)"], "responses": ["\ndef convert_yellow_color(color):\n    # Dictionary mapping yellow HTML color names to green replacements\n    yellow_to_green = {\n        'gold': 'ForestGreen',\n        'khaki': 'LimeGreen',\n        'lemonchiffon': 'PaleGreen',\n        'lightgoldenrodyellow': 'SpringGreen',\n        'lightyellow': 'MintCream',\n        'palegoldenrod': 'LightGreen',\n        'yellow': 'Lime'\n    }\n    \n    # Check if it's a hex color code\n    if color.startswith('#'):\n        # Extract RGB components\n        r_hex = color[1:3]\n        g_hex = color[3:5]\n        b_hex = color[5:7]\n        \n        # Convert hex to decimal\n        r = int(r_hex, 16)\n        g = int(g_hex, 16)\n        b = int(b_hex, 16)\n        \n        # Check if it's \"yellow\" (R > B and G > B)\n        if r > b and g > b:\n            # Sort the values\n            sorted_vals = sorted([r, g, b])\n            # Reassign: smallest to R, middle to B, largest to G\n            new_r = sorted_vals[0]\n            new_b = sorted_vals[1]\n            new_g = sorted_vals[2]\n            \n            # Convert back to hex\n            new_r_hex = format(new_r, '02x')\n            new_g_hex = format(new_g, '02x')\n            new_b_hex = format(new_b, '02x')\n            \n            # Preserve the original case format\n            result = '#'\n            hex_pairs = [r_hex, g_hex, b_hex]\n            new_hex_pairs = [new_r_hex, new_g_hex, new_b_hex]\n            \n            for i in range(3):\n                if hex_pairs[i].isupper():\n                    result += new_hex_pairs[i].upper()\n                else:\n                    result += new_hex_pairs[i].lower()\n            \n            return result\n        else:\n            return color\n    else:\n        # Handle HTML color names (case-insensitive)\n        color_lower = color.lower()\n        if color_lower in yellow_to_green:\n            return yellow_to_green[color_lower]\n        else:\n            return color\n\n# Read input and process\ninput_color = input().strip()\nresult = convert_yellow_color(input_color)\nprint(result)\n\n\n"], "prompt_tokens": [20435], "completion_tokens": [5150], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4391}
{"name": "4344", "description": "# Task\nImagine `n` horizontal lines and `m` vertical lines.\n\nSome of these lines intersect, creating rectangles.\n\nHow many rectangles are there?\n\n# Examples\n\nFor `n=2, m=2,` the result should be `1`.\n\nthere is only one 1x1 rectangle.\n\nFor `n=2, m=3`, the result should be `3`.\n\nthere are two 1x1 rectangles and one 1x2 rectangle. So `2 + 1 = 3`.\n\nFor n=3, m=3, the result should be `9`.\n\nthere are four 1x1 rectangles, two 1x2 rectangles, two 2x1 rectangles and one 2x2 rectangle. So `4 + 2 + 2 + 1 = 9`.\n\n\n\n# Input & Output\n\n\n- `[input]` integer `n`\n\nNumber of horizontal lines.\n\nConstraints: `0 <= n <= 100`\n\n\n- `[input]` integer `m`\n\nNumber of vertical lines.\n\nConstraints: `0 <= m <= 100`\n\n\n- `[output]` an integer\n\nNumber of rectangles.", "difficulty": "introductory", "id": 4344, "sample_io": [{"input": "2\n3", "output": [3]}, {"input": "2\n2", "output": [1]}, {"input": "3\n3", "output": [9]}], "test_list": [{"input": "2\n3", "output": [3]}, {"input": "2\n2", "output": [1]}, {"input": "1\n1", "output": [0]}, {"input": "0\n1", "output": [0]}, {"input": "3\n3", "output": [9]}, {"input": "100\n100", "output": [24502500]}], "starter_code": "\ndef rectangles(n, m):\n\t", "source_codes": ["n = int(input())\nm = int(input())\n\n# To form a rectangle, we need to choose 2 horizontal lines from n lines and 2 vertical lines from m lines\n# Number of ways to choose 2 lines from n lines is C(n,2) = n*(n-1)/2\n# Number of ways to choose 2 lines from m lines is C(m,2) = m*(m-1)/2\n# Total rectangles = C(n,2) * C(m,2)\n\nif n < 2 or m < 2:\n    print(0)\nelse:\n    # Calculate combinations C(n,2) and C(m,2)\n    horizontal_combinations = n * (n - 1) // 2\n    vertical_combinations = m * (m - 1) // 2\n    rectangles = horizontal_combinations * vertical_combinations\n    print(rectangles)"], "responses": ["\nn = int(input())\nm = int(input())\n\n# To form a rectangle, we need to choose 2 horizontal lines from n lines and 2 vertical lines from m lines\n# Number of ways to choose 2 lines from n lines is C(n,2) = n*(n-1)/2\n# Number of ways to choose 2 lines from m lines is C(m,2) = m*(m-1)/2\n# Total rectangles = C(n,2) * C(m,2)\n\nif n < 2 or m < 2:\n    print(0)\nelse:\n    # Calculate combinations C(n,2) and C(m,2)\n    horizontal_combinations = n * (n - 1) // 2\n    vertical_combinations = m * (m - 1) // 2\n    rectangles = horizontal_combinations * vertical_combinations\n    print(rectangles)\n\n\n"], "prompt_tokens": [7545], "completion_tokens": [3108], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4344}
{"name": "3856", "description": "The prime number sequence starts with: `2,3,5,7,11,13,17,19...`. Notice that `2` is in position `one`. \n\n`3` occupies position `two`, which is a prime-numbered position. Similarly, `5`, `11` and `17` also occupy prime-numbered positions. We shall call primes such as `3,5,11,17` dominant primes because they occupy prime-numbered positions in the prime number sequence. Let's call this `listA`. \n\nAs you can see from listA, for the prime range `range(0,10)`, there are `only two` dominant primes (`3` and `5`) and the sum of these primes is: `3 + 5 = 8`. \n\nSimilarly, as shown in listA, in the `range (6,20)`, the dominant primes in this range are `11` and `17`, with a sum of `28`.\n\nGiven a `range (a,b)`, what is the sum of dominant primes within that range? Note that  `a <= range <= b` and `b` will not exceed `500000`.\n\nGood luck!\n\nIf you like this Kata, you will enjoy:\n\n[Simple Prime Streaming](https://www.codewars.com/kata/5a908da30025e995880000e3)\n\n[Sum of prime-indexed elements](https://www.codewars.com/kata/59f38b033640ce9fc700015b)\n\n[Divisor harmony](https://www.codewars.com/kata/59bf97cd4f98a8b1cd00007e)", "difficulty": "introductory", "id": 3856, "sample_io": [{"input": "0\n10", "output": [8]}, {"input": "6\n20", "output": [28]}], "test_list": [{"input": "0\n10", "output": [8]}, {"input": "2\n200", "output": [1080]}, {"input": "200\n2000", "output": [48132]}, {"input": "500\n10000", "output": [847039]}, {"input": "1000\n100000", "output": [52114889]}, {"input": "2000\n200000", "output": [183035206]}, {"input": "3000\n400000", "output": [650120994]}, {"input": "4000\n500000", "output": [972664400]}], "starter_code": "\ndef solve(a,b):\n\t", "source_codes": ["def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n                \n    return is_prime\n\ndef get_dominant_primes(limit):\n    # Generate all primes up to limit\n    is_prime = sieve_of_eratosthenes(limit)\n    \n    # Get list of primes with their positions (1-indexed)\n    primes = []\n    for i in range(2, limit + 1):\n        if is_prime[i]:\n            primes.append(i)\n    \n    # Find dominant primes (primes at prime positions)\n    dominant_primes = set()\n    for i in range(len(primes)):\n        position = i + 1  # 1-indexed position\n        if is_prime[position]:  # If position is prime\n            dominant_primes.add(primes[i])\n            \n    return sorted(list(dominant_primes))\n\n# Precompute dominant primes up to 500000\ndominant_primes_list = get_dominant_primes(500000)\n\n# Read input\na = int(input())\nb = int(input())\n\n# Calculate sum of dominant primes in range [a, b]\nresult = sum(p for p in dominant_primes_list if a <= p <= b)\n\n# Output result\nprint(result)"], "responses": ["\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n                \n    return is_prime\n\ndef get_dominant_primes(limit):\n    # Generate all primes up to limit\n    is_prime = sieve_of_eratosthenes(limit)\n    \n    # Get list of primes with their positions (1-indexed)\n    primes = []\n    for i in range(2, limit + 1):\n        if is_prime[i]:\n            primes.append(i)\n    \n    # Find dominant primes (primes at prime positions)\n    dominant_primes = set()\n    for i in range(len(primes)):\n        position = i + 1  # 1-indexed position\n        if is_prime[position]:  # If position is prime\n            dominant_primes.add(primes[i])\n            \n    return sorted(list(dominant_primes))\n\n# Precompute dominant primes up to 500000\ndominant_primes_list = get_dominant_primes(500000)\n\n# Read input\na = int(input())\nb = int(input())\n\n# Calculate sum of dominant primes in range [a, b]\nresult = sum(p for p in dominant_primes_list if a <= p <= b)\n\n# Output result\nprint(result)\n\n\n"], "prompt_tokens": [11076], "completion_tokens": [5336], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3856}
{"name": "3698", "description": "In this exercise, you will have to create a function named tiyFizzBuzz. This function will take on a string parameter and will return that string with some characters replaced, depending on the value:\n\n- If a letter is a upper case consonants, replace that character with \"Iron\".\n- If a letter is a lower case consonants or a non-alpha character, do nothing to that character\n- If a letter is a upper case vowel, replace that character with \"Iron Yard\".\n- If a letter is a lower case vowel, replace that character with \"Yard\".\n\nReady?", "difficulty": "introductory", "id": 3698, "sample_io": [], "test_list": [{"input": " ", "output": [" "]}, {"input": "H", "output": ["Iron"]}, {"input": "b", "output": ["b"]}, {"input": "A", "output": ["Iron Yard"]}, {"input": "a", "output": ["Yard"]}, {"input": "Hello WORLD!", "output": ["IronYardllYard IronIron YardIronIronIron!"]}, {"input": "H6H4Na ./?U", "output": ["Iron6Iron4IronYard ./?Iron Yard"]}], "starter_code": "\ndef tiy_fizz_buzz(string):\n\t", "source_codes": ["def tiyFizzBuzz(s):\n    uppercase_vowels = 'AEIOU'\n    lowercase_vowels = 'aeiou'\n    result = ''\n    \n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                if char in uppercase_vowels:\n                    result += 'Iron Yard'\n                else:  # uppercase consonant\n                    result += 'Iron'\n            else:  # lowercase\n                if char in lowercase_vowels:\n                    result += 'Yard'\n                else:  # lowercase consonant\n                    result += char\n        else:  # non-alpha character\n            result += char\n    \n    return result\n\n# Read input and process\ninput_string = input()\noutput_string = tiyFizzBuzz(input_string)\nprint(output_string)"], "responses": ["\ndef tiyFizzBuzz(s):\n    uppercase_vowels = 'AEIOU'\n    lowercase_vowels = 'aeiou'\n    result = ''\n    \n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                if char in uppercase_vowels:\n                    result += 'Iron Yard'\n                else:  # uppercase consonant\n                    result += 'Iron'\n            else:  # lowercase\n                if char in lowercase_vowels:\n                    result += 'Yard'\n                else:  # lowercase consonant\n                    result += char\n        else:  # non-alpha character\n            result += char\n    \n    return result\n\n# Read input and process\ninput_string = input()\noutput_string = tiyFizzBuzz(input_string)\nprint(output_string)\n\n\n"], "prompt_tokens": [7253], "completion_tokens": [3591], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3698}
{"name": "4268", "description": "Given a non-negative number, return the next bigger polydivisible number, or an empty value like `null` or `Nothing`.\n\nA number is polydivisible if its first digit is cleanly divisible by `1`, its first two digits by `2`, its first three by `3`, and so on. There are finitely many polydivisible numbers.", "difficulty": "introductory", "id": 4268, "sample_io": [], "test_list": [{"input": "0", "output": [1]}, {"input": "10", "output": [12]}, {"input": "11", "output": [12]}, {"input": "1234", "output": [1236]}, {"input": "123220", "output": [123252]}, {"input": "998", "output": [1020]}, {"input": "999", "output": [1020]}, {"input": "1234567890", "output": [1236004020]}, {"input": "3608528850368400786036724", "output": [3608528850368400786036725]}, {"input": "3608528850368400786036725", "output": [null]}], "starter_code": "\ndef next_num(n):\n\t", "source_codes": ["def is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Handle small numbers directly\n    if n == 0:\n        return 1\n    \n    # Try to build the next polydivisible number more efficiently\n    s = str(n + 1)\n    length = len(s)\n    \n    # Try to find a polydivisible number with the same number of digits first\n    digits = list(s)\n    \n    # Check if we can make a polydivisible number by changing suffix\n    def backtrack(pos):\n        if pos == length:\n            num = int(''.join(digits))\n            return num if is_polydivisible(num) else None\n        \n        # Try current digit and higher digits at this position\n        start_digit = int(digits[pos]) if pos == 0 else 0\n        for d in range(start_digit, 10):\n            digits[pos] = str(d)\n            # Check if current prefix satisfies polydivisible property\n            prefix = int(''.join(digits[:pos+1]))\n            if prefix % (pos + 1) == 0:\n                result = backtrack(pos + 1)\n                if result is not None:\n                    return result\n        return None\n    \n    # First try to find a polydivisible number with same number of digits\n    result = backtrack(0)\n    if result is not None and result > n:\n        return result\n    \n    # If not found, try longer numbers\n    current_length = length\n    while current_length < 15:  # Reasonable upper bound\n        # Try numbers with current_length + 1 digits starting with 1\n        for first_digit in range(1, 10):\n            digits = [str(first_digit)] + ['0'] * current_length\n            result = build_polydivisible(digits, 0)\n            if result is not None and result > n:\n                return result\n        current_length += 1\n    \n    return None\n\ndef build_polydivisible(digits, pos):\n    \"\"\"Build a polydivisible number by filling digits\"\"\"\n    length = len(digits)\n    \n    if pos == length:\n        num = int(''.join(digits))\n        return num if is_polydivisible(num) else None\n    \n    # Try all possible digits at current position\n    for d in range(0, 10):\n        digits[pos] = str(d)\n        # Check if current prefix is valid\n        prefix = int(''.join(digits[:pos+1]))\n        if prefix % (pos + 1) == 0:\n            result = build_polydivisible(digits, pos + 1)\n            if result is not None:\n                return result\n    \n    return None\n\ndef simple_next_polydivisible(n):\n    \"\"\"Simplified version - optimized brute force for smaller ranges\"\"\"\n    candidate = n + 1\n    \n    # Quick optimization: skip obvious non-candidates\n    while candidate < 10**12:\n        # Quick checks for common cases\n        if candidate < 10:\n            if is_polydivisible(candidate):\n                return candidate\n        else:\n            # More systematic search for larger numbers\n            if is_polydivisible(candidate):\n                return candidate\n        candidate += 1\n        \n        # Optimization: jump to next number with better chances\n        if candidate > 10 and candidate % 10 == 9:\n            # If last digit is 9, check if incrementing gives better chance\n            pass\n            \n    return None\n\n# Even simpler and more reliable approach\ndef find_next_polydivisible(n):\n    candidate = n + 1\n    # Set a reasonable limit based on known polydivisible numbers\n    limit = min(n + 5000000, 10**12)  # Balance between thoroughness and speed\n    \n    while candidate <= limit:\n        if is_polydivisible(candidate):\n            return candidate\n        candidate += 1\n    \n    # If not found in local search, try building systematically\n    return build_next_polydivisible(len(str(n + 1)))\n\ndef build_next_polydivisible(min_digits):\n    \"\"\"Build polydivisible numbers systematically\"\"\"\n    # Known polydivisible numbers exist up to 25 digits, but they're rare\n    # We'll search methodically\n    \n    def dfs(current_str, target_len):\n        if len(current_str) == target_len:\n            return int(current_str)\n        \n        for digit in range(0, 10):\n            new_str = current_str + str(digit)\n            if int(new_str) % len(new_str) == 0:\n                result = dfs(new_str, target_len)\n                if result is not None:\n                    return result\n        return None\n    \n    # Try increasing lengths\n    for length in range(min_digits, min_digits + 5):\n        for first_digit in range(1, 10):\n            result = dfs(str(first_digit), length)\n            if result is not None:\n                return result\n    \n    return None\n\n# Read input and produce output\nn = int(input())\n\n# Use the simple approach first since it works for most test cases\ncandidate = n + 1\nwhile candidate < n + 1000000 and candidate < 10**12:  # Reasonable bounds\n    if is_polydivisible(candidate):\n        print(candidate)\n        exit()\n    candidate += 1\n\n# If not found in quick search, use systematic building\nresult = build_next_polydivisible(len(str(n + 1)))\nif result is not None:\n    print(result)\nelse:\n    print(\"\")"], "responses": ["\ndef is_polydivisible(n):\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        if int(s[:i]) % i != 0:\n            return False\n    return True\n\ndef next_polydivisible(n):\n    # Handle small numbers directly\n    if n == 0:\n        return 1\n    \n    # Try to build the next polydivisible number more efficiently\n    s = str(n + 1)\n    length = len(s)\n    \n    # Try to find a polydivisible number with the same number of digits first\n    digits = list(s)\n    \n    # Check if we can make a polydivisible number by changing suffix\n    def backtrack(pos):\n        if pos == length:\n            num = int(''.join(digits))\n            return num if is_polydivisible(num) else None\n        \n        # Try current digit and higher digits at this position\n        start_digit = int(digits[pos]) if pos == 0 else 0\n        for d in range(start_digit, 10):\n            digits[pos] = str(d)\n            # Check if current prefix satisfies polydivisible property\n            prefix = int(''.join(digits[:pos+1]))\n            if prefix % (pos + 1) == 0:\n                result = backtrack(pos + 1)\n                if result is not None:\n                    return result\n        return None\n    \n    # First try to find a polydivisible number with same number of digits\n    result = backtrack(0)\n    if result is not None and result > n:\n        return result\n    \n    # If not found, try longer numbers\n    current_length = length\n    while current_length < 15:  # Reasonable upper bound\n        # Try numbers with current_length + 1 digits starting with 1\n        for first_digit in range(1, 10):\n            digits = [str(first_digit)] + ['0'] * current_length\n            result = build_polydivisible(digits, 0)\n            if result is not None and result > n:\n                return result\n        current_length += 1\n    \n    return None\n\ndef build_polydivisible(digits, pos):\n    \"\"\"Build a polydivisible number by filling digits\"\"\"\n    length = len(digits)\n    \n    if pos == length:\n        num = int(''.join(digits))\n        return num if is_polydivisible(num) else None\n    \n    # Try all possible digits at current position\n    for d in range(0, 10):\n        digits[pos] = str(d)\n        # Check if current prefix is valid\n        prefix = int(''.join(digits[:pos+1]))\n        if prefix % (pos + 1) == 0:\n            result = build_polydivisible(digits, pos + 1)\n            if result is not None:\n                return result\n    \n    return None\n\ndef simple_next_polydivisible(n):\n    \"\"\"Simplified version - optimized brute force for smaller ranges\"\"\"\n    candidate = n + 1\n    \n    # Quick optimization: skip obvious non-candidates\n    while candidate < 10**12:\n        # Quick checks for common cases\n        if candidate < 10:\n            if is_polydivisible(candidate):\n                return candidate\n        else:\n            # More systematic search for larger numbers\n            if is_polydivisible(candidate):\n                return candidate\n        candidate += 1\n        \n        # Optimization: jump to next number with better chances\n        if candidate > 10 and candidate % 10 == 9:\n            # If last digit is 9, check if incrementing gives better chance\n            pass\n            \n    return None\n\n# Even simpler and more reliable approach\ndef find_next_polydivisible(n):\n    candidate = n + 1\n    # Set a reasonable limit based on known polydivisible numbers\n    limit = min(n + 5000000, 10**12)  # Balance between thoroughness and speed\n    \n    while candidate <= limit:\n        if is_polydivisible(candidate):\n            return candidate\n        candidate += 1\n    \n    # If not found in local search, try building systematically\n    return build_next_polydivisible(len(str(n + 1)))\n\ndef build_next_polydivisible(min_digits):\n    \"\"\"Build polydivisible numbers systematically\"\"\"\n    # Known polydivisible numbers exist up to 25 digits, but they're rare\n    # We'll search methodically\n    \n    def dfs(current_str, target_len):\n        if len(current_str) == target_len:\n            return int(current_str)\n        \n        for digit in range(0, 10):\n            new_str = current_str + str(digit)\n            if int(new_str) % len(new_str) == 0:\n                result = dfs(new_str, target_len)\n                if result is not None:\n                    return result\n        return None\n    \n    # Try increasing lengths\n    for length in range(min_digits, min_digits + 5):\n        for first_digit in range(1, 10):\n            result = dfs(str(first_digit), length)\n            if result is not None:\n                return result\n    \n    return None\n\n# Read input and produce output\nn = int(input())\n\n# Use the simple approach first since it works for most test cases\ncandidate = n + 1\nwhile candidate < n + 1000000 and candidate < 10**12:  # Reasonable bounds\n    if is_polydivisible(candidate):\n        print(candidate)\n        exit()\n    candidate += 1\n\n# If not found in quick search, use systematic building\nresult = build_next_polydivisible(len(str(n + 1)))\nif result is not None:\n    print(result)\nelse:\n    print(\"\")\n\n\n"], "prompt_tokens": [6263], "completion_tokens": [4271], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4268}
{"name": "2704", "description": "# Task\n Given a `sequence` of integers, check whether it is possible to obtain a strictly increasing sequence by erasing no more than one element from it.\n\n# Example\n\n For `sequence = [1, 3, 2, 1]`, the output should be `false`;\n \n For `sequence = [1, 3, 2]`, the output should be `true`.\n\n# Input/Output\n\n\n - `[input]` integer array `sequence`\n\n    Constraints: `2 \u2264 sequence.length \u2264 1000, -10000 \u2264 sequence[i] \u2264 10000.`\n\n\n - `[output]` a boolean value\n\n    `true` if it is possible, `false` otherwise.", "difficulty": "introductory", "id": 2704, "sample_io": [{"input": "[1, 3, 2, 1]", "output": [false]}, {"input": "[1, 3, 2]", "output": [true]}], "test_list": [{"input": "[1, 3, 2, 1]", "output": [false]}, {"input": "[1, 3, 2]", "output": [true]}, {"input": "[1, 2, 3]", "output": [true]}, {"input": "[1, 2, 3, 1]", "output": [true]}, {"input": "[1, 4, 10, 4, 2]", "output": [false]}, {"input": "[10, 1, 2, 3, 4, 5]", "output": [true]}, {"input": "[1, 1, 1, 2, 3]", "output": [false]}, {"input": "[0, -2, 5, 6]", "output": [true]}, {"input": "[1, 1]", "output": [true]}, {"input": "[4, 5, 6, 1, 2, 3]", "output": [false]}, {"input": "[149, 15, 23, 32, 41, 48, 58, 66, 69, 75, 81, 91, 178, 100, 109, 118, 128, 134, 143]", "output": [false]}], "starter_code": "\ndef almost_increasing_sequence(sequence):\n\t", "source_codes": ["def almostIncreasingSequence(sequence):\n    def is_strictly_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] <= arr[i-1]:\n                return False\n        return True\n    \n    if is_strictly_increasing(sequence):\n        return True\n    \n    for i in range(len(sequence)):\n        # Create a new list without the element at index i\n        temp = sequence[:i] + sequence[i+1:]\n        if is_strictly_increasing(temp):\n            return True\n    \n    return False\n\n# Read input and process\nimport sys\ninput_str = input().strip()\n# Remove brackets and split by comma\nsequence = list(map(int, input_str.strip('[]').split(',')))\nresult = almostIncreasingSequence(sequence)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")"], "responses": ["\ndef almostIncreasingSequence(sequence):\n    def is_strictly_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] <= arr[i-1]:\n                return False\n        return True\n    \n    if is_strictly_increasing(sequence):\n        return True\n    \n    for i in range(len(sequence)):\n        # Create a new list without the element at index i\n        temp = sequence[:i] + sequence[i+1:]\n        if is_strictly_increasing(temp):\n            return True\n    \n    return False\n\n# Read input and process\nimport sys\ninput_str = input().strip()\n# Remove brackets and split by comma\nsequence = list(map(int, input_str.strip('[]').split(',')))\nresult = almostIncreasingSequence(sequence)\nif result:\n    print(\"True\")\nelse:\n    print(\"False\")\n\n\n"], "prompt_tokens": [5060], "completion_tokens": [2459], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2704}
{"name": "3978", "description": "This function should test if the `factor` is a factor of `base`.\n\nReturn `true` if it is a factor or `false` if it is not.\n\n## About factors\nFactors are numbers you can multiply together to get another number.\n\n2 and 3 are factors of 6 because: `2 * 3 = 6`\n\n- You can find a factor by dividing numbers. If the remainder is 0 then the number is a factor.\n- You can use the mod operator (`%`) in most languages to check for a remainder\n\nFor example 2 is not a factor of 7 because: `7 % 2 = 1`\n\nNote: `base` is a non-negative number, `factor` is a positive number.", "difficulty": "introductory", "id": 3978, "sample_io": [{"input": "7\n2", "output": [false]}, {"input": "6\n2", "output": [true]}, {"input": "6\n3", "output": [true]}], "test_list": [{"input": "10\n2", "output": [true]}, {"input": "63\n7", "output": [true]}, {"input": "2450\n5", "output": [true]}, {"input": "24612\n3", "output": [true]}, {"input": "9\n2", "output": [false]}, {"input": "653\n7", "output": [false]}, {"input": "2453\n5", "output": [false]}, {"input": "24617\n3", "output": [false]}], "starter_code": "\ndef check_for_factor(base, factor):\n\t", "source_codes": ["def is_factor(base, factor):\n    return base % factor == 0\n\nbase = int(input())\nfactor = int(input())\nresult = is_factor(base, factor)\nprint(result)"], "responses": ["\ndef is_factor(base, factor):\n    return base % factor == 0\n\nbase = int(input())\nfactor = int(input())\nresult = is_factor(base, factor)\nprint(result)\n\n\n"], "prompt_tokens": [6887], "completion_tokens": [1247], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3978}
{"name": "4262", "description": "Dee is lazy but she's kind and she likes to eat out at all the nice restaurants and gastropubs in town. To make paying quick and easy she uses a simple mental algorithm she's called The Fair %20 Rule. She's gotten so good she can do this in a few seconds and it always impresses her dates but she's perplexingly still single. Like you probably. \n\nThis is how she does it:\n\n - She rounds the price `P` at the tens place e.g:\n   - 25 becomes 30\n   - 24 becomes 20\n   - 5 becomes 10\n   - 4 becomes 0\n - She figures out the base tip `T` by dropping the singles place digit e.g:\n   - when `P = 24` she rounds to 20 drops 0 `T = 2`\n   - `P = 115` rounds to 120 drops 0 `T = 12`\n   - `P = 25` rounds to 30 drops 0 `T = 3`\n   - `P = 5` rounds to 10 drops 0 `T = 1`\n   - `P = 4` rounds to 0 `T = 0`\n - She then applies a 3 point satisfaction rating `R` to `T` i.e:\n   - When she's satisfied: `R = 1` and she'll add 1 to `T`\n   - Unsatisfied: `R = 0` and she'll subtract 1 from `T`\n   - Appalled: `R = -1` she'll divide `T` by 2, **rounds down** and subtracts 1\n \n## Your Task\n\nImplement a method `calc_tip` that takes two integer arguments for price `p` \n\nwhere `1 <= p <= 1000` and a rating `r` which is one of `-1, 0, 1`.\n\nThe return value `T` should be a non negative integer.\n\n*Note: each step should be done in the order listed.*\n\nDee always politely smiles and says \"Thank you\" on her way out. Dee is nice. Be like Dee.", "difficulty": "introductory", "id": 4262, "sample_io": [], "test_list": [{"input": "4\n1", "output": [1]}, {"input": "4\n0", "output": [0]}, {"input": "4\n-1", "output": [0]}, {"input": "5\n1", "output": [2]}, {"input": "5\n0", "output": [0]}, {"input": "5\n-1", "output": [0]}, {"input": "14\n1", "output": [2]}, {"input": "14\n0", "output": [0]}, {"input": "14\n-1", "output": [0]}, {"input": "15\n1", "output": [3]}, {"input": "15\n0", "output": [1]}, {"input": "15\n-1", "output": [0]}, {"input": "24\n1", "output": [3]}, {"input": "24\n0", "output": [1]}, {"input": "24\n-1", "output": [0]}, {"input": "25\n1", "output": [4]}, {"input": "25\n0", "output": [2]}, {"input": "25\n-1", "output": [0]}, {"input": "125\n1", "output": [14]}, {"input": "125\n0", "output": [12]}, {"input": "125\n-1", "output": [5]}, {"input": "144\n1", "output": [15]}, {"input": "144\n0", "output": [13]}, {"input": "144\n-1", "output": [6]}], "starter_code": "\ndef calc_tip(p, r):\n\t", "source_codes": ["def calc_tip(p, r):\n    # Step 1: Round to the nearest tens place\n    rounded_p = (p + 5) // 10 * 10\n    \n    # Step 2: Drop the singles digit to get base tip T\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    else:  # r == -1\n        T = T // 2 - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input and process\np, r = map(int, input().split())\nprint(calc_tip(p, r))"], "responses": ["\ndef calc_tip(p, r):\n    # Step 1: Round to the nearest tens place\n    rounded_p = (p + 5) // 10 * 10\n    \n    # Step 2: Drop the singles digit to get base tip T\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating\n    if r == 1:\n        T += 1\n    elif r == 0:\n        T -= 1\n    else:  # r == -1\n        T = T // 2 - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input and process\np, r = map(int, input().split())\nprint(calc_tip(p, r))\n\n\n"], "prompt_tokens": [11180], "completion_tokens": [6031], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 4262}
{"name": "2798", "description": "# altERnaTIng cAsE <=> ALTerNAtiNG CaSe\n\nDefine `String.prototype.toAlternatingCase` (or a similar function/method *such as* `to_alternating_case`/`toAlternatingCase`/`ToAlternatingCase` in your selected language; **see the initial solution for details**) such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase. For example:\n``` haskell\ntoAlternatingCase \"hello world\" `shouldBe` \"HELLO WORLD\"\ntoAlternatingCase \"HELLO WORLD\" `shouldBe` \"hello world\"\ntoAlternatingCase \"hello WORLD\" `shouldBe` \"HELLO world\"\ntoAlternatingCase \"HeLLo WoRLD\" `shouldBe` \"hEllO wOrld\"\ntoAlternatingCase \"12345\"       `shouldBe` \"12345\"\ntoAlternatingCase \"1a2b3c4d5e\"  `shouldBe` \"1A2B3C4D5E\"\n```\n```C++\nstring source = \"HeLLo WoRLD\";\nstring upperCase = to_alternating_case(source);\ncout << upperCase << endl; // outputs: hEllO wOrld\n```\nAs usual, your function/method should be pure, i.e. it should **not** mutate the original string.", "difficulty": "introductory", "id": 2798, "sample_io": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}], "test_list": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}, {"input": "String.prototype.toAlternatingCase", "output": ["sTRING.PROTOTYPE.TOaLTERNATINGcASE"]}], "starter_code": "\ndef to_alternating_case(string):\n\t", "source_codes": ["def toAlternatingCase(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Read input from stdin\ninput_string = input()\n\n# Call the function and print the result in the expected format\nprint([toAlternatingCase(input_string)])"], "responses": ["\ndef toAlternatingCase(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Read input from stdin\ninput_string = input()\n\n# Call the function and print the result in the expected format\nprint([toAlternatingCase(input_string)])\n\n\n"], "prompt_tokens": [8016], "completion_tokens": [2431], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2798}
{"name": "2183", "description": "We start with a string $s$ consisting only of the digits $1$, $2$, or $3$. The length of $s$ is denoted by $|s|$. For each $i$ from $1$ to $|s|$, the $i$-th character of $s$ is denoted by $s_i$. \n\nThere is one cursor. The cursor's location $\\ell$ is denoted by an integer in $\\{0, \\ldots, |s|\\}$, with the following meaning:   If $\\ell = 0$, then the cursor is located before the first character of $s$.  If $\\ell = |s|$, then the cursor is located right after the last character of $s$.  If $0 < \\ell < |s|$, then the cursor is located between $s_\\ell$ and $s_{\\ell+1}$. \n\nWe denote by $s_\\text{left}$ the string to the left of the cursor and $s_\\text{right}$ the string to the right of the cursor. \n\nWe also have a string $c$, which we call our clipboard, which starts out as empty. There are three types of actions:  The Move action. Move the cursor one step to the right. This increments $\\ell$ once.  The Cut action. Set $c \\leftarrow s_\\text{right}$, then set $s \\leftarrow s_\\text{left}$.  The Paste action. Append the value of $c$ to the end of the string $s$. Note that this doesn't modify $c$. \n\nThe cursor initially starts at $\\ell = 0$. Then, we perform the following procedure:  Perform the Move action once.  Perform the Cut action once.  Perform the Paste action $s_\\ell$ times.  If $\\ell = x$, stop. Otherwise, return to step 1. \n\nYou're given the initial string $s$ and the integer $x$. What is the length of $s$ when the procedure stops? Since this value may be very large, only find it modulo $10^9 + 7$. \n\nIt is guaranteed that $\\ell \\le |s|$ at any time.\n\n\n-----Input-----\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 1000$) denoting the number of test cases. The next lines contain descriptions of the test cases.\n\nThe first line of each test case contains a single integer $x$ ($1 \\le x \\le 10^6$). The second line of each test case consists of the initial string $s$ ($1 \\le |s| \\le 500$). It is guaranteed, that $s$ consists of the characters \"1\", \"2\", \"3\".\n\nIt is guaranteed that the sum of $x$ in a single file is at most $10^6$. It is guaranteed that in each test case before the procedure will stop it will be true that $\\ell \\le |s|$ at any time.\n\n\n-----Output-----\n\nFor each test case, output a single line containing a single integer denoting the answer for that test case modulo $10^9 + 7$. \n\n\n-----Example-----\nInput\n4\n5\n231\n7\n2323\n6\n333\n24\n133321333\n\nOutput\n25\n1438\n1101\n686531475\n\n\n\n-----Note-----\n\nLet's illustrate what happens with the first test case. Initially, we have $s = $ 231. Initially, $\\ell = 0$ and $c = \\varepsilon$ (the empty string). The following things happen if we follow the procedure above:\n\n  Step 1, Move once: we get $\\ell = 1$.  Step 2, Cut once: we get $s = $ 2 and $c = $ 31.  Step 3, Paste $s_\\ell = $ 2 times: we get $s = $ 23131.  Step 4: $\\ell = 1 \\not= x = 5$, so we return to step 1. \n\n  Step 1, Move once: we get $\\ell = 2$.  Step 2, Cut once: we get $s = $ 23 and $c = $ 131.  Step 3, Paste $s_\\ell = $ 3 times: we get $s = $ 23131131131.  Step 4: $\\ell = 2 \\not= x = 5$, so we return to step 1. \n\n  Step 1, Move once: we get $\\ell = 3$.  Step 2, Cut once: we get $s = $ 231 and $c = $ 31131131.  Step 3, Paste $s_\\ell = $ 1 time: we get $s = $ 23131131131.  Step 4: $\\ell = 3 \\not= x = 5$, so we return to step 1. \n\n  Step 1, Move once: we get $\\ell = 4$.  Step 2, Cut once: we get $s = $ 2313 and $c = $ 1131131.  Step 3, Paste $s_\\ell = $ 3 times: we get $s = $ 2313113113111311311131131.  Step 4: $\\ell = 4 \\not= x = 5$, so we return to step 1. \n\n  Step 1, Move once: we get $\\ell = 5$.  Step 2, Cut once: we get $s = $ 23131 and $c = $ 13113111311311131131.  Step 3, Paste $s_\\ell = $ 1 times: we get $s = $ 2313113113111311311131131.  Step 4: $\\ell = 5 = x$, so we stop. \n\nAt the end of the procedure, $s$ has length $25$.", "difficulty": "competition", "id": 2183, "sample_io": [{"input": "4\n5\n231\n7\n2323\n6\n333\n24\n133321333\n", "output": ["25\n1438\n1101\n686531475\n"]}], "test_list": [{"input": "4\n5\n231\n7\n2323\n6\n333\n24\n133321333\n", "output": ["25\n1438\n1101\n686531475\n"]}, {"input": "9\n1500\n1212\n1500\n1221\n1500\n122\n1500\n12121\n1500\n22\n1500\n1111112111111112\n1500\n1111111111221111111\n1500\n111111122\n1500\n11111121111121111111\n", "output": ["1504\n1599\n1502\n1598\n1502\n1510\n1657\n1502\n1763\n"]}, {"input": "1\n1000000\n22\n", "output": ["1000002\n"]}, {"input": "1\n1000000\n221\n", "output": ["1001822\n"]}, {"input": "1\n1000000\n1221\n", "output": ["1001823\n"]}, {"input": "1\n1000000\n2121\n", "output": ["1001821\n"]}, {"input": "1\n1000000\n2211\n", "output": ["1002004\n"]}, {"input": "1\n1000000\n1212\n", "output": ["1000004\n"]}, {"input": "1\n1000000\n2112\n", "output": ["1000006\n"]}], "starter_code": "", "source_codes": ["def solve(x, s):\n    MOD = 10**9 + 7\n    \n    # Convert to list for easier access\n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Get the digit at current position\n        if l <= len(chars):\n            digit = int(chars[l-1])\n        else:\n            # This shouldn't happen according to constraints\n            digit = 1\n        \n        # Calculate lengths\n        left_len = l\n        right_len = length - l\n        \n        # New length after cut and paste\n        # Cut: keep left_len characters\n        # Paste: add right_len * digit characters\n        new_length = left_len + right_len * digit\n        \n        # We need to update our character array to access future digits\n        # But we don't need to store the entire string, just enough characters\n        if right_len > 0:\n            # Reconstruct what we need\n            # Left part stays the same for now\n            # But we might need to extend chars array if new_length is larger\n            pass\n            \n        length = new_length % MOD\n        \n        # Update chars array - keep only what we might need\n        # We need at least x characters to avoid index errors\n        needed_chars = max(x + 10, 1000)  # Buffer for safety\n        \n        if new_length <= needed_chars:\n            # We can afford to build the actual string\n            left_part = chars[:l] if l <= len(chars) else (chars + ['1'] * (l - len(chars)))[:l]\n            \n            if l <= len(chars):\n                right_part = chars[l:]\n            else:\n                right_part = []\n            \n            # Build new string\n            new_chars = left_part[:]\n            for _ in range(digit):\n                new_chars.extend(right_part)\n            \n            chars = new_chars\n        else:\n            # String is getting too big, but we still need to track characters at early positions\n            # For now, let's just keep track of what we need for accessing s_l\n            if l >= len(chars):\n                # Extend with dummy values - but this is problematic\n                # According to problem statement, we're guaranteed l <= |s| always\n                pass\n    \n    return length\n\ndef solve(x, s):\n    MOD = 10**9 + 7\n    \n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Access the digit - we're guaranteed l <= length\n        digit = int(chars[l-1])\n        \n        # Calculate new length\n        left_len = l\n        right_len = length - l\n        new_length = (left_len + (right_len * digit)) % MOD\n        \n        # For very large strings, we can't store all characters\n        # But we only need to access positions up to x\n        # So we'll maintain a prefix of the string sufficient for our needs\n        \n        max_needed = min(x + 100, 100000)  # Keep enough chars to access what we need\n        \n        if length <= max_needed:\n            # We can afford to actually build the string\n            left_part = chars[:l]\n            right_part = chars[l:]\n            \n            new_chars = left_part[:]\n            for _ in range(digit):\n                new_chars.extend(right_part)\n                \n            chars = new_chars\n            length = len(chars)\n        else:\n            # String is too long to store completely\n            # But we've already calculated the new length\n            length = new_length\n            \n            # We still need to maintain chars for accessing future digits\n            # Keep a reasonable prefix\n            if l < len(chars):\n                # We can still access the required digit\n                pass\n            # No need to actually extend chars since we won't access those positions anyway\n    \n    return length % MOD\n\n# Let me try a cleaner implementation\ndef solve(x, s):\n    MOD = 10**9 + 7\n    \n    # We'll track both actual characters (when manageable) and length\n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Get the digit at position l (1-indexed)\n        digit = 0\n        if l <= len(chars):\n            digit = int(chars[l-1])\n        else:\n            # This shouldn't happen due to problem constraints\n            # But let's handle it gracefully\n            digit = 1\n            \n        # Calculate new length: left part + (right part repeated digit times)\n        left_len = l\n        right_len = length - l\n        new_length = left_len + (right_len * digit)\n        \n        # Update our data structures\n        length = new_length\n        \n        # Maintain character array for accessing future digits\n        # Only keep what we might reasonably need\n        max_chars_to_keep = min(200000, new_length)\n        \n        if new_length <= max_chars_to_keep and l <= 10000:\n            # Rebuild character array since we can afford it and will likely need to access more digits\n            if l <= len(chars):\n                left_part = chars[:l]\n                right_part = chars[l:]\n            else:\n                # Extend with dummy chars - this shouldn't be needed\n                while len(chars) < l:\n                    chars.append('1')\n                left_part = chars[:l]\n                right_part = []\n            \n            # Build new string\n            new_chars = left_part[:]\n            added = 0\n            for _ in range(digit):\n                if len(new_chars) + len(right_part) <= max_chars_to_keep:\n                    new_chars.extend(right_part)\n                    added += len(right_part)\n                else:\n                    remaining_space = max_chars_to_keep - len(new_chars)\n                    if remaining_space > 0:\n                        new_chars.extend(right_part[:remaining_space])\n                        added += min(len(right_part), remaining_space)\n                    break\n            \n            chars = new_chars\n        \n        # Apply modulo to prevent overflow\n        length = length % MOD\n    \n    return length\n\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    s = input().strip()\n    print(solve(x, s))"], "responses": ["\ndef solve(x, s):\n    MOD = 10**9 + 7\n    \n    # Convert to list for easier access\n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Get the digit at current position\n        if l <= len(chars):\n            digit = int(chars[l-1])\n        else:\n            # This shouldn't happen according to constraints\n            digit = 1\n        \n        # Calculate lengths\n        left_len = l\n        right_len = length - l\n        \n        # New length after cut and paste\n        # Cut: keep left_len characters\n        # Paste: add right_len * digit characters\n        new_length = left_len + right_len * digit\n        \n        # We need to update our character array to access future digits\n        # But we don't need to store the entire string, just enough characters\n        if right_len > 0:\n            # Reconstruct what we need\n            # Left part stays the same for now\n            # But we might need to extend chars array if new_length is larger\n            pass\n            \n        length = new_length % MOD\n        \n        # Update chars array - keep only what we might need\n        # We need at least x characters to avoid index errors\n        needed_chars = max(x + 10, 1000)  # Buffer for safety\n        \n        if new_length <= needed_chars:\n            # We can afford to build the actual string\n            left_part = chars[:l] if l <= len(chars) else (chars + ['1'] * (l - len(chars)))[:l]\n            \n            if l <= len(chars):\n                right_part = chars[l:]\n            else:\n                right_part = []\n            \n            # Build new string\n            new_chars = left_part[:]\n            for _ in range(digit):\n                new_chars.extend(right_part)\n            \n            chars = new_chars\n        else:\n            # String is getting too big, but we still need to track characters at early positions\n            # For now, let's just keep track of what we need for accessing s_l\n            if l >= len(chars):\n                # Extend with dummy values - but this is problematic\n                # According to problem statement, we're guaranteed l <= |s| always\n                pass\n    \n    return length\n\ndef solve(x, s):\n    MOD = 10**9 + 7\n    \n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Access the digit - we're guaranteed l <= length\n        digit = int(chars[l-1])\n        \n        # Calculate new length\n        left_len = l\n        right_len = length - l\n        new_length = (left_len + (right_len * digit)) % MOD\n        \n        # For very large strings, we can't store all characters\n        # But we only need to access positions up to x\n        # So we'll maintain a prefix of the string sufficient for our needs\n        \n        max_needed = min(x + 100, 100000)  # Keep enough chars to access what we need\n        \n        if length <= max_needed:\n            # We can afford to actually build the string\n            left_part = chars[:l]\n            right_part = chars[l:]\n            \n            new_chars = left_part[:]\n            for _ in range(digit):\n                new_chars.extend(right_part)\n                \n            chars = new_chars\n            length = len(chars)\n        else:\n            # String is too long to store completely\n            # But we've already calculated the new length\n            length = new_length\n            \n            # We still need to maintain chars for accessing future digits\n            # Keep a reasonable prefix\n            if l < len(chars):\n                # We can still access the required digit\n                pass\n            # No need to actually extend chars since we won't access those positions anyway\n    \n    return length % MOD\n\n# Let me try a cleaner implementation\ndef solve(x, s):\n    MOD = 10**9 + 7\n    \n    # We'll track both actual characters (when manageable) and length\n    chars = list(s)\n    length = len(s)\n    l = 0\n    \n    while l != x:\n        l += 1\n        \n        # Get the digit at position l (1-indexed)\n        digit = 0\n        if l <= len(chars):\n            digit = int(chars[l-1])\n        else:\n            # This shouldn't happen due to problem constraints\n            # But let's handle it gracefully\n            digit = 1\n            \n        # Calculate new length: left part + (right part repeated digit times)\n        left_len = l\n        right_len = length - l\n        new_length = left_len + (right_len * digit)\n        \n        # Update our data structures\n        length = new_length\n        \n        # Maintain character array for accessing future digits\n        # Only keep what we might reasonably need\n        max_chars_to_keep = min(200000, new_length)\n        \n        if new_length <= max_chars_to_keep and l <= 10000:\n            # Rebuild character array since we can afford it and will likely need to access more digits\n            if l <= len(chars):\n                left_part = chars[:l]\n                right_part = chars[l:]\n            else:\n                # Extend with dummy chars - this shouldn't be needed\n                while len(chars) < l:\n                    chars.append('1')\n                left_part = chars[:l]\n                right_part = []\n            \n            # Build new string\n            new_chars = left_part[:]\n            added = 0\n            for _ in range(digit):\n                if len(new_chars) + len(right_part) <= max_chars_to_keep:\n                    new_chars.extend(right_part)\n                    added += len(right_part)\n                else:\n                    remaining_space = max_chars_to_keep - len(new_chars)\n                    if remaining_space > 0:\n                        new_chars.extend(right_part[:remaining_space])\n                        added += min(len(right_part), remaining_space)\n                    break\n            \n            chars = new_chars\n        \n        # Apply modulo to prevent overflow\n        length = length % MOD\n    \n    return length\n\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    s = input().strip()\n    print(solve(x, s))\n\n\n"], "prompt_tokens": [22196], "completion_tokens": [6778], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2183}
{"name": "1607", "description": "\"QAQ\" is a word to denote an expression of crying. Imagine \"Q\" as eyes with tears and \"A\" as a mouth.\n\nNow Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of \"QAQ\" in the string (Diamond is so cute!). $8$ illustration by \u732b\u5c4b https://twitter.com/nekoyaliu \n\nBort wants to know how many subsequences \"QAQ\" are in the string Diamond has given. Note that the letters \"QAQ\" don't have to be consecutive, but the order of letters should be exact.\n\n\n-----Input-----\n\nThe only line contains a string of length n (1 \u2264 n \u2264 100). It's guaranteed that the string only contains uppercase English letters.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the number of subsequences \"QAQ\" in the string.\n\n\n-----Examples-----\nInput\nQAQAQYSYIOIWIN\n\nOutput\n4\n\nInput\nQAQQQZZYNOIWIN\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example there are 4 subsequences \"QAQ\": \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\".", "difficulty": "interview", "id": 1607, "sample_io": [{"input": "QAQAQYSYIOIWIN\n", "output": ["4\n"]}, {"input": "QAQQQZZYNOIWIN\n", "output": ["3\n"]}], "test_list": [{"input": "QAQAQYSYIOIWIN\n", "output": ["4\n"]}, {"input": "QAQQQZZYNOIWIN\n", "output": ["3\n"]}, {"input": "QA\n", "output": ["0\n"]}, {"input": "IAQVAQZLQBQVQFTQQQADAQJA\n", "output": ["24\n"]}, {"input": "QQAAQASGAYAAAAKAKAQIQEAQAIAAIAQQQQQ\n", "output": ["378\n"]}, {"input": "AMVFNFJIAVNQJWIVONQOAOOQSNQSONOASONAONQINAONAOIQONANOIQOANOQINAONOQINAONOXJCOIAQOAOQAQAQAQAQWWWAQQAQ\n", "output": ["1077\n"]}, {"input": "AAQQAXBQQBQQXBNQRJAQKQNAQNQVDQASAGGANQQQQTJFFQQQTQQA\n", "output": ["568\n"]}, {"input": "KAZXAVLPJQBQVQQQQQAPAQQGQTQVZQAAAOYA\n", "output": ["70\n"]}, {"input": "W\n", "output": ["0\n"]}, {"input": "DBA\n", "output": ["0\n"]}, {"input": "RQAWNACASAAKAGAAAAQ\n", "output": ["10\n"]}, {"input": "QJAWZAAOAAGIAAAAAOQATASQAEAAAAQFQQHPA\n", "output": ["111\n"]}, {"input": "QQKWQAQAAAAAAAAGAAVAQUEQQUMQMAQQQNQLAMAAAUAEAAEMAAA\n", "output": ["411\n"]}, {"input": "QQUMQAYAUAAGWAAAQSDAVAAQAAAASKQJJQQQQMAWAYYAAAAAAEAJAXWQQ\n", "output": ["625\n"]}, {"input": "QORZOYAQ\n", "output": ["1\n"]}, {"input": "QCQAQAGAWAQQQAQAVQAQQQQAQAQQQAQAAATQAAVAAAQQQQAAAUUQAQQNQQWQQWAQAAQQKQYAQAAQQQAAQRAQQQWBQQQQAPBAQGQA\n", "output": ["13174\n"]}, {"input": "QQAQQAKQFAQLQAAWAMQAZQAJQAAQQOACQQAAAYANAQAQQAQAAQQAOBQQJQAQAQAQQQAAAAABQQQAVNZAQQQQAMQQAFAAEAQAQHQT\n", "output": ["10420\n"]}, {"input": "AQEGQHQQKQAQQPQKAQQQAAAAQQQAQEQAAQAAQAQFSLAAQQAQOQQAVQAAAPQQAWAQAQAFQAXAQQQQTRLOQAQQJQNQXQQQQSQVDQQQ\n", "output": ["12488\n"]}, {"input": "QNQKQQQLASQBAVQQQQAAQQOQRJQQAQQQEQZUOANAADAAQQJAQAQARAAAQQQEQBHTQAAQAAAAQQMKQQQIAOJJQQAQAAADADQUQQQA\n", "output": ["9114\n"]}, {"input": "QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\n", "output": ["35937\n"]}, {"input": "AMQQAAQAAQAAAAAAQQQBOAAANAAKQJCYQAE\n", "output": ["254\n"]}, {"input": "AYQBAEQGAQEOAKGIXLQJAIAKQAAAQPUAJAKAATFWQQAOQQQUFQYAQQMQHOKAAJXGFCARAQSATHAUQQAATQJJQDQRAANQQAE\n", "output": ["2174\n"]}, {"input": "AAQXAAQAYQAAAAGAQHVQYAGIVACADFAAQAAAAQZAAQMAKZAADQAQDAAQDAAAMQQOXYAQQQAKQBAAQQKAXQBJZDDLAAHQQ\n", "output": ["2962\n"]}, {"input": "AYQQYAVAMNIAUAAKBBQVACWKTQSAQZAAQAAASZJAWBCAALAARHACQAKQQAQAARPAQAAQAQAAZQUSHQAMFVFZQQQQSAQQXAA\n", "output": ["2482\n"]}, {"input": "LQMAQQARQAQBJQQQAGAAZQQXALQQAARQAQQQQAAQQAQQQAQQCAQQAQQAYQQQRAAZATQALYQQAAHHAAQHAAAAAAAAQQMAAQNAKQ\n", "output": ["7768\n"]}, {"input": "MAQQWAQOYQMAAAQAQPQZAOAAQAUAQNAAQAAAITQSAQAKAQKAQQWSQAAQQAGUCDQMQWKQUXKWQQAAQQAAQQZQDQQQAABXQUUXQOA\n", "output": ["5422\n"]}, {"input": "QTAAQDAQXAQQJQQQGAAAQQQQSBQZKAQQAQQQQEAQNUQBZCQLYQZQEQQAAQHQVAORKQVAQYQNASZQAARZAAGAAAAOQDCQ\n", "output": ["3024\n"]}, {"input": "QQWAQQGQQUZQQQLZAAQYQXQVAQFQUAQZUQZZQUKBHSHTQYLQAOQXAQQGAQQTQOAQARQADAJRAAQPQAQQUQAUAMAUVQAAAQQAWQ\n", "output": ["4527\n"]}, {"input": "QQAAQQAQVAQZQQQQAOEAQZPQIBQZACQQAFQQLAAQDATZQANHKYQQAQTAAFQRQAIQAJPWQAQTEIRXAEQQAYWAAAUKQQAQAQQQSQQH\n", "output": ["6416\n"]}, {"input": "AQQQQAQAAQQAQAQAAAAAAAAAQAQAAAAAQAQAQQQAQQQAAAQQQAAAAAAAQAAAAQQQQQQQAQQQQAQAAAQAAAAAQAQAAAAAQAQAAAA\n", "output": ["14270\n"]}, {"input": "AQQQQAQAAQQAQAQAAAAAAAAAQAQAAAAAQAQAQQQAQQQAAAQQQAAAAAAAQAAAAQQQQQQQAQQQQAQAAAQAAAAAQAQAAAAAQ\n", "output": ["13136\n"]}, {"input": "AQQQQAQAAQQAQAQAAAAAAAAAQAQAAAAAQAQAQQQAQQQAAAQQQAAAAAAAQAAAAQQQQQQQAQQQQAQAAAQAAAAAQAQAAAAAQAQAA\n", "output": ["14270\n"]}, {"input": "AQQQQAQAAQQAQAQAAAAAAAAAQAQAAAAAQAQAQQQAQQQAAAQQQAAAAAAAQAAAAQQQQQQQAQQQQAQAAAQAAAAAQAQAAAAAQQAA\n", "output": ["14231\n"]}, {"input": "QQQQQAQAAQQAQAQAAAAAAAAAQAQAAAAAQAQAQQQAQQQAAAQQQAAAAAAAQAAAAQQQQQQQAQQQQAQAAAQAAAAAQAQAAAAAQAQAA\n", "output": ["15296\n"]}, {"input": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\n", "output": ["0\n"]}, {"input": "QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n", "output": ["0\n"]}, {"input": "QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ\n", "output": ["0\n"]}, {"input": "QAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQA\n", "output": ["20825\n"]}, {"input": "AQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQ\n", "output": ["20825\n"]}, {"input": "Q\n", "output": ["0\n"]}, {"input": "A\n", "output": ["0\n"]}, {"input": "FFF\n", "output": ["0\n"]}, {"input": "AAAAAA\n", "output": ["0\n"]}], "starter_code": "", "source_codes": ["s = input().strip()\nn = len(s)\n\n# Precompute the number of Qs after each position\nq_after = [0] * n\n\n# Fill q_after array from right to left\nfor i in range(n - 2, -1, -1):  # Start from second last element\n    q_after[i] = q_after[i + 1] + (1 if s[i + 1] == 'Q' else 0)\n\n# Count Qs before each position and calculate result\nq_before = 0\ncount = 0\nfor i in range(n):\n    if s[i] == 'A':\n        count += q_before * q_after[i]\n    elif s[i] == 'Q':\n        q_before += 1\n\nprint(count)"], "responses": ["\ns = input().strip()\nn = len(s)\n\n# Precompute the number of Qs after each position\nq_after = [0] * n\n\n# Fill q_after array from right to left\nfor i in range(n - 2, -1, -1):  # Start from second last element\n    q_after[i] = q_after[i + 1] + (1 if s[i + 1] == 'Q' else 0)\n\n# Count Qs before each position and calculate result\nq_before = 0\ncount = 0\nfor i in range(n):\n    if s[i] == 'A':\n        count += q_before * q_after[i]\n    elif s[i] == 'Q':\n        q_before += 1\n\nprint(count)\n\n\n"], "prompt_tokens": [8782], "completion_tokens": [4950], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1607}
{"name": "2190", "description": "There are n psychos standing in a line. Each psycho is assigned a unique integer from 1 to n. At each step every psycho who has an id greater than the psycho to his right (if exists) kills his right neighbor in the line. Note that a psycho might kill and get killed at the same step. \n\nYou're given the initial arrangement of the psychos in the line. Calculate how many steps are needed to the moment of time such, that nobody kills his neighbor after that moment. Look notes to understand the statement more precise.\n\n\n-----Input-----\n\nThe first line of input contains integer n denoting the number of psychos, (1 \u2264 n \u2264 10^5). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive \u2014 ids of the psychos in the line from left to right.\n\n\n-----Output-----\n\nPrint the number of steps, so that the line remains the same afterward.\n\n\n-----Examples-----\nInput\n10\n10 9 7 8 6 5 3 4 2 1\n\nOutput\n2\n\nInput\n6\n1 2 3 4 5 6\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample line of the psychos transforms as follows: [10 9 7 8 6 5 3 4 2 1]  \u2192  [10 8 4]  \u2192  [10]. So, there are two steps.", "difficulty": "competition", "id": 2190, "sample_io": [{"input": "10\n10 9 7 8 6 5 3 4 2 1\n", "output": ["2\n"]}, {"input": "6\n1 2 3 4 5 6\n", "output": ["0\n"]}], "test_list": [{"input": "10\n10 9 7 8 6 5 3 4 2 1\n", "output": ["2\n"]}, {"input": "6\n1 2 3 4 5 6\n", "output": ["0\n"]}, {"input": "6\n6 5 4 3 2 1\n", "output": ["1\n"]}, {"input": "10\n10 7 4 2 5 8 9 6 3 1\n", "output": ["4\n"]}, {"input": "15\n15 9 5 10 7 11 14 6 2 3 12 1 8 13 4\n", "output": ["4\n"]}, {"input": "1\n1\n", "output": ["0\n"]}, {"input": "2\n1 2\n", "output": ["0\n"]}, {"input": "2\n2 1\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["def solve():\n    n = int(input())\n    psychos = list(map(int, input().split()))\n    \n    if n <= 1:\n        return 0\n    \n    # steps[i] represents the step at which psycho at position i gets killed\n    # If steps[i] = 0, it means the psycho never gets killed\n    steps = [0] * n\n    stack = []  # Stack will store indices of psychos\n    \n    # Process from right to left\n    for i in range(n-1, -1, -1):\n        current_psycho = psychos[i]\n        \n        # While current psycho can kill the psycho at top of stack\n        while stack and current_psycho > psychos[stack[-1]]:\n            idx = stack.pop()\n            # The step when current psycho kills idx-th psycho is max(current_step + 1, when idx was supposed to die)\n            steps[idx] = max(steps[idx], steps[i] + 1 if i < n-1 else 1)\n        \n        stack.append(i)\n    \n    return max(steps)\n\nprint(solve())"], "responses": ["\ndef solve():\n    n = int(input())\n    psychos = list(map(int, input().split()))\n    \n    if n <= 1:\n        return 0\n    \n    # steps[i] represents the step at which psycho at position i gets killed\n    # If steps[i] = 0, it means the psycho never gets killed\n    steps = [0] * n\n    stack = []  # Stack will store indices of psychos\n    \n    # Process from right to left\n    for i in range(n-1, -1, -1):\n        current_psycho = psychos[i]\n        \n        # While current psycho can kill the psycho at top of stack\n        while stack and current_psycho > psychos[stack[-1]]:\n            idx = stack.pop()\n            # The step when current psycho kills idx-th psycho is max(current_step + 1, when idx was supposed to die)\n            steps[idx] = max(steps[idx], steps[i] + 1 if i < n-1 else 1)\n        \n        stack.append(i)\n    \n    return max(steps)\n\nprint(solve())\n\n\n"], "prompt_tokens": [10378], "completion_tokens": [3864], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2190}
{"name": "2095", "description": "A tree is an undirected connected graph without cycles.\n\nLet's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p_1, p_2, ..., p_{n}, where p_{i} denotes a parent of vertex i (here, for convenience a root is considered its own parent). [Image] For this rooted tree the array p is [2, 3, 3, 2]. \n\nGiven a sequence p_1, p_2, ..., p_{n}, one is able to restore a tree:  There must be exactly one index r that p_{r} = r. A vertex r is a root of the tree.  For all other n - 1 vertices i, there is an edge between vertex i and vertex p_{i}. \n\nA sequence p_1, p_2, ..., p_{n} is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a_1, a_2, ..., a_{n}, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.\n\n\n-----Input-----\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 200 000)\u00a0\u2014 the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 n).\n\n\n-----Output-----\n\nIn the first line print the minimum number of elements to change, in order to get a valid sequence.\n\nIn the second line, print any valid sequence possible to get from (a_1, a_2, ..., a_{n}) in the minimum number of changes. If there are many such sequences, any of them will be accepted.\n\n\n-----Examples-----\nInput\n4\n2 3 3 4\n\nOutput\n1\n2 3 4 4 \n\nInput\n5\n3 2 2 5 3\n\nOutput\n0\n3 2 2 5 3 \n\nInput\n8\n2 3 5 4 1 6 6 7\n\nOutput\n2\n2 3 7 8 1 6 6 7\n\n\n\n-----Note-----\n\nIn the first sample, it's enough to change one element. In the provided output, a sequence represents a tree rooted in a vertex 4 (because p_4 = 4), which you can see on the left drawing below. One of other correct solutions would be a sequence 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both drawings, roots are painted red. [Image] \n\nIn the second sample, the given sequence is already valid.", "difficulty": "competition", "id": 2095, "sample_io": [{"input": "4\n2 3 3 4\n", "output": ["1\n2 3 4 4 \n"]}, {"input": "5\n3 2 2 5 3\n", "output": ["0\n3 2 2 5 3 \n"]}, {"input": "8\n2 3 5 4 1 6 6 7\n", "output": ["2\n2 3 7 8 1 6 6 7\n"]}], "test_list": [{"input": "4\n2 3 3 4\n", "output": ["1\n2 3 4 4 \n"]}, {"input": "5\n3 2 2 5 3\n", "output": ["0\n3 2 2 5 3 \n"]}, {"input": "8\n2 3 5 4 1 6 6 7\n", "output": ["2\n2 3 7 8 1 6 6 7\n"]}, {"input": "2\n1 2\n", "output": ["1\n2 2 \n"]}, {"input": "7\n4 3 2 6 3 5 2\n", "output": ["1\n4 3 3 6 3 5 2 \n"]}, {"input": "6\n6 2 6 2 4 2\n", "output": ["0\n6 2 6 2 4 2 \n"]}, {"input": "7\n1 6 4 4 5 6 7\n", "output": ["4\n7 6 4 7 7 7 7 \n"]}, {"input": "7\n7 5 3 1 2 1 5\n", "output": ["1\n7 5 3 1 3 1 5 \n"]}, {"input": "7\n1 2 3 4 5 6 7\n", "output": ["6\n7 7 7 7 7 7 7 \n"]}, {"input": "18\n2 3 4 5 2 7 8 9 10 7 11 12 14 15 13 17 18 18\n", "output": ["5\n2 18 4 5 2 7 18 9 10 7 18 18 18 15 13 17 18 18 \n"]}, {"input": "8\n2 1 2 2 6 5 6 6\n", "output": ["2\n1 1 2 2 1 5 6 6 \n"]}, {"input": "3\n2 1 1\n", "output": ["1\n1 1 1 \n"]}], "starter_code": "", "source_codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    # Convert to 0-indexed for easier processing\n    a = [x - 1 for x in a]\n    \n    # Find all self-loops (potential roots)\n    self_loops = []\n    for i in range(n):\n        if a[i] == i:\n            self_loops.append(i)\n    \n    changes = 0\n    result = a[:]\n    \n    # Handle root selection\n    if len(self_loops) == 0:\n        # No root found, make node 0 the root\n        result[0] = 0\n        changes += 1\n        root = 0\n    elif len(self_loops) > 1:\n        # Multiple roots, keep one and redirect others\n        root = self_loops[0]\n        for i in range(1, len(self_loops)):\n            node = self_loops[i]\n            result[node] = root\n            changes += 1\n    else:\n        # Exactly one root\n        root = self_loops[0]\n    \n    # Build the tree and find connected components\n    # Create adjacency list for children\n    children = defaultdict(list)\n    for i in range(n):\n        if result[i] != i:  # Not root\n            children[result[i]].append(i)\n    \n    # Find all nodes reachable from root using BFS\n    visited = [False] * n\n    queue = deque([root])\n    visited[root] = True\n    reachable = {root}\n    \n    while queue:\n        node = queue.popleft()\n        for child in children[node]:\n            if not visited[child]:\n                visited[child] = True\n                queue.append(child)\n                reachable.add(child)\n    \n    # Redirect all unreachable nodes to point to root\n    for i in range(n):\n        if not visited[i]:\n            if result[i] != root:\n                result[i] = root\n                changes += 1\n    \n    # Final check: ensure no node points to a non-reachable node\n    # This handles cases where original edges pointed to nodes that became unreachable\n    for i in range(n):\n        if result[i] != i and result[i] not in reachable:\n            result[i] = root\n            if a[i] != root:  # Only count as change if we actually changed it\n                changes += 1\n    \n    print(changes)\n    print(' '.join(str(x + 1) for x in result))\n\nsolve()"], "responses": ["\nimport sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    # Convert to 0-indexed for easier processing\n    a = [x - 1 for x in a]\n    \n    # Find all self-loops (potential roots)\n    self_loops = []\n    for i in range(n):\n        if a[i] == i:\n            self_loops.append(i)\n    \n    changes = 0\n    result = a[:]\n    \n    # Handle root selection\n    if len(self_loops) == 0:\n        # No root found, make node 0 the root\n        result[0] = 0\n        changes += 1\n        root = 0\n    elif len(self_loops) > 1:\n        # Multiple roots, keep one and redirect others\n        root = self_loops[0]\n        for i in range(1, len(self_loops)):\n            node = self_loops[i]\n            result[node] = root\n            changes += 1\n    else:\n        # Exactly one root\n        root = self_loops[0]\n    \n    # Build the tree and find connected components\n    # Create adjacency list for children\n    children = defaultdict(list)\n    for i in range(n):\n        if result[i] != i:  # Not root\n            children[result[i]].append(i)\n    \n    # Find all nodes reachable from root using BFS\n    visited = [False] * n\n    queue = deque([root])\n    visited[root] = True\n    reachable = {root}\n    \n    while queue:\n        node = queue.popleft()\n        for child in children[node]:\n            if not visited[child]:\n                visited[child] = True\n                queue.append(child)\n                reachable.add(child)\n    \n    # Redirect all unreachable nodes to point to root\n    for i in range(n):\n        if not visited[i]:\n            if result[i] != root:\n                result[i] = root\n                changes += 1\n    \n    # Final check: ensure no node points to a non-reachable node\n    # This handles cases where original edges pointed to nodes that became unreachable\n    for i in range(n):\n        if result[i] != i and result[i] not in reachable:\n            result[i] = root\n            if a[i] != root:  # Only count as change if we actually changed it\n                changes += 1\n    \n    print(changes)\n    print(' '.join(str(x + 1) for x in result))\n\nsolve()\n\n\n"], "prompt_tokens": [17777], "completion_tokens": [7971], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2095}
{"name": "2042", "description": "Vasya's telephone contains n photos. Photo number 1 is currently opened on the phone. It is allowed to move left and right to the adjacent photo by swiping finger over the screen. If you swipe left from the first photo, you reach photo n. Similarly, by swiping right from the last photo you reach photo 1. It takes a seconds to swipe from photo to adjacent.\n\nFor each photo it is known which orientation is intended for it \u2014 horizontal or vertical. Phone is in the vertical orientation and can't be rotated. It takes b second to change orientation of the photo.\n\nVasya has T seconds to watch photos. He want to watch as many photos as possible. If Vasya opens the photo for the first time, he spends 1 second to notice all details in it. If photo is in the wrong orientation, he spends b seconds on rotating it before watching it. If Vasya has already opened the photo, he just skips it (so he doesn't spend any time for watching it or for changing its orientation). It is not allowed to skip unseen photos.\n\nHelp Vasya find the maximum number of photos he is able to watch during T seconds.\n\n\n-----Input-----\n\nThe first line of the input contains 4 integers n, a, b, T (1 \u2264 n \u2264 5\u00b710^5, 1 \u2264 a, b \u2264 1000, 1 \u2264 T \u2264 10^9) \u2014 the number of photos, time to move from a photo to adjacent, time to change orientation of a photo and time Vasya can spend for watching photo.\n\nSecond line of the input contains a string of length n containing symbols 'w' and 'h'. \n\nIf the i-th position of a string contains 'w', then the photo i should be seen in the horizontal orientation.\n\nIf the i-th position of a string contains 'h', then the photo i should be seen in vertical orientation.\n\n\n-----Output-----\n\nOutput the only integer, the maximum number of photos Vasya is able to watch during those T seconds.\n\n\n-----Examples-----\nInput\n4 2 3 10\nwwhw\n\nOutput\n2\n\nInput\n5 2 4 13\nhhwhh\n\nOutput\n4\n\nInput\n5 2 4 1000\nhhwhh\n\nOutput\n5\n\nInput\n3 1 100 10\nwhw\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample test you can rotate the first photo (3 seconds), watch the first photo (1 seconds), move left (2 second), rotate fourth photo (3 seconds), watch fourth photo (1 second). The whole process takes exactly 10 seconds.\n\nNote that in the last sample test the time is not enough even to watch the first photo, also you can't skip it.", "difficulty": "competition", "id": 2042, "sample_io": [{"input": "4 2 3 10\nwwhw\n", "output": ["2\n"]}, {"input": "5 2 4 13\nhhwhh\n", "output": ["4\n"]}, {"input": "5 2 4 1000\nhhwhh\n", "output": ["5\n"]}, {"input": "3 1 100 10\nwhw\n", "output": ["0\n"]}], "test_list": [{"input": "4 2 3 10\nwwhw\n", "output": ["2\n"]}, {"input": "5 2 4 13\nhhwhh\n", "output": ["4\n"]}, {"input": "5 2 4 1000\nhhwhh\n", "output": ["5\n"]}, {"input": "3 1 100 10\nwhw\n", "output": ["0\n"]}, {"input": "10 2 3 32\nhhwwhwhwwh\n", "output": ["7\n"]}, {"input": "1 2 3 3\nw\n", "output": ["0\n"]}, {"input": "100 20 100 10202\nwwwwhhwhhwhhwhhhhhwwwhhhwwwhwwhwhhwwhhwwwhwwhwwwhwhwhwwhhhwhwhhwhwwhhwhwhwwwhwwwwhwhwwwwhwhhhwhwhwww\n", "output": ["100\n"]}, {"input": "20 10 10 1\nhwhwhwhwhwhwhwhwhhhw\n", "output": ["1\n"]}, {"input": "12 10 10 1\nwhwhwhwhwhwh\n", "output": ["0\n"]}, {"input": "2 5 5 1000000000\nwh\n", "output": ["2\n"]}, {"input": "16 1 1000 2100\nhhhwwwhhhwhhhwww\n", "output": ["5\n"]}, {"input": "5 2 4 13\nhhhwh\n", "output": ["4\n"]}, {"input": "7 1 1000 13\nhhhhwhh\n", "output": ["6\n"]}, {"input": "10 1 1000 10\nhhhhhhwwhh\n", "output": ["5\n"]}, {"input": "7 1 100 8\nhhhwwwh\n", "output": ["4\n"]}, {"input": "5 2 4 12\nhhhwh\n", "output": ["4\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    a = int(data[1])\n    b = int(data[2])\n    T = int(data[3])\n    s = data[4]\n    \n    # Calculate cost for each photo (time to view for the first time)\n    cost = [0] * n\n    for i in range(n):\n        cost[i] = 1  # time to watch\n        if s[i] == 'w':  # needs rotation\n            cost[i] += b\n    \n    # If even the first photo can't be watched\n    if cost[0] > T:\n        print(0)\n        return\n    \n    # Special case: only one photo\n    if n == 1:\n        print(1)\n        return\n    \n    # Precompute prefix sums for moving right and left from position 0\n    # right_cost[i] = time to go from photo 0 to photo i and watch all photos 0 to i\n    right_cost = [0] * n\n    right_cost[0] = cost[0]\n    for i in range(1, n):\n        right_cost[i] = right_cost[i-1] + a + cost[i]\n    \n    # left_cost[i] = time to go from photo 0 to photo (n-i) and watch photos 0, (n-1), (n-2), ..., (n-i)\n    left_cost = [0] * n\n    left_cost[0] = cost[0]\n    for i in range(1, n):\n        left_cost[i] = left_cost[i-1] + a + cost[(n-i) % n]\n    \n    max_photos = 1  # At least we can see the first photo\n    \n    # Try going only right\n    for r in range(1, n):\n        if right_cost[r] <= T:\n            max_photos = max(max_photos, r + 1)\n        else:\n            break\n    \n    # Try going only left\n    for l in range(1, n):\n        if left_cost[l] <= T:\n            max_photos = max(max_photos, l + 1)\n        else:\n            break\n    \n    # Try going both directions: go left l steps, return to start, then go right r steps\n    for l in range(1, n):\n        if left_cost[l] > T:\n            break\n            \n        # Time to go left l steps and return to position 0\n        time_to_go_left_and_return = left_cost[l] + l * a\n        \n        # Remaining time for going right (subtracting the double-counted photo 0)\n        remaining_time = T - time_to_go_left_and_return + cost[0]\n        \n        if remaining_time < 0:\n            continue\n            \n        # Binary search for maximum r such that right_cost[r] <= remaining_time\n        left_idx, right_idx = 0, n - 1\n        best_r = -1\n        while left_idx <= right_idx:\n            mid = (left_idx + right_idx) // 2\n            if right_cost[mid] <= remaining_time:\n                best_r = mid\n                left_idx = mid + 1\n            else:\n                right_idx = mid - 1\n        \n        if best_r >= 0:\n            # Total photos = l + 1 (left side including start) + best_r (right side excluding start)\n            photos_count = l + 1 + best_r\n            max_photos = max(max_photos, photos_count)\n    \n    print(max_photos)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    a = int(data[1])\n    b = int(data[2])\n    T = int(data[3])\n    s = data[4]\n    \n    # Calculate cost for each photo (time to view for the first time)\n    cost = [0] * n\n    for i in range(n):\n        cost[i] = 1  # time to watch\n        if s[i] == 'w':  # needs rotation\n            cost[i] += b\n    \n    # If even the first photo can't be watched\n    if cost[0] > T:\n        print(0)\n        return\n    \n    # Special case: only one photo\n    if n == 1:\n        print(1)\n        return\n    \n    # Precompute prefix sums for moving right and left from position 0\n    # right_cost[i] = time to go from photo 0 to photo i and watch all photos 0 to i\n    right_cost = [0] * n\n    right_cost[0] = cost[0]\n    for i in range(1, n):\n        right_cost[i] = right_cost[i-1] + a + cost[i]\n    \n    # left_cost[i] = time to go from photo 0 to photo (n-i) and watch photos 0, (n-1), (n-2), ..., (n-i)\n    left_cost = [0] * n\n    left_cost[0] = cost[0]\n    for i in range(1, n):\n        left_cost[i] = left_cost[i-1] + a + cost[(n-i) % n]\n    \n    max_photos = 1  # At least we can see the first photo\n    \n    # Try going only right\n    for r in range(1, n):\n        if right_cost[r] <= T:\n            max_photos = max(max_photos, r + 1)\n        else:\n            break\n    \n    # Try going only left\n    for l in range(1, n):\n        if left_cost[l] <= T:\n            max_photos = max(max_photos, l + 1)\n        else:\n            break\n    \n    # Try going both directions: go left l steps, return to start, then go right r steps\n    for l in range(1, n):\n        if left_cost[l] > T:\n            break\n            \n        # Time to go left l steps and return to position 0\n        time_to_go_left_and_return = left_cost[l] + l * a\n        \n        # Remaining time for going right (subtracting the double-counted photo 0)\n        remaining_time = T - time_to_go_left_and_return + cost[0]\n        \n        if remaining_time < 0:\n            continue\n            \n        # Binary search for maximum r such that right_cost[r] <= remaining_time\n        left_idx, right_idx = 0, n - 1\n        best_r = -1\n        while left_idx <= right_idx:\n            mid = (left_idx + right_idx) // 2\n            if right_cost[mid] <= remaining_time:\n                best_r = mid\n                left_idx = mid + 1\n            else:\n                right_idx = mid - 1\n        \n        if best_r >= 0:\n            # Total photos = l + 1 (left side including start) + best_r (right side excluding start)\n            photos_count = l + 1 + best_r\n            max_photos = max(max_photos, photos_count)\n    \n    print(max_photos)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [16322], "completion_tokens": [8865], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2042}
{"name": "2037", "description": "You work in a big office. It is a 9\u00a0floor building with an elevator that can accommodate up to 4\u00a0people. It is your responsibility to manage this elevator.\n\nToday you are late, so there are queues on some floors already. For each person you know the floor where he currently is and the floor he wants to reach. Also, you know the order in which people came to the elevator.\n\nAccording to the company's rules, if an employee comes to the elevator earlier than another one, he has to enter the elevator earlier too (even if these employees stay on different floors). Note that the employees are allowed to leave the elevator in arbitrary order.\n\nThe elevator has two commands:   Go up or down one floor. The movement takes 1 second.  Open the doors on the current floor. During this operation all the employees who have reached their destination get out of the elevator. Then all the employees on the floor get in the elevator in the order they are queued up while it doesn't contradict the company's rules and there is enough space in the elevator. Each employee spends 1 second to get inside and outside the elevator. \n\nInitially the elevator is empty and is located on the floor 1.\n\nYou are interested what is the minimum possible time you need to spend to deliver all the employees to their destination. It is not necessary to return the elevator to the floor 1.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 2000)\u00a0\u2014 the number of employees.\n\nThe i-th of the next n lines contains two integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 9, a_{i} \u2260 b_{i})\u00a0\u2014 the floor on which an employee initially is, and the floor he wants to reach.\n\nThe employees are given in the order they came to the elevator.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimal possible time in seconds.\n\n\n-----Examples-----\nInput\n2\n3 5\n5 3\n\nOutput\n10\nInput\n2\n5 3\n3 5\n\nOutput\n12\n\n\n-----Note-----\n\n Explaination for the first sample [Image] t = 0\n\n[Image] t = 2\n\n[Image] t = 3\n\n[Image] t = 5\n\n[Image] t = 6\n\n[Image] t = 7\n\n[Image] t = 9\n\n[Image] t = 10", "difficulty": "competition", "id": 2037, "sample_io": [{"input": "2\n3 5\n5 3\n", "output": ["10"]}, {"input": "2\n5 3\n3 5\n", "output": ["12"]}], "test_list": [{"input": "2\n3 5\n5 3\n", "output": ["10"]}, {"input": "2\n5 3\n3 5\n", "output": ["12"]}, {"input": "9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 1\n", "output": ["34"]}, {"input": "50\n9 5\n2 6\n5 4\n7 5\n3 6\n5 8\n1 2\n6 1\n9 7\n8 1\n9 5\n6 8\n6 8\n2 8\n4 9\n6 7\n7 8\n5 8\n1 2\n9 2\n5 9\n6 7\n3 2\n9 8\n7 8\n7 4\n6 5\n1 7\n6 5\n2 6\n3 1\n6 5\n3 7\n9 3\n8 1\n8 3\n8 2\n1 9\n9 2\n3 2\n8 7\n5 1\n6 2\n2 1\n6 1\n3 4\n4 1\n2 3\n2 6\n2 9\n", "output": ["278"]}, {"input": "50\n8 9\n6 7\n6 8\n4 1\n3 2\n9 3\n8 3\n9 7\n4 6\n4 6\n5 6\n7 2\n6 3\n1 3\n8 2\n4 6\n6 8\n7 6\n8 6\n9 4\n8 6\n9 1\n3 8\n3 1\n4 7\n4 9\n9 1\n7 4\n3 5\n1 7\n3 5\n8 9\n5 4\n2 9\n2 9\n3 9\n8 5\n4 9\n9 4\n5 6\n6 1\n4 2\n3 9\n9 1\n9 4\n4 5\n2 4\n2 6\n3 6\n1 9\n", "output": ["252"]}, {"input": "50\n3 9\n8 9\n7 2\n9 1\n5 2\n2 8\n2 4\n8 6\n4 6\n1 6\n5 3\n3 8\n8 2\n6 7\n7 1\n2 4\n2 8\n3 7\n7 1\n7 9\n9 3\n7 2\n2 7\n8 4\n5 8\n6 8\n7 1\n7 5\n5 6\n9 1\n8 6\n3 6\n7 6\n4 3\n3 2\n9 2\n4 9\n2 1\n7 9\n1 8\n4 9\n5 2\n7 2\n9 8\n3 1\n4 5\n3 4\n2 7\n2 1\n6 1\n", "output": ["260"]}, {"input": "50\n7 1\n4 8\n9 3\n9 3\n2 4\n5 9\n1 5\n1 4\n7 6\n4 8\n3 6\n2 8\n5 1\n8 9\n7 4\n7 2\n2 4\n7 9\n8 7\n3 8\n1 7\n4 5\n7 2\n6 4\n6 1\n4 8\n5 6\n4 3\n6 5\n6 4\n6 9\n2 5\n9 3\n3 4\n3 4\n9 3\n7 9\n5 8\n1 6\n5 1\n8 3\n7 4\n1 8\n5 2\n1 7\n6 1\n9 6\n3 1\n6 5\n9 7\n", "output": ["274"]}, {"input": "50\n1 9\n9 4\n4 2\n2 4\n3 8\n9 5\n3 2\n8 3\n8 1\n4 7\n5 3\n2 6\n1 8\n6 5\n4 1\n5 7\n1 4\n4 7\n5 4\n8 2\n4 6\n8 7\n1 9\n1 6\n6 4\n5 2\n5 3\n2 6\n4 6\n5 2\n6 7\n5 3\n9 5\n8 3\n1 9\n2 6\n5 1\n7 3\n4 3\n7 2\n4 3\n5 7\n6 8\n8 2\n3 6\n4 9\n1 8\n7 8\n5 4\n7 6\n", "output": ["258"]}, {"input": "50\n5 9\n1 2\n6 9\n1 6\n8 1\n5 3\n2 1\n2 7\n6 1\n4 3\n6 1\n2 6\n2 8\n2 1\n3 4\n6 2\n4 8\n6 4\n2 1\n1 5\n4 9\n6 8\n4 1\n1 6\n1 5\n5 9\n2 6\n6 9\n4 2\n4 7\n8 2\n4 6\n2 5\n9 4\n3 1\n8 4\n3 9\n1 3\n2 3\n8 7\n5 4\n2 6\n9 5\n6 2\n5 8\n2 8\n8 9\n9 2\n5 3\n9 1\n", "output": ["282"]}, {"input": "50\n9 8\n8 9\n2 3\n2 6\n7 6\n9 8\n7 5\n8 5\n2 9\n4 2\n4 6\n9 4\n1 9\n4 8\n7 9\n7 4\n4 7\n7 6\n8 9\n2 8\n1 3\n6 7\n6 3\n1 8\n9 3\n4 9\n9 6\n4 2\n6 5\n3 8\n9 3\n7 5\n9 6\n5 6\n4 7\n5 7\n9 1\n7 5\n5 6\n3 1\n4 3\n7 1\n9 8\n7 8\n3 7\n8 3\n9 6\n5 7\n1 8\n6 4\n", "output": ["275"]}, {"input": "9\n2 1\n5 9\n2 6\n2 6\n4 7\n7 3\n3 1\n3 1\n7 8\n", "output": ["46"]}, {"input": "5\n1 7\n2 5\n8 6\n3 4\n1 6\n", "output": ["29"]}, {"input": "4\n2 1\n1 7\n5 8\n8 4\n", "output": ["21"]}, {"input": "1\n1 9\n", "output": ["10"]}, {"input": "1\n9 1\n", "output": ["18"]}, {"input": "1\n1 5\n", "output": ["6"]}, {"input": "1\n8 6\n", "output": ["11"]}], "starter_code": "", "source_codes": ["import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    persons = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        persons.append((a, b, i))  # (source, dest, arrival_index)\n\n    # Group people by source floor maintaining arrival order\n    waiting_queues = defaultdict(deque)\n    for p in persons:\n        waiting_queues[p[0]].append(p)\n    \n    # State\n    current_floor = 1\n    elevator = []  # list of (dest, arrival_index)\n    time = 0\n    delivered = set()  # indices of persons already delivered\n    \n    # Precompute for easier access\n    person_dest = {p[2]: p[1] for p in persons}\n\n    while len(delivered) < n:\n        # Determine next floor to visit\n        # Collect all possible target floors\n        targets = set()\n        \n        # Add destinations of people currently in elevator\n        for dest, _ in elevator:\n            targets.add(dest)\n            \n        # Add source floors of people still waiting\n        for floor in waiting_queues:\n            if waiting_queues[floor]:\n                targets.add(floor)\n        \n        if not targets:\n            break\n            \n        # If we're already at a target floor, process it first\n        if current_floor in targets:\n            next_floor = current_floor\n        else:\n            # Choose the next floor based on a better strategy\n            # For now, let's go to the closest floor\n            next_floor = min(targets, key=lambda f: abs(f - current_floor))\n        \n        # Move to next floor\n        if next_floor != current_floor:\n            time += abs(next_floor - current_floor)\n            current_floor = next_floor\n        \n        # Open doors\n        time += 1\n        \n        # People exit\n        exited_people = [(dest, idx) for dest, idx in elevator if dest == current_floor]\n        exited_count = len(exited_people)\n        time += exited_count\n        # Mark as delivered\n        for dest, idx in exited_people:\n            delivered.add(idx)\n        # Remove exited people from elevator\n        elevator = [(dest, idx) for dest, idx in elevator if dest != current_floor]\n        \n        # People enter in arrival order across all floors\n        # But they can only enter if they're on the current floor\n        if current_floor in waiting_queues:\n            remaining_capacity = 4 - len(elevator)\n            entered = 0\n            \n            # We need to check people in global arrival order\n            # But only those who are currently on this floor can enter\n            temp_queue = deque()\n            while waiting_queues[current_floor] and entered < remaining_capacity:\n                person = waiting_queues[current_floor].popleft()\n                if person[2] not in delivered:  # Not already delivered\n                    elevator.append((person[1], person[2]))  # (dest, arrival_index)\n                    entered += 1\n                    time += 1\n                # If person is already delivered, we just discard them\n            \n            # Put back any remaining people in the queue\n            while waiting_queues[current_floor]:\n                temp_queue.append(waiting_queues[current_floor].popleft())\n            \n            # Restore the queue\n            waiting_queues[current_floor] = temp_queue\n    \n    print(time)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nfrom collections import deque, defaultdict\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    persons = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        persons.append((a, b, i))  # (source, dest, arrival_index)\n\n    # Group people by source floor maintaining arrival order\n    waiting_queues = defaultdict(deque)\n    for p in persons:\n        waiting_queues[p[0]].append(p)\n    \n    # State\n    current_floor = 1\n    elevator = []  # list of (dest, arrival_index)\n    time = 0\n    delivered = set()  # indices of persons already delivered\n    \n    # Precompute for easier access\n    person_dest = {p[2]: p[1] for p in persons}\n\n    while len(delivered) < n:\n        # Determine next floor to visit\n        # Collect all possible target floors\n        targets = set()\n        \n        # Add destinations of people currently in elevator\n        for dest, _ in elevator:\n            targets.add(dest)\n            \n        # Add source floors of people still waiting\n        for floor in waiting_queues:\n            if waiting_queues[floor]:\n                targets.add(floor)\n        \n        if not targets:\n            break\n            \n        # If we're already at a target floor, process it first\n        if current_floor in targets:\n            next_floor = current_floor\n        else:\n            # Choose the next floor based on a better strategy\n            # For now, let's go to the closest floor\n            next_floor = min(targets, key=lambda f: abs(f - current_floor))\n        \n        # Move to next floor\n        if next_floor != current_floor:\n            time += abs(next_floor - current_floor)\n            current_floor = next_floor\n        \n        # Open doors\n        time += 1\n        \n        # People exit\n        exited_people = [(dest, idx) for dest, idx in elevator if dest == current_floor]\n        exited_count = len(exited_people)\n        time += exited_count\n        # Mark as delivered\n        for dest, idx in exited_people:\n            delivered.add(idx)\n        # Remove exited people from elevator\n        elevator = [(dest, idx) for dest, idx in elevator if dest != current_floor]\n        \n        # People enter in arrival order across all floors\n        # But they can only enter if they're on the current floor\n        if current_floor in waiting_queues:\n            remaining_capacity = 4 - len(elevator)\n            entered = 0\n            \n            # We need to check people in global arrival order\n            # But only those who are currently on this floor can enter\n            temp_queue = deque()\n            while waiting_queues[current_floor] and entered < remaining_capacity:\n                person = waiting_queues[current_floor].popleft()\n                if person[2] not in delivered:  # Not already delivered\n                    elevator.append((person[1], person[2]))  # (dest, arrival_index)\n                    entered += 1\n                    time += 1\n                # If person is already delivered, we just discard them\n            \n            # Put back any remaining people in the queue\n            while waiting_queues[current_floor]:\n                temp_queue.append(waiting_queues[current_floor].popleft())\n            \n            # Restore the queue\n            waiting_queues[current_floor] = temp_queue\n    \n    print(time)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13844], "completion_tokens": [7328], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2037}
{"name": "2199", "description": "Writing light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it.\n\n[Image]\u00a0\n\nThere are $n$ cities and $n-1$ two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from $1$ to $n$, and the city $1$ is the capital of the kingdom. So, the kingdom has a tree structure.\n\nAs the queen, Linova plans to choose exactly $k$ cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.\n\nA meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).\n\nTraveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.\n\nIn order to be a queen loved by people, Linova wants to choose $k$ cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($2\\le n\\le 2 \\cdot 10^5$, $1\\le k< n$) \u00a0\u2014 the number of cities and industry cities respectively.\n\nEach of the next $n-1$ lines contains two integers $u$ and $v$ ($1\\le u,v\\le n$), denoting there is a road connecting city $u$ and city $v$.\n\nIt is guaranteed that from any city, you can reach any other city by the roads.\n\n\n-----Output-----\n\nPrint the only line containing a single integer \u00a0\u2014 the maximum possible sum of happinesses of all envoys.\n\n\n-----Examples-----\nInput\n7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n\nOutput\n7\nInput\n4 1\n1 2\n1 3\n2 4\n\nOutput\n2\nInput\n8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n\nOutput\n9\n\n\n-----Note-----\n\n[Image]\n\nIn the first example, Linova can choose cities $2$, $5$, $6$, $7$ to develop industry, then the happiness of the envoy from city $2$ is $1$, the happiness of envoys from cities $5$, $6$, $7$ is $2$. The sum of happinesses is $7$, and it can be proved to be the maximum one.\n\n[Image]\n\nIn the second example, choosing cities $3$, $4$ developing industry can reach a sum of $3$, but remember that Linova plans to choose exactly $k$ cities developing industry, then the maximum sum is $2$.", "difficulty": "competition", "id": 2199, "sample_io": [{"input": "7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n", "output": ["7"]}, {"input": "4 1\n1 2\n1 3\n2 4\n", "output": ["2"]}, {"input": "8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n", "output": ["9"]}], "test_list": [{"input": "7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n", "output": ["7"]}, {"input": "4 1\n1 2\n1 3\n2 4\n", "output": ["2"]}, {"input": "8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n", "output": ["9"]}, {"input": "2 1\n1 2\n", "output": ["1"]}, {"input": "20 7\n9 7\n3 7\n15 9\n1 3\n11 9\n18 7\n17 18\n20 1\n4 11\n2 11\n12 18\n8 18\n13 2\n19 2\n10 9\n6 13\n5 8\n14 1\n16 13\n", "output": ["38"]}, {"input": "3 2\n1 2\n1 3\n", "output": ["2"]}, {"input": "3 1\n1 2\n2 3\n", "output": ["2"]}], "starter_code": "", "source_codes": ["import sys\nsys.setrecursionlimit(10**6)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    adj = [[] for _ in range(n+1)]\n    index = 2\n    for _ in range(n-1):\n        u = int(data[index])\n        v = int(data[index+1])\n        adj[u].append(v)\n        adj[v].append(u)\n        index += 2\n    \n    # Compute depth and subtree size via DFS\n    depth = [0]*(n+1)\n    subtree_size = [0]*(n+1)\n    \n    def dfs(u, parent):\n        subtree_size[u] = 1\n        for v in adj[u]:\n            if v != parent:\n                depth[v] = depth[u] + 1\n                dfs(v, u)\n                subtree_size[u] += subtree_size[v]\n    \n    depth[1] = 0\n    dfs(1, 0)\n    \n    # Calculate the gain for each node if it's chosen as industrial\n    # Gain = depth[u] - (subtree_size[u] - 1)\n    gains = []\n    for i in range(1, n+1):\n        gain = depth[i] - (subtree_size[i] - 1)\n        gains.append(gain)\n    \n    # Sort by gain descending\n    gains.sort(reverse=True)\n    \n    # Sum top k gains\n    result = sum(gains[:k])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    adj = [[] for _ in range(n+1)]\n    index = 2\n    for _ in range(n-1):\n        u = int(data[index])\n        v = int(data[index+1])\n        adj[u].append(v)\n        adj[v].append(u)\n        index += 2\n    \n    # Compute depth and subtree size via DFS\n    depth = [0]*(n+1)\n    subtree_size = [0]*(n+1)\n    \n    def dfs(u, parent):\n        subtree_size[u] = 1\n        for v in adj[u]:\n            if v != parent:\n                depth[v] = depth[u] + 1\n                dfs(v, u)\n                subtree_size[u] += subtree_size[v]\n    \n    depth[1] = 0\n    dfs(1, 0)\n    \n    # Calculate the gain for each node if it's chosen as industrial\n    # Gain = depth[u] - (subtree_size[u] - 1)\n    gains = []\n    for i in range(1, n+1):\n        gain = depth[i] - (subtree_size[i] - 1)\n        gains.append(gain)\n    \n    # Sort by gain descending\n    gains.sort(reverse=True)\n    \n    # Sum top k gains\n    result = sum(gains[:k])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [16577], "completion_tokens": [9231], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2199}
{"name": "2144", "description": "Ujan has a lot of numbers in his boxes. He likes order and balance, so he decided to reorder the numbers.\n\nThere are $k$ boxes numbered from $1$ to $k$. The $i$-th box contains $n_i$ integer numbers. The integers can be negative. All of the integers are distinct. \n\nUjan is lazy, so he will do the following reordering of the numbers exactly once. He will pick a single integer from each of the boxes, $k$ integers in total. Then he will insert the chosen numbers\u00a0\u2014 one integer in each of the boxes, so that the number of integers in each box is the same as in the beginning. Note that he may also insert an integer he picked from a box back into the same box.\n\nUjan will be happy if the sum of the integers in each box is the same. Can he achieve this and make the boxes perfectly balanced, like all things should be?\n\n\n-----Input-----\n\nThe first line contains a single integer $k$ ($1 \\leq k \\leq 15$), the number of boxes. \n\nThe $i$-th of the next $k$ lines first contains a single integer $n_i$ ($1 \\leq n_i \\leq 5\\,000$), the number of integers in box $i$. Then the same line contains $n_i$ integers $a_{i,1}, \\ldots, a_{i,n_i}$ ($|a_{i,j}| \\leq 10^9$), the integers in the $i$-th box. \n\nIt is guaranteed that all $a_{i,j}$ are distinct.\n\n\n-----Output-----\n\nIf Ujan cannot achieve his goal, output \"No\" in a single line. Otherwise in the first line output \"Yes\", and then output $k$ lines. The $i$-th of these lines should contain two integers $c_i$ and $p_i$. This means that Ujan should pick the integer $c_i$ from the $i$-th box and place it in the $p_i$-th box afterwards.\n\nIf there are multiple solutions, output any of those.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n4\n3 1 7 4\n2 3 2\n2 8 5\n1 10\n\nOutput\nYes\n7 2\n2 3\n5 1\n10 4\n\nInput\n2\n2 3 -2\n2 -1 5\n\nOutput\nNo\n\nInput\n2\n2 -10 10\n2 0 -20\n\nOutput\nYes\n-10 2\n-20 1\n\n\n\n-----Note-----\n\nIn the first sample, Ujan can put the number $7$ in the $2$nd box, the number $2$ in the $3$rd box, the number $5$ in the $1$st box and keep the number $10$ in the same $4$th box. Then the boxes will contain numbers $\\{1,5,4\\}$, $\\{3, 7\\}$, $\\{8,2\\}$ and $\\{10\\}$. The sum in each box then is equal to $10$.\n\nIn the second sample, it is not possible to pick and redistribute the numbers in the required way.\n\nIn the third sample, one can swap the numbers $-20$ and $-10$, making the sum in each box equal to $-10$.", "difficulty": "competition", "id": 2144, "sample_io": [{"input": "4\n3 1 7 4\n2 3 2\n2 8 5\n1 10\n", "output": ["Yes\n7 2\n2 3\n5 1\n10 4\n"]}, {"input": "2\n2 3 -2\n2 -1 5\n", "output": ["No\n"]}, {"input": "2\n2 -10 10\n2 0 -20\n", "output": ["Yes\n-10 2\n-20 1\n"]}], "test_list": [{"input": "4\n3 1 7 4\n2 3 2\n2 8 5\n1 10\n", "output": ["Yes\n7 2\n2 3\n5 1\n10 4\n"]}, {"input": "2\n2 3 -2\n2 -1 5\n", "output": ["No\n"]}, {"input": "2\n2 -10 10\n2 0 -20\n", "output": ["Yes\n-10 2\n-20 1\n"]}, {"input": "1\n1 0\n", "output": ["Yes\n0 1\n"]}, {"input": "3\n1 20\n2 30 40\n3 50 60 80\n", "output": ["No\n"]}, {"input": "3\n3 1 3 100\n2 4 104\n2 2 102\n", "output": ["No\n"]}, {"input": "4\n3 80 1 10\n3 52 19 24\n3 27 46 29\n3 74 13 25\n", "output": ["No\n"]}, {"input": "2\n5 -1000000000 999999999 -999999998 999999997 0\n5 1000000000 -999999999 999999998 -999999997 4\n", "output": ["Yes\n0 2\n4 1\n"]}, {"input": "5\n10 -251 650 475 -114 364 -75754 -982 -532 -151 -484\n10 -623 -132 -317561 -438 20 -275 -323 -530089 -311 -587\n10 450900 -519 903 -401 -789 -606529 277 -267 -682 -161\n10 -246 873 -641 838 719 234 789 -74 -287288 -772972\n10 186 741 -927 -866 -855 578 -1057019 202 162962 -458\n", "output": ["Yes\n650 3\n-530089 1\n450900 5\n-287288 2\n162962 4\n"]}, {"input": "2\n2 1 2\n10 0 1000000000 999999999 999999998 999999997 999999996 999999995 999999994 999999993 589934621\n", "output": ["No\n"]}], "starter_code": "", "source_codes": ["def solve():\n    k = int(input())\n    boxes = []\n    sums = []\n    \n    for i in range(k):\n        line = list(map(int, input().split()))\n        n = line[0]\n        numbers = line[1:]\n        boxes.append(numbers)\n        sums.append(sum(numbers))\n    \n    total_sum = sum(sums)\n    \n    if total_sum % k != 0:\n        print(\"No\")\n        return\n    \n    target = total_sum // k\n    deltas = [target - s for s in sums]\n    \n    # Create a mapping from number to list of boxes containing it\n    number_to_boxes = defaultdict(list)\n    for i in range(k):\n        for num in boxes[i]:\n            number_to_boxes[num].append(i)\n    \n    # Build bipartite graph\n    # Left side: boxes (givers)\n    # Right side: boxes (receivers)\n    # Edge from box i to box j exists if:\n    #   there exists a number c in box i such that\n    #   there exists a number d in box j where\n    #   (sum_i - c + d) = target\n    #   which means d = target - sum_i + c = c + deltas[i]\n    \n    graph = [[] for _ in range(k)]\n    \n    # For each box i, and each number c in it\n    for i in range(k):\n        for c in boxes[i]:\n            needed_number = c + deltas[i]  # what box i needs to receive if it gives c\n            if needed_number in number_to_boxes:\n                for j in number_to_boxes[needed_number]:\n                    graph[i].append((j, c))  # box i can give number c to box j\n    \n    # Find maximum matching using Hungarian-like algorithm\n    match_left = [-1] * k   # match_left[i] = (j, c) means i sends number c to j\n    match_right = [-1] * k  # match_right[j] = i means j receives from i\n    \n    def dfs(u, visited):\n        for v, c in graph[u]:\n            if visited[v]:\n                continue\n            visited[v] = True\n            \n            if match_right[v] == -1 or dfs(match_right[v], visited):\n                match_left[u] = (v, c)\n                match_right[v] = u\n                return True\n        return False\n    \n    # Try to find perfect matching\n    matched = 0\n    for i in range(k):\n        visited = [False] * k\n        if dfs(i, visited):\n            matched += 1\n    \n    if matched != k:\n        print(\"No\")\n        return\n    \n    print(\"Yes\")\n    for i in range(k):\n        j, c = match_left[i]  # box i gives number c to box j\n        print(c, j + 1)\n\nsolve()"], "responses": ["\nfrom collections import defaultdict\n\ndef solve():\n    k = int(input())\n    boxes = []\n    sums = []\n    \n    for i in range(k):\n        line = list(map(int, input().split()))\n        n = line[0]\n        numbers = line[1:]\n        boxes.append(numbers)\n        sums.append(sum(numbers))\n    \n    total_sum = sum(sums)\n    \n    if total_sum % k != 0:\n        print(\"No\")\n        return\n    \n    target = total_sum // k\n    deltas = [target - s for s in sums]\n    \n    # Create a mapping from number to list of boxes containing it\n    number_to_boxes = defaultdict(list)\n    for i in range(k):\n        for num in boxes[i]:\n            number_to_boxes[num].append(i)\n    \n    # Build bipartite graph\n    # Left side: boxes (givers)\n    # Right side: boxes (receivers)\n    # Edge from box i to box j exists if:\n    #   there exists a number c in box i such that\n    #   there exists a number d in box j where\n    #   (sum_i - c + d) = target\n    #   which means d = target - sum_i + c = c + deltas[i]\n    \n    graph = [[] for _ in range(k)]\n    \n    # For each box i, and each number c in it\n    for i in range(k):\n        for c in boxes[i]:\n            needed_number = c + deltas[i]  # what box i needs to receive if it gives c\n            if needed_number in number_to_boxes:\n                for j in number_to_boxes[needed_number]:\n                    graph[i].append((j, c))  # box i can give number c to box j\n    \n    # Find maximum matching using Hungarian-like algorithm\n    match_left = [-1] * k   # match_left[i] = (j, c) means i sends number c to j\n    match_right = [-1] * k  # match_right[j] = i means j receives from i\n    \n    def dfs(u, visited):\n        for v, c in graph[u]:\n            if visited[v]:\n                continue\n            visited[v] = True\n            \n            if match_right[v] == -1 or dfs(match_right[v], visited):\n                match_left[u] = (v, c)\n                match_right[v] = u\n                return True\n        return False\n    \n    # Try to find perfect matching\n    matched = 0\n    for i in range(k):\n        visited = [False] * k\n        if dfs(i, visited):\n            matched += 1\n    \n    if matched != k:\n        print(\"No\")\n        return\n    \n    print(\"Yes\")\n    for i in range(k):\n        j, c = match_left[i]  # box i gives number c to box j\n        print(c, j + 1)\n\nsolve()\n\n\n"], "prompt_tokens": [17929], "completion_tokens": [8885], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2144}
{"name": "2170", "description": "There are some rabbits in Singapore Zoo. To feed them, Zookeeper bought $n$ carrots with lengths $a_1, a_2, a_3, \\ldots, a_n$. However, rabbits are very fertile and multiply very quickly. Zookeeper now has $k$ rabbits and does not have enough carrots to feed all of them. To solve this problem, Zookeeper decided to cut the carrots into $k$ pieces. For some reason, all resulting carrot lengths must be positive integers.\n\nBig carrots are very difficult for rabbits to handle and eat, so the time needed to eat a carrot of size $x$ is $x^2$.\n\nHelp Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ $(1 \\leq n \\leq k \\leq 10^5)$: the initial number of carrots and the number of rabbits.\n\nThe next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ $(1 \\leq a_i \\leq 10^6)$: lengths of carrots.\n\nIt is guaranteed that the sum of $a_i$ is at least $k$.\n\n\n-----Output-----\n\nOutput one integer: the minimum sum of time taken for rabbits to eat carrots.\n\n\n-----Examples-----\nInput\n3 6\n5 3 1\n\nOutput\n15\n\nInput\n1 4\n19\n\nOutput\n91\n\n\n\n-----Note-----\n\nFor the first test, the optimal sizes of carrots are $\\{1,1,1,2,2,2\\}$. The time taken is $1^2+1^2+1^2+2^2+2^2+2^2=15$\n\nFor the second test, the optimal sizes of carrots are $\\{4,5,5,5\\}$. The time taken is $4^2+5^2+5^2+5^2=91$.", "difficulty": "competition", "id": 2170, "sample_io": [{"input": "3 6\n5 3 1\n", "output": ["15\n"]}, {"input": "1 4\n19\n", "output": ["91\n"]}], "test_list": [{"input": "3 6\n5 3 1\n", "output": ["15\n"]}, {"input": "1 4\n19\n", "output": ["91\n"]}, {"input": "1 3\n1000000\n", "output": ["333333333334\n"]}, {"input": "1 1\n1\n", "output": ["1\n"]}, {"input": "10 23\n343 984 238 758983 231 74 231 548 893 543\n", "output": ["41149446942\n"]}, {"input": "20 40\n2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n", "output": ["40\n"]}, {"input": "29 99047\n206580 305496 61753 908376 272137 803885 675070 665109 995787 667887 164508 634877 994427 270698 931765 721679 518973 65009 804367 608526 535640 117656 342804 398273 369209 298745 365459 942772 89584\n", "output": ["2192719703\n"]}, {"input": "54 42164\n810471 434523 262846 930807 148016 633714 247313 376546 142288 30094 599543 829013 182512 647950 512266 827248 452285 531124 257259 453752 114536 833190 737596 267349 598567 781294 390500 318098 354290 725051 978831 905185 849542 761886 55532 608148 631077 557070 355245 929381 280340 620004 285066 42159 82460 348896 446782 672690 364747 339938 715721 870099 357424 323761\n", "output": ["17049737221\n"]}, {"input": "12 21223\n992192 397069 263753 561788 903539 521894 818097 223467 511651 737418 975119 528954\n", "output": ["2604648091\n"]}], "starter_code": "", "source_codes": ["import heapq\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Create a max heap using negative values\n    # Initially, we have n pieces\n    heap = [-x for x in a]\n    heapq.heapify(heap)\n    \n    # We currently have n pieces, need k pieces\n    # So we need to make (k - n) cuts\n    current_pieces = n\n    \n    while current_pieces < k:\n        # Get the largest piece\n        largest = -heapq.heappop(heap)\n        \n        # Split it into two pieces as equally as possible\n        piece1 = largest // 2\n        piece2 = largest - piece1\n        \n        # Both pieces must be positive\n        if piece1 > 0 and piece2 > 0:\n            heapq.heappush(heap, -piece1)\n            heapq.heappush(heap, -piece2)\n            current_pieces += 1  # One piece became two pieces\n        else:\n            # If we can't split meaningfully, put it back\n            heapq.heappush(heap, -largest)\n            break\n    \n    # Calculate total time (sum of squares)\n    total_time = sum((-x) ** 2 for x in heap)\n    print(total_time)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport heapq\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Create a max heap using negative values\n    # Initially, we have n pieces\n    heap = [-x for x in a]\n    heapq.heapify(heap)\n    \n    # We currently have n pieces, need k pieces\n    # So we need to make (k - n) cuts\n    current_pieces = n\n    \n    while current_pieces < k:\n        # Get the largest piece\n        largest = -heapq.heappop(heap)\n        \n        # Split it into two pieces as equally as possible\n        piece1 = largest // 2\n        piece2 = largest - piece1\n        \n        # Both pieces must be positive\n        if piece1 > 0 and piece2 > 0:\n            heapq.heappush(heap, -piece1)\n            heapq.heappush(heap, -piece2)\n            current_pieces += 1  # One piece became two pieces\n        else:\n            # If we can't split meaningfully, put it back\n            heapq.heappush(heap, -largest)\n            break\n    \n    # Calculate total time (sum of squares)\n    total_time = sum((-x) ** 2 for x in heap)\n    print(total_time)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [10400], "completion_tokens": [8271], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2170}
{"name": "2070", "description": "Karen has just arrived at school, and she has a math test today! [Image] \n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 10^9 + 7.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is a_{i} (1 \u2264 a_{i} \u2264 10^9), the i-th number on the first row.\n\n\n-----Output-----\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 10^9 + 7.\n\n\n-----Examples-----\nInput\n5\n3 6 9 12 15\n\nOutput\n36\n\nInput\n4\n3 7 5 2\n\nOutput\n1000000006\n\n\n\n-----Note-----\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is 10^9 + 6, so this is the correct output.", "difficulty": "competition", "id": 2070, "sample_io": [{"input": "5\n3 6 9 12 15\n", "output": ["36\n"]}, {"input": "4\n3 7 5 2\n", "output": ["1000000006\n"]}], "test_list": [{"input": "5\n3 6 9 12 15\n", "output": ["36\n"]}, {"input": "4\n3 7 5 2\n", "output": ["1000000006\n"]}, {"input": "1\n1\n", "output": ["1\n"]}, {"input": "16\n985629174 189232688 48695377 692426437 952164554 243460498 173956955 210310239 237322183 96515847 678847559 682240199 498792552 208770488 736004147 176573082\n", "output": ["347261016\n"]}, {"input": "18\n341796022 486073481 86513380 593942288 60606166 627385348 778725113 896678215 384223198 661124212 882144246 60135494 374392733 408166459 179944793 331468916 401182818 69503967\n", "output": ["773499683\n"]}, {"input": "17\n458679894 912524637 347508634 863280107 226481104 787939275 48953130 553494227 458256339 673787326 353107999 298575751 436592642 233596921 957974470 254020999 707869688\n", "output": ["769845668\n"]}, {"input": "19\n519879446 764655030 680293934 914539062 744988123 317088317 653721289 239862203 605157354 943428394 261437390 821695238 312192823 432992892 547139308 408916833 829654733 223751525 672158759\n", "output": ["265109293\n"]}, {"input": "1\n1000000000\n", "output": ["1000000000\n"]}, {"input": "3\n524125987 923264237 374288891\n", "output": ["996365563\n"]}, {"input": "4\n702209411 496813081 673102149 561219907\n", "output": ["317278572\n"]}, {"input": "5\n585325539 365329221 412106895 291882089 564718673\n", "output": ["974257995\n"]}, {"input": "6\n58376259 643910770 5887448 757703054 544067926 902981667\n", "output": ["676517605\n"]}, {"input": "7\n941492387 72235422 449924898 783332532 378192988 592684636 147499872\n", "output": ["328894634\n"]}, {"input": "2\n500000004 500000003\n", "output": ["0\n"]}], "starter_code": "", "source_codes": ["def main():\n    MOD = 10**9 + 7\n    \n    # Function to compute modular inverse using Fermat's little theorem\n    def mod_inverse(a, mod):\n        return pow(a, mod - 2, mod)\n    \n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        print(a[0] % MOD)\n        return\n    \n    # Precompute factorials and their modular inverses\n    fact = [1] * n\n    for i in range(1, n):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact = [1] * n\n    inv_fact[n-1] = mod_inverse(fact[n-1], MOD)\n    for i in range(n-2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        return (fact[n] * inv_fact[k] % MOD) * inv_fact[n-k] % MOD\n    \n    result = 0\n    for i in range(n):\n        # The coefficient pattern needs to be adjusted\n        # For the alternating operations, the coefficient of element i is C(n-1, i) * (-1)^i\n        sign = 1 if i % 2 == 0 else -1\n        coefficient = comb(n-1, i) * sign\n        result = (result + coefficient * a[i]) % MOD\n    \n    # Ensure non-negative result\n    print((result + MOD) % MOD)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef main():\n    MOD = 10**9 + 7\n    \n    # Function to compute modular inverse using Fermat's little theorem\n    def mod_inverse(a, mod):\n        return pow(a, mod - 2, mod)\n    \n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        print(a[0] % MOD)\n        return\n    \n    # Precompute factorials and their modular inverses\n    fact = [1] * n\n    for i in range(1, n):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact = [1] * n\n    inv_fact[n-1] = mod_inverse(fact[n-1], MOD)\n    for i in range(n-2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        return (fact[n] * inv_fact[k] % MOD) * inv_fact[n-k] % MOD\n    \n    result = 0\n    for i in range(n):\n        # The coefficient pattern needs to be adjusted\n        # For the alternating operations, the coefficient of element i is C(n-1, i) * (-1)^i\n        sign = 1 if i % 2 == 0 else -1\n        coefficient = comb(n-1, i) * sign\n        result = (result + coefficient * a[i]) % MOD\n    \n    # Ensure non-negative result\n    print((result + MOD) % MOD)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13771], "completion_tokens": [8639], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2070}
{"name": "2215", "description": "Jzzhu is the president of country A. There are n cities numbered from 1 to n in his country. City 1 is the capital of A. Also there are m roads connecting the cities. One can go from city u_{i} to v_{i} (and vise versa) using the i-th road, the length of this road is x_{i}. Finally, there are k train routes in the country. One can use the i-th train route to go from capital of the country to city s_{i} (and vise versa), the length of this route is y_{i}.\n\nJzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (2 \u2264 n \u2264 10^5;\u00a01 \u2264 m \u2264 3\u00b710^5;\u00a01 \u2264 k \u2264 10^5).\n\nEach of the next m lines contains three integers u_{i}, v_{i}, x_{i} (1 \u2264 u_{i}, v_{i} \u2264 n;\u00a0u_{i} \u2260 v_{i};\u00a01 \u2264 x_{i} \u2264 10^9).\n\nEach of the next k lines contains two integers s_{i} and y_{i} (2 \u2264 s_{i} \u2264 n;\u00a01 \u2264 y_{i} \u2264 10^9).\n\nIt is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.\n\n\n-----Output-----\n\nOutput a single integer representing the maximum number of the train routes which can be closed.\n\n\n-----Examples-----\nInput\n5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n\nOutput\n2\n\nInput\n2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n\nOutput\n2", "difficulty": "competition", "id": 2215, "sample_io": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}], "test_list": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}, {"input": "5 4 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "3 2 5\n1 2 2\n2 3 4\n3 5\n3 5\n3 5\n3 6\n3 7\n", "output": ["4\n"]}, {"input": "5 5 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 3 1000000000\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "2 1 5\n1 2 4\n2 3\n2 5\n2 4\n2 4\n2 5\n", "output": ["4\n"]}, {"input": "3 3 6\n1 2 499999999\n2 3 500000000\n1 3 999999999\n2 499999999\n2 500000000\n2 499999999\n3 999999999\n3 1000000000\n3 1000000000\n", "output": ["6\n"]}, {"input": "2 1 1\n1 2 1\n2 1000000000\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 4\n2 3 4\n2 2\n3 6\n", "output": ["1\n"]}, {"input": "5 5 2\n1 2 100\n2 3 100\n3 4 100\n4 5 20\n2 5 5\n5 50\n4 1\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 100\n2 3 1\n2 1\n3 3\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["import heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    \n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u, v, x = map(int, sys.stdin.readline().split())\n        graph[u].append((v, x))\n        graph[v].append((u, x))\n    \n    # Compute shortest distances from capital (node 1) using roads only\n    dist = dijkstra(n, graph, 1)\n    \n    count = 0\n    for _ in range(k):\n        s, y = map(int, sys.stdin.readline().split())\n        if dist[s] <= y:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport heapq\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    \n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u, v, x = map(int, sys.stdin.readline().split())\n        graph[u].append((v, x))\n        graph[v].append((u, x))\n    \n    # Compute shortest distances from capital (node 1) using roads only\n    dist = dijkstra(n, graph, 1)\n    \n    count = 0\n    for _ in range(k):\n        s, y = map(int, sys.stdin.readline().split())\n        if dist[s] <= y:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13691], "completion_tokens": [8657], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2215}
{"name": "2187", "description": "Jzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. \n\nJzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.\n\nJzzhu wonders how to get the maximum possible number of groups. Can you help him?\n\n\n-----Input-----\n\nA single integer n (1 \u2264 n \u2264 10^5), the number of the apples.\n\n\n-----Output-----\n\nThe first line must contain a single integer m, representing the maximum number of groups he can get. Each of the next m lines must contain two integers \u2014 the numbers of apples in the current group.\n\nIf there are several optimal answers you can print any of them.\n\n\n-----Examples-----\nInput\n6\n\nOutput\n2\n6 3\n2 4\n\nInput\n9\n\nOutput\n3\n9 3\n2 4\n6 8\n\nInput\n2\n\nOutput\n0", "difficulty": "competition", "id": 2187, "sample_io": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}], "test_list": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}, {"input": "10\n", "output": ["4\n2 4\n6 8\n10 5\n9 3\n"]}, {"input": "100\n", "output": ["44\n33 27\n22 11\n25 5\n64 66\n42 44\n31 62\n58 29\n43 86\n15 21\n6 99\n8 12\n85 65\n7 49\n23 46\n16 14\n20 18\n90 92\n48 50\n40 36\n74 37\n35 55\n10 95\n56 60\n47 94\n45 39\n93 87\n88 84\n72 76\n28 24\n75 81\n78 80\n54 52\n38 19\n3 9\n32 30\n91 77\n70 68\n63 69\n2 4\n57 51\n82 41\n17 34\n13 26\n96 98\n"]}, {"input": "1\n", "output": ["0\n"]}, {"input": "3\n", "output": ["0\n"]}, {"input": "5\n", "output": ["1\n2 4\n"]}], "starter_code": "", "source_codes": ["def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\n\nif n < 2:\n    print(0)\nelse:\n    used = [False] * (n + 1)\n    pairs = []\n    \n    # First, pair all even numbers (they share factor 2)\n    even_numbers = []\n    for i in range(2, n + 1, 2):\n        even_numbers.append(i)\n    \n    # Pair consecutive even numbers\n    for i in range(0, len(even_numbers) - 1, 2):\n        pairs.append((even_numbers[i], even_numbers[i + 1]))\n        used[even_numbers[i]] = True\n        used[even_numbers[i + 1]] = True\n    \n    # Then, pair remaining odd numbers\n    for i in range(3, n + 1):\n        if used[i]:\n            continue\n        # Look for the best partner for i\n        best_j = -1\n        for j in range(i + 1, n + 1):\n            if used[j]:\n                continue\n            if gcd(i, j) > 1:\n                best_j = j\n                break\n        \n        if best_j != -1:\n            pairs.append((i, best_j))\n            used[i] = True\n            used[best_j] = True\n    \n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])"], "responses": ["\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\n\nif n < 2:\n    print(0)\nelse:\n    used = [False] * (n + 1)\n    pairs = []\n    \n    # First, pair all even numbers (they share factor 2)\n    even_numbers = []\n    for i in range(2, n + 1, 2):\n        even_numbers.append(i)\n    \n    # Pair consecutive even numbers\n    for i in range(0, len(even_numbers) - 1, 2):\n        pairs.append((even_numbers[i], even_numbers[i + 1]))\n        used[even_numbers[i]] = True\n        used[even_numbers[i + 1]] = True\n    \n    # Then, pair remaining odd numbers\n    for i in range(3, n + 1):\n        if used[i]:\n            continue\n        # Look for the best partner for i\n        best_j = -1\n        for j in range(i + 1, n + 1):\n            if used[j]:\n                continue\n            if gcd(i, j) > 1:\n                best_j = j\n                break\n        \n        if best_j != -1:\n            pairs.append((i, best_j))\n            used[i] = True\n            used[best_j] = True\n    \n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])\n\n\n"], "prompt_tokens": [8989], "completion_tokens": [3687], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2187}
{"name": "2047", "description": "Allen dreams of one day owning a enormous fleet of electric cars, the car of the future! He knows that this will give him a big status boost. As Allen is planning out all of the different types of cars he will own and how he will arrange them, he realizes that he has a problem. \n\nAllen's future parking lot can be represented as a rectangle with $4$ rows and $n$ ($n \\le 50$) columns of rectangular spaces, each of which can contain at most one car at any time. He imagines having $k$ ($k \\le 2n$) cars in the grid, and all the cars are initially in the second and third rows. Each of the cars also has a different designated parking space in the first or fourth row. Allen has to put the cars into corresponding parking places.\n\n [Image] Illustration to the first example. \n\nHowever, since Allen would never entrust his cars to anyone else, only one car can be moved at a time. He can drive a car from a space in any of the four cardinal directions to a neighboring empty space. Furthermore, Allen can only move one of his cars into a space on the first or fourth rows if it is the car's designated parking space. \n\nAllen knows he will be a very busy man, and will only have time to move cars at most $20000$ times before he realizes that moving cars is not worth his time. Help Allen determine if he should bother parking his cars or leave it to someone less important.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 2n$), representing the number of columns and the number of cars, respectively.\n\nThe next four lines will contain $n$ integers each between $0$ and $k$ inclusive, representing the initial state of the parking lot. The rows are numbered $1$ to $4$ from top to bottom and the columns are numbered $1$ to $n$ from left to right.\n\nIn the first and last line, an integer $1 \\le x \\le k$ represents a parking spot assigned to car $x$ (you can only move this car to this place), while the integer $0$ represents a empty space (you can't move any car to this place).\n\nIn the second and third line, an integer $1 \\le x \\le k$ represents initial position of car $x$, while the integer $0$ represents an empty space (you can move any car to this place).\n\nEach $x$ between $1$ and $k$ appears exactly once in the second and third line, and exactly once in the first and fourth line.\n\n\n-----Output-----\n\nIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most $20000$ car moves, then print $m$, the number of moves, on the first line. On the following $m$ lines, print the moves (one move per line) in the format $i$ $r$ $c$, which corresponds to Allen moving car $i$ to the neighboring space at row $r$ and column $c$.\n\nIf it is not possible for Allen to move all the cars to the correct spaces with at most $20000$ car moves, print a single line with the integer $-1$.\n\n\n-----Examples-----\nInput\n4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n\nOutput\n6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n\nInput\n1 2\n1\n2\n1\n2\n\nOutput\n-1\n\nInput\n1 2\n1\n1\n2\n2\n\nOutput\n2\n1 1 1\n2 4 1\n\n\n\n-----Note-----\n\nIn the first sample test case, all cars are in front of their spots except car $5$, which is in front of the parking spot adjacent. The example shows the shortest possible sequence of moves, but any sequence of length at most $20000$ will be accepted.\n\nIn the second sample test case, there is only one column, and the cars are in the wrong order, so no cars can move and the task is impossible.", "difficulty": "competition", "id": 2047, "sample_io": [{"input": "4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n", "output": ["6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n"]}, {"input": "1 2\n1\n2\n1\n2\n", "output": ["-1\n"]}, {"input": "1 2\n1\n1\n2\n2\n", "output": ["2\n1 1 1\n2 4 1\n"]}], "test_list": [{"input": "4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n", "output": ["6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n"]}, {"input": "1 2\n1\n2\n1\n2\n", "output": ["-1\n"]}, {"input": "1 2\n1\n1\n2\n2\n", "output": ["2\n1 1 1\n2 4 1\n"]}, {"input": "2 2\n1 0\n0 2\n0 1\n0 2\n", "output": ["7\n2 2 1\n1 2 2\n2 3 1\n1 2 1\n2 3 2\n1 1 1\n2 4 2\n"]}, {"input": "7 14\n2 11 1 14 9 8 5\n12 6 7 1 10 2 3\n14 13 9 8 5 4 11\n13 6 4 3 12 7 10\n", "output": ["-1\n"]}, {"input": "2 1\n0 0\n0 0\n0 1\n0 1\n", "output": ["1\n1 4 2\n"]}, {"input": "2 3\n0 2\n0 1\n3 2\n3 1\n", "output": ["7\n1 2 1\n2 2 2\n3 4 1\n1 3 1\n2 1 2\n1 3 2\n1 4 2\n"]}, {"input": "1 1\n0\n1\n0\n1\n", "output": ["2\n1 3 1\n1 4 1\n"]}, {"input": "2 4\n3 4\n2 1\n3 4\n2 1\n", "output": ["-1\n"]}, {"input": "3 5\n2 1 5\n5 3 2\n4 0 1\n0 4 3\n", "output": ["18\n4 3 2\n5 3 1\n3 2 1\n2 2 2\n1 2 3\n4 4 2\n5 3 2\n3 3 1\n2 2 1\n1 2 2\n5 3 3\n3 3 2\n2 1 1\n1 1 2\n5 2 3\n3 3 3\n5 1 3\n3 4 3\n"]}, {"input": "10 1\n0 0 1 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n", "output": ["1\n1 1 3\n"]}, {"input": "50 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": ["34\n1 3 27\n1 3 28\n1 3 29\n1 3 30\n1 3 31\n1 3 32\n1 3 33\n1 3 34\n1 3 35\n1 3 36\n1 3 37\n1 3 38\n1 3 39\n1 3 40\n1 3 41\n1 3 42\n1 3 43\n1 3 44\n1 3 45\n1 3 46\n1 3 47\n1 3 48\n1 3 49\n1 3 50\n1 2 50\n1 2 49\n1 2 48\n1 2 47\n1 2 46\n1 2 45\n1 2 44\n1 2 43\n1 2 42\n1 1 42\n"]}, {"input": "22 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0\n", "output": ["65\n2 2 13\n1 3 21\n2 2 12\n1 3 22\n2 2 11\n1 2 22\n2 2 10\n1 2 21\n2 2 9\n1 2 20\n2 2 8\n1 2 19\n2 2 7\n1 2 18\n2 2 6\n1 2 17\n2 2 5\n1 2 16\n2 2 4\n1 2 15\n2 2 3\n1 2 14\n2 2 2\n1 2 13\n2 2 1\n1 2 12\n2 3 1\n1 2 11\n2 3 2\n1 2 10\n2 3 3\n1 2 9\n2 3 4\n1 2 8\n2 3 5\n1 2 7\n2 3 6\n1 2 6\n2 3 7\n1 2 5\n2 3 8\n1 2 4\n2 3 9\n1 2 3\n2 3 10\n1 2 2\n2 3 11\n1 2 1\n2 3 12\n1 3 1\n2 3 13\n1 3 2\n2 3 14\n1 3 3\n2 3 15\n1 3 4\n2 3 16\n1 3 5\n2 3 17\n1 3 6\n2 3 18\n1 3 7\n2 4 18\n1 3 8\n1 4 8\n"]}, {"input": "12 3\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n2 0 0 0 0 3 0 0 0 1 0 0\n0 0 0 0 0 0 0 1 3 0 2 0\n", "output": ["38\n1 3 11\n3 3 7\n2 3 2\n1 3 12\n3 3 8\n2 3 3\n1 2 12\n3 3 9\n2 3 4\n1 2 11\n3 4 9\n2 3 5\n1 2 10\n2 3 6\n1 2 9\n2 3 7\n1 2 8\n2 3 8\n1 2 7\n2 3 9\n1 2 6\n2 3 10\n1 2 5\n2 3 11\n1 2 4\n2 4 11\n1 2 3\n1 2 2\n1 2 1\n1 3 1\n1 3 2\n1 3 3\n1 3 4\n1 3 5\n1 3 6\n1 3 7\n1 3 8\n1 4 8\n"]}, {"input": "10 20\n18 9 4 5 12 14 16 1 15 20\n11 13 16 6 18 5 20 17 4 3\n12 9 15 14 8 10 2 19 1 7\n6 11 13 2 7 19 10 3 8 17\n", "output": ["-1\n"]}, {"input": "15 30\n20 24 17 13 26 8 5 6 27 14 18 22 25 2 15\n4 12 6 25 3 5 28 11 15 21 9 26 7 17 13\n19 20 24 16 2 23 8 29 22 30 1 27 10 14 18\n9 29 3 7 12 28 10 16 23 19 21 1 30 11 4\n", "output": ["-1\n"]}], "starter_code": "", "source_codes": ["def main():\n    n, k = map(int, input().split())\n    grid = []\n    for _ in range(4):\n        grid.append(list(map(int, input().split())))\n    \n    # Parse initial positions and target positions\n    initial_pos = {}\n    target_pos = {}\n    for i in range(4):\n        for j in range(n):\n            val = grid[i][j]\n            if val != 0:\n                if i == 0 or i == 3:  # Target positions (rows 1 and 4 in 0-indexed)\n                    target_pos[val] = (i, j)\n                else:  # Initial positions (rows 2 and 3 in 0-indexed)\n                    initial_pos[val] = (i, j)\n    \n    # Check if already solved\n    solved = True\n    for car in range(1, k+1):\n        if initial_pos[car] != target_pos[car]:\n            solved = False\n            break\n    \n    if solved:\n        print(0)\n        return\n    \n    # BFS with state compression\n    def state_key(pos_dict):\n        return tuple(sorted((car, pos) for car, pos in pos_dict.items()))\n    \n    queue = deque([(initial_pos.copy(), [])])\n    visited = {state_key(initial_pos)}\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        pos_dict, moves = queue.popleft()\n        \n        if len(moves) >= 20000:\n            continue\n            \n        # Create current grid state\n        current_grid = [[0] * n for _ in range(4)]\n        for car, (r, c) in pos_dict.items():\n            current_grid[r][c] = car\n        \n        # Find all empty spaces\n        empty_spaces = set()\n        for r in range(4):\n            for c in range(n):\n                if current_grid[r][c] == 0:\n                    empty_spaces.add((r, c))\n        \n        # For each empty space, try to move adjacent cars into it\n        for er, ec in empty_spaces:\n            # Check all 4 directions for cars that can move here\n            for dr, dc in directions:\n                nr, nc = er + dr, ec + dc\n                \n                # Check bounds\n                if not (0 <= nr < 4 and 0 <= nc < n):\n                    continue\n                \n                car = current_grid[nr][nc]\n                if car == 0:  # No car here\n                    continue\n                \n                # Check if this is a valid move\n                valid_move = True\n                if er == 0 or er == 3:  # Moving to first or fourth row\n                    if (er, ec) != target_pos[car]:  # Must be the car's designated spot\n                        valid_move = False\n                \n                if valid_move:\n                    # Make the move\n                    new_pos_dict = pos_dict.copy()\n                    new_pos_dict[car] = (er, ec)\n                    \n                    new_state = state_key(new_pos_dict)\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        new_moves = moves + [(car, er + 1, ec + 1)]  # Convert to 1-indexed\n                        \n                        # Check if goal reached\n                        goal_reached = True\n                        for c_id in range(1, k + 1):\n                            if new_pos_dict[c_id] != target_pos[c_id]:\n                                goal_reached = False\n                                break\n                        \n                        if goal_reached:\n                            print(len(new_moves))\n                            for move in new_moves:\n                                print(move[0], move[1], move[2])\n                            return\n                        \n                        if len(new_moves) < 20000:\n                            queue.append((new_pos_dict, new_moves))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nfrom collections import deque\n\ndef main():\n    n, k = map(int, input().split())\n    grid = []\n    for _ in range(4):\n        grid.append(list(map(int, input().split())))\n    \n    # Parse initial positions and target positions\n    initial_pos = {}\n    target_pos = {}\n    for i in range(4):\n        for j in range(n):\n            val = grid[i][j]\n            if val != 0:\n                if i == 0 or i == 3:  # Target positions (rows 1 and 4 in 0-indexed)\n                    target_pos[val] = (i, j)\n                else:  # Initial positions (rows 2 and 3 in 0-indexed)\n                    initial_pos[val] = (i, j)\n    \n    # Check if already solved\n    solved = True\n    for car in range(1, k+1):\n        if initial_pos[car] != target_pos[car]:\n            solved = False\n            break\n    \n    if solved:\n        print(0)\n        return\n    \n    # BFS with state compression\n    def state_key(pos_dict):\n        return tuple(sorted((car, pos) for car, pos in pos_dict.items()))\n    \n    queue = deque([(initial_pos.copy(), [])])\n    visited = {state_key(initial_pos)}\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        pos_dict, moves = queue.popleft()\n        \n        if len(moves) >= 20000:\n            continue\n            \n        # Create current grid state\n        current_grid = [[0] * n for _ in range(4)]\n        for car, (r, c) in pos_dict.items():\n            current_grid[r][c] = car\n        \n        # Find all empty spaces\n        empty_spaces = set()\n        for r in range(4):\n            for c in range(n):\n                if current_grid[r][c] == 0:\n                    empty_spaces.add((r, c))\n        \n        # For each empty space, try to move adjacent cars into it\n        for er, ec in empty_spaces:\n            # Check all 4 directions for cars that can move here\n            for dr, dc in directions:\n                nr, nc = er + dr, ec + dc\n                \n                # Check bounds\n                if not (0 <= nr < 4 and 0 <= nc < n):\n                    continue\n                \n                car = current_grid[nr][nc]\n                if car == 0:  # No car here\n                    continue\n                \n                # Check if this is a valid move\n                valid_move = True\n                if er == 0 or er == 3:  # Moving to first or fourth row\n                    if (er, ec) != target_pos[car]:  # Must be the car's designated spot\n                        valid_move = False\n                \n                if valid_move:\n                    # Make the move\n                    new_pos_dict = pos_dict.copy()\n                    new_pos_dict[car] = (er, ec)\n                    \n                    new_state = state_key(new_pos_dict)\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        new_moves = moves + [(car, er + 1, ec + 1)]  # Convert to 1-indexed\n                        \n                        # Check if goal reached\n                        goal_reached = True\n                        for c_id in range(1, k + 1):\n                            if new_pos_dict[c_id] != target_pos[c_id]:\n                                goal_reached = False\n                                break\n                        \n                        if goal_reached:\n                            print(len(new_moves))\n                            for move in new_moves:\n                                print(move[0], move[1], move[2])\n                            return\n                        \n                        if len(new_moves) < 20000:\n                            queue.append((new_pos_dict, new_moves))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [21067], "completion_tokens": [8265], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2047}
{"name": "2026", "description": "Yaroslav is playing a game called \"Time\". The game has a timer showing the lifespan he's got left. As soon as the timer shows 0, Yaroslav's character dies and the game ends. Also, the game has n clock stations, station number i is at point (x_{i}, y_{i}) of the plane. As the player visits station number i, he increases the current time on his timer by a_{i}. The stations are for one-time use only, so if the player visits some station another time, the time on his timer won't grow.\n\nA player spends d\u00b7dist time units to move between stations, where dist is the distance the player has covered and d is some constant. The distance between stations i and j is determined as |x_{i} - x_{j}| + |y_{i} - y_{j}|.\n\nInitially, the player is at station number 1, and the player has strictly more than zero and strictly less than one units of time. At station number 1 one unit of money can increase the time on the timer by one time unit (you can buy only integer number of time units).\n\nNow Yaroslav is wondering, how much money he needs to get to station n. Help Yaroslav. Consider the time to buy and to increase the timer value negligibly small.\n\n\n-----Input-----\n\nThe first line contains integers n and d (3 \u2264 n \u2264 100, 10^3 \u2264 d \u2264 10^5) \u2014 the number of stations and the constant from the statement.\n\nThe second line contains n - 2 integers: a_2, a_3, ..., a_{n} - 1 (1 \u2264 a_{i} \u2264 10^3). The next n lines contain the coordinates of the stations. The i-th of them contains two integers x_{i}, y_{i} (-100 \u2264 x_{i}, y_{i} \u2264 100).\n\nIt is guaranteed that no two stations are located at the same point.\n\n\n-----Output-----\n\nIn a single line print an integer \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n3 1000\n1000\n0 0\n0 1\n0 3\n\nOutput\n2000\n\nInput\n3 1000\n1000\n1 0\n1 1\n1 2\n\nOutput\n1000", "difficulty": "competition", "id": 2026, "sample_io": [{"input": "3 1000\n1000\n0 0\n0 1\n0 3\n", "output": ["2000\n"]}, {"input": "3 1000\n1000\n1 0\n1 1\n1 2\n", "output": ["1000\n"]}], "test_list": [{"input": "3 1000\n1000\n0 0\n0 1\n0 3\n", "output": ["2000\n"]}, {"input": "3 1000\n1000\n1 0\n1 1\n1 2\n", "output": ["1000\n"]}, {"input": "5 1421\n896 448 727\n-19 -40\n-87 40\n69 51\n-55 61\n-7 67\n", "output": ["169099\n"]}, {"input": "6 1000\n142 712 254 869\n7 0\n95 38\n96 -20\n-7 93\n75 -45\n-80 -20\n", "output": ["107000\n"]}, {"input": "7 1288\n943 265 649 447 806\n-4 -51\n-26 32\n47 -28\n31 32\n61 65\n-45 -37\n82 42\n", "output": ["229903\n"]}, {"input": "8 1931\n440 627 324 538 539 119\n-85 -41\n-91 61\n-84 11\n92 -19\n8 -5\n16 -25\n97 -98\n91 78\n", "output": ["569018\n"]}, {"input": "9 1829\n98 513 987 291 162 637 356\n38 -3\n-89 93\n-86 45\n-43 -84\n-3 -87\n53 -59\n18 -19\n81 -74\n-85 32\n", "output": ["288982\n"]}, {"input": "10 1000\n759 222 589 423 947 507 31 414\n-4 -71\n-31 -53\n24 28\n-13 -65\n-59 -49\n-42 -79\n85 -71\n-60 -17\n28 66\n74 2\n", "output": ["151000\n"]}, {"input": "11 1199\n282 735 54 1000 419 939 901 789 128\n10 -81\n26 72\n19 -91\n-61 85\n0 -33\n-62 79\n-59 65\n-2 -77\n-63 100\n-15 53\n94 54\n", "output": ["262581\n"]}, {"input": "12 1609\n196 486 94 344 524 588 315 504 449 201\n86 -22\n-2 25\n-95 -8\n-5 -30\n-78 71\n5 -54\n-69 -92\n-41 0\n10 19\n61 17\n75 -39\n-46 22\n", "output": ["282231\n"]}, {"input": "3 97325\n40\n43 43\n45 -95\n-93 63\n", "output": ["15182700\n"]}, {"input": "11 1615\n137 681 199 33 388 585 241 518 7\n-60 89\n24 6\n-100 -55\n-26 -90\n-40 -33\n-100 28\n12 34\n-60 -13\n38 -89\n62 81\n-35 54\n", "output": ["96900\n"]}, {"input": "4 62071\n706 480\n6 96\n51 -12\n99 66\n-69 -61\n", "output": ["14400472\n"]}, {"input": "12 1542\n389 356 290 648 182 94 585 988 762 494\n-46 96\n1 88\n0 95\n-91 -100\n-42 -29\n45 -27\n-52 -34\n-62 27\n-19 46\n-100 95\n5 -55\n-36 -65\n", "output": ["263034\n"]}, {"input": "3 100000\n1\n-100 -100\n-100 -99\n100 100\n", "output": ["39999999\n"]}, {"input": "12 1211\n1 5 7 1000 1000 1000 1000 1000 1000 1000\n1 1\n5 5\n3 4\n4 3\n0 1\n0 2\n0 5\n0 7\n1 0\n3 0\n8 0\n10 10\n", "output": ["20220\n"]}, {"input": "6 1000\n1000 1000 1000 1000\n0 0\n0 -1\n1 -1\n2 -1\n2 0\n2 1\n", "output": ["1000\n"]}], "starter_code": "", "source_codes": ["import heapq\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    d = int(data[idx])\n    idx += 1\n    \n    # a[i] corresponds to station i+1 (stations 2 to n-1)\n    a = [0] * (n + 1)  # 1-indexed\n    for i in range(n - 2):\n        a[i + 2] = int(data[idx])  # a[2] is station 2's reward, etc.\n        idx += 1\n    \n    coords = []\n    for i in range(n):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        coords.append((x, y))\n    \n    # Calculate distances\n    def manhattan(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    # Build distance matrix\n    dist = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist[i][j] = manhattan(coords[i], coords[j])\n    \n    # Dijkstra\n    # State: (money_spent, station, time_balance)\n    # Since initial time is in (0,1), we model this as starting with 0 time\n    # and any negative balance represents money needed\n    \n    # We need to be careful about time balance bounds\n    INF = float('inf')\n    # money_spent, station, time_balance\n    pq = [(0, 0, 0)]  # start at station 0 (1-indexed station 1) with 0 time balance\n    visited = {}  # (station, time_balance) -> min_money\n    \n    while pq:\n        money, u, time_bal = heapq.heappop(pq)\n        \n        if u == n - 1:  # Reached destination (0-indexed n-1 = station n)\n            print(money)\n            return\n        \n        # Create a key for visited check - we need to discretize time balance\n        # Since we're looking for minimum money, we can normalize time balance\n        # Key insight: if time_balance is large enough, we don't need to track exact values\n        threshold = 1000000  # Large enough threshold\n        normalized_time = min(time_bal, threshold)\n        key = (u, normalized_time)\n        \n        if key in visited and visited[key] <= money:\n            continue\n        visited[key] = money\n        \n        # Try going to all other stations\n        for v in range(n):\n            if v == u:\n                continue\n                \n            # Calculate travel cost\n            travel_cost = d * dist[u][v]\n            new_time_bal = time_bal - travel_cost\n            new_money = money\n            \n            # Collect reward if this is a reward station (station 2 through n-1 in 1-indexed)\n            # In 0-indexed: stations 1 through n-2\n            if 1 <= v <= n - 2:  # 0-indexed stations 1 to n-2 correspond to 1-indexed stations 2 to n-1\n                new_time_bal += a[v + 1]  # a is 1-indexed, so station v(0-indexed) is station v+1(1-indexed)\n            \n            # If time goes negative, we need to pay money to cover deficit\n            if new_time_bal < 0:\n                new_money += (-new_time_bal)\n                new_time_bal = 0\n            \n            # Normalize the new time balance for visited check\n            normalized_new_time = min(new_time_bal, threshold)\n            \n            # Check if this path is worth exploring\n            state_key = (v, normalized_new_time)\n            if state_key not in visited or visited[state_key] > new_money:\n                heapq.heappush(pq, (new_money, v, new_time_bal))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    d = int(data[idx])\n    idx += 1\n    \n    # a[i] corresponds to station i+1 (stations 2 to n-1)\n    a = [0] * (n + 1)  # 1-indexed\n    for i in range(n - 2):\n        a[i + 2] = int(data[idx])  # a[2] is station 2's reward, etc.\n        idx += 1\n    \n    coords = []\n    for i in range(n):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        coords.append((x, y))\n    \n    # Calculate distances\n    def manhattan(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    # Build distance matrix\n    dist = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist[i][j] = manhattan(coords[i], coords[j])\n    \n    # Dijkstra\n    # State: (money_spent, station, time_balance)\n    # Since initial time is in (0,1), we model this as starting with 0 time\n    # and any negative balance represents money needed\n    \n    # We need to be careful about time balance bounds\n    INF = float('inf')\n    # money_spent, station, time_balance\n    pq = [(0, 0, 0)]  # start at station 0 (1-indexed station 1) with 0 time balance\n    visited = {}  # (station, time_balance) -> min_money\n    \n    while pq:\n        money, u, time_bal = heapq.heappop(pq)\n        \n        if u == n - 1:  # Reached destination (0-indexed n-1 = station n)\n            print(money)\n            return\n        \n        # Create a key for visited check - we need to discretize time balance\n        # Since we're looking for minimum money, we can normalize time balance\n        # Key insight: if time_balance is large enough, we don't need to track exact values\n        threshold = 1000000  # Large enough threshold\n        normalized_time = min(time_bal, threshold)\n        key = (u, normalized_time)\n        \n        if key in visited and visited[key] <= money:\n            continue\n        visited[key] = money\n        \n        # Try going to all other stations\n        for v in range(n):\n            if v == u:\n                continue\n                \n            # Calculate travel cost\n            travel_cost = d * dist[u][v]\n            new_time_bal = time_bal - travel_cost\n            new_money = money\n            \n            # Collect reward if this is a reward station (station 2 through n-1 in 1-indexed)\n            # In 0-indexed: stations 1 through n-2\n            if 1 <= v <= n - 2:  # 0-indexed stations 1 to n-2 correspond to 1-indexed stations 2 to n-1\n                new_time_bal += a[v + 1]  # a is 1-indexed, so station v(0-indexed) is station v+1(1-indexed)\n            \n            # If time goes negative, we need to pay money to cover deficit\n            if new_time_bal < 0:\n                new_money += (-new_time_bal)\n                new_time_bal = 0\n            \n            # Normalize the new time balance for visited check\n            normalized_new_time = min(new_time_bal, threshold)\n            \n            # Check if this path is worth exploring\n            state_key = (v, normalized_new_time)\n            if state_key not in visited or visited[state_key] > new_money:\n                heapq.heappush(pq, (new_money, v, new_time_bal))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [14530], "completion_tokens": [8869], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2026}
{"name": "2146", "description": "Have you ever used the chat application QQ? Well, in a chat group of QQ, administrators can muzzle a user for days.\n\nIn Boboniu's chat group, there's a person called Du Yi who likes to make fun of Boboniu every day.\n\nDu will chat in the group for $n$ days. On the $i$-th day:  If Du can speak, he'll make fun of Boboniu with fun factor $a_i$. But after that, he may be muzzled depending on Boboniu's mood.  Otherwise, Du won't do anything. \n\nBoboniu's mood is a constant $m$. On the $i$-th day:  If Du can speak and $a_i>m$, then Boboniu will be angry and muzzle him for $d$ days, which means that Du won't be able to speak on the $i+1, i+2, \\cdots, \\min(i+d,n)$-th days.  Otherwise, Boboniu won't do anything. \n\nThe total fun factor is the sum of the fun factors on the days when Du can speak.\n\nDu asked you to find the maximum total fun factor among all possible permutations of $a$.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $d$ and $m$ ($1\\le d\\le n\\le 10^5,0\\le m\\le 10^9$).\n\nThe next line contains $n$ integers $a_1, a_2, \\ldots,a_n$ ($0\\le a_i\\le 10^9$).\n\n\n-----Output-----\n\nPrint one integer: the maximum total fun factor among all permutations of $a$.\n\n\n-----Examples-----\nInput\n5 2 11\n8 10 15 23 5\n\nOutput\n48\n\nInput\n20 2 16\n20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7\n\nOutput\n195\n\n\n\n-----Note-----\n\nIn the first example, you can set $a'=[15, 5, 8, 10, 23]$. Then Du's chatting record will be:  Make fun of Boboniu with fun factor $15$.  Be muzzled.  Be muzzled.  Make fun of Boboniu with fun factor $10$.  Make fun of Boboniu with fun factor $23$. \n\nThus the total fun factor is $48$.", "difficulty": "competition", "id": 2146, "sample_io": [{"input": "5 2 11\n8 10 15 23 5\n", "output": ["48\n"]}, {"input": "20 2 16\n20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7\n", "output": ["195\n"]}], "test_list": [{"input": "5 2 11\n8 10 15 23 5\n", "output": ["48\n"]}, {"input": "20 2 16\n20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7\n", "output": ["195\n"]}, {"input": "1 1 0\n0\n", "output": ["0\n"]}, {"input": "100 61 71\n11 18 0 47 33 75 91 13 8 21 73 64 50 97 62 50 2 36 68 32 64 74 32 77 81 41 23 44 40 36 45 33 21 68 57 79 75 23 67 37 99 27 30 56 75 62 75 63 46 19 79 42 11 66 21 25 2 12 89 48 75 7 57 85 80 14 82 29 66 47 29 10 1 84 79 39 33 81 73 51 80 67 52 25 38 68 57 53 38 83 83 3 86 29 50 46 3 68 88 10\n", "output": ["2765\n"]}, {"input": "10 3 10\n17 17 17 8 7 6 5 4 1 1\n", "output": ["64\n"]}, {"input": "79 14 68\n55 91 81 39 60 85 43 53 41 12 23 70 26 61 51 92 52 23 78 41 20 49 38 57 86 77 59 74 86 12 8 79 32 70 69 43 78 37 88 71 22 0 21 21 30 3 76 87 98 52 83 66 79 60 56 31 19 89 73 81 79 16 76 79 94 23 65 7 53 81 21 63 11 31 35 17 31 65 89\n", "output": ["2038\n"]}, {"input": "39 37 39\n38 56 198 166 86 51 13 54 101 143 82 138 122 146 86 198 81 177 92 56 107 58 124 82 41 126 79 47 191 41 188 108 38 12 18 57 68 134 79\n", "output": ["396\n"]}, {"input": "4 4 8\n84 25 75 21\n", "output": ["84\n"]}, {"input": "5 3 3\n8 5 5 1 14\n", "output": ["22\n"]}, {"input": "1 1 1\n2\n", "output": ["2\n"]}], "starter_code": "", "source_codes": ["def solve():\n    n, d, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Separate large and small elements\n    large = [x for x in a if x > m]\n    small = [x for x in a if x <= m]\n    \n    # Sort in descending order\n    large.sort(reverse=True)\n    small.sort(reverse=True)\n    \n    # Calculate prefix sums for efficiency\n    large_prefix = [0]\n    for x in large:\n        large_prefix.append(large_prefix[-1] + x)\n    \n    small_prefix = [0]\n    for x in small:\n        small_prefix.append(small_prefix[-1] + x)\n    \n    # Maximum number of large elements we can place\n    if not large:\n        max_large_count = 0\n    else:\n        max_large_count = min(len(large), (n + d) // (d + 1))\n    \n    max_fun = 0\n    \n    # Try placing i large elements\n    for i in range(max_large_count + 1):\n        # Positions needed: i large elements + (i-1)*d blocked positions\n        if i == 0:\n            positions_needed = 0\n        else:\n            positions_needed = i + (i - 1) * d\n        \n        if positions_needed <= n:\n            # Remaining positions for small elements\n            remaining_positions = n - positions_needed\n            small_count = min(remaining_positions, len(small))\n            \n            # Calculate total fun\n            fun = large_prefix[i] + small_prefix[small_count]\n            max_fun = max(max_fun, fun)\n    \n    print(max_fun)\n\nsolve()"], "responses": ["\ndef solve():\n    n, d, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Separate large and small elements\n    large = [x for x in a if x > m]\n    small = [x for x in a if x <= m]\n    \n    # Sort in descending order\n    large.sort(reverse=True)\n    small.sort(reverse=True)\n    \n    # Calculate prefix sums for efficiency\n    large_prefix = [0]\n    for x in large:\n        large_prefix.append(large_prefix[-1] + x)\n    \n    small_prefix = [0]\n    for x in small:\n        small_prefix.append(small_prefix[-1] + x)\n    \n    # Maximum number of large elements we can place\n    if not large:\n        max_large_count = 0\n    else:\n        max_large_count = min(len(large), (n + d) // (d + 1))\n    \n    max_fun = 0\n    \n    # Try placing i large elements\n    for i in range(max_large_count + 1):\n        # Positions needed: i large elements + (i-1)*d blocked positions\n        if i == 0:\n            positions_needed = 0\n        else:\n            positions_needed = i + (i - 1) * d\n        \n        if positions_needed <= n:\n            # Remaining positions for small elements\n            remaining_positions = n - positions_needed\n            small_count = min(remaining_positions, len(small))\n            \n            # Calculate total fun\n            fun = large_prefix[i] + small_prefix[small_count]\n            max_fun = max(max_fun, fun)\n    \n    print(max_fun)\n\nsolve()\n\n\n"], "prompt_tokens": [14032], "completion_tokens": [7781], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2146}
{"name": "2159", "description": "Polycarp is making a quest for his friends. He has already made n tasks, for each task the boy evaluated how interesting it is as an integer q_{i}, and the time t_{i} in minutes needed to complete the task. \n\nAn interesting feature of his quest is: each participant should get the task that is best suited for him, depending on his preferences. The task is chosen based on an interactive quiz that consists of some questions. The player should answer these questions with \"yes\" or \"no\". Depending on the answer to the question, the participant either moves to another question or goes to one of the tasks that are in the quest. In other words, the quest is a binary tree, its nodes contain questions and its leaves contain tasks. \n\nWe know that answering any of the questions that are asked before getting a task takes exactly one minute from the quest player. Polycarp knows that his friends are busy people and they can't participate in the quest for more than T minutes. Polycarp wants to choose some of the n tasks he made, invent the corresponding set of questions for them and use them to form an interactive quiz as a binary tree so that no matter how the player answers quiz questions, he spends at most T minutes on completing the whole quest (that is, answering all the questions and completing the task). Specifically, the quest can contain zero questions and go straight to the task. Each task can only be used once (i.e., the people who give different answers to questions should get different tasks).\n\nPolycarp wants the total \"interest\" value of the tasks involved in the quest to be as large as possible. Help him determine the maximum possible total interest value of the task considering that the quest should be completed in T minutes at any variant of answering questions.\n\n\n-----Input-----\n\nThe first line contains two integers n and T (1 \u2264 n \u2264 1000, 1 \u2264 T \u2264 100) \u2014 the number of tasks made by Polycarp and the maximum time a quest player should fit into.\n\nNext n lines contain two integers t_{i}, q_{i} (1 \u2264 t_{i} \u2264 T, 1 \u2264 q_{i} \u2264 1000) each \u2014 the time in minutes needed to complete the i-th task and its interest value.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum possible total interest value of all the tasks in the quest.\n\n\n-----Examples-----\nInput\n5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n\nOutput\n11\n\nInput\n5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n\nOutput\n9\n\nInput\n2 2\n1 1\n2 10\n\nOutput\n10\n\n\n\n-----Note-----\n\nIn the first sample test all the five tasks can be complemented with four questions and joined into one quest.\n\nIn the second sample test it is impossible to use all the five tasks, but you can take two of them, the most interesting ones.\n\nIn the third sample test the optimal strategy is to include only the second task into the quest.\n\nHere is the picture that illustrates the answers to the sample tests. The blue circles represent the questions, the two arrows that go from every circle represent where a person goes depending on his answer to that question. The tasks are the red ovals. [Image]", "difficulty": "competition", "id": 2159, "sample_io": [{"input": "5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n", "output": ["11\n"]}, {"input": "5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n", "output": ["9\n"]}, {"input": "2 2\n1 1\n2 10\n", "output": ["10\n"]}], "test_list": [{"input": "5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n", "output": ["11\n"]}, {"input": "5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n", "output": ["9\n"]}, {"input": "2 2\n1 1\n2 10\n", "output": ["10\n"]}, {"input": "10 1\n1 732\n1 649\n1 821\n1 756\n1 377\n1 216\n1 733\n1 420\n1 857\n1 193\n", "output": ["857\n"]}, {"input": "26 5\n2 377\n3 103\n1 547\n2 700\n3 616\n5 363\n2 316\n5 260\n3 385\n2 460\n4 206\n4 201\n3 236\n1 207\n1 400\n2 382\n2 365\n1 633\n1 775\n4 880\n1 808\n1 871\n3 518\n1 805\n3 771\n3 598\n", "output": ["6977\n"]}, {"input": "42 4\n1 897\n2 883\n1 766\n1 169\n3 671\n3 751\n2 204\n2 550\n3 873\n2 348\n2 286\n1 413\n1 551\n4 821\n2 573\n1 423\n4 59\n3 881\n2 450\n1 206\n3 181\n3 218\n3 870\n2 906\n1 695\n1 162\n3 370\n3 580\n2 874\n2 864\n3 47\n3 126\n2 494\n4 21\n3 791\n4 520\n4 917\n2 244\n4 74\n3 348\n4 416\n3 581\n", "output": ["4698\n"]}, {"input": "70 4\n1 83\n3 923\n2 627\n4 765\n3 74\n4 797\n4 459\n2 682\n1 840\n2 414\n4 797\n3 832\n3 203\n2 939\n4 694\n1 157\n3 544\n1 169\n3 100\n4 69\n1 851\n3 605\n4 562\n1 718\n3 74\n3 740\n2 655\n2 804\n2 218\n4 186\n4 999\n3 989\n2 407\n4 702\n2 15\n1 509\n4 376\n4 260\n1 533\n2 514\n3 520\n4 737\n2 877\n2 383\n1 556\n3 745\n2 659\n2 636\n2 443\n4 819\n2 382\n4 660\n1 376\n2 410\n3 379\n4 996\n3 944\n4 949\n2 485\n3 434\n3 786\n3 367\n4 403\n3 330\n3 625\n2 302\n3 673\n3 794\n3 411\n1 256\n", "output": ["4946\n"]}, {"input": "17 1\n1 632\n1 996\n1 665\n1 432\n1 565\n1 350\n1 857\n1 183\n1 982\n1 910\n1 938\n1 155\n1 176\n1 168\n1 419\n1 814\n1 487\n", "output": ["996\n"]}, {"input": "10 9\n1 518\n3 971\n5 862\n2 71\n8 138\n4 121\n6 967\n1 518\n9 754\n7 607\n", "output": ["4773\n"]}, {"input": "1 2\n1 1\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    T = int(data[1])\n    tasks = []\n    index = 2\n    for i in range(n):\n        t = int(data[index])\n        q = int(data[index+1])\n        tasks.append((q, t))  # (interest, time)\n        index += 2\n    \n    # Sort by interest descending\n    tasks.sort(reverse=True)\n    \n    max_interest = 0\n    \n    # Try all possible heights of the binary tree\n    for height in range(T + 1):  # height can be from 0 to T\n        # With this height, each task must satisfy: height + task_time <= T\n        max_task_time = T - height\n        \n        if max_task_time <= 0:\n            continue\n            \n        # Maximum number of tasks we can place with this height\n        max_tasks_count = 2 ** height if height > 0 else 1\n        \n        # Count how many tasks we can actually use\n        usable_tasks = 0\n        total_interest = 0\n        \n        for interest, time in tasks:\n            if time <= max_task_time and usable_tasks < max_tasks_count:\n                total_interest += interest\n                usable_tasks += 1\n            elif usable_tasks >= max_tasks_count:\n                break\n        \n        max_interest = max(max_interest, total_interest)\n    \n    print(max_interest)\n\nsolve()"], "responses": ["\nimport sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    T = int(data[1])\n    tasks = []\n    index = 2\n    for i in range(n):\n        t = int(data[index])\n        q = int(data[index+1])\n        tasks.append((q, t))  # (interest, time)\n        index += 2\n    \n    # Sort by interest descending\n    tasks.sort(reverse=True)\n    \n    max_interest = 0\n    \n    # Try all possible heights of the binary tree\n    for height in range(T + 1):  # height can be from 0 to T\n        # With this height, each task must satisfy: height + task_time <= T\n        max_task_time = T - height\n        \n        if max_task_time <= 0:\n            continue\n            \n        # Maximum number of tasks we can place with this height\n        max_tasks_count = 2 ** height if height > 0 else 1\n        \n        # Count how many tasks we can actually use\n        usable_tasks = 0\n        total_interest = 0\n        \n        for interest, time in tasks:\n            if time <= max_task_time and usable_tasks < max_tasks_count:\n                total_interest += interest\n                usable_tasks += 1\n            elif usable_tasks >= max_tasks_count:\n                break\n        \n        max_interest = max(max_interest, total_interest)\n    \n    print(max_interest)\n\nsolve()\n\n\n"], "prompt_tokens": [15955], "completion_tokens": [6705], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2159}
{"name": "2009", "description": "For a vector $\\vec{v} = (x, y)$, define $|v| = \\sqrt{x^2 + y^2}$.\n\nAllen had a bit too much to drink at the bar, which is at the origin. There are $n$ vectors $\\vec{v_1}, \\vec{v_2}, \\cdots, \\vec{v_n}$. Allen will make $n$ moves. As Allen's sense of direction is impaired, during the $i$-th move he will either move in the direction $\\vec{v_i}$ or $-\\vec{v_i}$. In other words, if his position is currently $p = (x, y)$, he will either move to $p + \\vec{v_i}$ or $p - \\vec{v_i}$.\n\nAllen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $p$ satisfies $|p| \\le 1.5 \\cdot 10^6$ so that he can stay safe.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the number of moves.\n\nEach of the following lines contains two space-separated integers $x_i$ and $y_i$, meaning that $\\vec{v_i} = (x_i, y_i)$. We have that $|v_i| \\le 10^6$ for all $i$.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers $c_1, c_2, \\cdots, c_n$, each of which is either $1$ or $-1$. Your solution is correct if the value of $p = \\sum_{i = 1}^n c_i \\vec{v_i}$, satisfies $|p| \\le 1.5 \\cdot 10^6$.\n\nIt can be shown that a solution always exists under the given constraints.\n\n\n-----Examples-----\nInput\n3\n999999 0\n0 999999\n999999 0\n\nOutput\n1 1 -1 \n\nInput\n1\n-824590 246031\n\nOutput\n1 \n\nInput\n8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n\nOutput\n1 1 1 1 1 1 1 -1", "difficulty": "competition", "id": 2009, "sample_io": [{"input": "3\n999999 0\n0 999999\n999999 0\n", "output": ["1 1 -1 \n"]}, {"input": "1\n-824590 246031\n", "output": ["1 \n"]}, {"input": "8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n", "output": ["1 1 1 1 1 1 1 -1 \n"]}], "test_list": [{"input": "3\n999999 0\n0 999999\n999999 0\n", "output": ["1 1 -1 \n"]}, {"input": "1\n-824590 246031\n", "output": ["1 \n"]}, {"input": "8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n", "output": ["1 1 1 1 1 1 1 -1 \n"]}, {"input": "6\n1000000 0\n1000000 0\n-1000000 0\n0 1000000\n0 -1000000\n0 -1000000\n", "output": ["1 1 1 1 1 1 \n"]}, {"input": "8\n-411248 143802\n300365 629658\n363219 343742\n396148 -94037\n-722124 467785\n-178147 -931253\n265458 73307\n-621502 -709713\n", "output": ["1 1 1 1 1 1 1 -1 \n"]}, {"input": "3\n1000000 0\n0 999999\n600000 -600000\n", "output": ["-1 1 1 \n"]}, {"input": "5\n140239 46311\n399464 -289055\n-540174 823360\n538102 -373313\n326189 933934\n", "output": ["1 1 1 1 -1 \n"]}, {"input": "3\n1000000 0\n0 999999\n300000 -300000\n", "output": ["1 1 -1 \n"]}, {"input": "9\n1000000 0\n0 -999999\n600000 600000\n600000 600000\n600000 600000\n-600000 -600000\n600000 600000\n600000 600000\n-700000 710000\n", "output": ["1 1 1 -1 1 1 1 -1 1 \n"]}, {"input": "2\n1 999999\n1 -999999\n", "output": ["1 1 \n"]}, {"input": "2\n999999 1\n999999 -1\n", "output": ["1 -1 \n"]}, {"input": "2\n-1 999999\n-1 -999999\n", "output": ["1 1 \n"]}, {"input": "2\n-999999 -1\n-999999 1\n", "output": ["1 -1 \n"]}, {"input": "2\n999999 1\n-999999 1\n", "output": ["1 1 \n"]}, {"input": "2\n999999 -1\n-999999 -1\n", "output": ["1 1 \n"]}, {"input": "2\n1 999999\n-1 999999\n", "output": ["1 -1 \n"]}, {"input": "2\n1 -999999\n-1 -999999\n", "output": ["1 -1 \n"]}, {"input": "4\n1000000 0\n-1 999999\n600000 -600000\n0 0\n", "output": ["-1 1 1 1 \n"]}, {"input": "2\n999999 -1\n-1 999999\n", "output": ["1 1 \n"]}], "starter_code": "", "source_codes": ["import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        vectors.append((x, y))\n    \n    x_sum, y_sum = 0, 0\n    signs = []\n    \n    for x, y in vectors:\n        # Calculate potential new positions\n        pos_plus = (x_sum + x, y_sum + y)\n        pos_minus = (x_sum - x, y_sum - y)\n        \n        # Calculate squared distances to avoid sqrt\n        dist_plus_sq = pos_plus[0]**2 + pos_plus[1]**2\n        dist_minus_sq = pos_minus[0]**2 + pos_minus[1]**2\n        \n        # Choose the sign that minimizes the distance\n        if dist_plus_sq <= dist_minus_sq:\n            signs.append(1)\n            x_sum, y_sum = pos_plus\n        else:\n            signs.append(-1)\n            x_sum, y_sum = pos_minus\n    \n    # Fix output formatting - no trailing space\n    print(' '.join(map(str, signs)), end='')\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        vectors.append((x, y))\n    \n    x_sum, y_sum = 0, 0\n    signs = []\n    \n    for x, y in vectors:\n        # Calculate potential new positions\n        pos_plus = (x_sum + x, y_sum + y)\n        pos_minus = (x_sum - x, y_sum - y)\n        \n        # Calculate squared distances to avoid sqrt\n        dist_plus_sq = pos_plus[0]**2 + pos_plus[1]**2\n        dist_minus_sq = pos_minus[0]**2 + pos_minus[1]**2\n        \n        # Choose the sign that minimizes the distance\n        if dist_plus_sq <= dist_minus_sq:\n            signs.append(1)\n            x_sum, y_sum = pos_plus\n        else:\n            signs.append(-1)\n            x_sum, y_sum = pos_minus\n    \n    # Fix output formatting - no trailing space\n    print(' '.join(map(str, signs)), end='')\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [15952], "completion_tokens": [4766], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2009}
{"name": "2066", "description": "In the official contest this problem has a different statement, for which jury's solution was working incorrectly, and for this reason it was excluded from the contest. This mistake have been fixed and the current given problem statement and model solution corresponds to what jury wanted it to be during the contest.\n\nVova and Lesha are friends. They often meet at Vova's place and compete against each other in a computer game named The Ancient Papyri: Swordsink. Vova always chooses a warrior as his fighter and Leshac chooses an archer. After that they should choose initial positions for their characters and start the fight. A warrior is good at melee combat, so Vova will try to make the distance between fighters as small as possible. An archer prefers to keep the enemy at a distance, so Lesha will try to make the initial distance as large as possible.\n\nThere are n (n is always even) possible starting positions for characters marked along the Ox axis. The positions are given by their distinct coordinates x_1, x_2, ..., x_{n}, two characters cannot end up at the same position.\n\nVova and Lesha take turns banning available positions, Vova moves first. During each turn one of the guys bans exactly one of the remaining positions. Banned positions cannot be used by both Vova and Lesha. They continue to make moves until there are only two possible positions remaining (thus, the total number of moves will be n - 2). After that Vova's character takes the position with the lesser coordinate and Lesha's character takes the position with the bigger coordinate and the guys start fighting.\n\nVova and Lesha are already tired by the game of choosing positions, as they need to play it before every fight, so they asked you (the developer of the The Ancient Papyri: Swordsink) to write a module that would automatically determine the distance at which the warrior and the archer will start fighting if both Vova and Lesha play optimally.\n\n\n-----Input-----\n\nThe first line on the input contains a single integer n (2 \u2264 n \u2264 200 000, n is even)\u00a0\u2014 the number of positions available initially. The second line contains n distinct integers x_1, x_2, ..., x_{n} (0 \u2264 x_{i} \u2264 10^9), giving the coordinates of the corresponding positions.\n\n\n-----Output-----\n\nPrint the distance between the warrior and the archer at the beginning of the fight, provided that both Vova and Lesha play optimally.\n\n\n-----Examples-----\nInput\n6\n0 1 3 7 15 31\n\nOutput\n7\n\nInput\n2\n73 37\n\nOutput\n36\n\n\n\n-----Note-----\n\nIn the first sample one of the optimum behavior of the players looks like that:  Vova bans the position at coordinate 15;  Lesha bans the position at coordinate 3;  Vova bans the position at coordinate 31;  Lesha bans the position at coordinate 1. \n\nAfter these actions only positions 0 and 7 will remain, and the distance between them is equal to 7.\n\nIn the second sample there are only two possible positions, so there will be no bans.", "difficulty": "competition", "id": 2066, "sample_io": [{"input": "6\n0 1 3 7 15 31\n", "output": ["7\n"]}, {"input": "2\n73 37\n", "output": ["36\n"]}], "test_list": [{"input": "6\n0 1 3 7 15 31\n", "output": ["7\n"]}, {"input": "2\n73 37\n", "output": ["36\n"]}, {"input": "2\n0 1000000000\n", "output": ["1000000000\n"]}, {"input": "8\n729541013 135019377 88372488 319157478 682081360 558614617 258129110 790518782\n", "output": ["470242129\n"]}, {"input": "2\n0 1\n", "output": ["1\n"]}, {"input": "8\n552283832 997699491 89302459 301640204 288141798 31112026 710831619 862166501\n", "output": ["521171806\n"]}, {"input": "4\n0 500000000 500000001 1000000000\n", "output": ["500000000\n"]}, {"input": "18\n515925896 832652240 279975694 570998878 28122427 209724246 898414431 709461320 358922485 439508829 403574907 358500312 596248410 968234748 187793884 728450713 30350176 528924900\n", "output": ["369950401\n"]}, {"input": "20\n713900269 192811911 592111899 609607891 585084800 601258511 223103775 876894656 751583891 230837577 971499807 312977833 344314550 397998873 558637732 216574673 913028292 762852863 464376621 61315042\n", "output": ["384683838\n"]}, {"input": "10\n805513144 38998401 16228409 266085559 293487744 471510400 138613792 649258082 904651590 244678415\n", "output": ["277259335\n"]}, {"input": "6\n0 166666666 333333333 499999998 666666665 833333330\n", "output": ["499999997\n"]}, {"input": "16\n1 62500001 125000001 187500000 250000000 312500000 375000000 437500001 500000000 562500000 625000000 687500001 750000001 812500002 875000002 937500000\n", "output": ["499999999\n"]}, {"input": "12\n5 83333336 166666669 250000001 333333336 416666670 500000004 583333336 666666667 750000001 833333334 916666671\n", "output": ["499999998\n"]}, {"input": "20\n54 50000046 100000041 150000049 200000061 250000039 300000043 350000054 400000042 450000045 500000076 550000052 600000064 650000065 700000055 750000046 800000044 850000042 900000052 950000054\n", "output": ["499999988\n"]}], "starter_code": "", "source_codes": ["def solve():\n    n = int(input())\n    xs = list(map(int, input().split()))\n    xs.sort()\n    \n    # Calculate consecutive differences\n    gaps = [xs[i+1] - xs[i] for i in range(n-1)]\n    gaps.sort()\n    \n    # For optimal play, the answer is the median of gaps\n    # Which is at index (n-2)//2 for 0-based indexing when we have n-1 gaps\n    print(gaps[(n-2)//2])\n\nsolve()"], "responses": ["\ndef solve():\n    n = int(input())\n    xs = list(map(int, input().split()))\n    xs.sort()\n    \n    # Calculate consecutive differences\n    gaps = [xs[i+1] - xs[i] for i in range(n-1)]\n    gaps.sort()\n    \n    # For optimal play, the answer is the median of gaps\n    # Which is at index (n-2)//2 for 0-based indexing when we have n-1 gaps\n    print(gaps[(n-2)//2])\n\nsolve()\n\n\n"], "prompt_tokens": [13054], "completion_tokens": [7883], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2066}
{"name": "2162", "description": "Consider a tree $T$ (that is, a connected graph without cycles) with $n$ vertices labelled $1$ through $n$. We start the following process with $T$: while $T$ has more than one vertex, do the following:\n\n\n\n choose a random edge of $T$ equiprobably;\n\n shrink the chosen edge: if the edge was connecting vertices $v$ and $u$, erase both $v$ and $u$ and create a new vertex adjacent to all vertices previously adjacent to either $v$ or $u$. The new vertex is labelled either $v$ or $u$ equiprobably.\n\nAt the end of the process, $T$ consists of a single vertex labelled with one of the numbers $1, \\ldots, n$. For each of the numbers, what is the probability of this number becoming the label of the final vertex?\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\leq n \\leq 50$).\n\nThe following $n - 1$ lines describe the tree edges. Each of these lines contains two integers $u_i, v_i$\u00a0\u2014 labels of vertices connected by the respective edge ($1 \\leq u_i, v_i \\leq n$, $u_i \\neq v_i$). It is guaranteed that the given graph is a tree.\n\n\n-----Output-----\n\nPrint $n$ floating numbers\u00a0\u2014 the desired probabilities for labels $1, \\ldots, n$ respectively. All numbers should be correct up to $10^{-6}$ relative or absolute precision.\n\n\n-----Examples-----\nInput\n4\n1 2\n1 3\n1 4\n\nOutput\n0.1250000000\n0.2916666667\n0.2916666667\n0.2916666667\n\nInput\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\nOutput\n0.0850694444\n0.0664062500\n0.0664062500\n0.1955295139\n0.1955295139\n0.1955295139\n0.1955295139\n\n\n\n-----Note-----\n\nIn the first sample, the resulting vertex has label 1 if and only if for all three edges the label 1 survives, hence the probability is $1/2^3 = 1/8$. All other labels have equal probability due to symmetry, hence each of them has probability $(1 - 1/8) / 3 = 7/24$.", "difficulty": "competition", "id": 2162, "sample_io": [{"input": "4\n1 2\n1 3\n1 4\n", "output": ["0.1250000000\n0.2916666667\n0.2916666667\n0.2916666667\n"]}, {"input": "7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n", "output": ["0.0850694444\n0.0664062500\n0.0664062500\n0.1955295139\n0.1955295139\n0.1955295139\n0.1955295139\n"]}], "test_list": [{"input": "4\n1 2\n1 3\n1 4\n", "output": ["0.1250000000\n0.2916666667\n0.2916666667\n0.2916666667\n"]}, {"input": "7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n", "output": ["0.0850694444\n0.0664062500\n0.0664062500\n0.1955295139\n0.1955295139\n0.1955295139\n0.1955295139\n"]}, {"input": "1\n", "output": ["1.0000000000\n"]}, {"input": "10\n9 8\n7 4\n10 7\n6 7\n1 9\n4 9\n9 3\n2 3\n1 5\n", "output": ["0.0716733902\n0.1568513416\n0.0716733902\n0.0513075087\n0.1568513416\n0.1496446398\n0.0462681362\n0.1274088542\n0.0186767578\n0.1496446398\n"]}, {"input": "20\n13 11\n4 12\n17 16\n15 19\n16 6\n7 6\n6 8\n12 2\n19 20\n1 8\n4 17\n18 12\n9 5\n14 13\n11 15\n1 19\n3 13\n4 9\n15 10\n", "output": ["0.0241401787\n0.0917954309\n0.0976743034\n0.0150433990\n0.1006279377\n0.0150716827\n0.0758016731\n0.0241290115\n0.0444770708\n0.0796739239\n0.0310518413\n0.0248005499\n0.0287209519\n0.0976743034\n0.0160891602\n0.0248310267\n0.0253902066\n0.0917954309\n0.0146375074\n0.0765744099\n"]}, {"input": "30\n15 21\n21 3\n22 4\n5 18\n26 25\n12 24\n11 2\n27 13\n11 14\n7 29\n10 26\n16 17\n16 27\n16 1\n3 22\n5 19\n2 23\n4 10\n8 4\n1 20\n30 22\n9 3\n28 15\n23 4\n4 1\n2 7\n5 27\n6 26\n6 24\n", "output": ["0.0047521072\n0.0089582002\n0.0091024503\n0.0005692947\n0.0158713738\n0.0231639046\n0.0280364616\n0.0385477047\n0.0508439275\n0.0104849699\n0.0280364616\n0.0756812249\n0.0527268460\n0.0663906850\n0.0348291400\n0.0067068947\n0.0473003760\n0.0620785158\n0.0620785158\n0.0431676433\n0.0225005681\n0.0055308416\n0.0101877956\n0.0354105896\n0.0520300528\n0.0099339742\n0.0093540308\n0.0748580820\n0.0663906850\n0.0444766827\n"]}, {"input": "2\n2 1\n", "output": ["0.5000000000\n0.5000000000\n"]}, {"input": "3\n2 1\n3 2\n", "output": ["0.3750000000\n0.2500000000\n0.3750000000\n"]}, {"input": "4\n3 1\n3 2\n2 4\n", "output": ["0.3125000000\n0.1875000000\n0.1875000000\n0.3125000000\n"]}], "starter_code": "", "source_codes": ["import sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(sys.stdin.readline())\n    \n    if n == 1:\n        print(\"1.0000000000\")\n        return\n    \n    adj = defaultdict(list)\n    \n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # For each vertex, compute probability that its label becomes final\n    def dfs(node, parent):\n        # Returns probability array where prob[i] = probability that label i becomes final\n        # when we only consider the subtree rooted at node\n        \n        # Start with node's own probability = 1, others = 0\n        prob = [0.0] * (n + 1)\n        prob[node] = 1.0\n        \n        # Count children\n        children = [child for child in adj[node] if child != parent]\n        \n        # For each child, we need to merge its subtree into current node\n        for child in children:\n            child_prob = dfs(child, node)\n            \n            # When we contract the edge (node, child), the resulting vertex\n            # gets label node with prob 0.5 or label child with prob 0.5\n            # So the probability distribution becomes the average of the two\n            new_prob = [0.0] * (n + 1)\n            for i in range(1, n + 1):\n                new_prob[i] = 0.5 * prob[i] + 0.5 * child_prob[i]\n            prob = new_prob\n        \n        return prob\n    \n    # Run DFS from node 1\n    result = dfs(1, -1)\n    \n    # Output probabilities for labels 1 through n\n    for i in range(1, n + 1):\n        print(f\"{result[i]:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(sys.stdin.readline())\n    \n    if n == 1:\n        print(\"1.0000000000\")\n        return\n    \n    adj = defaultdict(list)\n    \n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # For each vertex, compute probability that its label becomes final\n    def dfs(node, parent):\n        # Returns probability array where prob[i] = probability that label i becomes final\n        # when we only consider the subtree rooted at node\n        \n        # Start with node's own probability = 1, others = 0\n        prob = [0.0] * (n + 1)\n        prob[node] = 1.0\n        \n        # Count children\n        children = [child for child in adj[node] if child != parent]\n        \n        # For each child, we need to merge its subtree into current node\n        for child in children:\n            child_prob = dfs(child, node)\n            \n            # When we contract the edge (node, child), the resulting vertex\n            # gets label node with prob 0.5 or label child with prob 0.5\n            # So the probability distribution becomes the average of the two\n            new_prob = [0.0] * (n + 1)\n            for i in range(1, n + 1):\n                new_prob[i] = 0.5 * prob[i] + 0.5 * child_prob[i]\n            prob = new_prob\n        \n        return prob\n    \n    # Run DFS from node 1\n    result = dfs(1, -1)\n    \n    # Output probabilities for labels 1 through n\n    for i in range(1, n + 1):\n        print(f\"{result[i]:.10f}\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [16731], "completion_tokens": [6698], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2162}
{"name": "2192", "description": "There are n beacons located at distinct positions on a number line. The i-th beacon has position a_{i} and power level b_{i}. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance b_{i} inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.\n\nSaitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 the initial number of beacons.\n\nThe i-th of next n lines contains two integers a_{i} and b_{i} (0 \u2264 a_{i} \u2264 1 000 000, 1 \u2264 b_{i} \u2264 1 000 000)\u00a0\u2014 the position and power level of the i-th beacon respectively. No two beacons will have the same position, so a_{i} \u2260 a_{j} if i \u2260 j.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimum number of beacons that could be destroyed if exactly one beacon is added.\n\n\n-----Examples-----\nInput\n4\n1 9\n3 1\n6 1\n7 4\n\nOutput\n1\n\nInput\n7\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nFor the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.\n\nFor the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.", "difficulty": "competition", "id": 2192, "sample_io": [{"input": "4\n1 9\n3 1\n6 1\n7 4\n", "output": ["1\n"]}, {"input": "7\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n", "output": ["3\n"]}], "test_list": [{"input": "4\n1 9\n3 1\n6 1\n7 4\n", "output": ["1\n"]}, {"input": "7\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n", "output": ["3\n"]}, {"input": "1\n0 1\n", "output": ["0\n"]}, {"input": "1\n0 1000000\n", "output": ["0\n"]}, {"input": "1\n1000000 1000000\n", "output": ["0\n"]}, {"input": "7\n1 1\n2 1\n3 1\n4 1\n5 1\n6 6\n7 7\n", "output": ["4\n"]}, {"input": "5\n1 1\n3 1\n5 1\n7 10\n8 10\n", "output": ["2\n"]}, {"input": "11\n110 90\n100 70\n90 10\n80 10\n70 1\n60 1\n50 10\n40 1\n30 1\n10 1\n20 1\n", "output": ["4\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef count_destruction(beacons):\n    \"\"\"Count how many beacons are destroyed when processing beacons from right to left\"\"\"\n    n = len(beacons)\n    if n == 0:\n        return 0\n    \n    alive = [True] * n\n    destroyed = 0\n    \n    # Process from right to left\n    for i in range(n - 1, -1, -1):\n        if not alive[i]:\n            continue\n            \n        pos, power = beacons[i]\n        left_boundary = pos - power\n        \n        # Destroy beacons to the left within range\n        for j in range(i):\n            if alive[j] and beacons[j][0] >= left_boundary:\n                alive[j] = False\n                destroyed += 1\n    \n    return destroyed\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    beacons = []\n    index = 1\n    for i in range(n):\n        a = int(data[index])\n        b = int(data[index+1])\n        beacons.append((a, b))\n        index += 2\n    \n    # Sort beacons by position\n    beacons.sort()\n    \n    min_destroyed = n  # worst case\n    \n    # Try having our added beacon destroy k beacons (k from 0 to n)\n    for k in range(n + 1):\n        # Our added beacon destroys k rightmost beacons\n        # So we're left with beacons[0:n-k]\n        remaining = beacons[:n-k] if k < n else []\n        destroyed_by_added = k\n        destroyed_by_remaining = count_destruction(remaining)\n        total = destroyed_by_added + destroyed_by_remaining\n        min_destroyed = min(min_destroyed, total)\n    \n    print(min_destroyed)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef count_destruction(beacons):\n    \"\"\"Count how many beacons are destroyed when processing beacons from right to left\"\"\"\n    n = len(beacons)\n    if n == 0:\n        return 0\n    \n    alive = [True] * n\n    destroyed = 0\n    \n    # Process from right to left\n    for i in range(n - 1, -1, -1):\n        if not alive[i]:\n            continue\n            \n        pos, power = beacons[i]\n        left_boundary = pos - power\n        \n        # Destroy beacons to the left within range\n        for j in range(i):\n            if alive[j] and beacons[j][0] >= left_boundary:\n                alive[j] = False\n                destroyed += 1\n    \n    return destroyed\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    beacons = []\n    index = 1\n    for i in range(n):\n        a = int(data[index])\n        b = int(data[index+1])\n        beacons.append((a, b))\n        index += 2\n    \n    # Sort beacons by position\n    beacons.sort()\n    \n    min_destroyed = n  # worst case\n    \n    # Try having our added beacon destroy k beacons (k from 0 to n)\n    for k in range(n + 1):\n        # Our added beacon destroys k rightmost beacons\n        # So we're left with beacons[0:n-k]\n        remaining = beacons[:n-k] if k < n else []\n        destroyed_by_added = k\n        destroyed_by_remaining = count_destruction(remaining)\n        total = destroyed_by_added + destroyed_by_remaining\n        min_destroyed = min(min_destroyed, total)\n    \n    print(min_destroyed)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [12594], "completion_tokens": [10570], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2192}
{"name": "2056", "description": "You are given two binary strings $a$ and $b$ of the same length. You can perform the following two operations on the string $a$:\n\n  Swap any two bits at indices $i$ and $j$ respectively ($1 \\le i, j \\le n$), the cost of this operation is $|i - j|$, that is, the absolute difference between $i$ and $j$.  Select any arbitrary index $i$ ($1 \\le i \\le n$) and flip (change $0$ to $1$ or $1$ to $0$) the bit at this index. The cost of this operation is $1$. \n\nFind the minimum cost to make the string $a$ equal to $b$. It is not allowed to modify string $b$.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^6$)\u00a0\u2014 the length of the strings $a$ and $b$.\n\nThe second and third lines contain strings $a$ and $b$ respectively.\n\nBoth strings $a$ and $b$ have length $n$ and contain only '0' and '1'.\n\n\n-----Output-----\n\nOutput the minimum cost to make the string $a$ equal to $b$.\n\n\n-----Examples-----\nInput\n3\n100\n001\n\nOutput\n2\n\nInput\n4\n0101\n0011\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, one of the optimal solutions is to flip index $1$ and index $3$, the string $a$ changes in the following way: \"100\" $\\to$ \"000\" $\\to$ \"001\". The cost is $1 + 1 = 2$.\n\nThe other optimal solution is to swap bits and indices $1$ and $3$, the string $a$ changes then \"100\" $\\to$ \"001\", the cost is also $|1 - 3| = 2$.\n\nIn the second example, the optimal solution is to swap bits at indices $2$ and $3$, the string $a$ changes as \"0101\" $\\to$ \"0011\". The cost is $|2 - 3| = 1$.", "difficulty": "competition", "id": 2056, "sample_io": [{"input": "3\n100\n001\n", "output": ["2\n"]}, {"input": "4\n0101\n0011\n", "output": ["1\n"]}], "test_list": [{"input": "3\n100\n001\n", "output": ["2\n"]}, {"input": "4\n0101\n0011\n", "output": ["1\n"]}, {"input": "8\n10001001\n01101110\n", "output": ["4\n"]}, {"input": "1\n0\n1\n", "output": ["1\n"]}, {"input": "6\n110110\n000000\n", "output": ["4\n"]}, {"input": "15\n101010101010101\n010101010101010\n", "output": ["8\n"]}, {"input": "7\n1110001\n0000000\n", "output": ["4\n"]}, {"input": "7\n1110001\n0000001\n", "output": ["3\n"]}, {"input": "91\n0010010000110001001011011011111001000110001000100111110010010001100110010111100111011111100\n1101110110000100110000100011010110111101100000011011100111111000110000001101101111100100101\n", "output": ["43\n"]}, {"input": "19\n1111010011111010100\n1010000110100110110\n", "output": ["8\n"]}, {"input": "2\n10\n01\n", "output": ["1\n"]}, {"input": "10\n1010101010\n1010101010\n", "output": ["0\n"]}, {"input": "1\n1\n1\n", "output": ["0\n"]}, {"input": "2\n10\n00\n", "output": ["1\n"]}, {"input": "4\n1000\n0001\n", "output": ["2\n"]}], "starter_code": "", "source_codes": ["def min_cost_to_equal(a, b):\n    n = len(a)\n    mismatches = []\n    \n    # Find all positions where a[i] != b[i]\n    for i in range(n):\n        if a[i] != b[i]:\n            mismatches.append(i)\n    \n    # If no mismatches, cost is 0\n    if not mismatches:\n        return 0\n    \n    # Number of mismatches\n    count = len(mismatches)\n    \n    # If odd number of mismatches, we must flip one bit (cost 1)\n    # and optimally pair the rest\n    if count % 2 == 1:\n        # We need to flip one position individually\n        # The best strategy is to find which position to flip to minimize total cost\n        min_cost = float('inf')\n        \n        # Try flipping each mismatch position and solve for remaining optimally\n        for i in range(count):\n            # Remove the i-th mismatch (this one we'll flip individually, cost = 1)\n            remaining = mismatches[:i] + mismatches[i+1:]\n            \n            # Pair up remaining positions optimally\n            pairing_cost = 0\n            for j in range(0, len(remaining), 2):\n                pos1 = remaining[j]\n                pos2 = remaining[j + 1]\n                swap_cost = abs(pos2 - pos1)\n                # Choose minimum between swapping and flipping both individually\n                pairing_cost += min(swap_cost, 2)\n            \n            total_cost = 1 + pairing_cost  # 1 for the individual flip\n            min_cost = min(min_cost, total_cost)\n        \n        return min_cost\n    else:\n        # Even number of mismatches - pair them optimally using dynamic programming\n        # Sort positions for better pairing\n        mismatches.sort()\n        \n        # DP approach: dp[i] = minimum cost to fix first i mismatches\n        dp = [float('inf')] * (count + 1)\n        dp[0] = 0\n        \n        for i in range(2, count + 1):\n            # Option 1: pair (i-2)th and (i-1)th mismatch\n            swap_cost = mismatches[i-1] - mismatches[i-2]  # since sorted\n            dp[i] = min(dp[i], dp[i-2] + min(swap_cost, 2))\n            \n            # Option 2: don't pair them but pair with previous ones if possible\n            if i >= 4:\n                # Try different pairings\n                pass\n        \n        # Simpler greedy approach for even case:\n        # Pair consecutive elements optimally\n        total_cost = 0\n        for i in range(0, count, 2):\n            pos1 = mismatches[i]\n            pos2 = mismatches[i + 1]\n            swap_cost = abs(pos2 - pos1)\n            total_cost += min(swap_cost, 2)\n        \n        return total_cost\n\n# Read input\nn = int(input())\na = input().strip()\nb = input().strip()\n\n# Calculate and print result\nresult = min_cost_to_equal(a, b)\nprint(result)"], "responses": ["\ndef min_cost_to_equal(a, b):\n    n = len(a)\n    mismatches = []\n    \n    # Find all positions where a[i] != b[i]\n    for i in range(n):\n        if a[i] != b[i]:\n            mismatches.append(i)\n    \n    # If no mismatches, cost is 0\n    if not mismatches:\n        return 0\n    \n    # Number of mismatches\n    count = len(mismatches)\n    \n    # If odd number of mismatches, we must flip one bit (cost 1)\n    # and optimally pair the rest\n    if count % 2 == 1:\n        # We need to flip one position individually\n        # The best strategy is to find which position to flip to minimize total cost\n        min_cost = float('inf')\n        \n        # Try flipping each mismatch position and solve for remaining optimally\n        for i in range(count):\n            # Remove the i-th mismatch (this one we'll flip individually, cost = 1)\n            remaining = mismatches[:i] + mismatches[i+1:]\n            \n            # Pair up remaining positions optimally\n            pairing_cost = 0\n            for j in range(0, len(remaining), 2):\n                pos1 = remaining[j]\n                pos2 = remaining[j + 1]\n                swap_cost = abs(pos2 - pos1)\n                # Choose minimum between swapping and flipping both individually\n                pairing_cost += min(swap_cost, 2)\n            \n            total_cost = 1 + pairing_cost  # 1 for the individual flip\n            min_cost = min(min_cost, total_cost)\n        \n        return min_cost\n    else:\n        # Even number of mismatches - pair them optimally using dynamic programming\n        # Sort positions for better pairing\n        mismatches.sort()\n        \n        # DP approach: dp[i] = minimum cost to fix first i mismatches\n        dp = [float('inf')] * (count + 1)\n        dp[0] = 0\n        \n        for i in range(2, count + 1):\n            # Option 1: pair (i-2)th and (i-1)th mismatch\n            swap_cost = mismatches[i-1] - mismatches[i-2]  # since sorted\n            dp[i] = min(dp[i], dp[i-2] + min(swap_cost, 2))\n            \n            # Option 2: don't pair them but pair with previous ones if possible\n            if i >= 4:\n                # Try different pairings\n                pass\n        \n        # Simpler greedy approach for even case:\n        # Pair consecutive elements optimally\n        total_cost = 0\n        for i in range(0, count, 2):\n            pos1 = mismatches[i]\n            pos2 = mismatches[i + 1]\n            swap_cost = abs(pos2 - pos1)\n            total_cost += min(swap_cost, 2)\n        \n        return total_cost\n\n# Read input\nn = int(input())\na = input().strip()\nb = input().strip()\n\n# Calculate and print result\nresult = min_cost_to_equal(a, b)\nprint(result)\n\n\n"], "prompt_tokens": [11717], "completion_tokens": [5989], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2056}
{"name": "2060", "description": "Evlampiy has found one more cool application to process photos. However the application has certain limitations.\n\nEach photo i has a contrast v_{i}. In order for the processing to be truly of high quality, the application must receive at least k photos with contrasts which differ as little as possible.\n\nEvlampiy already knows the contrast v_{i} for each of his n photos. Now he wants to split the photos into groups, so that each group contains at least k photos. As a result, each photo must belong to exactly one group.\n\nHe considers a processing time of the j-th group to be the difference between the maximum and minimum values of v_{i} in the group. Because of multithreading the processing time of a division into groups is the maximum processing time among all groups.\n\nSplit n photos into groups in a such way that the processing time of the division is the minimum possible, i.e. that the the maximum processing time over all groups as least as possible.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 \u2264 k \u2264 n \u2264 3\u00b710^5) \u2014 number of photos and minimum size of a group.\n\nThe second line contains n integers v_1, v_2, ..., v_{n} (1 \u2264 v_{i} \u2264 10^9), where v_{i} is the contrast of the i-th photo.\n\n\n-----Output-----\n\nPrint the minimal processing time of the division into groups.\n\n\n-----Examples-----\nInput\n5 2\n50 110 130 40 120\n\nOutput\n20\n\nInput\n4 1\n2 3 4 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the photos should be split into 2 groups: [40, 50] and [110, 120, 130]. The processing time of the first group is 10, and the processing time of the second group is 20. Maximum among 10 and 20 is 20. It is impossible to split the photos into groups in a such way that the processing time of division is less than 20.\n\nIn the second example the photos should be split into four groups, each containing one photo. So the minimal possible processing time of a division is 0.", "difficulty": "competition", "id": 2060, "sample_io": [{"input": "5 2\n50 110 130 40 120\n", "output": ["20\n"]}, {"input": "4 1\n2 3 4 1\n", "output": ["0\n"]}], "test_list": [{"input": "5 2\n50 110 130 40 120\n", "output": ["20\n"]}, {"input": "4 1\n2 3 4 1\n", "output": ["0\n"]}, {"input": "1 1\n4\n", "output": ["0\n"]}, {"input": "2 2\n7 5\n", "output": ["2\n"]}, {"input": "3 2\n34 3 75\n", "output": ["72\n"]}, {"input": "5 2\n932 328 886 96 589\n", "output": ["343\n"]}, {"input": "10 4\n810 8527 9736 3143 2341 6029 7474 707 2513 2023\n", "output": ["3707\n"]}, {"input": "20 11\n924129 939902 178964 918687 720767 695035 577430 407131 213304 810868 596349 266075 123602 376312 36680 18426 716200 121546 61834 851586\n", "output": ["921476\n"]}, {"input": "100 28\n1 2 3 5 1 1 1 4 1 5 2 4 3 2 5 4 1 1 4 1 4 5 4 1 4 5 1 3 5 1 1 1 4 2 5 2 3 5 2 2 3 2 4 5 5 5 5 1 2 4 1 3 1 1 1 4 3 1 5 2 5 1 3 3 2 4 5 1 1 3 4 1 1 3 3 1 2 4 3 3 4 4 3 1 2 1 5 1 4 4 2 3 1 3 3 4 2 4 1 1\n", "output": ["1\n"]}, {"input": "101 9\n3 2 2 1 4 1 3 2 3 4 3 2 3 1 4 4 1 1 4 1 3 3 4 1 2 1 1 3 1 2 2 4 3 1 4 3 1 1 4 4 1 2 1 1 4 2 3 4 1 2 1 4 4 1 4 3 1 4 2 1 2 1 4 3 4 3 4 2 2 4 3 2 1 3 4 3 2 2 4 3 3 2 4 1 3 2 2 4 1 3 4 2 1 3 3 2 2 1 1 3 1\n", "output": ["0\n"]}, {"input": "2 2\n1 1000000000\n", "output": ["999999999\n"]}, {"input": "2 1\n1 1000000000\n", "output": ["0\n"]}, {"input": "11 3\n412 3306 3390 2290 1534 316 1080 2860 253 230 3166\n", "output": ["1122\n"]}, {"input": "10 3\n2414 294 184 666 2706 1999 2201 1270 904 653\n", "output": ["707\n"]}, {"input": "24 4\n33 27 12 65 19 6 46 33 57 2 21 50 73 13 59 69 51 45 39 1 6 64 39 27\n", "output": ["9\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef can_partition(arr, n, k, max_diff):\n    groups = 0\n    i = 0\n    while i < n:\n        # Start a new group\n        groups += 1\n        start = i\n        # Include as many elements as possible in this group\n        # But we need to make sure we don't take too many and leave insufficient for remaining groups\n        while i < n and arr[i] - arr[start] <= max_diff:\n            # Check if taking elements from start to i leaves enough for remaining groups\n            # This is a simpler check - just be greedy but ensure current group has at least k\n            i += 1\n        \n        # Check if this group has enough elements\n        if i - start < k:\n            return False\n            \n        # Check if we have enough elements left for remaining groups\n        # This check is not needed as we're being greedy forward\n        \n    return True\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    v = list(map(int, sys.stdin.readline().split()))\n    \n    v.sort()\n    \n    left, right = 0, v[-1] - v[0]\n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_partition(v, n, k, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(result)\n\nsolve()"], "responses": ["\nimport sys\n\ndef can_partition(arr, n, k, max_diff):\n    groups = 0\n    i = 0\n    while i < n:\n        # Start a new group\n        groups += 1\n        start = i\n        # Include as many elements as possible in this group\n        # But we need to make sure we don't take too many and leave insufficient for remaining groups\n        while i < n and arr[i] - arr[start] <= max_diff:\n            # Check if taking elements from start to i leaves enough for remaining groups\n            # This is a simpler check - just be greedy but ensure current group has at least k\n            i += 1\n        \n        # Check if this group has enough elements\n        if i - start < k:\n            return False\n            \n        # Check if we have enough elements left for remaining groups\n        # This check is not needed as we're being greedy forward\n        \n    return True\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    v = list(map(int, sys.stdin.readline().split()))\n    \n    v.sort()\n    \n    left, right = 0, v[-1] - v[0]\n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_partition(v, n, k, mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [12140], "completion_tokens": [3877], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": 2060}
{"name": "2087", "description": "Vasya has n items lying in a line. The items are consecutively numbered by numbers from 1 to n in such a way that the leftmost item has number 1, the rightmost item has number n. Each item has a weight, the i-th item weights w_{i} kilograms.\n\nVasya needs to collect all these items, however he won't do it by himself. He uses his brand new robot. The robot has two different arms \u2014 the left one and the right one. The robot can consecutively perform the following actions:   Take the leftmost item with the left hand and spend w_{i} \u00b7 l energy units (w_{i} is a weight of the leftmost item, l is some parameter). If the previous action was the same (left-hand), then the robot spends extra Q_{l} energy units;  Take the rightmost item with the right hand and spend w_{j} \u00b7 r energy units (w_{j} is a weight of the rightmost item, r is some parameter). If the previous action was the same (right-hand), then the robot spends extra Q_{r} energy units; \n\nNaturally, Vasya wants to program the robot in a way that the robot spends as little energy as possible. He asked you to solve this problem. Your task is to find the minimum number of energy units robot spends to collect all items.\n\n\n-----Input-----\n\nThe first line contains five integers n, l, r, Q_{l}, Q_{r} (1 \u2264 n \u2264 10^5; 1 \u2264 l, r \u2264 100; 1 \u2264 Q_{l}, Q_{r} \u2264 10^4).\n\nThe second line contains n integers w_1, w_2, ..., w_{n} (1 \u2264 w_{i} \u2264 100).\n\n\n-----Output-----\n\nIn the single line print a single number \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n3 4 4 19 1\n42 3 99\n\nOutput\n576\n\nInput\n4 7 2 3 9\n1 2 3 4\n\nOutput\n34\n\n\n\n-----Note-----\n\nConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4\u00b742 + 4\u00b799 + 4\u00b73 = 576 energy units.\n\nThe second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2\u00b74) + (7\u00b71) + (2\u00b73) + (2\u00b72 + 9) = 34 energy units.", "difficulty": "competition", "id": 2087, "sample_io": [{"input": "3 4 4 19 1\n42 3 99\n", "output": ["576\n"]}, {"input": "4 7 2 3 9\n1 2 3 4\n", "output": ["34\n"]}], "test_list": [{"input": "3 4 4 19 1\n42 3 99\n", "output": ["576\n"]}, {"input": "4 7 2 3 9\n1 2 3 4\n", "output": ["34\n"]}, {"input": "2 100 100 10000 10000\n100 100\n", "output": ["20000\n"]}, {"input": "2 3 4 5 6\n1 2\n", "output": ["11\n"]}, {"input": "1 78 94 369 10000\n93\n", "output": ["7254\n"]}, {"input": "1 94 78 369 10000\n93\n", "output": ["7254\n"]}, {"input": "5 1 100 1 10000\n1 2 3 4 5\n", "output": ["19\n"]}, {"input": "5 100 1 10000 1\n1 2 3 4 5\n", "output": ["19\n"]}, {"input": "5 1 100 10000 1\n1 2 3 4 5\n", "output": ["906\n"]}, {"input": "5 100 1 1 10000\n1 2 3 4 5\n", "output": ["312\n"]}, {"input": "6 32 47 965 897\n7 4 1 3 5 4\n", "output": ["948\n"]}, {"input": "7 3 13 30 978\n1 2 3 4 5 1 7\n", "output": ["199\n"]}, {"input": "7 13 3 978 30\n7 1 5 4 3 2 1\n", "output": ["199\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef main():\n    n, l, r, Ql, Qr = map(int, sys.stdin.readline().split())\n    w = list(map(int, sys.stdin.readline().split()))\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(i, j, last):\n        \"\"\"\n        Returns minimum energy to collect items from index i to j inclusive.\n        last: 0 if last move was left, 1 if right, -1 if none (initial state)\n        \"\"\"\n        if i > j:\n            return 0\n            \n        if (i, j, last) in memo:\n            return memo[(i, j, last)]\n        \n        # Option 1: Take from left (index i)\n        cost_left = w[i] * l\n        if last == 0:  # previous was also left\n            cost_left += Ql\n        cost_left += dp(i + 1, j, 0)\n        \n        # Option 2: Take from right (index j)\n        cost_right = w[j] * r\n        if last == 1:  # previous was also right\n            cost_right += Qr\n        cost_right += dp(i, j - 1, 1)\n        \n        res = min(cost_left, cost_right)\n        memo[(i, j, last)] = res\n        return res\n    \n    result = dp(0, n - 1, -1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    n, l, r, Ql, Qr = map(int, sys.stdin.readline().split())\n    w = list(map(int, sys.stdin.readline().split()))\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(i, j, last):\n        \"\"\"\n        Returns minimum energy to collect items from index i to j inclusive.\n        last: 0 if last move was left, 1 if right, -1 if none (initial state)\n        \"\"\"\n        if i > j:\n            return 0\n            \n        if (i, j, last) in memo:\n            return memo[(i, j, last)]\n        \n        # Option 1: Take from left (index i)\n        cost_left = w[i] * l\n        if last == 0:  # previous was also left\n            cost_left += Ql\n        cost_left += dp(i + 1, j, 0)\n        \n        # Option 2: Take from right (index j)\n        cost_right = w[j] * r\n        if last == 1:  # previous was also right\n            cost_right += Qr\n        cost_right += dp(i, j - 1, 1)\n        \n        res = min(cost_left, cost_right)\n        memo[(i, j, last)] = res\n        return res\n    \n    result = dp(0, n - 1, -1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13726], "completion_tokens": [5145], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2087}
