{"name": "4411", "description": "# Background:\n\nYou're working in a number zoo, and it seems that one of the numbers has gone missing!\n\nZoo workers have no idea what number is missing, and are too incompetent to figure it out, so they're hiring you to do it for them.\n\nIn case the zoo loses another number, they want your program to work regardless of how many numbers there are in total.\n\n___\n\n## Task:\n\nWrite a function that takes a shuffled list of unique numbers from `1` to `n` with one element missing (which can be any number including `n`). Return this missing number.\n\n**Note**: huge lists will be tested.\n\n## Examples:\n\n```\n[1, 3, 4]  =>  2\n[1, 2, 3]  =>  4\n[4, 2, 3]  =>  1\n```", "difficulty": "introductory", "id": 4411, "sample_io": [{"input": "[1, 2, 3]", "output": [4]}, {"input": "[1, 3, 4]", "output": [2]}, {"input": "[4, 2, 3]", "output": [1]}], "test_list": [{"input": "[2, 3, 4]", "output": [1]}, {"input": "[1, 3, 4]", "output": [2]}, {"input": "[1, 2, 4]", "output": [3]}, {"input": "[1, 2, 3]", "output": [4]}, {"input": "[]", "output": [1]}, {"input": "[1]", "output": [2]}, {"input": "[2]", "output": [1]}], "starter_code": "\ndef find_missing_number(numbers):\n\t", "source_codes": ["def find_missing_number(arr):\n    n = len(arr) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum\n\n# Read input and process\nimport sys\ninput_str = input().strip()\nif input_str.startswith('[') and input_str.endswith(']'):\n    # Parse the list from string representation\n    inner_content = input_str[1:-1].strip()\n    if inner_content:\n        numbers_str = inner_content.split(',')\n        numbers = [int(x.strip()) for x in numbers_str]\n    else:\n        numbers = []\nelse:\n    # Handle space-separated input\n    if input_str:\n        numbers = [int(x) for x in input_str.split()]\n    else:\n        numbers = []\n\nresult = find_missing_number(numbers)\nprint(result)"], "responses": ["\ndef find_missing_number(arr):\n    n = len(arr) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum\n\n# Read input and process\nimport sys\ninput_str = input().strip()\nif input_str.startswith('[') and input_str.endswith(']'):\n    # Parse the list from string representation\n    inner_content = input_str[1:-1].strip()\n    if inner_content:\n        numbers_str = inner_content.split(',')\n        numbers = [int(x.strip()) for x in numbers_str]\n    else:\n        numbers = []\nelse:\n    # Handle space-separated input\n    if input_str:\n        numbers = [int(x) for x in input_str.split()]\n    else:\n        numbers = []\n\nresult = find_missing_number(numbers)\nprint(result)\n\n\n"], "prompt_tokens": [7201], "completion_tokens": [2716], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4411}
{"name": "3741", "description": "Calculate the number of items in a vector that appear at the same index in each vector, with the same value. \n\n```python\n   vector_affinity([1, 2, 3, 4, 5], [1, 2, 2, 4, 3]) # => 0.6\n   vector_affinity([1, 2, 3], [1, 2, 3]) # => 1.0\n```\n\nAffinity value should be realized on a scale of 0.0 to 1.0, with 1.0 being absolutely identical. Two identical sets should always be evaulated as having an affinity or 1.0.\n\nHint: The last example test case holds a significant clue to calculating the affinity correctly.", "difficulty": "introductory", "id": 3741, "sample_io": [{"input": "[1, 2, 3, 4, 5]\n[1, 2, 2, 4, 3]", "output": [0.6]}, {"input": "[1, 2, 3]\n[1, 2, 3]", "output": [1.0]}], "test_list": [{"input": "[1, 2, 3]\n[1, 2, 3, 4, 5]", "output": [0.6]}, {"input": "[1, 2, 3, 4]\n[1, 2, 3, 5]", "output": [0.75]}, {"input": "[1, 2, 3, 4, 5]\n[]", "output": [0.0]}, {"input": "[1, 2, 3]\n[1, 2, 3]", "output": [1.0]}, {"input": "[6, 6, 6, 6, 6, 6]\n[6, None, None, 6, 6, None]", "output": [0.5]}, {"input": "[6]\n[6, 6, 6, 6, 6, 6]", "output": [0.16666666666666666]}, {"input": "[]\n[]", "output": [1.0]}, {"input": "[None]\n[None]", "output": [1.0]}], "starter_code": "\ndef vector_affinity(a, b):\n\t", "source_codes": ["def vector_affinity(vec1, vec2):\n    if not vec1 and not vec2:\n        return 1.0\n    \n    min_length = min(len(vec1), len(vec2))\n    \n    if min_length == 0:\n        return 1.0\n        \n    matches = sum(1 for i in range(min_length) if vec1[i] == vec2[i])\n    return matches / min_length\n\nvec1 = eval(input())\nvec2 = eval(input())\nprint(vector_affinity(vec1, vec2))", "def vector_affinity(vector1, vector2):\n    # Handle case where both vectors are empty\n    if not vector1 and not vector2:\n        return 1.0\n    \n    # Get the minimum length to avoid index errors\n    min_length = min(len(vector1), len(vector2))\n    \n    # If one or both vectors are empty\n    if min_length == 0:\n        return 1.0  # According to test case 6\n    \n    # Count matches at same indices\n    matches = 0\n    for i in range(min_length):\n        if vector1[i] == vector2[i]:\n            matches += 1\n    \n    # Return affinity as ratio of matches to comparison length\n    return float(matches) / float(min_length)\n\n# Read input\nvector1_str = input().strip()\nvector2_str = input().strip()\n\n# Parse vectors safely\ndef parse_vector(s):\n    # Remove brackets and whitespace\n    s = s.strip()\n    if s == '[]':\n        return []\n    # Remove brackets and split\n    content = s[1:-1].strip()\n    if not content:\n        return []\n    # Split by comma and convert to integers\n    return [int(x.strip()) for x in content.split(',') if x.strip()]\n\nvector1 = parse_vector(vector1_str)\nvector2 = parse_vector(vector2_str)\n\n# Calculate and print result\nresult = vector_affinity(vector1, vector2)\nprint(result)", "def vector_affinity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError(\"Vectors must have the same length\")\n    \n    if len(vec1) == 0:\n        return 1.0\n    \n    matching_positions = sum(1 for a, b in zip(vec1, vec2) if a == b)\n    return matching_positions / len(vec1)\n\n# Read input\nvec1_str = input().strip()\nvec2_str = input().strip()\n\n# Parse vectors - remove brackets and split by comma\nvec1_str = vec1_str.strip('[]').strip()\nvec2_str = vec2_str.strip('[]').strip()\n\nif vec1_str == '':\n    vec1 = []\nelse:\n    vec1 = [int(x.strip()) for x in vec1_str.split(',')]\n\nif vec2_str == '':\n    vec2 = []\nelse:\n    vec2 = [int(x.strip()) for x in vec2_str.split(',')]\n\n# Calculate and print result\nresult = vector_affinity(vec1, vec2)\nprint(result)", "def vector_affinity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError(\"Vectors must have the same length\")\n    \n    if len(vec1) == 0:\n        return 1.0\n    \n    matching_count = sum(1 for a, b in zip(vec1, vec2) if a == b)\n    return matching_count / len(vec1)\n\n# Read input from stdin\nvec1_str = input().strip()\nvec2_str = input().strip()\n\n# Parse strings to lists more safely\nvec1 = eval(vec1_str)\nvec2 = eval(vec2_str)\n\n# Calculate and print the affinity\nresult = vector_affinity(vec1, vec2)\nprint(result)", "import ast\n\ndef vector_affinity(vec1, vec2):\n    if not vec1 and not vec2:\n        return 1.0\n    \n    min_length = min(len(vec1), len(vec2))\n    max_length = max(len(vec1), len(vec2))\n    \n    if max_length == 0:\n        return 1.0\n        \n    matches = sum(1 for i in range(min_length) if vec1[i] == vec2[i])\n    return matches / max_length\n\n# Read input\nvec1 = ast.literal_eval(input())\nvec2 = ast.literal_eval(input())\n\n# Calculate and print result\nresult = vector_affinity(vec1, vec2)\nprint(result)"], "responses": ["\ndef vector_affinity(vec1, vec2):\n    if not vec1 and not vec2:\n        return 1.0\n    \n    min_length = min(len(vec1), len(vec2))\n    \n    if min_length == 0:\n        return 1.0\n        \n    matches = sum(1 for i in range(min_length) if vec1[i] == vec2[i])\n    return matches / min_length\n\nvec1 = eval(input())\nvec2 = eval(input())\nprint(vector_affinity(vec1, vec2))\n\n\n", "\ndef vector_affinity(vector1, vector2):\n    # Handle case where both vectors are empty\n    if not vector1 and not vector2:\n        return 1.0\n    \n    # Get the minimum length to avoid index errors\n    min_length = min(len(vector1), len(vector2))\n    \n    # If one or both vectors are empty\n    if min_length == 0:\n        return 1.0  # According to test case 6\n    \n    # Count matches at same indices\n    matches = 0\n    for i in range(min_length):\n        if vector1[i] == vector2[i]:\n            matches += 1\n    \n    # Return affinity as ratio of matches to comparison length\n    return float(matches) / float(min_length)\n\n# Read input\nvector1_str = input().strip()\nvector2_str = input().strip()\n\n# Parse vectors safely\ndef parse_vector(s):\n    # Remove brackets and whitespace\n    s = s.strip()\n    if s == '[]':\n        return []\n    # Remove brackets and split\n    content = s[1:-1].strip()\n    if not content:\n        return []\n    # Split by comma and convert to integers\n    return [int(x.strip()) for x in content.split(',') if x.strip()]\n\nvector1 = parse_vector(vector1_str)\nvector2 = parse_vector(vector2_str)\n\n# Calculate and print result\nresult = vector_affinity(vector1, vector2)\nprint(result)\n\n\n", "\ndef vector_affinity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError(\"Vectors must have the same length\")\n    \n    if len(vec1) == 0:\n        return 1.0\n    \n    matching_positions = sum(1 for a, b in zip(vec1, vec2) if a == b)\n    return matching_positions / len(vec1)\n\n# Read input\nvec1_str = input().strip()\nvec2_str = input().strip()\n\n# Parse vectors - remove brackets and split by comma\nvec1_str = vec1_str.strip('[]').strip()\nvec2_str = vec2_str.strip('[]').strip()\n\nif vec1_str == '':\n    vec1 = []\nelse:\n    vec1 = [int(x.strip()) for x in vec1_str.split(',')]\n\nif vec2_str == '':\n    vec2 = []\nelse:\n    vec2 = [int(x.strip()) for x in vec2_str.split(',')]\n\n# Calculate and print result\nresult = vector_affinity(vec1, vec2)\nprint(result)\n\n\n", "\ndef vector_affinity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError(\"Vectors must have the same length\")\n    \n    if len(vec1) == 0:\n        return 1.0\n    \n    matching_count = sum(1 for a, b in zip(vec1, vec2) if a == b)\n    return matching_count / len(vec1)\n\n# Read input from stdin\nvec1_str = input().strip()\nvec2_str = input().strip()\n\n# Parse strings to lists more safely\nvec1 = eval(vec1_str)\nvec2 = eval(vec2_str)\n\n# Calculate and print the affinity\nresult = vector_affinity(vec1, vec2)\nprint(result)\n\n\n", "\nimport ast\n\ndef vector_affinity(vec1, vec2):\n    if not vec1 and not vec2:\n        return 1.0\n    \n    min_length = min(len(vec1), len(vec2))\n    max_length = max(len(vec1), len(vec2))\n    \n    if max_length == 0:\n        return 1.0\n        \n    matches = sum(1 for i in range(min_length) if vec1[i] == vec2[i])\n    return matches / max_length\n\n# Read input\nvec1 = ast.literal_eval(input())\nvec2 = ast.literal_eval(input())\n\n# Calculate and print result\nresult = vector_affinity(vec1, vec2)\nprint(result)\n\n\n"], "prompt_tokens": [8385, 9058, 7671, 7790, 8984], "completion_tokens": [4595, 5068, 2849, 2351, 3641], "no_of_try": 5, "api_calls": 50, "is_solved": true, "language": "Python3", "task_id": 3741}
{"name": "3242", "description": "# Task\nGiven an integer array `arr`. Your task is to remove one element, maximize the product of elements. \n\nThe result is the element which should be removed. If more than one valid results exist, return the smallest one.\n\n\n# Input/Output\n\n\n`[input]` integer array `arr`\n\nnon-empty unsorted integer array. It contains positive integer, negative integer or zero.\n\n`3 \u2264 arr.length \u2264 15`\n\n`-10 \u2264 arr[i] \u2264 10`\n\n`[output]` an integer\n\nThe element that should be removed.\n\n# Example\n\nFor `arr = [1, 2, 3]`, the output should be `1`.\n\nFor `arr = [-1, 2, -3]`, the output should be `2`.\n\nFor `arr = [-1, -2, -3]`, the output should be `-1`.\n\nFor `arr = [-1, -2, -3, -4]`, the output should be `-4`.", "difficulty": "introductory", "id": 3242, "sample_io": [{"input": "[1, 2, 3]", "output": [1]}, {"input": "[-1, 2, -3]", "output": [2]}, {"input": "[-1, -2, -3]", "output": [-1]}, {"input": "[-1, -2, -3, -4]", "output": [-4]}], "test_list": [{"input": "[1, 2, 3]", "output": [1]}, {"input": "[-1, 2, -3]", "output": [2]}, {"input": "[-1, -2, -3]", "output": [-1]}, {"input": "[-1, -2, -3, -4]", "output": [-4]}, {"input": "[0, 1, 2, 3]", "output": [0]}, {"input": "[0, -1, -2, -3]", "output": [-3]}, {"input": "[0, -1, -2, -3, -4]", "output": [0]}, {"input": "[0, -1, 2, -3, 4]", "output": [0]}, {"input": "[0, -1, 2, 3]", "output": [-1]}, {"input": "[0, -1, -2, -3, 4]", "output": [-3]}, {"input": "[0, 0, 1]", "output": [0]}, {"input": "[0, 0, -1]", "output": [-1]}, {"input": "[0, -1, 1]", "output": [-1]}, {"input": "[0, 0, -1, 1]", "output": [-1]}, {"input": "[0, 0, 0]", "output": [0]}, {"input": "[0, 0, 1, 2, 3]", "output": [0]}, {"input": "[-1, -2, -3, 0, 1, 2, 3]", "output": [-3]}, {"input": "[-1, -2, 0, 1, 2]", "output": [0]}, {"input": "[-1, -2, 1, 2]", "output": [1]}, {"input": "[-1, -2, -3, 1, 2, 3]", "output": [-1]}], "starter_code": "\ndef maximum_product(arr):\n\t", "source_codes": ["def max_product_after_removal(arr):\n    max_product = float('-inf')\n    element_to_remove = None\n    \n    for i in range(len(arr)):\n        # Create new array without the current element\n        new_arr = arr[:i] + arr[i+1:]\n        \n        # Calculate product of remaining elements\n        product = 1\n        for num in new_arr:\n            product *= num\n        \n        # Update if we found a better product or same product with smaller element\n        if product > max_product or (product == max_product and arr[i] < element_to_remove):\n            max_product = product\n            element_to_remove = arr[i]\n    \n    return element_to_remove\n\n# Read input and parse it correctly\nimport ast\narr = ast.literal_eval(input().strip())\n\n# Find and print result\nresult = max_product_after_removal(arr)\nprint(result)"], "responses": ["\ndef max_product_after_removal(arr):\n    max_product = float('-inf')\n    element_to_remove = None\n    \n    for i in range(len(arr)):\n        # Create new array without the current element\n        new_arr = arr[:i] + arr[i+1:]\n        \n        # Calculate product of remaining elements\n        product = 1\n        for num in new_arr:\n            product *= num\n        \n        # Update if we found a better product or same product with smaller element\n        if product > max_product or (product == max_product and arr[i] < element_to_remove):\n            max_product = product\n            element_to_remove = arr[i]\n    \n    return element_to_remove\n\n# Read input and parse it correctly\nimport ast\narr = ast.literal_eval(input().strip())\n\n# Find and print result\nresult = max_product_after_removal(arr)\nprint(result)\n\n\n"], "prompt_tokens": [8904], "completion_tokens": [3018], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3242}
{"name": "4453", "description": "# Summary:\nGiven a number, `num`, return the shortest amount of `steps` it would take from 1, to land exactly on that number.\n\n# Description:\nA `step` is defined as either:\n- Adding 1 to the number: `num += 1`\n- Doubling the number: `num *= 2`\n\nYou will always start from the number `1` and you will have to return the shortest count of steps it would take to land exactly on that number.\n\n`1 <= num <= 10000`\n\nExamples:\n\n`num == 3` would return `2` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- +1 --> 3:        2 steps\n\n2 steps\n```\n\n`num == 12` would return `4` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- +1 --> 3:        2 steps\n3 -- x2 --> 6:        3 steps\n6 -- x2 --> 12:       4 steps\n\n4 steps\n```\n\n`num == 16` would return `4` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- x2 --> 4:        2 steps\n4 -- x2 --> 8:        3 steps\n8 -- x2 --> 16:       4 steps\n\n4 steps\n```", "difficulty": "introductory", "id": 4453, "sample_io": [{"input": "12", "output": [4]}, {"input": "3", "output": [2]}, {"input": "16", "output": [4]}], "test_list": [{"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "4", "output": [2]}, {"input": "5", "output": [3]}, {"input": "6", "output": [3]}, {"input": "7", "output": [4]}, {"input": "8", "output": [3]}, {"input": "9", "output": [4]}, {"input": "10", "output": [4]}, {"input": "20", "output": [5]}, {"input": "30", "output": [7]}, {"input": "40", "output": [6]}, {"input": "50", "output": [7]}, {"input": "11", "output": [5]}, {"input": "24", "output": [5]}, {"input": "37", "output": [7]}, {"input": "19", "output": [6]}, {"input": "48", "output": [6]}, {"input": "59", "output": [9]}, {"input": "65", "output": [7]}, {"input": "73", "output": [8]}, {"input": "83", "output": [9]}, {"input": "64", "output": [6]}, {"input": "99", "output": [9]}, {"input": "100", "output": [8]}, {"input": "10000", "output": [17]}, {"input": "1500", "output": [16]}, {"input": "1534", "output": [18]}, {"input": "1978", "output": [17]}, {"input": "2763", "output": [17]}, {"input": "9999", "output": [20]}, {"input": "2673", "output": [16]}, {"input": "4578", "output": [17]}, {"input": "9876", "output": [18]}, {"input": "2659", "output": [16]}, {"input": "7777", "output": [18]}, {"input": "9364", "output": [17]}, {"input": "7280", "output": [17]}, {"input": "4998", "output": [17]}, {"input": "9283", "output": [17]}, {"input": "8234", "output": [16]}, {"input": "7622", "output": [19]}, {"input": "800", "output": [11]}, {"input": "782", "output": [13]}, {"input": "674", "output": [12]}, {"input": "4467", "output": [18]}, {"input": "1233", "output": [14]}, {"input": "3678", "output": [18]}, {"input": "7892", "output": [19]}, {"input": "5672", "output": [16]}], "starter_code": "\ndef shortest_steps_to_num(num):\n\t", "source_codes": ["def min_steps_to_one(num):\n    steps = 0\n    while num > 1:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            if num == 3:\n                num -= 1\n            else:\n                num -= 1\n        steps += 1\n    return steps\n\n# Read input and solve\nnum = int(input())\nprint(min_steps_to_one(num))"], "responses": ["\ndef min_steps_to_one(num):\n    steps = 0\n    while num > 1:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            if num == 3:\n                num -= 1\n            else:\n                num -= 1\n        steps += 1\n    return steps\n\n# Read input and solve\nnum = int(input())\nprint(min_steps_to_one(num))\n\n\n"], "prompt_tokens": [17198], "completion_tokens": [5057], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4453}
{"name": "3616", "description": "Define a \"prime prime\" number to be a rational number written as one prime number over another prime number: `primeA / primeB` (e.g. `7/31`)\n\nGiven a whole number `N`, generate the number of \"prime prime\" rational numbers less than 1, using only prime numbers between `0` and `N` (non inclusive).\n\nReturn the count of these \"prime primes\", and the integer part  of their sum.\n\n## Example\n\n```python\nN = 6\n\n# The \"prime primes\" less than 1 are:\n2/3, 2/5, 3/5               # count: 3\n\n2/3 + 2/5 + 3/5 = 1.6667    # integer part: 1\n\nThus, the function should return 3 and 1.\n```", "difficulty": "introductory", "id": 3616, "sample_io": [{"input": "6", "output": [[3, 1]]}], "test_list": [{"input": "6", "output": [[3, 1]]}, {"input": "4", "output": [[1, 0]]}, {"input": "10", "output": [[6, 3]]}, {"input": "65", "output": [[153, 63]]}, {"input": "0", "output": [[0, 0]]}, {"input": "1000", "output": [[14028, 6266]]}, {"input": "666", "output": [[7260, 3213]]}], "starter_code": "\ndef prime_primes(N):\n\t", "source_codes": ["def sieve_of_eratosthenes(n):\n    if n <= 2:\n        return []\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n                \n    return [i for i in range(2, n) if is_prime[i]]\n\ndef solve(N):\n    if N <= 2:\n        return [0, 0]\n    \n    primes = sieve_of_eratosthenes(N)\n    count = 0\n    total_sum = 0.0\n    \n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            primeA = primes[i]\n            primeB = primes[j]\n            # Since i < j and primes are in ascending order, primeA < primeB\n            count += 1\n            total_sum += primeA / primeB\n    \n    return [count, int(total_sum)]\n\nN = int(input())\nresult = solve(N)\nprint(f\"[{result[0]}, {result[1]}]\")"], "responses": ["\ndef sieve_of_eratosthenes(n):\n    if n <= 2:\n        return []\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n                \n    return [i for i in range(2, n) if is_prime[i]]\n\ndef solve(N):\n    if N <= 2:\n        return [0, 0]\n    \n    primes = sieve_of_eratosthenes(N)\n    count = 0\n    total_sum = 0.0\n    \n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            primeA = primes[i]\n            primeB = primes[j]\n            # Since i < j and primes are in ascending order, primeA < primeB\n            count += 1\n            total_sum += primeA / primeB\n    \n    return [count, int(total_sum)]\n\nN = int(input())\nresult = solve(N)\nprint(f\"[{result[0]}, {result[1]}]\")\n\n\n"], "prompt_tokens": [7088], "completion_tokens": [4572], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3616}
{"name": "3439", "description": "Given an integer `n`, find two integers `a` and `b` such that:\n```Pearl\nA) a >= 0 and b >= 0\nB) a + b = n\nC) DigitSum(a) + Digitsum(b) is maximum of all possibilities.  \n```\nYou will return the digitSum(a) + digitsum(b). \n\n```\nFor example:\nsolve(29) = 11. If we take 15 + 14 = 29 and digitSum = 1 + 5 + 1 + 4 = 11. There is no larger outcome.\n```\n`n` will not exceed `10e10`.\n\nMore examples in test cases. \n\nGood luck!", "difficulty": "introductory", "id": 3439, "sample_io": [{"input": "29", "output": [11]}], "test_list": [{"input": "18", "output": [18]}, {"input": "29", "output": [11]}, {"input": "45", "output": [18]}, {"input": "1140", "output": [33]}, {"input": "7019", "output": [35]}, {"input": "50000000", "output": [68]}, {"input": "15569047737", "output": [144]}, {"input": "2452148459", "output": [116]}, {"input": "1", "output": [1]}, {"input": "0", "output": [0]}], "starter_code": "\ndef solve(n):\n\t", "source_codes": ["def digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef solve(n):\n    if n < 10:\n        return n\n    \n    # The key insight: to maximize digit sum, we want as many 9s as possible\n    # One good strategy is (n-1) + 1\n    # Another strategy is n + 0\n    option1 = digit_sum(n)\n    option2 = digit_sum(n - 1) + 1\n    \n    return max(option1, option2)\n\nn = int(input())\nprint(solve(n))", "def solve(n):\n    if n == 0:\n        return 0\n    \n    # Convert to string to work with digits\n    s = str(n)\n    \n    # If single digit, return the digit itself (split as 0 + n)\n    if len(s) == 1:\n        return n\n    \n    # Strategy 1: (n-1) + 1\n    option1 = sum(int(digit) for digit in str(n-1)) + 1\n    \n    # Strategy 2: Make a number with (len(s)-1) 9s and its complement\n    all_nines = int('9' * (len(s) - 1))\n    complement = n - all_nines\n    option2 = sum(int(digit) for digit in str(all_nines)) + sum(int(digit) for digit in str(complement))\n    \n    # Strategy 3: For number like abc..., try (a-1)999... + 1xxx... pattern\n    first_digit = int(s[0])\n    if first_digit > 1:\n        # First number: (first_digit-1) followed by 9s\n        first_part = str(first_digit - 1) + '9' * (len(s) - 1)\n        # Second number: n - first_part\n        second_part = n - int(first_part)\n        \n        first_sum = sum(int(digit) for digit in first_part)\n        second_sum = sum(int(digit) for digit in str(second_part))\n        option3 = first_sum + second_sum\n        \n        return max(option1, option2, option3)\n    elif first_digit == 1:\n        # Special case when first digit is 1\n        # We can do 0 + n (digit sum of n)\n        option3 = sum(int(digit) for digit in s)\n        return max(option1, option2, option3)\n    else:  # first_digit == 0, but this shouldn't happen for positive n\n        return max(option1, option2)\n\n# Read input and solve\nn = int(input())\nprint(solve(n))"], "responses": ["\ndef digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef solve(n):\n    if n < 10:\n        return n\n    \n    # The key insight: to maximize digit sum, we want as many 9s as possible\n    # One good strategy is (n-1) + 1\n    # Another strategy is n + 0\n    option1 = digit_sum(n)\n    option2 = digit_sum(n - 1) + 1\n    \n    return max(option1, option2)\n\nn = int(input())\nprint(solve(n))\n\n\n", "\ndef solve(n):\n    if n == 0:\n        return 0\n    \n    # Convert to string to work with digits\n    s = str(n)\n    \n    # If single digit, return the digit itself (split as 0 + n)\n    if len(s) == 1:\n        return n\n    \n    # Strategy 1: (n-1) + 1\n    option1 = sum(int(digit) for digit in str(n-1)) + 1\n    \n    # Strategy 2: Make a number with (len(s)-1) 9s and its complement\n    all_nines = int('9' * (len(s) - 1))\n    complement = n - all_nines\n    option2 = sum(int(digit) for digit in str(all_nines)) + sum(int(digit) for digit in str(complement))\n    \n    # Strategy 3: For number like abc..., try (a-1)999... + 1xxx... pattern\n    first_digit = int(s[0])\n    if first_digit > 1:\n        # First number: (first_digit-1) followed by 9s\n        first_part = str(first_digit - 1) + '9' * (len(s) - 1)\n        # Second number: n - first_part\n        second_part = n - int(first_part)\n        \n        first_sum = sum(int(digit) for digit in first_part)\n        second_sum = sum(int(digit) for digit in str(second_part))\n        option3 = first_sum + second_sum\n        \n        return max(option1, option2, option3)\n    elif first_digit == 1:\n        # Special case when first digit is 1\n        # We can do 0 + n (digit sum of n)\n        option3 = sum(int(digit) for digit in s)\n        return max(option1, option2, option3)\n    else:  # first_digit == 0, but this shouldn't happen for positive n\n        return max(option1, option2)\n\n# Read input and solve\nn = int(input())\nprint(solve(n))\n\n\n"], "prompt_tokens": [7504, 7584], "completion_tokens": [4285, 5890], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 3439}
{"name": "3155", "description": "Mr. Square is going on a holiday. He wants to bring 2 of his favorite squares with him, so he put them in his rectangle suitcase.\n\nWrite a function that, given the size of the squares and the suitcase, return whether the squares can fit inside the suitcase.\n```Python\nfit_in(a,b,m,n)\na,b are the sizes of the 2 squares\nm,n are the sizes of the suitcase\n```\n\n# Example\n```Python\nfit_in(1,2,3,2) should return True\nfit_in(1,2,2,1) should return False\nfit_in(3,2,3,2) should return False\nfit_in(1,2,1,2) should return False\n```", "difficulty": "introductory", "id": 3155, "sample_io": [{"input": "1\n2\n3\n2", "output": [true]}, {"input": "1\n2\n2\n1", "output": [false]}, {"input": "3\n2\n3\n2", "output": [false]}, {"input": "1\n2\n1\n2", "output": [false]}], "test_list": [{"input": "1\n2\n3\n2", "output": [true]}, {"input": "1\n2\n2\n1", "output": [false]}, {"input": "3\n2\n3\n2", "output": [false]}, {"input": "1\n2\n1\n2", "output": [false]}, {"input": "6\n5\n8\n7", "output": [false]}, {"input": "6\n6\n12\n6", "output": [true]}, {"input": "7\n1\n7\n8", "output": [true]}, {"input": "10\n10\n11\n11", "output": [false]}, {"input": "7\n2\n9\n7", "output": [true]}, {"input": "7\n2\n8\n7", "output": [false]}, {"input": "4\n1\n5\n3", "output": [false]}, {"input": "1\n2\n3\n4", "output": [true]}, {"input": "1\n2\n4\n3", "output": [true]}, {"input": "1\n3\n2\n4", "output": [false]}, {"input": "1\n3\n4\n2", "output": [false]}, {"input": "1\n4\n2\n3", "output": [false]}, {"input": "1\n4\n3\n2", "output": [false]}, {"input": "2\n1\n3\n4", "output": [true]}, {"input": "2\n1\n4\n3", "output": [true]}, {"input": "2\n3\n1\n4", "output": [false]}, {"input": "2\n3\n4\n1", "output": [false]}, {"input": "2\n4\n1\n3", "output": [false]}, {"input": "2\n4\n3\n1", "output": [false]}, {"input": "3\n2\n1\n4", "output": [false]}, {"input": "3\n2\n4\n1", "output": [false]}, {"input": "3\n1\n2\n4", "output": [false]}, {"input": "3\n1\n4\n2", "output": [false]}, {"input": "3\n4\n2\n1", "output": [false]}, {"input": "3\n4\n1\n2", "output": [false]}, {"input": "4\n2\n3\n1", "output": [false]}, {"input": "4\n2\n1\n3", "output": [false]}, {"input": "4\n3\n2\n1", "output": [false]}, {"input": "4\n3\n1\n2", "output": [false]}, {"input": "4\n1\n2\n3", "output": [false]}, {"input": "4\n1\n3\n2", "output": [false]}], "starter_code": "\ndef fit_in(a,b,m,n):\n\t", "source_codes": ["def fit_in(a, b, m, n):\n    # Two possible arrangements:\n    # 1. Side by side: width = a + b, height = max(a, b)\n    # 2. One above other: width = max(a, b), height = a + b\n    \n    # Arrangement 1: side by side\n    width1 = a + b\n    height1 = max(a, b)\n    \n    # Arrangement 2: one above other\n    width2 = max(a, b)\n    height2 = a + b\n    \n    # Check if either arrangement fits in the suitcase (considering both orientations)\n    if (width1 <= m and height1 <= n) or (width1 <= n and height1 <= m):\n        return True\n    \n    if (width2 <= m and height2 <= n) or (width2 <= n and height2 <= m):\n        return True\n    \n    return False\n\n# Read inputs\na = int(input())\nb = int(input())\nm = int(input())\nn = int(input())\n\n# Call function and print result\nresult = fit_in(a, b, m, n)\nprint(result)"], "responses": ["\ndef fit_in(a, b, m, n):\n    # Two possible arrangements:\n    # 1. Side by side: width = a + b, height = max(a, b)\n    # 2. One above other: width = max(a, b), height = a + b\n    \n    # Arrangement 1: side by side\n    width1 = a + b\n    height1 = max(a, b)\n    \n    # Arrangement 2: one above other\n    width2 = max(a, b)\n    height2 = a + b\n    \n    # Check if either arrangement fits in the suitcase (considering both orientations)\n    if (width1 <= m and height1 <= n) or (width1 <= n and height1 <= m):\n        return True\n    \n    if (width2 <= m and height2 <= n) or (width2 <= n and height2 <= m):\n        return True\n    \n    return False\n\n# Read inputs\na = int(input())\nb = int(input())\nm = int(input())\nn = int(input())\n\n# Call function and print result\nresult = fit_in(a, b, m, n)\nprint(result)\n\n\n"], "prompt_tokens": [6939], "completion_tokens": [3314], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3155}
{"name": "3562", "description": "In computer science and discrete mathematics, an [inversion](https://en.wikipedia.org/wiki/Inversion_%28discrete_mathematics%29) is a pair of places in a sequence where the elements in these places are out of their natural order. So, if we use ascending order for a group of numbers, then an inversion is when larger numbers appear before lower number in a sequence.\n\nCheck out this example sequence: ```(1, 2, 5, 3, 4, 7, 6)``` and we can see here three inversions\n```5``` and ```3```; ```5``` and ```4```; ```7``` and ```6```.\n\nYou are given a sequence of numbers and you should count the number of inversions in this sequence.\n\n```Input```: A sequence as a tuple of integers.\n\n```Output```: The inversion number as an integer.\n\nExample:\n```python\n  count_inversion((1, 2, 5, 3, 4, 7, 6)) == 3\n  count_inversion((0, 1, 2, 3)) == 0\n```", "difficulty": "introductory", "id": 3562, "sample_io": [{"input": "[1, 2, 5, 3, 4, 7, 6]", "output": [3]}, {"input": "[0, 1, 2, 3]", "output": [0]}], "test_list": [{"input": "[1, 2, 3]", "output": [0]}, {"input": "[-3, -2, -1]", "output": [0]}, {"input": "[-20, 0, 20]", "output": [0]}, {"input": "[-13, 4, 8]", "output": [0]}, {"input": "[1, 3, 2]", "output": [1]}, {"input": "[-2, -3, -1]", "output": [1]}, {"input": "[-20, 20, 0]", "output": [1]}, {"input": "[-13, 9, 8]", "output": [1]}, {"input": "[3, 6, 2]", "output": [2]}, {"input": "[3, 6, 2, 7, 3]", "output": [4]}, {"input": "[26, 32, -21, 45, 21]", "output": [5]}, {"input": "[14, 12, 17, 124, 1, -12, 21, -24]", "output": [18]}, {"input": "[]", "output": [0]}, {"input": "[25, 12, 7, 4, 2, -7, -12, -22]", "output": [28]}, {"input": "[324, 123, 36, 4, -1, -72, -123]", "output": [21]}, {"input": "[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]", "output": [55]}, {"input": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]", "output": [0]}, {"input": "[3, 3, 3]", "output": [0]}, {"input": "[-5, -5, -5]", "output": [0]}, {"input": "[0, 0, 7]", "output": [0]}, {"input": "[2, 2, 8]", "output": [0]}, {"input": "[1, 3, 3, 7]", "output": [0]}], "starter_code": "\ndef count_inversion(sequence):\n\t", "source_codes": ["def count_inversion(sequence):\n    inversions = 0\n    n = len(sequence)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sequence[i] > sequence[j]:\n                inversions += 1\n    return inversions\n\n# Read input from stdin and process\nimport sys\nimport json\n\ninput_data = sys.stdin.read().strip()\ntry:\n    # Try to parse as JSON array\n    sequence = json.loads(input_data)\nexcept json.JSONDecodeError:\n    # Fallback to manual parsing\n    if input_data == \"[]\":\n        sequence = []\n    else:\n        # Remove brackets and split by comma\n        content = input_data[1:-1].strip()\n        if content:\n            # Handle potential spaces around commas\n            sequence = list(map(int, [x.strip() for x in content.split(',')]))\n        else:\n            sequence = []\n\nresult = count_inversion(sequence)\nprint(result)"], "responses": ["\ndef count_inversion(sequence):\n    inversions = 0\n    n = len(sequence)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sequence[i] > sequence[j]:\n                inversions += 1\n    return inversions\n\n# Read input from stdin and process\nimport sys\nimport json\n\ninput_data = sys.stdin.read().strip()\ntry:\n    # Try to parse as JSON array\n    sequence = json.loads(input_data)\nexcept json.JSONDecodeError:\n    # Fallback to manual parsing\n    if input_data == \"[]\":\n        sequence = []\n    else:\n        # Remove brackets and split by comma\n        content = input_data[1:-1].strip()\n        if content:\n            # Handle potential spaces around commas\n            sequence = list(map(int, [x.strip() for x in content.split(',')]))\n        else:\n            sequence = []\n\nresult = count_inversion(sequence)\nprint(result)\n\n\n"], "prompt_tokens": [8350], "completion_tokens": [2706], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3562}
{"name": "3883", "description": "If we alternate the vowels and consonants in the string `\"have\"`, we get the following list, arranged alphabetically:\n`['ahev', 'aveh', 'ehav', 'evah', 'vahe', 'veha']`. These are the only possibilities in which vowels and consonants are alternated. The first element, `ahev`, is alphabetically lowest. \n\nGiven a string:\n* alternate the vowels and consonants and return the lexicographically lowest element in the list\n* If any two or more vowels or consonants must follow each other, return `\"failed\"`\n* if the number of vowels and consonants are equal, the first letter of the result must be a vowel.\n\nExamples: \n\n```Haskell\nsolve(\"codewars\") = \"failed\". However you alternate vowels and consonants, two consonants must follow each other\nsolve(\"oruder\") = \"edorur\"\nsolve(\"orudere\") = \"ederoru\". This is the only option that allows you to alternate vowels & consonants.\n```\n\n```if c:\nIn C, return an allocated string even if the response is \"failed\".\n```\n\nVowels will be any of \"aeiou\". Input will be a lowercase string, no spaces. See test cases for more examples. \n\nGood luck!\n\nIf you like this Kata, please try: \n\n[Consonant value](https://www.codewars.com/kata/59c633e7dcc4053512000073)\n\n[Alternate capitalization](https://www.codewars.com/kata/59cfc000aeb2844d16000075)", "difficulty": "introductory", "id": 3883, "sample_io": [{"input": "codewars", "output": ["failed"]}, {"input": "oruder", "output": ["edorur"]}, {"input": "orudere", "output": ["ederoru"]}], "test_list": [{"input": "java", "output": ["ajav"]}, {"input": "oruder", "output": ["edorur"]}, {"input": "zodiac", "output": ["acidoz"]}, {"input": "apple", "output": ["lapep"]}, {"input": "acidity", "output": ["caditiy"]}, {"input": "codewars", "output": ["failed"]}, {"input": "orudere", "output": ["ederoru"]}], "starter_code": "\ndef solve(s):\n\t", "source_codes": ["def solve(s):\n    if not s:\n        return \"\"\n    \n    vowels = \"aeiou\"\n    vowel_list = [c for c in s if c in vowels]\n    consonant_list = [c for c in s if c not in vowels]\n    \n    vowel_count = len(vowel_list)\n    consonant_count = len(consonant_list)\n    \n    # Check if alternating is possible\n    if abs(vowel_count - consonant_count) > 1:\n        return \"failed\"\n    \n    # Sort both lists\n    vowel_list.sort()\n    consonant_list.sort()\n    \n    # Build alternating string\n    result = []\n    vowel_index = 0\n    consonant_index = 0\n    \n    if vowel_count == consonant_count:\n        # Equal counts: must start with vowel\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n            else:  # Odd positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n    \n    elif vowel_count == consonant_count + 1:\n        # One more vowel: must start with vowel\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n            else:  # Odd positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n    \n    elif consonant_count == vowel_count + 1:\n        # One more consonant: must start with consonant\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n            else:  # Odd positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n    \n    else:\n        return \"failed\"\n    \n    return ''.join(result)\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))"], "responses": ["\ndef solve(s):\n    if not s:\n        return \"\"\n    \n    vowels = \"aeiou\"\n    vowel_list = [c for c in s if c in vowels]\n    consonant_list = [c for c in s if c not in vowels]\n    \n    vowel_count = len(vowel_list)\n    consonant_count = len(consonant_list)\n    \n    # Check if alternating is possible\n    if abs(vowel_count - consonant_count) > 1:\n        return \"failed\"\n    \n    # Sort both lists\n    vowel_list.sort()\n    consonant_list.sort()\n    \n    # Build alternating string\n    result = []\n    vowel_index = 0\n    consonant_index = 0\n    \n    if vowel_count == consonant_count:\n        # Equal counts: must start with vowel\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n            else:  # Odd positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n    \n    elif vowel_count == consonant_count + 1:\n        # One more vowel: must start with vowel\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n            else:  # Odd positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n    \n    elif consonant_count == vowel_count + 1:\n        # One more consonant: must start with consonant\n        for i in range(len(s)):\n            if i % 2 == 0:  # Even positions: consonants\n                if consonant_index < len(consonant_list):\n                    result.append(consonant_list[consonant_index])\n                    consonant_index += 1\n            else:  # Odd positions: vowels\n                if vowel_index < len(vowel_list):\n                    result.append(vowel_list[vowel_index])\n                    vowel_index += 1\n    \n    else:\n        return \"failed\"\n    \n    return ''.join(result)\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))\n\n\n"], "prompt_tokens": [10816], "completion_tokens": [5200], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3883}
