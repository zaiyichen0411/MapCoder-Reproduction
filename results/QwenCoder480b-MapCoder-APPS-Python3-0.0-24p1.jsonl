{"name": "3554", "description": "Zonk is addictive dice game. In each round player rolls 6 dice. Then (s)he composes combinations from them. Each combination gives certain points. \n\nThen player can take one or more dice combinations to his hand and re-roll remaining dice or save his score. Dice in player's hand won't be taken into account in subsequent rolls.\n\nIf no combinations can be composed - situation is called \"zonk\". Player thrown zonk loses all points in this round and next player moves. So it's player decision when to reroll and when to stop and save his score.\n\nYour task is simple - just evaluate current roll and return maximum number of points can be scored from it. If no combinations can be made - function must return string ``\"Zonk\"`` (without quotes).\n\nThere are different variations of Zonk. In this kata, we will use most common table of combinations:\n\nCombinationExample rollPoints\nStraight (1,2,3,4,5 and 6)6 3 1 2 5 41000 points\nThree pairs of any dice2 2 4 4 1 1750 points\nThree of 11 4 1 11000 points\nThree of 22 3 4 2 2200 points\nThree of 33 4 3 6 3 2300 points\nThree of 44 4 4400 points\nThree of 52 5 5 5 4500 points\nThree of 66 6 2 6600 points\nFour of a kind1 1 1 1 4 62 \u00d7 Three-of-a-kind score (in example, 2000 pts)\nFive of a kind5 5 5 4 5 53 \u00d7 Three-of-a-kind score (in example, 1500 pts)\nSix of a kind4 4 4 4 4 44 \u00d7 Three-of-a-kind score (in example, 1600 pts)\nEvery 14 3 1 2 2100 points\nEvery 55 2 650 points\n\n\nEach die cannot be used in multiple combinations the same time, so three pairs of 2, 3 and 5 will worth you only ``750`` points (for three pairs), not 850 (for three pairs and two fives). But you can select multiple combinations, ``2 2 2 1 6`` will worth you ``300`` points (200 for three-of-kind '2' plus 100 for single '1' die)\n\nExamples:\n```python\n  get_score([1,2,3]) # returns 100 = points from one 1\n  get_score([3,4,1,1,5]) # returns 250 = points from two 1 and one 5\n  get_score([2,3,2,3,3,2]) # returns 500 = three of 2 + three of 3\n  get_score([1,1,1,1,1,5]) # returns 3050 = five 1 + one 5\n  get_score([2,3,4,3,6,6]) # returns \"Zonk\" = no combinations here\n  get_score([2,2,6,6,2,2]) # returns 400 = four 2, this cannot be scored as three pairs\n  get_score([1,3,4,3,4,1]) # returns 750 = three pairs\n  get_score([3,3,3,3]) # returns 600 = four of 3\n  get_score([1,2,3,4,5]) # returns 150 = it's not straight\n```\nOf course, in real Zonk game it's sometimes not worth to collect all combination from roll. Taking less dice and rerolling more remaining may be better, but task is just to calculate maximum possible score from current single roll.\n\nP.S. Inspired by this kata: http://www.codewars.com/kata/5270d0d18625160ada0000e4", "difficulty": "introductory", "id": 3554, "sample_io": [{"input": "[1, 2, 3]", "output": [100]}, {"input": "[3,4,1,1,5]", "output": [250]}, {"input": "[2,3,2,3,3,2]", "output": [500]}, {"input": "[1,1,1,1,1,5]", "output": [3050]}, {"input": "[2,3,4,3,6,6]", "output": ["Zonk"]}, {"input": "[2,2,6,6,2,2]", "output": [400]}, {"input": "[1,3,4,3,4,1]", "output": [750]}, {"input": "[3,3,3,3]", "output": [600]}, {"input": "[1,2,3,4,5]", "output": [150]}], "test_list": [{"input": "[1]", "output": [100]}, {"input": "[5]", "output": [50]}, {"input": "[1, 1]", "output": [200]}, {"input": "[5, 5]", "output": [100]}, {"input": "[5, 1]", "output": [150]}, {"input": "[5, 6]", "output": [50]}, {"input": "[1, 1, 1]", "output": [1000]}, {"input": "[2, 2, 2]", "output": [200]}, {"input": "[3, 3, 3]", "output": [300]}, {"input": "[4, 4, 4]", "output": [400]}, {"input": "[5, 5, 5]", "output": [500]}, {"input": "[6, 6, 6]", "output": [600]}, {"input": "[1, 2, 1]", "output": [200]}, {"input": "[1, 1, 5]", "output": [250]}, {"input": "[5, 5, 6]", "output": [100]}, {"input": "[1, 5, 5]", "output": [200]}, {"input": "[1, 1, 1, 1]", "output": [2000]}, {"input": "[2, 2, 2, 2]", "output": [400]}, {"input": "[3, 3, 3, 3]", "output": [600]}, {"input": "[4, 4, 4, 4]", "output": [800]}, {"input": "[5, 5, 5, 5]", "output": [1000]}, {"input": "[6, 6, 6, 6]", "output": [1200]}, {"input": "[1, 5, 5, 1]", "output": [300]}, {"input": "[2, 3, 4, 5]", "output": [50]}, {"input": "[3, 3, 5, 3]", "output": [350]}, {"input": "[1, 1, 1, 1, 1]", "output": [3000]}, {"input": "[2, 2, 2, 2, 2]", "output": [600]}, {"input": "[3, 3, 3, 3, 3]", "output": [900]}, {"input": "[4, 4, 4, 4, 4]", "output": [1200]}, {"input": "[5, 5, 5, 5, 5]", "output": [1500]}, {"input": "[6, 6, 6, 6, 6]", "output": [1800]}, {"input": "[1, 5, 1, 5, 1]", "output": [1100]}, {"input": "[1, 2, 3, 4, 5]", "output": [150]}, {"input": "[2, 3, 4, 5, 6]", "output": [50]}, {"input": "[1, 3, 4, 5, 2]", "output": [150]}, {"input": "[1, 1, 1, 1, 1, 1]", "output": [4000]}, {"input": "[2, 2, 2, 2, 2, 2]", "output": [800]}, {"input": "[3, 3, 3, 3, 3, 3]", "output": [1200]}, {"input": "[4, 4, 4, 4, 4, 4]", "output": [1600]}, {"input": "[5, 5, 5, 5, 5, 5]", "output": [2000]}, {"input": "[6, 6, 6, 6, 6, 6]", "output": [2400]}, {"input": "[2, 1, 3, 4, 6, 5]", "output": [1000]}, {"input": "[4, 4, 2, 2, 6, 6]", "output": [750]}, {"input": "[1, 2, 3, 4, 5, 5]", "output": [200]}, {"input": "[2, 2, 4, 2, 2, 4]", "output": [400]}, {"input": "[1, 3, 4, 5, 2, 2]", "output": [150]}, {"input": "[1, 5, 2, 1, 2, 5]", "output": [750]}, {"input": "[4, 1, 1, 1, 1, 5]", "output": [2050]}, {"input": "[3, 5, 2, 4, 2, 6]", "output": [50]}, {"input": "[1, 6, 6, 1, 1, 6]", "output": [1600]}], "starter_code": "\ndef get_score(dice):\n\t", "source_codes": ["def get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    # Calculate points\n    points = 0\n    remaining_counts = counts.copy()  # Track unused dice\n    \n    # Handle multiples first (highest multipliers first)\n    for num, count in list(counts.items()):\n        if count >= 3:\n            # Calculate base points for three of a kind\n            base_points = 1000 if num == 1 else num * 100\n            \n            if count == 3:\n                points += base_points\n                remaining_counts[num] -= 3\n            elif count == 4:\n                points += base_points * 2  # Four of a kind\n                remaining_counts[num] -= 4\n            elif count == 5:\n                points += base_points * 3  # Five of a kind\n                remaining_counts[num] -= 5\n            elif count == 6:\n                points += base_points * 4  # Six of a kind\n                remaining_counts[num] -= 6\n    \n    # Handle remaining 1s and 5s\n    points += remaining_counts.get(1, 0) * 100\n    points += remaining_counts.get(5, 0) * 50\n    \n    return points if points > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and all(counts[i] == 1 for i in range(1, 7)):\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Process combinations in priority order (higher scoring first)\n    \n    # Six of a kind\n    for num in range(1, 7):\n        if counts[num] >= 6:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 4\n            counts[num] -= 6\n    \n    # Five of a kind\n    for num in range(1, 7):\n        if counts[num] >= 5:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 3\n            counts[num] -= 5\n    \n    # Four of a kind\n    for num in range(1, 7):\n        if counts[num] >= 4:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 2\n            counts[num] -= 4\n    \n    # Three of a kind\n    for num in range(1, 7):\n        if counts[num] >= 3:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score\n            counts[num] -= 3\n    \n    # Single 1s and 5s\n    score += counts[1] * 100\n    score += counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    from collections import Counter\n    \n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Recursive function to find maximum score\n    def max_score_from_counts(remaining_counts):\n        if not remaining_counts:\n            return 0\n        \n        max_score = 0\n        \n        # Check for six of a kind\n        for num, count in remaining_counts.items():\n            if count >= 6:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 6\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 4 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n                return max_score  # Greedy return since this is optimal\n        \n        # Check for five of a kind\n        for num, count in remaining_counts.items():\n            if count >= 5:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 5\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 3 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for four of a kind\n        for num, count in remaining_counts.items():\n            if count >= 4:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 4\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 2 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for three of a kind\n        for num, count in remaining_counts.items():\n            if count >= 3:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 3\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Score individual 1s and 5s\n        score_from_singles = 0\n        new_counts = remaining_counts.copy()\n        \n        if 1 in new_counts:\n            score_from_singles += new_counts[1] * 100\n            del new_counts[1]\n        \n        if 5 in new_counts:\n            score_from_singles += new_counts[5] * 50\n            del new_counts[5]\n        \n        score_from_singles += max_score_from_counts(new_counts)\n        max_score = max(max_score, score_from_singles)\n        \n        return max_score\n    \n    # Calculate maximum score\n    max_points = max_score_from_counts(counts)\n    \n    # If no points can be scored, return \"Zonk\"\n    if max_points == 0:\n        return \"Zonk\"\n    else:\n        return max_points\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    counts = Counter(dice)\n    \n    # Points mapping for three of a kind\n    POINTS = {\n        1: 1000,\n        2: 200,\n        3: 300,\n        4: 400,\n        5: 500,\n        6: 600\n    }\n    \n    def max_score_from_counts(counts_dict):\n        if not counts_dict:\n            return 0\n            \n        max_score = 0\n        counts_list = dict(counts_dict)\n        \n        # Check for straight (1,2,3,4,5,6)\n        if all(counts_list.get(i, 0) >= 1 for i in range(1, 7)):\n            new_counts = counts_list.copy()\n            for i in range(1, 7):\n                new_counts[i] -= 1\n                if new_counts[i] == 0:\n                    del new_counts[i]\n            max_score = max(max_score, 1000 + max_score_from_counts(new_counts))\n        \n        # Check for three pairs\n        pair_count = sum(count // 2 for count in counts_list.values())\n        if pair_count >= 3:\n            # This means we have at least 3 pairs\n            # But we need exactly 3 pairs using all 6 dice\n            total_dice_used = sum((count // 2) * 2 for count in counts_list.values())\n            if total_dice_used == 6 and pair_count == 3:\n                max_score = max(max_score, 750)\n        \n        # Check for N of a kind (6, 5, 4, 3)\n        for num in list(counts_list.keys()):\n            if num not in counts_list:\n                continue\n            count = counts_list[num]\n            for n in range(min(6, count), 2, -1):  # 6 down to 3\n                base_points = POINTS[num]\n                multiplier = n - 2  # 3->1, 4->2, 5->3, 6->4\n                points = base_points * multiplier\n                new_counts = counts_list.copy()\n                new_counts[num] -= n\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                max_score = max(max_score, points + max_score_from_counts(new_counts))\n        \n        # Individual 1s and 5s\n        score = 0\n        new_counts = counts_list.copy()\n        \n        # Score individual 1s\n        if 1 in new_counts:\n            score += new_counts[1] * 100\n            del new_counts[1]\n        \n        # Score individual 5s\n        if 5 in new_counts:\n            score += new_counts[5] * 50\n            del new_counts[5]\n        \n        if new_counts or score > 0:\n            if new_counts:\n                score += max_score_from_counts(new_counts)\n            max_score = max(max_score, score)\n        \n        return max_score\n    \n    # Special case: if we have exactly three pairs\n    if len(dice) == 6:\n        pair_counts = [count for count in counts.values()]\n        if sorted(pair_counts) == [2, 2, 2]:\n            return 750\n    \n    score = max_score_from_counts(counts)\n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)", "def get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    def calculate_score(counts_dict):\n        score = 0\n        remaining_counts = counts_dict.copy()\n        \n        # Handle six of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 6:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 4\n                remaining_counts[num] -= 6\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle five of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 5:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 3\n                remaining_counts[num] -= 5\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle four of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 4:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 2\n                remaining_counts[num] -= 4\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle three of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 3:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score\n                remaining_counts[num] -= 3\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle remaining 1s and 5s\n        if 1 in remaining_counts:\n            score += remaining_counts[1] * 100\n            del remaining_counts[1]\n        \n        if 5 in remaining_counts:\n            score += remaining_counts[5] * 50\n            del remaining_counts[5]\n        \n        return score\n    \n    result = calculate_score(counts)\n    return result if result > 0 else \"Zonk\"\n\n# Read input and process\ndice = list(map(int, input().strip()[1:-1].split(',')))\nresult = get_score(dice)\nprint(result)", "def get_score(dice):\n    from collections import Counter\n    \n    # Count frequency of each die\n    counts = Counter(dice)\n    \n    # Make a copy to track remaining dice\n    remaining = counts.copy()\n    total_score = 0\n    \n    # Check for straight (1,2,3,4,5,6) - 1000 points\n    if len(dice) == 6 and set(dice) == {1, 2, 3, 4, 5, 6}:\n        return 1000\n    \n    # Check for three pairs - 750 points\n    if len(dice) == 6:\n        pairs = 0\n        can_form_three_pairs = True\n        temp_counts = counts.copy()\n        \n        for die, count in temp_counts.items():\n            if count == 2:\n                pairs += 1\n            elif count != 2:\n                can_form_three_pairs = False\n                break\n        \n        if can_form_three_pairs and pairs == 3:\n            return 750\n    \n    # Check for N of a kind (6, 5, 4 of a kind)\n    # Process from highest to lowest to maximize score\n    for n in [6, 5, 4, 3]:\n        for die_val in range(1, 7):\n            if remaining[die_val] >= n:\n                # Calculate base score for three of a kind\n                if die_val == 1:\n                    base_score = 1000\n                else:\n                    base_score = die_val * 100\n                \n                # Apply multiplier based on N\n                if n == 3:\n                    multiplier = 1\n                elif n == 4:\n                    multiplier = 2\n                elif n == 5:\n                    multiplier = 3\n                elif n == 6:\n                    multiplier = 4\n                \n                total_score += base_score * multiplier\n                remaining[die_val] -= n\n    \n    # Handle remaining three of a kind\n    for die_val in range(1, 7):\n        if remaining[die_val] >= 3:\n            if die_val == 1:\n                total_score += 1000\n            else:\n                total_score += die_val * 100\n            remaining[die_val] -= 3\n    \n    # Handle remaining 1s and 5s\n    total_score += remaining[1] * 100  # Each 1 is worth 100 points\n    total_score += remaining[5] * 50   # Each 5 is worth 50 points\n    \n    # If no score was made, return \"Zonk\"\n    if total_score == 0:\n        return \"Zonk\"\n    \n    return total_score\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)"], "responses": ["\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    # Calculate points\n    points = 0\n    remaining_counts = counts.copy()  # Track unused dice\n    \n    # Handle multiples first (highest multipliers first)\n    for num, count in list(counts.items()):\n        if count >= 3:\n            # Calculate base points for three of a kind\n            base_points = 1000 if num == 1 else num * 100\n            \n            if count == 3:\n                points += base_points\n                remaining_counts[num] -= 3\n            elif count == 4:\n                points += base_points * 2  # Four of a kind\n                remaining_counts[num] -= 4\n            elif count == 5:\n                points += base_points * 3  # Five of a kind\n                remaining_counts[num] -= 5\n            elif count == 6:\n                points += base_points * 4  # Six of a kind\n                remaining_counts[num] -= 6\n    \n    # Handle remaining 1s and 5s\n    points += remaining_counts.get(1, 0) * 100\n    points += remaining_counts.get(5, 0) * 50\n    \n    return points if points > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    score = 0\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and all(counts[i] == 1 for i in range(1, 7)):\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Process combinations in priority order (higher scoring first)\n    \n    # Six of a kind\n    for num in range(1, 7):\n        if counts[num] >= 6:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 4\n            counts[num] -= 6\n    \n    # Five of a kind\n    for num in range(1, 7):\n        if counts[num] >= 5:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 3\n            counts[num] -= 5\n    \n    # Four of a kind\n    for num in range(1, 7):\n        if counts[num] >= 4:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score * 2\n            counts[num] -= 4\n    \n    # Three of a kind\n    for num in range(1, 7):\n        if counts[num] >= 3:\n            base_score = {1: 1000, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}[num]\n            score += base_score\n            counts[num] -= 3\n    \n    # Single 1s and 5s\n    score += counts[1] * 100\n    score += counts[5] * 50\n    \n    return score if score > 0 else \"Zonk\"\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\ndef get_score(dice):\n    from collections import Counter\n    \n    if not dice:\n        return \"Zonk\"\n    \n    counts = Counter(dice)\n    \n    # Check for straight\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Recursive function to find maximum score\n    def max_score_from_counts(remaining_counts):\n        if not remaining_counts:\n            return 0\n        \n        max_score = 0\n        \n        # Check for six of a kind\n        for num, count in remaining_counts.items():\n            if count >= 6:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 6\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 4 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n                return max_score  # Greedy return since this is optimal\n        \n        # Check for five of a kind\n        for num, count in remaining_counts.items():\n            if count >= 5:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 5\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 3 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for four of a kind\n        for num, count in remaining_counts.items():\n            if count >= 4:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 4\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = 2 * base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Check for three of a kind\n        for num, count in remaining_counts.items():\n            if count >= 3:\n                new_counts = remaining_counts.copy()\n                new_counts[num] -= 3\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                base = 1000 if num == 1 else num * 100\n                score = base + max_score_from_counts(new_counts)\n                max_score = max(max_score, score)\n        \n        # Score individual 1s and 5s\n        score_from_singles = 0\n        new_counts = remaining_counts.copy()\n        \n        if 1 in new_counts:\n            score_from_singles += new_counts[1] * 100\n            del new_counts[1]\n        \n        if 5 in new_counts:\n            score_from_singles += new_counts[5] * 50\n            del new_counts[5]\n        \n        score_from_singles += max_score_from_counts(new_counts)\n        max_score = max(max_score, score_from_singles)\n        \n        return max_score\n    \n    # Calculate maximum score\n    max_points = max_score_from_counts(counts)\n    \n    # If no points can be scored, return \"Zonk\"\n    if max_points == 0:\n        return \"Zonk\"\n    else:\n        return max_points\n\n# Read input and process\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    # Points mapping for three of a kind\n    POINTS = {\n        1: 1000,\n        2: 200,\n        3: 300,\n        4: 400,\n        5: 500,\n        6: 600\n    }\n    \n    def max_score_from_counts(counts_dict):\n        if not counts_dict:\n            return 0\n            \n        max_score = 0\n        counts_list = dict(counts_dict)\n        \n        # Check for straight (1,2,3,4,5,6)\n        if all(counts_list.get(i, 0) >= 1 for i in range(1, 7)):\n            new_counts = counts_list.copy()\n            for i in range(1, 7):\n                new_counts[i] -= 1\n                if new_counts[i] == 0:\n                    del new_counts[i]\n            max_score = max(max_score, 1000 + max_score_from_counts(new_counts))\n        \n        # Check for three pairs\n        pair_count = sum(count // 2 for count in counts_list.values())\n        if pair_count >= 3:\n            # This means we have at least 3 pairs\n            # But we need exactly 3 pairs using all 6 dice\n            total_dice_used = sum((count // 2) * 2 for count in counts_list.values())\n            if total_dice_used == 6 and pair_count == 3:\n                max_score = max(max_score, 750)\n        \n        # Check for N of a kind (6, 5, 4, 3)\n        for num in list(counts_list.keys()):\n            if num not in counts_list:\n                continue\n            count = counts_list[num]\n            for n in range(min(6, count), 2, -1):  # 6 down to 3\n                base_points = POINTS[num]\n                multiplier = n - 2  # 3->1, 4->2, 5->3, 6->4\n                points = base_points * multiplier\n                new_counts = counts_list.copy()\n                new_counts[num] -= n\n                if new_counts[num] == 0:\n                    del new_counts[num]\n                max_score = max(max_score, points + max_score_from_counts(new_counts))\n        \n        # Individual 1s and 5s\n        score = 0\n        new_counts = counts_list.copy()\n        \n        # Score individual 1s\n        if 1 in new_counts:\n            score += new_counts[1] * 100\n            del new_counts[1]\n        \n        # Score individual 5s\n        if 5 in new_counts:\n            score += new_counts[5] * 50\n            del new_counts[5]\n        \n        if new_counts or score > 0:\n            if new_counts:\n                score += max_score_from_counts(new_counts)\n            max_score = max(max_score, score)\n        \n        return max_score\n    \n    # Special case: if we have exactly three pairs\n    if len(dice) == 6:\n        pair_counts = [count for count in counts.values()]\n        if sorted(pair_counts) == [2, 2, 2]:\n            return 750\n    \n    score = max_score_from_counts(counts)\n    return score if score > 0 else \"Zonk\"\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n", "\nfrom collections import Counter\n\ndef get_score(dice):\n    counts = Counter(dice)\n    \n    # Check for straight (1,2,3,4,5,6)\n    if len(dice) == 6 and sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Check for three pairs\n    if len(dice) == 6 and sorted(counts.values()) == [2, 2, 2]:\n        return 750\n    \n    def calculate_score(counts_dict):\n        score = 0\n        remaining_counts = counts_dict.copy()\n        \n        # Handle six of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 6:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 4\n                remaining_counts[num] -= 6\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle five of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 5:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 3\n                remaining_counts[num] -= 5\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle four of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 4:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score * 2\n                remaining_counts[num] -= 4\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle three of a kind\n        for num, count in list(remaining_counts.items()):\n            if count >= 3:\n                base_score = 1000 if num == 1 else num * 100\n                score += base_score\n                remaining_counts[num] -= 3\n                if remaining_counts[num] == 0:\n                    del remaining_counts[num]\n        \n        # Handle remaining 1s and 5s\n        if 1 in remaining_counts:\n            score += remaining_counts[1] * 100\n            del remaining_counts[1]\n        \n        if 5 in remaining_counts:\n            score += remaining_counts[5] * 50\n            del remaining_counts[5]\n        \n        return score\n    \n    result = calculate_score(counts)\n    return result if result > 0 else \"Zonk\"\n\n# Read input and process\ndice = list(map(int, input().strip()[1:-1].split(',')))\nresult = get_score(dice)\nprint(result)\n\n\n", "\ndef get_score(dice):\n    from collections import Counter\n    \n    # Count frequency of each die\n    counts = Counter(dice)\n    \n    # Make a copy to track remaining dice\n    remaining = counts.copy()\n    total_score = 0\n    \n    # Check for straight (1,2,3,4,5,6) - 1000 points\n    if len(dice) == 6 and set(dice) == {1, 2, 3, 4, 5, 6}:\n        return 1000\n    \n    # Check for three pairs - 750 points\n    if len(dice) == 6:\n        pairs = 0\n        can_form_three_pairs = True\n        temp_counts = counts.copy()\n        \n        for die, count in temp_counts.items():\n            if count == 2:\n                pairs += 1\n            elif count != 2:\n                can_form_three_pairs = False\n                break\n        \n        if can_form_three_pairs and pairs == 3:\n            return 750\n    \n    # Check for N of a kind (6, 5, 4 of a kind)\n    # Process from highest to lowest to maximize score\n    for n in [6, 5, 4, 3]:\n        for die_val in range(1, 7):\n            if remaining[die_val] >= n:\n                # Calculate base score for three of a kind\n                if die_val == 1:\n                    base_score = 1000\n                else:\n                    base_score = die_val * 100\n                \n                # Apply multiplier based on N\n                if n == 3:\n                    multiplier = 1\n                elif n == 4:\n                    multiplier = 2\n                elif n == 5:\n                    multiplier = 3\n                elif n == 6:\n                    multiplier = 4\n                \n                total_score += base_score * multiplier\n                remaining[die_val] -= n\n    \n    # Handle remaining three of a kind\n    for die_val in range(1, 7):\n        if remaining[die_val] >= 3:\n            if die_val == 1:\n                total_score += 1000\n            else:\n                total_score += die_val * 100\n            remaining[die_val] -= 3\n    \n    # Handle remaining 1s and 5s\n    total_score += remaining[1] * 100  # Each 1 is worth 100 points\n    total_score += remaining[5] * 50   # Each 5 is worth 50 points\n    \n    # If no score was made, return \"Zonk\"\n    if total_score == 0:\n        return \"Zonk\"\n    \n    return total_score\n\n# Read input and call function\ndice_input = eval(input())\nresult = get_score(dice_input)\nprint(result)\n\n\n"], "prompt_tokens": [19557, 19583, 20262, 21753, 19530, 20433], "completion_tokens": [5356, 6496, 7337, 8649, 6596, 6715], "no_of_try": 6, "api_calls": 60, "is_solved": true, "language": "Python3", "task_id": 3554}
{"name": "4724", "description": "DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.", "difficulty": "introductory", "id": 4724, "sample_io": [{"input": "apple of banana", "output": ["Apple of Banana"]}, {"input": "apple", "output": ["Apple"]}, {"input": "one   space", "output": ["One   Space"]}, {"input": "   space WALK   ", "output": ["   Space Walk   "]}], "test_list": [{"input": "Apple Banana", "output": ["Apple Banana"]}, {"input": "Apple", "output": ["Apple"]}, {"input": "", "output": [""]}, {"input": "of", "output": ["of"]}, {"input": "Revelation of the contents outraged American public opinion, and helped generate", "output": ["Revelation of The Contents Outraged American Public Opinion, And Helped Generate"]}, {"input": "more  than    one space between words", "output": ["More  Than    One Space Between Words"]}, {"input": "  leading spaces", "output": ["  Leading Spaces"]}, {"input": "trailing spaces   ", "output": ["Trailing Spaces   "]}, {"input": "ALL CAPS CRAZINESS", "output": ["All Caps Craziness"]}, {"input": "rAnDoM CaPs CrAzInEsS", "output": ["Random Caps Craziness"]}], "starter_code": "\ndef drop_cap(str_):\n\t", "source_codes": ["def drop_cap(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i] == ' ':\n            result.append(s[i])\n            i += 1\n        else:\n            # Find the end of the current word\n            start = i\n            while i < len(s) and s[i] != ' ':\n                i += 1\n            word = s[start:i]\n            if len(word) > 2:\n                result.append(word.capitalize())\n            else:\n                result.append(word)\n    return ''.join(result)\n\ns = input()\nprint(drop_cap(s))"], "responses": ["\ndef drop_cap(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i] == ' ':\n            result.append(s[i])\n            i += 1\n        else:\n            # Find the end of the current word\n            start = i\n            while i < len(s) and s[i] != ' ':\n                i += 1\n            word = s[start:i]\n            if len(word) > 2:\n                result.append(word.capitalize())\n            else:\n                result.append(word)\n    return ''.join(result)\n\ns = input()\nprint(drop_cap(s))\n\n\n"], "prompt_tokens": [4378], "completion_tokens": [2320], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4724}
{"name": "4561", "description": "Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st):\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!", "difficulty": "introductory", "id": 4561, "sample_io": [{"input": "adfa", "output": [true]}, {"input": "bd", "output": [true]}], "test_list": [{"input": "abba", "output": [true]}, {"input": "abaazaba", "output": [false]}, {"input": "abccba", "output": [true]}, {"input": "adfa", "output": [true]}, {"input": "ae", "output": [false]}, {"input": "abzy", "output": [false]}, {"input": "ababbaba", "output": [true]}, {"input": "sq", "output": [true]}, {"input": "kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm", "output": [true]}], "starter_code": "\ndef solve(st):\n\t", "source_codes": ["def solve(st):\n    def get_transformations(c):\n        if c == 'a':\n            return {'b'}\n        elif c == 'z':\n            return {'y'}\n        else:\n            return {chr(ord(c) - 1), chr(ord(c) + 1)}\n    \n    n = len(st)\n    for i in range((n + 1) // 2):\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        left_transforms = get_transformations(left_char)\n        right_transforms = get_transformations(right_char)\n        \n        # Check if there's at least one common transformation\n        if not left_transforms & right_transforms:\n            return False\n    \n    return True\n\nst = input().strip()\nprint(solve(st))"], "responses": ["\ndef solve(st):\n    def get_transformations(c):\n        if c == 'a':\n            return {'b'}\n        elif c == 'z':\n            return {'y'}\n        else:\n            return {chr(ord(c) - 1), chr(ord(c) + 1)}\n    \n    n = len(st)\n    for i in range((n + 1) // 2):\n        left_char = st[i]\n        right_char = st[n - 1 - i]\n        \n        left_transforms = get_transformations(left_char)\n        right_transforms = get_transformations(right_char)\n        \n        # Check if there's at least one common transformation\n        if not left_transforms & right_transforms:\n            return False\n    \n    return True\n\nst = input().strip()\nprint(solve(st))\n\n\n"], "prompt_tokens": [7817], "completion_tokens": [2858], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4561}
{"name": "4468", "description": "## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`", "difficulty": "introductory", "id": 4468, "sample_io": [{"input": "0", "output": [""]}, {"input": "56", "output": ["5*10+6"]}, {"input": "60", "output": ["6*10"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "10004", "output": ["1*10000+4"]}], "test_list": [{"input": "8964631", "output": ["8*1000000+9*100000+6*10000+4*1000+6*100+3*10+1"]}, {"input": "56", "output": ["5*10+6"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "11", "output": ["1*10+1"]}, {"input": "991", "output": ["9*100+9*10+1"]}, {"input": "47", "output": ["4*10+7"]}, {"input": "234", "output": ["2*100+3*10+4"]}, {"input": "196587", "output": ["1*100000+9*10000+6*1000+5*100+8*10+7"]}, {"input": "660", "output": ["6*100+6*10"]}, {"input": "600", "output": ["6*100"]}, {"input": "9090", "output": ["9*1000+9*10"]}, {"input": "10104", "output": ["1*10000+1*100+4"]}, {"input": "80008", "output": ["8*10000+8"]}, {"input": "90000", "output": ["9*10000"]}, {"input": "0", "output": [""]}], "starter_code": "\ndef simplify(n):\n\t", "source_codes": ["n = int(input())\n\nif n == 0:\n    print(\"\")\nelse:\n    s = str(n)\n    length = len(s)\n    result = []\n    \n    for i, digit in enumerate(s):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                result.append(digit)\n            elif power == 1:\n                result.append(f\"{digit}*10\")\n            else:\n                result.append(f\"{digit}*1{'0' * power}\")\n    \n    print(\"+\".join(result))"], "responses": ["\nn = int(input())\n\nif n == 0:\n    print(\"\")\nelse:\n    s = str(n)\n    length = len(s)\n    result = []\n    \n    for i, digit in enumerate(s):\n        if digit != '0':\n            power = length - i - 1\n            if power == 0:\n                result.append(digit)\n            elif power == 1:\n                result.append(f\"{digit}*10\")\n            else:\n                result.append(f\"{digit}*1{'0' * power}\")\n    \n    print(\"+\".join(result))\n\n\n"], "prompt_tokens": [7287], "completion_tokens": [2992], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4468}
{"name": "3613", "description": "# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 \u2264 string1.length \u2264 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value", "difficulty": "introductory", "id": 3613, "sample_io": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}], "test_list": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}, {"input": "aaxxaaz\naazzaay", "output": [true]}, {"input": "aaxyaa\naazzaa", "output": [false]}, {"input": "aazzaa\naaxyaa", "output": [false]}, {"input": "jpeuizmi\nmxxcwriq", "output": [false]}], "starter_code": "\ndef is_substitution_cipher(s1, s2):\n\t", "source_codes": ["def can_convert(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    # Handle empty strings\n    if len(string1) == 0:\n        return True\n    \n    # Mapping from string1 to string2\n    map1to2 = {}\n    # Mapping from string2 to string1\n    map2to1 = {}\n    \n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check if char1 already has a mapping\n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            # Check if char2 is already mapped to a different char\n            if char2 in map2to1:\n                if map2to1[char2] != char1:\n                    return False\n            map1to2[char1] = char2\n            map2to1[char2] = char1\n    \n    return True\n\n# Read input\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Check and print result\nresult = can_convert(string1, string2)\nprint(str(result))"], "responses": ["\ndef can_convert(string1, string2):\n    if len(string1) != len(string2):\n        return False\n    \n    # Handle empty strings\n    if len(string1) == 0:\n        return True\n    \n    # Mapping from string1 to string2\n    map1to2 = {}\n    # Mapping from string2 to string1\n    map2to1 = {}\n    \n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check if char1 already has a mapping\n        if char1 in map1to2:\n            if map1to2[char1] != char2:\n                return False\n        else:\n            # Check if char2 is already mapped to a different char\n            if char2 in map2to1:\n                if map2to1[char2] != char1:\n                    return False\n            map1to2[char1] = char2\n            map2to1[char2] = char1\n    \n    return True\n\n# Read input\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Check and print result\nresult = can_convert(string1, string2)\nprint(str(result))\n\n\n"], "prompt_tokens": [8968], "completion_tokens": [4234], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3613}
{"name": "4465", "description": "Write a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.", "difficulty": "introductory", "id": 4465, "sample_io": [{"input": "123456", "output": [654321]}, {"input": "105", "output": [510]}, {"input": "12", "output": [21]}], "test_list": [{"input": "69", "output": [96]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [7210]}, {"input": "414", "output": [441]}, {"input": "608719", "output": [987610]}, {"input": "123456789", "output": [987654321]}, {"input": "700000000001", "output": [710000000000]}, {"input": "666666", "output": [666666]}, {"input": "2", "output": [2]}, {"input": "0", "output": [0]}], "starter_code": "\ndef super_size(n):\n\t", "source_codes": ["def super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)"], "responses": ["\ndef super_size(n):\n    # Convert to string, sort digits in descending order, join back and convert to int\n    return int(''.join(sorted(str(n), reverse=True)))\n\n# Read input and call function\nn = int(input())\nresult = super_size(n)\nprint(result)\n\n\n"], "prompt_tokens": [6435], "completion_tokens": [1789], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4465}
{"name": "3045", "description": "Given 2 elevators (named \"left\" and \"right\") in a building with 3 floors (numbered `0` to `2`), write a function `elevator` accepting 3 arguments (in order):\n\n- `left` - The current floor of the left elevator\n- `right` - The current floor of the right elevator\n- `call` -  The floor that called an elevator\n\nIt should return the name of the elevator closest to the called floor (`\"left\"`/`\"right\"`).\n\nIn the case where both elevators are equally distant from the called floor, choose the elevator to the right.\n\nYou can assume that the inputs will always be valid integers between 0-2.\n\nExamples:\n\n```python\nelevator(0, 1, 0) # => \"left\"\nelevator(0, 1, 1) # => \"right\"\nelevator(0, 1, 2) # => \"right\"\nelevator(0, 0, 0) # => \"right\"\nelevator(0, 2, 1) # => \"right\"\n```", "difficulty": "introductory", "id": 3045, "sample_io": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}], "test_list": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}, {"input": "0\n0\n1", "output": ["right"]}, {"input": "0\n0\n2", "output": ["right"]}, {"input": "0\n2\n0", "output": ["left"]}, {"input": "0\n2\n2", "output": ["right"]}, {"input": "1\n0\n0", "output": ["right"]}, {"input": "1\n0\n1", "output": ["left"]}, {"input": "1\n0\n2", "output": ["left"]}, {"input": "1\n1\n0", "output": ["right"]}, {"input": "1\n1\n1", "output": ["right"]}, {"input": "1\n1\n2", "output": ["right"]}, {"input": "1\n2\n0", "output": ["left"]}, {"input": "1\n2\n1", "output": ["left"]}, {"input": "1\n2\n2", "output": ["right"]}, {"input": "2\n0\n0", "output": ["right"]}, {"input": "2\n0\n1", "output": ["right"]}, {"input": "2\n0\n2", "output": ["left"]}, {"input": "2\n1\n0", "output": ["right"]}, {"input": "2\n1\n1", "output": ["right"]}, {"input": "2\n1\n2", "output": ["left"]}, {"input": "2\n2\n0", "output": ["right"]}, {"input": "2\n2\n1", "output": ["right"]}, {"input": "2\n2\n2", "output": ["right"]}], "starter_code": "\ndef elevator(left, right, call):\n\t", "source_codes": ["def elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    else:  # right_distance <= left_distance, choose right\n        return \"right\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))"], "responses": ["\ndef elevator(left, right, call):\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    if left_distance < right_distance:\n        return \"left\"\n    else:  # right_distance <= left_distance, choose right\n        return \"right\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call function and print result\nprint(elevator(left, right, call))\n\n\n"], "prompt_tokens": [8310], "completion_tokens": [3430], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3045}
{"name": "4276", "description": "Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```", "difficulty": "introductory", "id": 4276, "sample_io": [{"input": "4.2", "output": [4]}, {"input": "4.3", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.8", "output": [5]}, {"input": "4.75", "output": [5]}], "test_list": [{"input": "4.2", "output": [4]}, {"input": "4.25", "output": [4.5]}, {"input": "4.4", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.75", "output": [5]}, {"input": "4.8", "output": [5]}, {"input": "4.5", "output": [4.5]}, {"input": "4.55", "output": [4.5]}, {"input": "4.74", "output": [4.5]}, {"input": "4.74999999999", "output": [4.5]}, {"input": "4.74999999991", "output": [4.5]}], "starter_code": "\ndef solution(n):\n\t", "source_codes": ["import math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Round half up: add 0.5 and floor\n    rounded = math.floor(doubled + 0.5)\n    \n    # Divide by 2 to return to original scale\n    result = rounded / 2\n    \n    # Format output - if it's a whole number, return as integer\n    if result == int(result):\n        return int(result)\n    else:\n        return result\n\n# Read input from stdin\nnumber = float(input())\n\n# Calculate and print the result\nresult = solution(number)\nprint(result)"], "responses": ["\nimport math\n\ndef solution(number):\n    # Multiply by 2 to work with 0.5 steps as integers\n    doubled = number * 2\n    \n    # Round half up: add 0.5 and floor\n    rounded = math.floor(doubled + 0.5)\n    \n    # Divide by 2 to return to original scale\n    result = rounded / 2\n    \n    # Format output - if it's a whole number, return as integer\n    if result == int(result):\n        return int(result)\n    else:\n        return result\n\n# Read input from stdin\nnumber = float(input())\n\n# Calculate and print the result\nresult = solution(number)\nprint(result)\n\n\n"], "prompt_tokens": [7164], "completion_tokens": [2708], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4276}
{"name": "2882", "description": "Imagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000", "difficulty": "introductory", "id": 2882, "sample_io": [{"input": "4", "output": [34]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [15]}, {"input": "4", "output": [34]}, {"input": "15", "output": [1695]}, {"input": "150", "output": [1687575]}, {"input": "100", "output": [500050]}, {"input": "500", "output": [62500250]}, {"input": "1000", "output": [500000500]}, {"input": "10000", "output": [500000005000]}], "starter_code": "\ndef cumulative_triangle(n):\n\t", "source_codes": ["def triangle_sum(n):\n    return n * (n * n + 1) // 2\n\nn = int(input())\nresult = triangle_sum(n)\nprint(result)"], "responses": ["\ndef triangle_sum(n):\n    return n * (n * n + 1) // 2\n\nn = int(input())\nresult = triangle_sum(n)\nprint(result)\n\n\n"], "prompt_tokens": [6221], "completion_tokens": [3253], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2882}
{"name": "4440", "description": "ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but **exactly** 4 digits or exactly 6 digits. \n\nIf the function is passed a valid PIN string, return `true`, else return `false`.\n\n## Examples \n```\n\"1234\"   -->  true\n\"12345\"  -->  false\n\"a234\"   -->  false\n```", "difficulty": "introductory", "id": 4440, "sample_io": [{"input": "1234", "output": [true]}, {"input": "12345", "output": [false]}, {"input": "a234", "output": [false]}], "test_list": [{"input": "1", "output": [false]}, {"input": "12", "output": [false]}, {"input": "123", "output": [false]}, {"input": "12345", "output": [false]}, {"input": "1234567", "output": [false]}, {"input": "-1234", "output": [false]}, {"input": "-12345", "output": [false]}, {"input": "1.234", "output": [false]}, {"input": "00000000", "output": [false]}, {"input": "a234", "output": [false]}, {"input": ".234", "output": [false]}, {"input": "1234", "output": [true]}, {"input": "0000", "output": [true]}, {"input": "1111", "output": [true]}, {"input": "123456", "output": [true]}, {"input": "098765", "output": [true]}, {"input": "000000", "output": [true]}, {"input": "090909", "output": [true]}], "starter_code": "\ndef validate_pin(pin):\n\t", "source_codes": ["def validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) == 4 or len(pin) == 6:\n        # Check if all characters are digits\n        if pin.isdigit():\n            return True\n    return False\n\n# Read input from standard input\npin = input().strip()\n\n# Call the function and print the result\nresult = validate_pin(pin)\nprint(str(result))"], "responses": ["\ndef validate_pin(pin):\n    # Check if length is exactly 4 or 6\n    if len(pin) == 4 or len(pin) == 6:\n        # Check if all characters are digits\n        if pin.isdigit():\n            return True\n    return False\n\n# Read input from standard input\npin = input().strip()\n\n# Call the function and print the result\nresult = validate_pin(pin)\nprint(str(result))\n\n\n"], "prompt_tokens": [6145], "completion_tokens": [1723], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4440}
{"name": "2771", "description": "Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book G\u00f6del, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!", "difficulty": "introductory", "id": 2771, "sample_io": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}], "test_list": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}, {"input": "100", "output": [56]}, {"input": "1000", "output": [502]}], "starter_code": "\ndef hofstadter_Q(n):\n\t", "source_codes": ["import sys\n\ndef hofstadter_q(n):\n    if n <= 0:\n        return None\n    if n <= 2:\n        return 1\n    \n    # Initialize memoization array\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n    \n    # Compute values iteratively from 3 to n\n    for i in range(3, n + 1):\n        memo[i] = memo[i - memo[i - 1]] + memo[i - memo[i - 2]]\n    \n    return memo[n]\n\n# Read input from stdin\nn = int(input().strip())\n\n# Compute and output the result\nresult = hofstadter_q(n)\nprint(result)"], "responses": ["\nimport sys\n\ndef hofstadter_q(n):\n    if n <= 0:\n        return None\n    if n <= 2:\n        return 1\n    \n    # Initialize memoization array\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n    \n    # Compute values iteratively from 3 to n\n    for i in range(3, n + 1):\n        memo[i] = memo[i - memo[i - 1]] + memo[i - memo[i - 2]]\n    \n    return memo[n]\n\n# Read input from stdin\nn = int(input().strip())\n\n# Compute and output the result\nresult = hofstadter_q(n)\nprint(result)\n\n\n"], "prompt_tokens": [8128], "completion_tokens": [4254], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2771}
{"name": "4335", "description": "What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:\n\n```\n'abba' & 'baab' == true\n\n'abba' & 'bbaa' == true\n\n'abba' & 'abbba' == false\n\n'abba' & 'abca' == false\n```\n\nWrite a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:\n\nanagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']\n\nanagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']\n\nanagrams('laser', ['lazing', 'lazy',  'lacer']) => []", "difficulty": "introductory", "id": 4335, "sample_io": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "laser\n['lazing', 'lazy', 'lacer']", "output": [[]]}], "test_list": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "a\n['a', 'b', 'c', 'd']", "output": [["a"]]}, {"input": "ab\n['cc', 'ac', 'bc', 'cd', 'ab', 'ba', 'racar', 'caers', 'racer']", "output": [["ab", "ba"]]}, {"input": "abba\n['a', 'b', 'c', 'd', 'aabb', 'bbaa', 'abab', 'baba', 'baab', 'abcd', 'abbba', 'baaab', 'abbab', 'abbaa', 'babaa']", "output": [["aabb", "bbaa", "abab", "baba", "baab"]]}, {"input": "big\n['gig', 'dib', 'bid', 'biig']", "output": [[]]}], "starter_code": "\ndef anagrams(word, words):\n\t", "source_codes": ["def anagrams(word, candidates):\n    # Create a frequency map for the input word\n    word_freq = {}\n    for char in word:\n        word_freq[char] = word_freq.get(char, 0) + 1\n    \n    result = []\n    \n    # Check each candidate\n    for candidate in candidates:\n        # Skip if lengths don't match\n        if len(candidate) != len(word):\n            continue\n            \n        # Create frequency map for candidate\n        candidate_freq = {}\n        for char in candidate:\n            candidate_freq[char] = candidate_freq.get(char, 0) + 1\n        \n        # Compare frequency maps\n        if candidate_freq == word_freq:\n            result.append(candidate)\n    \n    return result\n\n# Read input\nword = input().strip()\ncandidates_str = input().strip()\ncandidates = eval(candidates_str)\n\n# Find anagrams and print result\nresult = anagrams(word, candidates)\nprint(result)"], "responses": ["\ndef anagrams(word, candidates):\n    # Create a frequency map for the input word\n    word_freq = {}\n    for char in word:\n        word_freq[char] = word_freq.get(char, 0) + 1\n    \n    result = []\n    \n    # Check each candidate\n    for candidate in candidates:\n        # Skip if lengths don't match\n        if len(candidate) != len(word):\n            continue\n            \n        # Create frequency map for candidate\n        candidate_freq = {}\n        for char in candidate:\n            candidate_freq[char] = candidate_freq.get(char, 0) + 1\n        \n        # Compare frequency maps\n        if candidate_freq == word_freq:\n            result.append(candidate)\n    \n    return result\n\n# Read input\nword = input().strip()\ncandidates_str = input().strip()\ncandidates = eval(candidates_str)\n\n# Find anagrams and print result\nresult = anagrams(word, candidates)\nprint(result)\n\n\n"], "prompt_tokens": [8970], "completion_tokens": [3445], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4335}
{"name": "3512", "description": "Just like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```", "difficulty": "introductory", "id": 3512, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "1000", "output": [5]}, {"input": "1000000", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "21", "output": [6]}, {"input": "302", "output": [1]}, {"input": "4003", "output": [7]}, {"input": "50004", "output": [8]}, {"input": "600005", "output": [5]}, {"input": "7000006", "output": [3]}, {"input": "80000007", "output": [8]}, {"input": "900000008", "output": [1]}, {"input": "1000000009", "output": [9]}], "starter_code": "\ndef last_fib_digit(n):\n\t", "source_codes": ["def last_fib_digit(n):\n    # Pisano period for modulo 10 is 60\n    pisano_period = 60\n    \n    # Reduce n using the Pisano period\n    n = n % pisano_period\n    if n == 0:\n        n = pisano_period\n    \n    # Handle base cases\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    \n    # Calculate Fibonacci number iteratively, keeping only last digit\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, (a + b) % 10\n    \n    return b\n\n# Read input and solve\nn = int(input())\nprint(last_fib_digit(n))"], "responses": ["\ndef last_fib_digit(n):\n    # Pisano period for modulo 10 is 60\n    pisano_period = 60\n    \n    # Reduce n using the Pisano period\n    n = n % pisano_period\n    if n == 0:\n        n = pisano_period\n    \n    # Handle base cases\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    \n    # Calculate Fibonacci number iteratively, keeping only last digit\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, (a + b) % 10\n    \n    return b\n\n# Read input and solve\nn = int(input())\nprint(last_fib_digit(n))\n\n\n"], "prompt_tokens": [7681], "completion_tokens": [2569], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3512}
{"name": "3435", "description": "# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters called airstrike to help them in war - dashes and dots are spreaded everywhere on the battlefield.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and `*` which means a bomb drop place. Return who wins the fight after bombs are exploded. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3 \n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3 \n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.  \nThe `*` bombs kills the adjacent letters ( i.e. `aa*aa` => `a___a`, `**aa**` => `______` );\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war", "difficulty": "introductory", "id": 3435, "sample_io": [], "test_list": [{"input": "z", "output": ["Right side wins!"]}, {"input": "z*dq*mw*pb*s", "output": ["Let's fight again!"]}, {"input": "zdqmwpbs", "output": ["Let's fight again!"]}, {"input": "zz*zzs", "output": ["Right side wins!"]}, {"input": "sz**z**zs", "output": ["Left side wins!"]}, {"input": "z*z*z*zs", "output": ["Left side wins!"]}, {"input": "*wwwwww*z*", "output": ["Left side wins!"]}], "starter_code": "\ndef alphabet_war(fight):\n\t", "source_codes": ["def alphabet_war(fight):\n    # Define powers for left and right side letters\n    left_powers = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_powers = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Handle empty string case\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Convert string to list for easier manipulation\n    chars = list(fight)\n    length = len(chars)\n    \n    # Mark characters destroyed by bombs\n    destroyed = [False] * length\n    for i in range(length):\n        if chars[i] == '*':\n            # Destroy left adjacent character\n            if i > 0:\n                destroyed[i-1] = True\n            # Destroy right adjacent character\n            if i < length - 1:\n                destroyed[i+1] = True\n    \n    # Calculate total powers for both sides\n    left_power = 0\n    right_power = 0\n    \n    for i in range(length):\n        if not destroyed[i] and chars[i] != '*':\n            if chars[i] in left_powers:\n                left_power += left_powers[chars[i]]\n            elif chars[i] in right_powers:\n                right_power += right_powers[chars[i]]\n    \n    # Determine winner\n    if left_power > right_power:\n        return \"Left side wins!\"\n    elif right_power > left_power:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and call function\nfight = input().strip()\nresult = alphabet_war(fight)\nprint(result)"], "responses": ["\ndef alphabet_war(fight):\n    # Define powers for left and right side letters\n    left_powers = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_powers = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    \n    # Handle empty string case\n    if not fight:\n        return \"Let's fight again!\"\n    \n    # Convert string to list for easier manipulation\n    chars = list(fight)\n    length = len(chars)\n    \n    # Mark characters destroyed by bombs\n    destroyed = [False] * length\n    for i in range(length):\n        if chars[i] == '*':\n            # Destroy left adjacent character\n            if i > 0:\n                destroyed[i-1] = True\n            # Destroy right adjacent character\n            if i < length - 1:\n                destroyed[i+1] = True\n    \n    # Calculate total powers for both sides\n    left_power = 0\n    right_power = 0\n    \n    for i in range(length):\n        if not destroyed[i] and chars[i] != '*':\n            if chars[i] in left_powers:\n                left_power += left_powers[chars[i]]\n            elif chars[i] in right_powers:\n                right_power += right_powers[chars[i]]\n    \n    # Determine winner\n    if left_power > right_power:\n        return \"Left side wins!\"\n    elif right_power > left_power:\n        return \"Right side wins!\"\n    else:\n        return \"Let's fight again!\"\n\n# Read input and call function\nfight = input().strip()\nresult = alphabet_war(fight)\nprint(result)\n\n\n"], "prompt_tokens": [9731], "completion_tokens": [5018], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3435}
{"name": "3387", "description": "What's in a name?\n..Or rather, what's a name in? For us, a particular string is where we are looking for a name.\n\nTask\n\nTest whether or not the string contains all of the letters which spell a given name, in order.\n\nThe format\nA function passing two strings, searching for one (the name) within the other.\n``function nameInStr(str, name){ return true || false }``\n\nExamples\n\n    nameInStr(\"Across the rivers\", \"chris\") --> true\n                ^      ^  ^^   ^\n                c      h  ri   s\n                \n    Contains all of the letters in \"chris\", in order.\n----------------------------------------------------------\n    nameInStr(\"Next to a lake\", \"chris\") --> false\n    \n    Contains none of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"Under a sea\", \"chris\") --> false\n                   ^   ^\n                   r   s\n                   \n    Contains only some of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"A crew that boards the ship\", \"chris\") --> false\n                 cr    h              s i\n                 cr                h  s i  \n                 c     h      r       s i\n                 ...\n                 \n    Contains all of the letters in \"chris\", but not in order.\n--------------------------------------------------------------------\n    nameInStr(\"A live son\", \"Allison\") --> false\n               ^ ^^   ^^^\n               A li   son\n                 \n    Contains all of the correct letters in \"Allison\", in order, \n    but not enough of all of them (missing an 'l').\n    \n\nNote: testing will _not_ be case-sensitive.", "difficulty": "introductory", "id": 3387, "sample_io": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}], "test_list": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}, {"input": "Just enough nice friends\nJennifer", "output": [false]}, {"input": "thomas\nThomas", "output": [true]}, {"input": "pippippi\nPippi", "output": [true]}, {"input": "pipipp\nPippi", "output": [false]}, {"input": "ppipip\nPippi", "output": [false]}], "starter_code": "\ndef name_in_str(str, name):\n\t", "source_codes": ["def nameInStr(str_text, name):\n    str_text = str_text.lower()\n    name = name.lower()\n    \n    str_index = 0\n    name_index = 0\n    \n    while str_index < len(str_text) and name_index < len(name):\n        if str_text[str_index] == name[name_index]:\n            name_index += 1\n        str_index += 1\n    \n    return name_index == len(name)\n\n# Read input from stdin\nstr_input = input()\nname_input = input()\n\n# Call the function and print the result\nresult = nameInStr(str_input, name_input)\nprint(str(result).capitalize())"], "responses": ["\ndef nameInStr(str_text, name):\n    str_text = str_text.lower()\n    name = name.lower()\n    \n    str_index = 0\n    name_index = 0\n    \n    while str_index < len(str_text) and name_index < len(name):\n        if str_text[str_index] == name[name_index]:\n            name_index += 1\n        str_index += 1\n    \n    return name_index == len(name)\n\n# Read input from stdin\nstr_input = input()\nname_input = input()\n\n# Call the function and print the result\nresult = nameInStr(str_input, name_input)\nprint(str(result).capitalize())\n\n\n"], "prompt_tokens": [9846], "completion_tokens": [3634], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3387}
{"name": "4024", "description": "# Definition \n\nA number is a **_Special Number_** *if it\u2019s digits only consist 0, 1, 2, 3, 4 or 5*\n\n**_Given_** a number *determine if it special number or not* .  \n\n\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_The number_** passed will be **_positive_** (N > 0) .\n\n* All **single-digit numbers** with in the interval **_[0:5]_** are considered as **_special number_**. \n___\n\n# Input >> Output Examples\n\n```\nspecialNumber(2) ==> return \"Special!!\"\n```\n## Explanation: \n\nIt's **_a single-digit number_** within the interval **_[0:5]_** . \n\n```\nspecialNumber(9) ==> return \"NOT!!\"\n```\n## Explanation:\n\nAlthough, it's a single-digit number but **_Outside the interval [0:5]_** .\n\n```\nspecialNumber(23) ==> return \"Special!!\"\n```\n## Explanation: \n\nAll **_the number's digits_** formed from the interval **_[0:5]_** digits .\n\n```\nspecialNumber(39) ==> return \"NOT!!\"\n```\n## Explanation: \n\nAlthough, *there is a digit (3) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(59) ==> return \"NOT!!\"\n```\n## Explanation:  \n\nAlthough, *there is a digit (5) Within the interval* **_But_** **_the second digit is not (Must be ALL The Number's Digits )_** .\n\n```\nspecialNumber(513) ==> return \"Special!!\"\n```\n___\n```\nspecialNumber(709) ==> return \"NOT!!\"\n```\n___\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)          \n\n### ALL translation are welcomed\n\n## Enjoy Learning !!\n# Zizou", "difficulty": "introductory", "id": 4024, "sample_io": [{"input": "2", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "59", "output": ["NOT!!"]}, {"input": "513", "output": ["Special!!"]}, {"input": "709", "output": ["NOT!!"]}], "test_list": [{"input": "2", "output": ["Special!!"]}, {"input": "3", "output": ["Special!!"]}, {"input": "5", "output": ["Special!!"]}, {"input": "9", "output": ["NOT!!"]}, {"input": "7", "output": ["NOT!!"]}, {"input": "23", "output": ["Special!!"]}, {"input": "79", "output": ["NOT!!"]}, {"input": "32", "output": ["Special!!"]}, {"input": "39", "output": ["NOT!!"]}, {"input": "55", "output": ["Special!!"]}, {"input": "11350224", "output": ["Special!!"]}], "starter_code": "\ndef special_number(number):\n\t", "source_codes": ["def specialNumber(n):\n    for digit in str(n):\n        if digit > '5':\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input().strip())\nprint(specialNumber(n))"], "responses": ["\ndef specialNumber(n):\n    for digit in str(n):\n        if digit > '5':\n            return \"NOT!!\"\n    return \"Special!!\"\n\nn = int(input().strip())\nprint(specialNumber(n))\n\n\n"], "prompt_tokens": [10134], "completion_tokens": [2356], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 4024}
{"name": "3478", "description": "Magic The Gathering is a collectible card game that features wizards battling against each other with spells and creature summons. The game itself can be quite complicated to learn. In this series of katas, we'll be solving some of the situations that arise during gameplay. You won't need any prior knowledge of the game to solve these contrived problems, as I will provide you with enough information.\n\n## Creatures\n\nEach creature has a power and toughness. We will represent this in an array. [2, 3] means this creature has a power of 2 and a toughness of 3.\n\nWhen two creatures square off, they each deal damage equal to their power to each other at the same time. If a creature takes on damage greater than or equal to their toughness, they die.\n\nExamples:\n\n- Creature 1 - [2, 3]\n- Creature 2 - [3, 3]\n- Creature 3 - [1, 4]\n- Creature 4 - [4, 1]\n\nIf creature 1 battles creature 2, creature 1 dies, while 2 survives. If creature 3 battles creature 4, they both die, as 3 deals 1 damage to 4, but creature 4 only has a toughness of 1.\n\nWrite a function `battle(player1, player2)` that takes in 2 arrays of creatures. Each players' creatures battle each other in order (player1[0] battles the creature in player2[0]) and so on. If one list of creatures is longer than the other, those creatures are considered unblocked, and do not battle.\n\nYour function should return an object (a hash in Ruby) with the keys player1 and player2 that contain the power and toughness of the surviving creatures.\n\nExample:\n```\nGood luck with your battles!\n\n\nCheck out my other Magic The Gathering katas:\n\n\nMagic The Gathering #1: Creatures\nMagic The Gathering #2: Mana", "difficulty": "introductory", "id": 3478, "sample_io": [], "test_list": [{"input": "[[2, 3], [1, 4]]\n[[3, 3], [4, 1]]", "output": [{"player1": [], "player2": [[3, 3]]}]}, {"input": "[]\n[]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 1]]\n[[1, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 1]]\n[[2, 1]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[1, 2]]\n[[1, 2]]", "output": [{"player1": [[1, 2]], "player2": [[1, 2]]}]}, {"input": "[[2, 3]]\n[[3, 2]]", "output": [{"player1": [], "player2": []}]}, {"input": "[[2, 7]]\n[[3, 5]]", "output": [{"player1": [[2, 7]], "player2": [[3, 5]]}]}, {"input": "[[2, 5]]\n[[6, 6]]", "output": [{"player1": [], "player2": [[6, 6]]}]}, {"input": "[[6, 6]]\n[[2, 5]]", "output": [{"player1": [[6, 6]], "player2": []}]}, {"input": "[]\n[[1, 1], [2, 2]]", "output": [{"player1": [], "player2": [[1, 1], [2, 2]]}]}, {"input": "[[1, 1], [2, 2]]\n[]", "output": [{"player1": [[1, 1], [2, 2]], "player2": []}]}, {"input": "[[1, 3], [3, 5], [4, 6], [5, 2]]\n[[2, 4], [6, 1], [4, 4], [3, 7], [3, 1]]", "output": [{"player1": [[1, 3], [4, 6]], "player2": [[2, 4], [3, 7], [3, 1]]}]}], "starter_code": "\ndef battle(player1, player2):\n\t", "source_codes": ["def battle(player1, player2):\n    # Create copies to avoid modifying original lists\n    p1_creatures = [list(creature) for creature in player1]\n    p2_creatures = [list(creature) for creature in player2]\n    \n    # Determine number of battles\n    num_battles = min(len(p1_creatures), len(p2_creatures))\n    \n    # Process battles\n    for i in range(num_battles):\n        p1_power, p1_toughness = p1_creatures[i]\n        p2_power, p2_toughness = p2_creatures[i]\n        \n        # Deal damage simultaneously\n        # Each creature deals damage equal to its power\n        p1_creatures[i][1] -= p2_power  # p1 takes damage from p2\n        p2_creatures[i][1] -= p1_power  # p2 takes damage from p1\n    \n    # Filter out dead creatures and use original stats for survivors\n    surviving_p1 = []\n    surviving_p2 = []\n    \n    # Check battled creatures\n    for i in range(num_battles):\n        # Use original stats for survivors\n        if p1_creatures[i][1] > 0:  # Changed >= to >\n            surviving_p1.append(list(player1[i]))\n        if p2_creatures[i][1] > 0:  # Changed >= to >\n            surviving_p2.append(list(player2[i]))\n    \n    # Add unblocked creatures (those beyond the battle count) with original stats\n    surviving_p1.extend([list(creature) for creature in player1[num_battles:]])\n    surviving_p2.extend([list(creature) for creature in player2[num_battles:]])\n    \n    return {\"player1\": surviving_p1, \"player2\": surviving_p2}\n\n# Read input and execute\nif __name__ == \"__main__\":\n    player1 = eval(input())\n    player2 = eval(input())\n    result = battle(player1, player2)\n    print(result)"], "responses": ["\ndef battle(player1, player2):\n    # Create copies to avoid modifying original lists\n    p1_creatures = [list(creature) for creature in player1]\n    p2_creatures = [list(creature) for creature in player2]\n    \n    # Determine number of battles\n    num_battles = min(len(p1_creatures), len(p2_creatures))\n    \n    # Process battles\n    for i in range(num_battles):\n        p1_power, p1_toughness = p1_creatures[i]\n        p2_power, p2_toughness = p2_creatures[i]\n        \n        # Deal damage simultaneously\n        # Each creature deals damage equal to its power\n        p1_creatures[i][1] -= p2_power  # p1 takes damage from p2\n        p2_creatures[i][1] -= p1_power  # p2 takes damage from p1\n    \n    # Filter out dead creatures and use original stats for survivors\n    surviving_p1 = []\n    surviving_p2 = []\n    \n    # Check battled creatures\n    for i in range(num_battles):\n        # Use original stats for survivors\n        if p1_creatures[i][1] > 0:  # Changed >= to >\n            surviving_p1.append(list(player1[i]))\n        if p2_creatures[i][1] > 0:  # Changed >= to >\n            surviving_p2.append(list(player2[i]))\n    \n    # Add unblocked creatures (those beyond the battle count) with original stats\n    surviving_p1.extend([list(creature) for creature in player1[num_battles:]])\n    surviving_p2.extend([list(creature) for creature in player2[num_battles:]])\n    \n    return {\"player1\": surviving_p1, \"player2\": surviving_p2}\n\n# Read input and execute\nif __name__ == \"__main__\":\n    player1 = eval(input())\n    player2 = eval(input())\n    result = battle(player1, player2)\n    print(result)\n\n\n"], "prompt_tokens": [10516], "completion_tokens": [9224], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3478}
{"name": "3766", "description": "~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)", "difficulty": "introductory", "id": 3766, "sample_io": [{"input": "100", "output": [[2, 2, 5, 5]]}], "test_list": [{"input": "10", "output": [[2, 5]]}, {"input": "100", "output": [[2, 2, 5, 5]]}, {"input": "1000", "output": [[2, 2, 2, 5, 5, 5]]}, {"input": "1000001", "output": [[101, 9901]]}, {"input": "0", "output": [[]]}, {"input": "1", "output": [[1]]}, {"input": "2", "output": [[2]]}, {"input": "a", "output": [[]]}, {"input": "1.1", "output": [[]]}, {"input": "-1", "output": [[]]}], "starter_code": "\ndef getAllPrimeFactors(n):\n\t", "source_codes": ["import sys\nimport math\n\ndef getAllPrimeFactors(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n    \n    factors = []\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n        \n    unique_factors = []\n    counts = []\n    i = 0\n    while i < len(factors):\n        current = factors[i]\n        unique_factors.append(current)\n        count = 1\n        while i + count < len(factors) and factors[i + count] == current:\n            count += 1\n        counts.append(count)\n        i += count\n    return [unique_factors, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n        \n    # Get unique factors and counts\n    unique_factors, counts = getUniquePrimeFactorsWithCount(n)\n    # Handle edge case where there are no factors\n    if not unique_factors:\n        return []\n        \n    products = []\n    for i in range(len(unique_factors)):\n        products.append(unique_factors[i] ** counts[i])\n    return products\n\n# Read input and execute\nn = int(input())\nresult = getAllPrimeFactors(n)\nprint(result)", "import sys\n\ndef getAllPrimeFactors(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n    \n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n        if divisor * divisor > n and n > 1:\n            factors.append(n)\n            break\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    if n == 1:\n        return [[1], [1]]\n        \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n        \n    unique_primes = []\n    counts = []\n    i = 0\n    while i < len(factors):\n        prime = factors[i]\n        count = 0\n        j = i\n        while j < len(factors) and factors[j] == prime:\n            count += 1\n            j += 1\n        unique_primes.append(prime)\n        counts.append(count)\n        i = j\n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n        \n    unique_factors, counts = getUniquePrimeFactorsWithCount(n)\n    if not unique_factors:\n        return []\n        \n    products = []\n    for i in range(len(unique_factors)):\n        products.append(unique_factors[i] ** counts[i])\n    return products\n\ntry:\n    n = int(input())\n    result = getAllPrimeFactors(n)\n    print(result)\nexcept ValueError:\n    print([])"], "responses": ["\nimport sys\nimport math\n\ndef getAllPrimeFactors(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n    \n    factors = []\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    if n == 1:\n        return [[1], [1]]\n    \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n        \n    unique_factors = []\n    counts = []\n    i = 0\n    while i < len(factors):\n        current = factors[i]\n        unique_factors.append(current)\n        count = 1\n        while i + count < len(factors) and factors[i + count] == current:\n            count += 1\n        counts.append(count)\n        i += count\n    return [unique_factors, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    # Handle invalid inputs\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n        \n    # Get unique factors and counts\n    unique_factors, counts = getUniquePrimeFactorsWithCount(n)\n    # Handle edge case where there are no factors\n    if not unique_factors:\n        return []\n        \n    products = []\n    for i in range(len(unique_factors)):\n        products.append(unique_factors[i] ** counts[i])\n    return products\n\n# Read input and execute\nn = int(input())\nresult = getAllPrimeFactors(n)\nprint(result)\n\n\n", "\nimport sys\n\ndef getAllPrimeFactors(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n    \n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n        if divisor * divisor > n and n > 1:\n            factors.append(n)\n            break\n    return factors\n\ndef getUniquePrimeFactorsWithCount(n):\n    if not isinstance(n, int) or n <= 0:\n        return [[], []]\n    if n == 1:\n        return [[1], [1]]\n        \n    factors = getAllPrimeFactors(n)\n    if not factors:\n        return [[], []]\n        \n    unique_primes = []\n    counts = []\n    i = 0\n    while i < len(factors):\n        prime = factors[i]\n        count = 0\n        j = i\n        while j < len(factors) and factors[j] == prime:\n            count += 1\n            j += 1\n        unique_primes.append(prime)\n        counts.append(count)\n        i = j\n    return [unique_primes, counts]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n    if n == 1:\n        return [1]\n        \n    unique_factors, counts = getUniquePrimeFactorsWithCount(n)\n    if not unique_factors:\n        return []\n        \n    products = []\n    for i in range(len(unique_factors)):\n        products.append(unique_factors[i] ** counts[i])\n    return products\n\ntry:\n    n = int(input())\n    result = getAllPrimeFactors(n)\n    print(result)\nexcept ValueError:\n    print([])\n\n\n"], "prompt_tokens": [15056, 14817], "completion_tokens": [4979, 5600], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 3766}
{"name": "3292", "description": "Given a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```", "difficulty": "introductory", "id": 3292, "sample_io": [{"input": "ABC", "output": [6]}], "test_list": [{"input": "abcdef", "output": [6]}, {"input": "ifkhchlhfd", "output": [6]}, {"input": "aaaaaddddr", "output": [30]}, {"input": "jfmgklf8hglbe", "output": [6]}, {"input": "jaam", "output": [12]}, {"input": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "output": [96]}], "starter_code": "\ndef calc(x):\n\t", "source_codes": ["s = input().strip()\n\n# Step 1: Convert each character to ASCII and concatenate to form total1\ntotal1 = ''.join(str(ord(char)) for char in s)\n\n# Step 2: Replace all occurrences of '7' with '1' to form total2\ntotal2 = total1.replace('7', '1')\n\n# Step 3: Calculate the sum of digits in total1 and total2\nsum1 = sum(int(digit) for digit in total1)\nsum2 = sum(int(digit) for digit in total2)\n\n# Step 4: Output the difference\nprint(sum1 - sum2)"], "responses": ["\ns = input().strip()\n\n# Step 1: Convert each character to ASCII and concatenate to form total1\ntotal1 = ''.join(str(ord(char)) for char in s)\n\n# Step 2: Replace all occurrences of '7' with '1' to form total2\ntotal2 = total1.replace('7', '1')\n\n# Step 3: Calculate the sum of digits in total1 and total2\nsum1 = sum(int(digit) for digit in total1)\nsum2 = sum(int(digit) for digit in total2)\n\n# Step 4: Output the difference\nprint(sum1 - sum2)\n\n\n"], "prompt_tokens": [6979], "completion_tokens": [2710], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3292}
{"name": "2886", "description": "# Description:\n\n Find the longest successive exclamation marks and question marks combination in the string. A successive exclamation marks and question marks combination must contains two part: a substring of \"!\" and a substring \"?\", they are adjacent. \n \n If more than one result are found, return the one which at left side; If no such a combination found, return `\"\"`.\n\n# Examples\n\n```\nfind(\"!!\") === \"\"\nfind(\"!??\") === \"!??\"\nfind(\"!?!!\") === \"?!!\"\nfind(\"!!???!????\") === \"!!???\"\nfind(\"!!???!?????\") === \"!?????\"\nfind(\"!????!!!?\") === \"????!!!\" \nfind(\"!?!!??!!!?\") === \"??!!!\"\n```\n\n# Note\nPlease don't post issue about difficulty or duplicate. Because:\n>[That's unfair on the kata creator. This is a valid kata and introduces new people to javascript some regex or loops, depending on how they tackle this problem.  --matt c](https://www.codewars.com/kata/remove-exclamation-marks/discuss#57fabb625c9910c73000024e)", "difficulty": "introductory", "id": 2886, "sample_io": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "test_list": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "starter_code": "\ndef find(s):\n\t", "source_codes": ["s = input().strip()\n\nmax_len = 0\nresult = \"\"\n\ni = 0\nwhile i < len(s) - 1:\n    if s[i] in '!?':\n        # Found start of potential combination\n        # Check if we have '!' followed by '?' or '?' followed by '!'\n        \n        # Case 1: '!' followed by '?'\n        if s[i] == '!':\n            # Count consecutive '!'\n            excl_count = 0\n            j = i\n            while j < len(s) and s[j] == '!':\n                excl_count += 1\n                j += 1\n            \n            # Count consecutive '?' after '!'\n            ques_count = 0\n            while j < len(s) and s[j] == '?':\n                ques_count += 1\n                j += 1\n            \n            # Valid combination if both counts > 0\n            if excl_count > 0 and ques_count > 0:\n                combo_len = excl_count + ques_count\n                if combo_len > max_len:\n                    max_len = combo_len\n                    result = '!' * excl_count + '?' * ques_count\n                i = j - ques_count  # Move past the '?' part\n                continue\n        \n        # Case 2: '?' followed by '!'\n        if s[i] == '?':\n            # Count consecutive '?'\n            ques_count = 0\n            j = i\n            while j < len(s) and s[j] == '?':\n                ques_count += 1\n                j += 1\n            \n            # Count consecutive '!' after '?'\n            excl_count = 0\n            while j < len(s) and s[j] == '!':\n                excl_count += 1\n                j += 1\n            \n            # Valid combination if both counts > 0\n            if ques_count > 0 and excl_count > 0:\n                combo_len = ques_count + excl_count\n                if combo_len > max_len:\n                    max_len = combo_len\n                    result = '?' * ques_count + '!' * excl_count\n                i = j - excl_count  # Move past the '!' part\n                continue\n    \n    i += 1\n\nprint(result)"], "responses": ["\ns = input().strip()\n\nmax_len = 0\nresult = \"\"\n\ni = 0\nwhile i < len(s) - 1:\n    if s[i] in '!?':\n        # Found start of potential combination\n        # Check if we have '!' followed by '?' or '?' followed by '!'\n        \n        # Case 1: '!' followed by '?'\n        if s[i] == '!':\n            # Count consecutive '!'\n            excl_count = 0\n            j = i\n            while j < len(s) and s[j] == '!':\n                excl_count += 1\n                j += 1\n            \n            # Count consecutive '?' after '!'\n            ques_count = 0\n            while j < len(s) and s[j] == '?':\n                ques_count += 1\n                j += 1\n            \n            # Valid combination if both counts > 0\n            if excl_count > 0 and ques_count > 0:\n                combo_len = excl_count + ques_count\n                if combo_len > max_len:\n                    max_len = combo_len\n                    result = '!' * excl_count + '?' * ques_count\n                i = j - ques_count  # Move past the '?' part\n                continue\n        \n        # Case 2: '?' followed by '!'\n        if s[i] == '?':\n            # Count consecutive '?'\n            ques_count = 0\n            j = i\n            while j < len(s) and s[j] == '?':\n                ques_count += 1\n                j += 1\n            \n            # Count consecutive '!' after '?'\n            excl_count = 0\n            while j < len(s) and s[j] == '!':\n                excl_count += 1\n                j += 1\n            \n            # Valid combination if both counts > 0\n            if ques_count > 0 and excl_count > 0:\n                combo_len = ques_count + excl_count\n                if combo_len > max_len:\n                    max_len = combo_len\n                    result = '?' * ques_count + '!' * excl_count\n                i = j - excl_count  # Move past the '!' part\n                continue\n    \n    i += 1\n\nprint(result)\n\n\n"], "prompt_tokens": [7586], "completion_tokens": [3040], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 2886}
{"name": "4515", "description": "Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.", "difficulty": "introductory", "id": 4515, "sample_io": [{"input": "['56-23','1-100']", "output": ["1-100"]}, {"input": "['1-3', '5-7', '2-3']", "output": ["1-3"]}, {"input": "['11-11', '344-344']", "output": [false]}], "test_list": [{"input": "['43-45', '1021-55', '000-18888', '92-34', '76-32', '99-1', '1020-54']", "output": ["000-18888"]}, {"input": "['1-2', '2-4', '5-7', '8-9', '44-45']", "output": ["2-4"]}, {"input": "['1-1000', '2-1000', '100-67', '98-45', '8-9']", "output": ["1-1000"]}, {"input": "['33-33', '77-77']", "output": [false]}, {"input": "['23-67', '67-23', '88-88', '45-46']", "output": ["23-67"]}, {"input": "['45896-2354', '4654-556767', '2455-423522', '3455-355', '34-34', '2524522-0']", "output": ["2524522-0"]}, {"input": "['1-1', '2-2', '1-0', '77-77']", "output": ["1-0"]}, {"input": "['0-0']", "output": [false]}, {"input": "[]", "output": [false]}], "starter_code": "\ndef diff(arr):\n\t", "source_codes": ["def find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input and process\ncouples = eval(input())\nresult = find_greatest_difference(couples)\nprint(result)", "import sys\nimport ast\n\ndef find_greatest_difference_couple(couples):\n    max_diff = -1\n    result_couple = \"\"\n    \n    for couple in couples:\n        # Remove any whitespace and split by '-'\n        num1, num2 = map(int, couple.strip().split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_couple = couple.strip()\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result_couple\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n# Parse the input string to extract the array\ncouples = ast.literal_eval(input_str)\n\n# Handle empty array case\nif not couples or couples == ['']:\n    print(False)\nelse:\n    result = find_greatest_difference_couple(couples)\n    print(result)"], "responses": ["\ndef find_greatest_difference(couples):\n    max_diff = -1\n    result = \"\"\n    \n    for couple in couples:\n        parts = couple.split('-')\n        num1 = int(parts[0])\n        num2 = int(parts[1])\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input and process\ncouples = eval(input())\nresult = find_greatest_difference(couples)\nprint(result)\n\n\n", "\nimport sys\nimport ast\n\ndef find_greatest_difference_couple(couples):\n    max_diff = -1\n    result_couple = \"\"\n    \n    for couple in couples:\n        # Remove any whitespace and split by '-'\n        num1, num2 = map(int, couple.strip().split('-'))\n        diff = abs(num1 - num2)\n        \n        if diff > max_diff:\n            max_diff = diff\n            result_couple = couple.strip()\n    \n    if max_diff == 0:\n        return False\n    else:\n        return result_couple\n\n# Read input from stdin\ninput_str = sys.stdin.read().strip()\n# Parse the input string to extract the array\ncouples = ast.literal_eval(input_str)\n\n# Handle empty array case\nif not couples or couples == ['']:\n    print(False)\nelse:\n    result = find_greatest_difference_couple(couples)\n    print(result)\n\n\n"], "prompt_tokens": [6929, 7574], "completion_tokens": [2279, 2151], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 4515}
{"name": "3068", "description": "You need to play around with the provided string (s).\n\nMove consonants forward 9 places through the alphabet.\nIf they pass 'z', start again at 'a'.\n\nMove vowels back 5 places through the alphabet.\nIf they pass 'a', start again at 'z'.\nFor our Polish friends this kata does not count 'y' as a vowel.\n\nExceptions:\n\nIf the character is 'c' or 'o', move it back 1 place.\nFor 'd' move it back 3, and for 'e', move it back 4.\n\nIf a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.\n\nProvided string will always be lower case, won't be empty and will have no special characters.", "difficulty": "introductory", "id": 3068, "sample_io": [], "test_list": [{"input": "testcase", "output": ["tabtbvba"]}, {"input": "codewars", "output": ["bnaafvab"]}, {"input": "exampletesthere", "output": ["agvvyuatabtqaaa"]}, {"input": "returnofthespacecamel", "output": ["aatpawnftqabyvbabvvau"]}, {"input": "bringonthebootcamp", "output": ["kaiwpnwtqaknntbvvy"]}, {"input": "weneedanofficedog", "output": ["fawaaavwnffibaanp"]}], "starter_code": "\ndef vowel_back(st):\n\t", "source_codes": ["def move_forward(char, steps):\n    return chr((ord(char) - ord('a') + steps) % 26 + ord('a'))\n\ndef move_backward(char, steps):\n    return chr((ord(char) - ord('a') - steps) % 26 + ord('a'))\n\ndef is_vowel(char):\n    return char in 'aeiou'\n\ndef transform_char(char):\n    # Exception rules\n    if char == 'c' or char == 'o':\n        new_char = move_backward(char, 1)\n    elif char == 'd':\n        new_char = move_backward(char, 3)\n    elif char == 'e':\n        new_char = move_backward(char, 4)\n    # Vowels (not exceptions)\n    elif is_vowel(char):\n        new_char = move_backward(char, 5)\n    # Consonants\n    else:\n        new_char = move_forward(char, 9)\n    \n    # Revert if transformed to exception characters\n    if new_char in 'code':\n        return char\n    else:\n        return new_char\n\n# Read input\ns = input().strip()\n\n# Transform each character\nresult = ''.join(transform_char(char) for char in s)\n\n# Print result\nprint(result)"], "responses": ["\ndef move_forward(char, steps):\n    return chr((ord(char) - ord('a') + steps) % 26 + ord('a'))\n\ndef move_backward(char, steps):\n    return chr((ord(char) - ord('a') - steps) % 26 + ord('a'))\n\ndef is_vowel(char):\n    return char in 'aeiou'\n\ndef transform_char(char):\n    # Exception rules\n    if char == 'c' or char == 'o':\n        new_char = move_backward(char, 1)\n    elif char == 'd':\n        new_char = move_backward(char, 3)\n    elif char == 'e':\n        new_char = move_backward(char, 4)\n    # Vowels (not exceptions)\n    elif is_vowel(char):\n        new_char = move_backward(char, 5)\n    # Consonants\n    else:\n        new_char = move_forward(char, 9)\n    \n    # Revert if transformed to exception characters\n    if new_char in 'code':\n        return char\n    else:\n        return new_char\n\n# Read input\ns = input().strip()\n\n# Transform each character\nresult = ''.join(transform_char(char) for char in s)\n\n# Print result\nprint(result)\n\n\n"], "prompt_tokens": [3870], "completion_tokens": [1869], "no_of_try": 1, "api_calls": 6, "is_solved": true, "language": "Python3", "task_id": 3068}
{"name": "4214", "description": "In this kata you will have to modify a sentence so it meets the following rules:\n\nconvert every word backwards that is:\n\n    longer than 6 characters\n\n  OR\n\n    has 2 or more 'T' or 't' in it\n\nconvert every word uppercase that is:\n\n    exactly 2 characters long\n\n  OR\n\n    before a comma\n\nconvert every word to a \"0\" that is:\n\n    exactly one character long\n \n\n NOTES: \n\n      Punctuation must not be touched. if a word is 6 characters long, and a \".\" is behind it,\n      it counts as 6 characters so it must not be flipped, but if a word is 7 characters long,\n      it must be flipped but the \".\" must stay at the end of the word.\n      -----------------------------------------------------------------------------------------\n      Only the first transformation applies to a given word, for example 'companions,'\n      will be 'snoinapmoc,' and not 'SNOINAPMOC,'.\n      -----------------------------------------------------------------------------------------\n      As for special characters like apostrophes or dashes, they count as normal characters, \n      so e.g 'sand-colored' must be transformed to 'deroloc-dnas'.", "difficulty": "introductory", "id": 4214, "sample_io": [{"input": "companions,", "output": ["snoinapmoc,"]}, {"input": "sand-colored", "output": ["deroloc-dnas"]}], "test_list": [{"input": "Welcome.", "output": ["emocleW."]}, {"input": "If a man does not keep pace with his companions, perhaps it is because he hears a different drummer.", "output": ["IF 0 man does not keep pace with his snoinapmoc, spahrep IT IS esuaceb HE hears 0 tnereffid remmurd."]}, {"input": "As Grainier drove along in the wagon behind a wide, slow, sand-colored mare, clusters of orange butterflies exploded off the purple blackish piles of bear sign and winked and winked and fluttered magically like leaves without trees.", "output": ["AS reiniarG drove along IN the wagon behind 0 WIDE, SLOW, deroloc-dnas MARE, sretsulc OF orange seilfrettub dedolpxe off the purple hsikcalb piles OF bear sign and winked and winked and derettulf yllacigam like leaves tuohtiw trees."]}, {"input": "You should check the mileage on your car since you've been driving it so much, and because it's starting to make weird noises.", "output": ["You should check the egaelim ON your car since you've been gnivird IT SO MUCH, and esuaceb it's gnitrats TO make weird noises."]}, {"input": "Wherever you go, you can always find beauty.", "output": ["reverehW you GO, you can always find beauty."]}, {"input": "Action is indeed, commmmmmmming.", "output": ["Action IS INDEED, gnimmmmmmmmoc."]}, {"input": "Mother, please, help, me.", "output": ["MOTHER, PLEASE, HELP, ME."]}, {"input": "Jojojo, jojo, tata man kata.", "output": ["JOJOJO, JOJO, atat man kata."]}], "starter_code": "\ndef spin_solve(sentence):\n\t", "source_codes": ["import re\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace tokens\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part and punctuation part\n        match = re.match(r\"(\\w+)(\\W*)\", token)\n        if match:\n            word_part = match.group(1)\n            punct_part = match.group(2)\n            \n            # Count 't' and 'T' in the word part\n            t_count = word_part.lower().count('t')\n            \n            # Apply transformations in order\n            if len(word_part) > 6 or t_count >= 2:\n                # Rule 1: reverse the word part\n                transformed = word_part[::-1] + punct_part\n            elif len(word_part) == 2 or (punct_part.startswith(',') and len(punct_part) == 1):\n                # Rule 2: uppercase the word part\n                # Word is exactly 2 characters OR word ends with just a comma\n                transformed = word_part.upper() + punct_part\n            elif len(word_part) == 1:\n                # Rule 3: convert to \"0\"\n                transformed = \"0\" + punct_part\n            else:\n                # No transformation\n                transformed = token\n                \n            result_tokens.append(transformed)\n        else:\n            # Token is only punctuation/whitespace\n            result_tokens.append(token)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)", "import re\nimport sys\n\ndef process_word(word, next_part=\"\"):\n    # Separate the word from trailing punctuation\n    match = re.match(r\"(.*?)([^a-zA-Z]*)$\", word)\n    if match:\n        core_word = match.group(1)\n        punctuation = match.group(2)\n    else:\n        core_word = word\n        punctuation = \"\"\n    \n    # Count total characters (excluding punctuation for length check)\n    total_length = len(core_word)\n    \n    # Count T/t in the core word only\n    t_count = core_word.lower().count('t')\n\n    # Rule 1: Flip if >6 chars or 2+ T/t\n    if total_length > 6 or t_count >= 2:\n        return core_word[::-1] + punctuation\n    \n    # Rule 2: Uppercase if exactly 2 chars or before a comma\n    if total_length == 2 or ',' in next_part:\n        return core_word.upper() + punctuation\n    \n    # Rule 3: Replace with \"0\" if exactly 1 char\n    if total_length == 1:\n        return \"0\" + punctuation\n    \n    # No change\n    return core_word + punctuation\n\ndef transform_sentence(sentence):\n    if not sentence:\n        return \"\"\n    \n    # Split by spaces and preserve spaces\n    parts = re.split(r'(\\s+)', sentence)\n    \n    # Filter out empty strings and whitespace parts for word processing\n    non_space_parts = [part for part in parts if not re.match(r'^\\s+$', part) and part != '']\n    \n    result = []\n    i = 0\n    part_index = 0\n    \n    while part_index < len(parts):\n        part = parts[part_index]\n        \n        # If it's whitespace, keep as is\n        if re.match(r'^\\s+$', part):\n            result.append(part)\n            part_index += 1\n            continue\n            \n        # If it's a word (not just punctuation)\n        if re.search(r'[a-zA-Z]', part):\n            # Get the next non-whitespace part to check for comma\n            next_part = \"\"\n            next_index = part_index + 1\n            while next_index < len(parts):\n                if not re.match(r'^\\s+$', parts[next_index]):\n                    next_part = parts[next_index]\n                    break\n                next_index += 1\n            \n            processed = process_word(part, next_part)\n            result.append(processed)\n        else:\n            # Just punctuation or other characters\n            result.append(part)\n            \n        part_index += 1\n    \n    return \"\".join(result)\n\nif __name__ == \"__main__\":\n    input_sentence = sys.stdin.read().strip()\n    output_sentence = transform_sentence(input_sentence)\n    print(output_sentence, end='')", "import re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split into tokens (words with optional trailing punctuation, spaces, and standalone punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    # Identify words before commas\n    words_before_comma = set()\n    for i in range(len(tokens)):\n        if tokens[i] == ',' and i > 0:\n            # Find the previous non-space token\n            for j in range(i-1, -1, -1):\n                if not tokens[j].isspace() and tokens[j] != '':\n                    words_before_comma.add(j)\n                    break\n    \n    result = []\n    \n    for i, token in enumerate(tokens):\n        # If it's whitespace, keep as is\n        if re.match(r'\\s+', token):\n            result.append(token)\n            continue\n        \n        # Separate word from trailing punctuation\n        match = re.match(r'^(\\w+)(\\W*)$', token)\n        if match:\n            word_part = match.group(1)\n            punct_part = match.group(2)\n            \n            # Apply transformations in order of precedence\n            transformed = False\n            \n            # Rule 1: Flip if longer than 6 chars OR has 2+ T/t\n            if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n                result.append(word_part[::-1] + punct_part)\n                transformed = True\n            # Rule 2: Uppercase if exactly 2 chars OR before comma\n            elif len(word_part) == 2 or i in words_before_comma:\n                result.append(word_part.upper() + punct_part)\n                transformed = True\n            # Rule 3: Convert to \"0\" if exactly 1 char\n            elif len(word_part) == 1:\n                result.append(\"0\" + punct_part)\n                transformed = True\n            \n            if not transformed:\n                result.append(token)\n        else:\n            # Token doesn't match word+punctuation pattern, keep as is\n            result.append(token)\n    \n    return \"\".join(result)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)", "import re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words with attached punctuation and spaces)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result = []\n    \n    for i, token in enumerate(tokens):\n        # If it's whitespace, keep as is\n        if re.match(r'\\s+', token):\n            result.append(token)\n            continue\n        \n        # Separate word from punctuation\n        # Find where the actual word ends (before punctuation starts)\n        word_end = len(token)\n        for j, char in enumerate(token):\n            if not char.isalnum() and char != \"'\" and char != \"-\":\n                word_end = j\n                break\n        \n        word_part = token[:word_end]\n        punct_part = token[word_end:]\n        \n        # Rule 1: Convert backwards if longer than 6 chars OR has 2+ T/t\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result.append(word_part[::-1] + punct_part)\n        # Rule 2: Convert uppercase if exactly 2 chars OR before a comma\n        elif len(word_part) == 2 or punct_part.startswith(','):\n            result.append(word_part.upper() + punct_part)\n        # Rule 3: Convert to \"0\" if exactly one char\n        elif len(word_part) == 1:\n            result.append(\"0\" + punct_part)\n        else:\n            result.append(token)\n            \n    return ''.join(result)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)"], "responses": ["\nimport re\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words and punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Skip whitespace tokens\n        if token.isspace() or token == '':\n            result_tokens.append(token)\n            continue\n            \n        # Extract word part and punctuation part\n        match = re.match(r\"(\\w+)(\\W*)\", token)\n        if match:\n            word_part = match.group(1)\n            punct_part = match.group(2)\n            \n            # Count 't' and 'T' in the word part\n            t_count = word_part.lower().count('t')\n            \n            # Apply transformations in order\n            if len(word_part) > 6 or t_count >= 2:\n                # Rule 1: reverse the word part\n                transformed = word_part[::-1] + punct_part\n            elif len(word_part) == 2 or (punct_part.startswith(',') and len(punct_part) == 1):\n                # Rule 2: uppercase the word part\n                # Word is exactly 2 characters OR word ends with just a comma\n                transformed = word_part.upper() + punct_part\n            elif len(word_part) == 1:\n                # Rule 3: convert to \"0\"\n                transformed = \"0\" + punct_part\n            else:\n                # No transformation\n                transformed = token\n                \n            result_tokens.append(transformed)\n        else:\n            # Token is only punctuation/whitespace\n            result_tokens.append(token)\n    \n    return ''.join(result_tokens)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n", "\nimport re\nimport sys\n\ndef process_word(word, next_part=\"\"):\n    # Separate the word from trailing punctuation\n    match = re.match(r\"(.*?)([^a-zA-Z]*)$\", word)\n    if match:\n        core_word = match.group(1)\n        punctuation = match.group(2)\n    else:\n        core_word = word\n        punctuation = \"\"\n    \n    # Count total characters (excluding punctuation for length check)\n    total_length = len(core_word)\n    \n    # Count T/t in the core word only\n    t_count = core_word.lower().count('t')\n\n    # Rule 1: Flip if >6 chars or 2+ T/t\n    if total_length > 6 or t_count >= 2:\n        return core_word[::-1] + punctuation\n    \n    # Rule 2: Uppercase if exactly 2 chars or before a comma\n    if total_length == 2 or ',' in next_part:\n        return core_word.upper() + punctuation\n    \n    # Rule 3: Replace with \"0\" if exactly 1 char\n    if total_length == 1:\n        return \"0\" + punctuation\n    \n    # No change\n    return core_word + punctuation\n\ndef transform_sentence(sentence):\n    if not sentence:\n        return \"\"\n    \n    # Split by spaces and preserve spaces\n    parts = re.split(r'(\\s+)', sentence)\n    \n    # Filter out empty strings and whitespace parts for word processing\n    non_space_parts = [part for part in parts if not re.match(r'^\\s+$', part) and part != '']\n    \n    result = []\n    i = 0\n    part_index = 0\n    \n    while part_index < len(parts):\n        part = parts[part_index]\n        \n        # If it's whitespace, keep as is\n        if re.match(r'^\\s+$', part):\n            result.append(part)\n            part_index += 1\n            continue\n            \n        # If it's a word (not just punctuation)\n        if re.search(r'[a-zA-Z]', part):\n            # Get the next non-whitespace part to check for comma\n            next_part = \"\"\n            next_index = part_index + 1\n            while next_index < len(parts):\n                if not re.match(r'^\\s+$', parts[next_index]):\n                    next_part = parts[next_index]\n                    break\n                next_index += 1\n            \n            processed = process_word(part, next_part)\n            result.append(processed)\n        else:\n            # Just punctuation or other characters\n            result.append(part)\n            \n        part_index += 1\n    \n    return \"\".join(result)\n\nif __name__ == \"__main__\":\n    input_sentence = sys.stdin.read().strip()\n    output_sentence = transform_sentence(input_sentence)\n    print(output_sentence, end='')\n\n\n", "\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split into tokens (words with optional trailing punctuation, spaces, and standalone punctuation)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    # Identify words before commas\n    words_before_comma = set()\n    for i in range(len(tokens)):\n        if tokens[i] == ',' and i > 0:\n            # Find the previous non-space token\n            for j in range(i-1, -1, -1):\n                if not tokens[j].isspace() and tokens[j] != '':\n                    words_before_comma.add(j)\n                    break\n    \n    result = []\n    \n    for i, token in enumerate(tokens):\n        # If it's whitespace, keep as is\n        if re.match(r'\\s+', token):\n            result.append(token)\n            continue\n        \n        # Separate word from trailing punctuation\n        match = re.match(r'^(\\w+)(\\W*)$', token)\n        if match:\n            word_part = match.group(1)\n            punct_part = match.group(2)\n            \n            # Apply transformations in order of precedence\n            transformed = False\n            \n            # Rule 1: Flip if longer than 6 chars OR has 2+ T/t\n            if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n                result.append(word_part[::-1] + punct_part)\n                transformed = True\n            # Rule 2: Uppercase if exactly 2 chars OR before comma\n            elif len(word_part) == 2 or i in words_before_comma:\n                result.append(word_part.upper() + punct_part)\n                transformed = True\n            # Rule 3: Convert to \"0\" if exactly 1 char\n            elif len(word_part) == 1:\n                result.append(\"0\" + punct_part)\n                transformed = True\n            \n            if not transformed:\n                result.append(token)\n        else:\n            # Token doesn't match word+punctuation pattern, keep as is\n            result.append(token)\n    \n    return \"\".join(result)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n", "\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into tokens (words with attached punctuation and spaces)\n    tokens = re.findall(r'\\S+|\\s+', sentence)\n    \n    result = []\n    \n    for i, token in enumerate(tokens):\n        # If it's whitespace, keep as is\n        if re.match(r'\\s+', token):\n            result.append(token)\n            continue\n        \n        # Separate word from punctuation\n        # Find where the actual word ends (before punctuation starts)\n        word_end = len(token)\n        for j, char in enumerate(token):\n            if not char.isalnum() and char != \"'\" and char != \"-\":\n                word_end = j\n                break\n        \n        word_part = token[:word_end]\n        punct_part = token[word_end:]\n        \n        # Rule 1: Convert backwards if longer than 6 chars OR has 2+ T/t\n        if len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            result.append(word_part[::-1] + punct_part)\n        # Rule 2: Convert uppercase if exactly 2 chars OR before a comma\n        elif len(word_part) == 2 or punct_part.startswith(','):\n            result.append(word_part.upper() + punct_part)\n        # Rule 3: Convert to \"0\" if exactly one char\n        elif len(word_part) == 1:\n            result.append(\"0\" + punct_part)\n        else:\n            result.append(token)\n            \n    return ''.join(result)\n\n# Read input and process\ninput_sentence = input().strip()\noutput_sentence = transform_sentence(input_sentence)\nprint(output_sentence)\n\n\n"], "prompt_tokens": [9750, 10451, 9364, 9480], "completion_tokens": [4551, 5348, 4723, 3845], "no_of_try": 4, "api_calls": 40, "is_solved": true, "language": "Python3", "task_id": 4214}
{"name": "3884", "description": "# RegExp Fun #1 - When I miss few days of gym\n\n## Disclaimer\n\nThe background story of this Kata is 100% fiction.  Any resemblance to real people or real events is **nothing more than a coincidence** and should be regarded as such.\n\n## Background Story\n\nYou are a person who loves to go to the gym everyday with the squad of people that you've known since early childhood.  However, you recently contracted a sickness that forced you to stay at home for over a week.  As you see your body getting weaker and weaker every day and as you see your biceps and triceps disappearing, you can't help but lay in bed and cry.  You're usually an optimistic person but this time negative thoughts come to your head ... \n\n![When I miss few days of gym](https://pics.onsizzle.com/Instagram-faf8c9.png)\n\n\n## Task\n\nAs can be seen from the funny image above (or am I the only person to find the picture above hilarious?) there is lots of slang.  Your task is to define a function ```gymSlang``` which accepts a string argument and does the following:\n\n1. Replace *all* instances of ```\"probably\"``` to ```\"prolly\"```\n2. Replace *all* instances of ```\"i am\"``` to ```\"i'm\"```\n3. Replace *all* instances of ```\"instagram\"``` to ```\"insta\"```\n4. Replace *all* instances of ```\"do not\"``` to ```\"don't\"```\n5. Replace *all* instances of ```\"going to\"``` to ```\"gonna\"```\n6. Replace *all* instances of ```\"combination\"``` to ```\"combo\"```\n\nYour replacement regexes **should be case-sensitive**, only replacing the words above with slang if the detected pattern is in **lowercase**.  However, please note that apart from 100% lowercase matches, you will **also have to replace matches that are correctly capitalized** (e.g. ```\"Probably\" => \"Prolly\"``` or ```\"Instagram\" => \"Insta\"```).\n\nFinally, your code will be tested to make sure that you have used **RegExp** replace in your code.\n\nEnjoy :D", "difficulty": "introductory", "id": 3884, "sample_io": [{"input": "Probably", "output": ["Prolly"]}, {"input": "Instagram", "output": ["Insta"]}], "test_list": [{"input": "When I miss few days of gym", "output": ["When I miss few days of gym"]}, {"input": "Squad probably think I am fake", "output": ["Squad prolly think I'm fake"]}, {"input": "Whole squad probably bigger than me now", "output": ["Whole squad prolly bigger than me now"]}, {"input": "No selfie to post on Instagram either", "output": ["No selfie to post on Insta either"]}, {"input": "Gym crush probably found someone else", "output": ["Gym crush prolly found someone else"]}, {"input": "What if I die fat", "output": ["What if I die fat"]}, {"input": "What if I do not fit in my clothes now", "output": ["What if I don't fit in my clothes now"]}, {"input": "Going to feel like a new gym member", "output": ["Gonna feel like a new gym member"]}, {"input": "wait what was my lock combination", "output": ["wait what was my lock combo"]}, {"input": "that skinny girl can probably outlift me now", "output": ["that skinny girl can prolly outlift me now"]}, {"input": "probably Probably", "output": ["prolly Prolly"]}, {"input": "i am I am", "output": ["i'm I'm"]}, {"input": "instagram Instagram", "output": ["insta Insta"]}, {"input": "do not Do not", "output": ["don't Don't"]}, {"input": "going to Going to", "output": ["gonna Gonna"]}, {"input": "combination Combination", "output": ["combo Combo"]}, {"input": "probably Probably probably Probably probably Probably probably Probably probably Probably", "output": ["prolly Prolly prolly Prolly prolly Prolly prolly Prolly prolly Prolly"]}, {"input": "i am I am i am I am i am I am i am I am i am I am i am I am", "output": ["i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm"]}, {"input": "instagram Instagram instagram Instagram instagram Instagram instagram Instagram instagram Instagram", "output": ["insta Insta insta Insta insta Insta insta Insta insta Insta"]}, {"input": "do not Do not do not Do not do not Do not do not Do not", "output": ["don't Don't don't Don't don't Don't don't Don't"]}, {"input": "Going to going to Going to Going to going to Going to Going to going to Going to", "output": ["Gonna gonna Gonna Gonna gonna Gonna Gonna gonna Gonna"]}, {"input": "combination combination Combination combination Combination", "output": ["combo combo Combo combo Combo"]}], "starter_code": "\ndef gym_slang(phrase):\n\t", "source_codes": ["import re\nimport sys\n\ndef gymSlang(phrase):\n    # Define replacement mappings\n    replacements = {\n        'probably': 'prolly',\n        'i am': \"i'm\",\n        'instagram': 'insta',\n        'do not': \"don't\",\n        'going to': 'gonna',\n        'combination': 'combo'\n    }\n    \n    def replace_word(match):\n        original = match.group(0)\n        word_lower = original.lower()\n        replacement = replacements[word_lower]\n        \n        # Handle capitalization\n        if original.isupper():\n            # ALL CAPS - don't replace\n            return original\n        elif original[0].isupper():\n            # First letter capitalized\n            return replacement.capitalize()\n        else:\n            # All lowercase\n            return replacement\n    \n    # Apply replacements in order\n    result = phrase\n    for word, replacement in replacements.items():\n        # Pattern matches word boundary, the word (any case), word boundary\n        pattern = r'\\b' + re.escape(word) + r'\\b'\n        result = re.sub(pattern, replace_word, result, flags=re.IGNORECASE)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_phrase = sys.stdin.read().strip()\n    output_phrase = gymSlang(input_phrase)\n    print(output_phrase)"], "responses": ["\nimport re\nimport sys\n\ndef gymSlang(phrase):\n    # Define replacement mappings\n    replacements = {\n        'probably': 'prolly',\n        'i am': \"i'm\",\n        'instagram': 'insta',\n        'do not': \"don't\",\n        'going to': 'gonna',\n        'combination': 'combo'\n    }\n    \n    def replace_word(match):\n        original = match.group(0)\n        word_lower = original.lower()\n        replacement = replacements[word_lower]\n        \n        # Handle capitalization\n        if original.isupper():\n            # ALL CAPS - don't replace\n            return original\n        elif original[0].isupper():\n            # First letter capitalized\n            return replacement.capitalize()\n        else:\n            # All lowercase\n            return replacement\n    \n    # Apply replacements in order\n    result = phrase\n    for word, replacement in replacements.items():\n        # Pattern matches word boundary, the word (any case), word boundary\n        pattern = r'\\b' + re.escape(word) + r'\\b'\n        result = re.sub(pattern, replace_word, result, flags=re.IGNORECASE)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_phrase = sys.stdin.read().strip()\n    output_phrase = gymSlang(input_phrase)\n    print(output_phrase)\n\n\n"], "prompt_tokens": [10811], "completion_tokens": [4002], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 3884}
{"name": "3732", "description": "A Madhav array has the following property:\n\n```a[0] = a[1] + a[2] = a[3] + a[4] + a[5] = a[6] + a[7] + a[8] + a[9] = ...```\n\nComplete the function/method that returns `true` if the given array is a Madhav array, otherwise it returns `false`.\n\n*Edge cases: An array of length* `0` *or* `1` *should not be considered a Madhav array as there is nothing to compare.*", "difficulty": "introductory", "id": 3732, "sample_io": [], "test_list": [{"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, -100]", "output": [false]}, {"input": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, -2, -1]", "output": [true]}, {"input": "[-6, -3, -3, 8, -5, -4]", "output": [false]}, {"input": "[-6, -3, -3, 8, -10, -4]", "output": [true]}, {"input": "[3, 1, 2, 3, 0]", "output": [false]}, {"input": "[3, 3]", "output": [false]}, {"input": "[]", "output": [false]}, {"input": "[1]", "output": [false]}, {"input": "[5, 2, 4, 1, 0, 3]", "output": [false]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 6]", "output": [true]}, {"input": "[6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 1]", "output": [false]}, {"input": "[2, 1, 1]", "output": [true]}, {"input": "[2, 1, 1, 4, -1, -1]", "output": [true]}], "starter_code": "\ndef is_madhav_array(arr):\n\t", "source_codes": ["def is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Check if array length follows the pattern 1 + 2 + 3 + ... + k\n    # This sum is k(k+1)/2, so we need to find k such that k(k+1)/2 = n\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    # If k(k+1)/2 != n, then array doesn't have complete groups\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Check if all groups sum to the first element\n    target_sum = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        group_sum = 0\n        for _ in range(group_size):\n            group_sum += arr[index]\n            index += 1\n        \n        if group_sum != target_sum:\n            return False\n    \n    return True\n\n# Read input and process\ninput_str = input().strip()\n\n# Simple parsing - remove brackets and split by comma\nif input_str == \"[]\" or input_str == \"[ ]\":\n    arr = []\nelse:\n    # Remove brackets and split\n    content = input_str[1:-1]\n    if content.strip() == \"\":\n        arr = []\n    else:\n        # Handle potential spaces around commas\n        arr = [int(x.strip()) for x in content.split(\",\")]\n\nresult = is_madhav_array(arr)\nprint(str(result).lower())", "def is_madhav_array(arr):\n    # Edge cases\n    if len(arr) <= 1:\n        return False\n    \n    # Check if length is a triangular number\n    n = 1\n    while n * (n + 1) // 2 < len(arr):\n        n += 1\n    \n    if n * (n + 1) // 2 != len(arr):\n        return False\n    \n    # Check if all groups sum to the first element\n    target = arr[0]\n    index = 1  # Start from the second element\n    \n    for group_size in range(2, n + 1):  # Groups of sizes 2, 3, ..., n\n        group_sum = 0\n        for _ in range(group_size):\n            if index >= len(arr):\n                return False\n            group_sum += arr[index]\n            index += 1\n        \n        if group_sum != target:\n            return False\n    \n    return True\n\n# Read input\narr = eval(input())\n\n# Call function and print result\nprint(str(is_madhav_array(arr)).lower())", "def is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Find the number of complete groups\n    # We need to find k such that n = k(k+1)/2\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    # Check if length matches exactly\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Check if all group sums equal first element\n    target = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        group_sum = sum(arr[index : index + group_size])\n        if group_sum != target:\n            return False\n        index += group_size\n    \n    return True\n\n# Read input and call function\nimport sys\ninput_line = input().strip()\nif input_line == '[]':\n    arr = []\nelse:\n    # Remove brackets and split by comma\n    input_line = input_line.strip('[]')\n    if input_line:\n        # Handle potential spaces around numbers\n        arr = list(map(int, input_line.split(',')))\n    else:\n        arr = []\nprint(str(is_madhav_array(arr)).lower())", "def is_madhav_array(arr):\n    # Edge cases\n    if len(arr) <= 1:\n        return False\n    \n    # Check if length is a triangular number\n    n = 1\n    while n * (n + 1) // 2 < len(arr):\n        n += 1\n    if n * (n + 1) // 2 != len(arr):\n        return False\n    \n    # Expected sum is the first element\n    expected_sum = arr[0]\n    \n    # Check each group\n    index = 1\n    group_size = 2\n    while index < len(arr):\n        # Calculate sum of current group\n        group_sum = sum(arr[index:index + group_size])\n        \n        # Check if it matches expected sum\n        if group_sum != expected_sum:\n            return False\n        \n        # Move to next group\n        index += group_size\n        group_size += 1\n    \n    return True\n\n# Read input and process\nif __name__ == \"__main__\":\n    try:\n        input_str = input().strip()\n        if input_str == \"[]\":\n            arr = []\n        else:\n            # Remove brackets and split by comma\n            arr = [int(x.strip()) for x in input_str[1:-1].split(\",\") if x.strip()]\n    except:\n        arr = []\n    \n    result = is_madhav_array(arr)\n    print(result)"], "responses": ["\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Check if array length follows the pattern 1 + 2 + 3 + ... + k\n    # This sum is k(k+1)/2, so we need to find k such that k(k+1)/2 = n\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    # If k(k+1)/2 != n, then array doesn't have complete groups\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Check if all groups sum to the first element\n    target_sum = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        group_sum = 0\n        for _ in range(group_size):\n            group_sum += arr[index]\n            index += 1\n        \n        if group_sum != target_sum:\n            return False\n    \n    return True\n\n# Read input and process\ninput_str = input().strip()\n\n# Simple parsing - remove brackets and split by comma\nif input_str == \"[]\" or input_str == \"[ ]\":\n    arr = []\nelse:\n    # Remove brackets and split\n    content = input_str[1:-1]\n    if content.strip() == \"\":\n        arr = []\n    else:\n        # Handle potential spaces around commas\n        arr = [int(x.strip()) for x in content.split(\",\")]\n\nresult = is_madhav_array(arr)\nprint(str(result).lower())\n\n\n", "\ndef is_madhav_array(arr):\n    # Edge cases\n    if len(arr) <= 1:\n        return False\n    \n    # Check if length is a triangular number\n    n = 1\n    while n * (n + 1) // 2 < len(arr):\n        n += 1\n    \n    if n * (n + 1) // 2 != len(arr):\n        return False\n    \n    # Check if all groups sum to the first element\n    target = arr[0]\n    index = 1  # Start from the second element\n    \n    for group_size in range(2, n + 1):  # Groups of sizes 2, 3, ..., n\n        group_sum = 0\n        for _ in range(group_size):\n            if index >= len(arr):\n                return False\n            group_sum += arr[index]\n            index += 1\n        \n        if group_sum != target:\n            return False\n    \n    return True\n\n# Read input\narr = eval(input())\n\n# Call function and print result\nprint(str(is_madhav_array(arr)).lower())\n\n\n", "\ndef is_madhav_array(arr):\n    n = len(arr)\n    \n    # Edge cases\n    if n <= 1:\n        return False\n    \n    # Find the number of complete groups\n    # We need to find k such that n = k(k+1)/2\n    k = 1\n    while k * (k + 1) // 2 < n:\n        k += 1\n    \n    # Check if length matches exactly\n    if k * (k + 1) // 2 != n:\n        return False\n    \n    # Check if all group sums equal first element\n    target = arr[0]\n    index = 1\n    \n    for group_size in range(2, k + 1):\n        group_sum = sum(arr[index : index + group_size])\n        if group_sum != target:\n            return False\n        index += group_size\n    \n    return True\n\n# Read input and call function\nimport sys\ninput_line = input().strip()\nif input_line == '[]':\n    arr = []\nelse:\n    # Remove brackets and split by comma\n    input_line = input_line.strip('[]')\n    if input_line:\n        # Handle potential spaces around numbers\n        arr = list(map(int, input_line.split(',')))\n    else:\n        arr = []\nprint(str(is_madhav_array(arr)).lower())\n\n\n", "\ndef is_madhav_array(arr):\n    # Edge cases\n    if len(arr) <= 1:\n        return False\n    \n    # Check if length is a triangular number\n    n = 1\n    while n * (n + 1) // 2 < len(arr):\n        n += 1\n    if n * (n + 1) // 2 != len(arr):\n        return False\n    \n    # Expected sum is the first element\n    expected_sum = arr[0]\n    \n    # Check each group\n    index = 1\n    group_size = 2\n    while index < len(arr):\n        # Calculate sum of current group\n        group_sum = sum(arr[index:index + group_size])\n        \n        # Check if it matches expected sum\n        if group_sum != expected_sum:\n            return False\n        \n        # Move to next group\n        index += group_size\n        group_size += 1\n    \n    return True\n\n# Read input and process\nif __name__ == \"__main__\":\n    try:\n        input_str = input().strip()\n        if input_str == \"[]\":\n            arr = []\n        else:\n            # Remove brackets and split by comma\n            arr = [int(x.strip()) for x in input_str[1:-1].split(\",\") if x.strip()]\n    except:\n        arr = []\n    \n    result = is_madhav_array(arr)\n    print(result)\n\n\n"], "prompt_tokens": [8569, 7645, 7734, 7840], "completion_tokens": [4337, 5362, 3781, 4962], "no_of_try": 4, "api_calls": 40, "is_solved": true, "language": "Python3", "task_id": 3732}
