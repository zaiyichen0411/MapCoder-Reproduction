{"name": "1586_G. Omkar and Time Travel", "description": "El Psy Kongroo.\n\nOmkar is watching Steins;Gate.\n\nIn Steins;Gate, Okabe Rintarou needs to complete n tasks (1 \u2264 n \u2264 2 \u22c5 10^5). Unfortunately, he doesn't know when he needs to complete the tasks.\n\nInitially, the time is 0. Time travel will now happen according to the following rules:\n\n  * For each k = 1, 2, \u2026, n, Okabe will realize at time b_k that he was supposed to complete the k-th task at time a_k (a_k < b_k). \n\n  * When he realizes this, if k-th task was already completed at time a_k, Okabe keeps the usual flow of time. Otherwise, he time travels to time a_k then immediately completes the task.\n\n  * If Okabe time travels to time a_k, all tasks completed after this time will become incomplete again. That is, for every j, if a_j>a_k, the j-th task will become incomplete, if it was complete (if it was incomplete, nothing will change).\n\n  * Okabe has bad memory, so he can time travel to time a_k only immediately after getting to time b_k and learning that he was supposed to complete the k-th task at time a_k. That is, even if Okabe already had to perform k-th task before, he wouldn't remember it before stumbling on the info about this task at time b_k again.\n\n\n\n\nPlease refer to the notes for an example of time travelling.\n\nThere is a certain set s of tasks such that the first moment that all of the tasks in s are simultaneously completed (regardless of whether any other tasks are currently completed), a funny scene will take place. Omkar loves this scene and wants to know how many times Okabe will time travel before this scene takes place. Find this number modulo 10^9 + 7. It can be proven that eventually all n tasks will be completed and so the answer always exists.\n\nInput\n\nThe first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of tasks that Okabe needs to complete.\n\nn lines follow. The k-th of these lines contain two integers a_k and b_k (1 \u2264 a_k < b_k \u2264 2n) \u2014 the time at which Okabe needs to complete the k-th task and the time that he realizes this respectively. All 2n of these times are distinct (so every time from 1 to 2n inclusive appears exactly once in the input).\n\nThe next line contains a single integer t (1 \u2264 t \u2264 n) \u2014 the size of the set s of tasks that lead to the funny scene.\n\nThe last line contains t integers s_1, s_2, \u2026, s_t \u2014 (1 \u2264 s_k \u2264 n, the numbers s_1, s_2, \u2026, s_t are distinct) \u2014 the set s of tasks.\n\nOutput\n\nOutput a single integer \u2014 the number of times that Okabe time travels until all tasks in the set s are simultaneously completed, modulo 10^9 + 7.\n\nExamples\n\nInput\n\n\n2\n1 4\n2 3\n2\n1 2\n\n\nOutput\n\n\n3\n\n\nInput\n\n\n2\n1 4\n2 3\n1\n1\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n1\n1 2\n1\n1\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n6\n10 12\n3 7\n4 6\n2 9\n5 8\n1 11\n3\n2 4 6\n\n\nOutput\n\n\n17\n\n\nInput\n\n\n16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n6\n3 8 2 5 12 11\n\n\nOutput\n\n\n138\n\nNote\n\nFor the first sample, all tasks need to be completed in order for the funny scene to occur.\n\nInitially, the time is 0. Nothing happens until time 3, when Okabe realizes that he should have done the 2-nd task at time 2. He then time travels to time 2 and completes the task.\n\nAs the task is done now, he does not time travel again when the time is again 3. However, at time 4, he travels to time 1 to complete the 1-st task.\n\nThis undoes the 2-nd task. This means that the 2-nd task is not currently completed, meaning that the funny scene will not occur at this point even though the 1-st task is currently completed and Okabe had previously completed the 2-nd task.\n\nOnce it is again time 3 he travels back to time 2 once more and does the 2-nd task again.\n\nNow all tasks are complete, with Okabe having time travelled 3 times.\n\nThe second sample has the same tasks for Okabe to complete. However, this time the funny scene only needs the first task to be completed in order to occur. From reading the above sample you can see that this occurs once Okabe has time travelled 2 times.", "tags": ["data structures", "dp", "math"], "difficulty": 13, "id": 1586, "sample_io": [{"input": "6\n10 12\n3 7\n4 6\n2 9\n5 8\n1 11\n3\n2 4 6\n", "output": ["17\n"]}, {"input": "1\n1 2\n1\n1\n", "output": ["1\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n6\n3 8 2 5 12 11\n", "output": ["138\n"]}, {"input": "2\n1 4\n2 3\n2\n1 2\n", "output": ["3\n"]}, {"input": "2\n1 4\n2 3\n1\n1\n", "output": ["2\n"]}], "test_list": [{"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 42 2 9 11 50 23 19 46 35 17 27 29 5 32 30 41 39 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 8 13 19 9 2 6 10 1 7 11 17 20 3 16\n", "output": ["161\n"]}, {"input": "18\n3 25\n26 30\n2 22\n13 27\n7 31\n19 34\n14 18\n16 28\n32 33\n29 35\n12 17\n15 21\n5 8\n6 23\n1 9\n4 36\n10 11\n20 24\n1\n13\n", "output": ["1\n"]}, {"input": "17\n8 29\n10 16\n11 19\n4 28\n15 25\n9 34\n21 24\n17 32\n3 30\n22 31\n7 18\n2 6\n1 5\n14 33\n13 23\n12 27\n20 26\n8\n9 5 17 11 14 7 3 4\n", "output": ["117\n"]}, {"input": "30\n2 16\n47 60\n28 31\n3 37\n20 34\n25 59\n5 26\n4 8\n39 46\n6 14\n38 42\n27 55\n36 58\n12 48\n18 50\n40 57\n19 29\n11 45\n17 54\n13 22\n1 52\n7 15\n33 56\n21 44\n23 41\n32 43\n24 53\n9 49\n30 35\n10 51\n30\n29 20 9 25 19 15 1 6 27 12 18 23 14 24 28 10 13 26 21 30 2 3 17 16 7 8 11 4 5 22\n", "output": ["641\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n7\n17 5 13 1 3 19 21\n", "output": ["240\n"]}, {"input": "40\n5 35\n8 66\n33 51\n56 70\n43 78\n44 57\n3 20\n25 71\n7 64\n21 40\n24 28\n47 60\n61 72\n38 53\n16 63\n2 58\n41 52\n26 74\n11 48\n14 15\n22 75\n46 68\n29 31\n9 10\n23 77\n19 80\n62 73\n13 37\n6 30\n39 67\n55 59\n50 76\n17 79\n27 54\n18 42\n45 49\n4 34\n12 36\n32 65\n1 69\n20\n23 7 8 35 31 32 37 27 25 40 1 9 18 14 11 29 26 13 12 24\n", "output": ["2526\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n3\n5 1 13\n", "output": ["69\n"]}, {"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 22 2 9 11 50 23 19 46 35 17 27 29 5 32 30 41 39 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "17\n8 29\n10 16\n11 19\n4 28\n15 25\n9 34\n21 24\n17 32\n3 30\n22 31\n7 18\n2 6\n1 5\n14 33\n13 23\n12 27\n20 26\n8\n8 5 17 11 14 7 3 4\n", "output": ["122\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n3\n5 1 14\n", "output": ["70\n"]}, {"input": "18\n3 25\n26 30\n2 22\n13 27\n7 31\n19 34\n14 18\n16 28\n32 33\n29 35\n12 17\n15 21\n5 8\n6 23\n1 9\n4 36\n10 11\n20 24\n1\n3\n", "output": ["8\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n3\n8 1 14\n", "output": ["64\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n3\n8 2 14\n", "output": ["11\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 19 21\n", "output": ["184\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 2 5 12 11\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n6\n3 8 1 5 12 11\n", "output": ["159\n"]}, {"input": "2\n1 4\n2 3\n1\n1 2\n", "output": ["2\n"]}, {"input": "2\n1 4\n2 3\n1\n2\n", "output": ["1\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 8 13 19 9 2 6 10 1 7 18 17 20 3 16\n", "output": ["161\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n2\n5 1 14\n", "output": ["69\n"]}, {"input": "18\n3 25\n26 30\n2 22\n13 27\n7 31\n19 34\n14 18\n16 28\n32 33\n29 35\n12 17\n15 21\n5 8\n6 23\n1 9\n4 36\n10 11\n20 24\n1\n2\n", "output": ["38\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 6 1 3 19 38\n", "output": ["143\n"]}, {"input": "6\n10 12\n3 7\n4 6\n2 9\n5 8\n1 11\n2\n2 4 6\n", "output": ["7\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n1\n5 1 14\n", "output": ["32\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 3 13 1 3 19 38\n", "output": ["115\n"]}, {"input": "17\n8 29\n10 16\n11 19\n4 28\n15 25\n9 34\n21 24\n17 32\n3 30\n22 31\n7 18\n2 6\n1 5\n14 33\n13 23\n12 27\n20 26\n8\n8 5 17 11 12 7 3 4\n", "output": ["110\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 9 6 9 12 11\n", "output": ["19\n"]}, {"input": "6\n10 12\n3 7\n4 6\n2 9\n5 8\n1 11\n2\n2 6 6\n", "output": ["12\n"]}, {"input": "40\n5 35\n8 66\n33 51\n56 70\n43 78\n44 57\n3 20\n25 71\n7 64\n21 40\n24 28\n47 60\n61 72\n38 53\n16 63\n2 58\n41 52\n26 74\n11 48\n14 15\n22 75\n46 68\n29 31\n9 10\n23 77\n19 80\n62 73\n13 37\n6 30\n39 67\n55 59\n50 76\n17 79\n27 54\n18 42\n45 49\n4 34\n12 36\n32 65\n1 69\n20\n5 7 8 35 31 32 37 27 25 40 1 9 18 14 11 29 26 13 12 24\n", "output": ["2545\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n3\n17 5 13 1 3 19 21\n", "output": ["181\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n14 5 13 1 3 19 38\n", "output": ["186\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n2\n8 1 14\n", "output": ["62\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 5 6 9 12 11\n", "output": ["79\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n3\n3 5 6 9 12 11\n", "output": ["81\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 9 6 1 3 19 38\n", "output": ["44\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 4 1 4 19 38\n", "output": ["231\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n3\n6 1 14\n", "output": ["64\n"]}, {"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 42 2 9 11 50 23 19 46 35 17 27 29 5 32 30 49 39 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n6\n3 8 2 5 14 11\n", "output": ["138\n"]}, {"input": "2\n1 4\n2 3\n1\n1 1\n", "output": ["2\n"]}, {"input": "2\n1 4\n2 3\n1\n2 1\n", "output": ["1\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 19 38\n", "output": ["184\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 4 5 12 11\n", "output": ["138\n"]}, {"input": "2\n1 4\n2 3\n1\n2 2\n", "output": ["1\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 8 13 19 9 2 6 14 1 7 18 17 20 3 16\n", "output": ["161\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 4 9 12 11\n", "output": ["138\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 8 13 19 9 2 6 14 1 7 18 17 20 3 4\n", "output": ["159\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 11 13 19 9 2 6 14 1 7 18 17 20 3 16\n", "output": ["161\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 6 9 12 11\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n6 8 2 5 12 11\n", "output": ["138\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n2\n5 1 16\n", "output": ["69\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 1 19 21\n", "output": ["184\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 2 5 12 19\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n4 8 4 5 12 11\n", "output": ["138\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 6 1 4 19 38\n", "output": ["143\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 3 6 1 3 19 38\n", "output": ["115\n"]}, {"input": "18\n3 25\n26 30\n2 22\n13 27\n7 31\n19 34\n14 18\n16 28\n32 33\n29 35\n12 17\n15 21\n5 8\n6 23\n1 10\n4 36\n10 11\n20 24\n1\n13\n", "output": ["1\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 35 38\n", "output": ["184\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n2 8 4 9 12 11\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n2 8 2 5 12 19\n", "output": ["138\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 3 13 1 3 19 55\n", "output": ["115\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 3 13 1 3 19 110\n", "output": ["115\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 2 5 12 12\n", "output": ["138\n"]}, {"input": "2\n1 4\n2 3\n1\n2 0\n", "output": ["1\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 1 9 12 11\n", "output": ["138\n"]}, {"input": "20\n10 32\n7 29\n23 26\n4 25\n28 34\n21 38\n13 31\n18 22\n11 14\n9 35\n8 12\n5 40\n1 16\n17 20\n2 3\n27 37\n19 33\n24 30\n6 39\n15 36\n15\n5 8 13 19 9 2 6 11 1 7 18 17 20 3 4\n", "output": ["159\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 23 38\n", "output": ["184\n"]}, {"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 22 2 9 11 50 23 19 46 35 17 38 29 5 32 30 41 39 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 42 2 18 11 50 23 19 46 35 17 27 29 5 32 30 49 39 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 2 5 4 19\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 1 9 7 11\n", "output": ["138\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n3\n17 5 13 1 0 19 21\n", "output": ["181\n"]}, {"input": "50\n38 51\n26 42\n11 22\n9 16\n34 54\n19 49\n36 88\n66 92\n48 87\n23 86\n14 41\n45 81\n30 83\n13 24\n73 82\n10 96\n80 100\n5 97\n47 85\n43 55\n50 52\n3 32\n6 17\n31 89\n37 67\n56 64\n63 91\n33 75\n20 68\n15 27\n18 78\n4 40\n60 65\n69 99\n74 93\n58 94\n35 53\n1 12\n29 95\n46 79\n7 72\n44 76\n2 77\n28 98\n8 39\n57 70\n62 71\n59 84\n21 90\n25 61\n27\n28 40 34 42 2 18 11 50 23 19 46 35 17 27 29 5 32 30 49 47 20 8 48 26 10 14 16\n", "output": ["9235\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n14 5 13 1 3 19 22\n", "output": ["186\n"]}, {"input": "18\n3 25\n26 30\n2 22\n13 27\n7 29\n19 34\n14 18\n16 28\n32 33\n29 35\n12 17\n15 21\n5 8\n6 23\n1 9\n4 36\n10 11\n20 24\n1\n13\n", "output": ["1\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n6\n3 8 2 5 14 12\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 8 5 5 12 11\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n3\n3 8 6 9 12 11\n", "output": ["138\n"]}, {"input": "19\n11 34\n15 21\n12 19\n10 23\n16 30\n5 32\n2 27\n1 13\n14 38\n22 28\n18 33\n36 37\n3 6\n17 20\n25 35\n7 9\n24 31\n4 8\n26 29\n1\n5 0 14\n", "output": ["32\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 70 38\n", "output": ["184\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 23 12\n", "output": ["184\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n3\n17 5 13 1 2 19 21\n", "output": ["181\n"]}, {"input": "21\n7 18\n19 32\n22 38\n27 39\n4 41\n15 20\n14 35\n3 42\n6 30\n26 34\n25 31\n12 29\n5 37\n9 16\n8 13\n10 33\n1 28\n24 36\n17 40\n11 21\n2 23\n4\n17 5 13 1 3 70 9\n", "output": ["184\n"]}, {"input": "2\n1 4\n2 3\n1\n1 0\n", "output": ["2\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n4\n6 8 2 5 12 11\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n4 8 4 5 12 21\n", "output": ["138\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n3\n3 8 1 9 12 11\n", "output": ["159\n"]}, {"input": "16\n31 32\n3 26\n17 19\n4 24\n1 28\n15 21\n12 16\n18 29\n20 23\n7 8\n11 14\n9 22\n6 30\n5 10\n25 27\n2 13\n2\n3 9 6 9 12 3\n", "output": ["19\n"]}], "source_codes": ["import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    tasks = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n    \n    # Sort by realization time\n    tasks.sort()\n    \n    t = int(sys.stdin.readline())\n    target_tasks = set(map(int, sys.stdin.readline().split()))\n    \n    MOD = 10**9 + 7\n    \n    # Track currently completed tasks and their completion times\n    completed_tasks = {}  # task_id -> completion_time\n    time_travel_count = 0\n    \n    # Process each task in order of realization time\n    for realization_time, required_time, task_id in tasks:\n        # Check if this task was already completed at or before its required time\n        if task_id in completed_tasks and completed_tasks[task_id] <= required_time:\n            # Task already completed appropriately, do nothing\n            pass\n        else:\n            # Need to time travel\n            time_travel_count = (time_travel_count + 1) % MOD\n            \n            # Remove all tasks that were completed after the required_time\n            # (they become undone due to time travel)\n            tasks_to_remove = []\n            for tid, completion_time in completed_tasks.items():\n                if completion_time > required_time:\n                    tasks_to_remove.append(tid)\n            \n            for tid in tasks_to_remove:\n                del completed_tasks[tid]\n            \n            # Complete current task at its required time\n            completed_tasks[task_id] = required_time\n        \n        # Check if all target tasks are currently completed\n        all_target_completed = True\n        for target_task in target_tasks:\n            if target_task not in completed_tasks:\n                all_target_completed = False\n                break\n        \n        if all_target_completed:\n            break\n    \n    print(time_travel_count)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i+1))  # (realization_time, task_time, index)\n    \n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    s_set = set()\n    for _ in range(t):\n        s_set.add(int(data[idx]))\n        idx += 1\n    \n    MOD = 10**9 + 7\n    \n    # Maintain completed tasks: list of (a_time, index) sorted by a_time\n    completed_tasks = []  # list of (a_time, index) sorted by a_time\n    completed_indices = set()  # set of task indices for quick lookup\n    \n    time_travels = 0\n    \n    for b, a, index in tasks:\n        # Check if there's already a task completed at time 'a'\n        pos = bisect.bisect_left(completed_tasks, (a, 0))\n        already_completed = False\n        \n        # Check if exact match exists\n        if pos < len(completed_tasks) and completed_tasks[pos][0] == a:\n            already_completed = True\n        elif pos > 0 and completed_tasks[pos-1][0] == a:\n            already_completed = True\n        \n        if not already_completed:\n            # Need to time travel\n            time_travels = (time_travels + 1) % MOD\n            \n            # Remove all tasks with a_j > a (they get invalidated)\n            # Find the first position where a_time > a\n            invalidate_pos = bisect.bisect_right(completed_tasks, (a, float('inf')))\n            \n            # Remove invalidated tasks from the set\n            for i in range(invalidate_pos, len(completed_tasks)):\n                _, old_index = completed_tasks[i]\n                completed_indices.discard(old_index)\n            \n            # Keep only tasks with a_j <= a\n            completed_tasks = completed_tasks[:invalidate_pos]\n            \n            # Add current task at the correct position to maintain sorted order\n            insert_pos = bisect.bisect_left(completed_tasks, (a, index))\n            completed_tasks.insert(insert_pos, (a, index))\n            completed_indices.add(index)\n        \n        # Check if all required tasks are completed\n        if s_set.issubset(completed_indices):\n            break\n    \n    print(time_travels)\n\nif __name__ == \"__main__\":\n    main()", "", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    tasks = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(sys.stdin.readline())\n    target_set = set(map(int, sys.stdin.readline().split()))\n    \n    completed_tasks = set()  # set of task_ids that are currently completed\n    task_required_times = {}  # task_id -> required_time\n    \n    # Pre-populate required times\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        task_required_times[i + 1] = a\n    \n    # Reset file pointer or re-read? No, let's rebuild from sorted tasks\n    completed_tasks = set()\n    travel_count = 0\n    MOD = 10**9 + 7\n    \n    # Rebuild task_required_times correctly\n    task_required_times = {}\n    for i, (b, a, task_id) in enumerate(tasks):\n        task_required_times[task_id] = a\n    \n    # Reprocess with correct sorting\n    for b, a, task_id in tasks:\n        # Check if this task needs to be completed now\n        needs_completion = False\n        if task_id not in completed_tasks:\n            needs_completion = True\n        else:\n            # Task exists, but we need to verify it wasn't undone by previous time travel\n            # Actually, our logic handles this correctly below\n            pass\n            \n        # Always check if we need to time travel and complete this task\n        # Remove all tasks that were completed after time a (they get undone)\n        tasks_to_remove = []\n        for tid in completed_tasks:\n            if task_required_times[tid] > a:\n                tasks_to_remove.append(tid)\n        \n        for tid in tasks_to_remove:\n            completed_tasks.remove(tid)\n        \n        # Complete this task\n        completed_tasks.add(task_id)\n        travel_count = (travel_count + 1) % MOD\n        \n        # Check if all target tasks are completed\n        if target_set.issubset(completed_tasks):\n            print(travel_count)\n            return\n    \n    # If we reach here, we didn't increment for the final necessary completions\n    # Let me reconsider the logic...\n    \n    # Actually, let's restart with clearer logic:\n\ndef main():\n    import sys\n    \n    n = int(sys.stdin.readline())\n    tasks = []\n    task_info = {}  # task_id -> (required_time, realization_time)\n    \n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n        task_info[i + 1] = (a, b)\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(sys.stdin.readline())\n    target_set = set(map(int, sys.stdin.readline().split()))\n    \n    completed_tasks = {}  # task_id -> completion_time\n    travel_count = 0\n    MOD = 10**9 + 7\n    \n    for b, a, task_id in tasks:\n        # Remove tasks completed after time a (they get undone by time travel)\n        tasks_to_remove = []\n        for tid, completion_time in completed_tasks.items():\n            if completion_time > a:\n                tasks_to_remove.append(tid)\n        \n        for tid in tasks_to_remove:\n            del completed_tasks[tid]\n        \n        # If task wasn't completed at time a, we need to time travel\n        if task_id not in completed_tasks:\n            travel_count = (travel_count + 1) % MOD\n            completed_tasks[task_id] = a\n        elif completed_tasks[task_id] > a:\n            # Task was completed but after time a, so it got undone\n            travel_count = (travel_count + 1) % MOD\n            completed_tasks[task_id] = a\n            \n        # Check if all target tasks are completed\n        all_targets_complete = True\n        for target_task in target_set:\n            if target_task not in completed_tasks:\n                all_targets_complete = False\n                break\n        \n        if all_targets_complete:\n            print(travel_count)\n            return\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    # Store tasks as (a_k, b_k, task_number)\n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((a, b, i+1))\n        idx += 2\n    \n    # Sort by discovery time b_k\n    tasks.sort(key=lambda x: x[1])\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    # Track completion times for each task\n    completion_time = [0] * (n + 1)  # completion_time[i] = time when task i was completed (0 if not completed)\n    time_travel_count = 0\n    MOD = 10**9 + 7\n    \n    for a_k, b_k, task_num in tasks:\n        # Check if task is currently completed at the correct time\n        if completion_time[task_num] != a_k:\n            # Need to time travel\n            time_travel_count += 1\n            \n            # Undo all tasks completed after time a_k\n            for j in range(1, n + 1):\n                if completion_time[j] > a_k:\n                    completion_time[j] = 0\n            \n            # Complete current task at time a_k\n            completion_time[task_num] = a_k\n        \n        # Check if all target tasks are completed\n        all_done = True\n        for target_task in target_set:\n            if completion_time[target_task] == 0:\n                all_done = False\n                break\n        \n        if all_done:\n            print(time_travel_count % MOD)\n            return\n\nif __name__ == \"__main__\":\n    main()", "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((b, a, i+1))  # (realization time, required time, task index)\n        idx += 2\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    MOD = 10**9 + 7\n    travel_count = 0\n    \n    # Maintain completed tasks as a list of (completion_time, task_index) sorted by time\n    completed = []  # List of (time, task_index) pairs, sorted by time\n    \n    # Keep track of current completion status of each task\n    task_completed_at = {}  # task_index -> completion_time\n    \n    for b_k, a_k, k in tasks:\n        # Check if task k was already completed at or before time a_k\n        if k in task_completed_at and task_completed_at[k] <= a_k:\n            # Task was already completed at required time, no travel needed\n            pass\n        else:\n            # Need to time travel to a_k and complete task k\n            travel_count = (travel_count + 1) % MOD\n            \n            # Remove all tasks completed after time a_k\n            # Find the first task completed after time a_k\n            pos = bisect.bisect_right(completed, (a_k, n+1))\n            \n            # Remove tasks from pos onwards\n            for i in range(pos, len(completed)):\n                time_comp, task_idx = completed[i]\n                del task_completed_at[task_idx]\n            \n            # Truncate the completed list\n            completed = completed[:pos]\n            \n            # Add the new completion\n            bisect.insort(completed, (a_k, k))\n            task_completed_at[k] = a_k\n        \n        # Check if all tasks in target_set are completed\n        all_completed = True\n        for target_task in target_set:\n            if target_task not in task_completed_at:\n                all_completed = False\n                break\n        \n        if all_completed:\n            print(travel_count % MOD)\n            return\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []  # (b_k, a_k, k)\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i))\n    \n    # Sort by realization time b_k\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        s_i = int(data[idx]) - 1  # Convert to 0-indexed\n        idx += 1\n        target_set.add(s_i)\n    \n    # Keep track of when each task was completed (-1 if not completed)\n    completed_at = [-1] * n\n    time_travels = 0\n    mod = 10**9 + 7\n    \n    for b_k, a_k, k in tasks:\n        # Check if task k was completed at time a_k\n        if completed_at[k] != a_k:\n            # Need to time travel\n            time_travels += 1\n            \n            # Rollback: mark all tasks completed after time a_k as incomplete\n            for i in range(n):\n                if completed_at[i] > a_k:\n                    completed_at[i] = -1\n            \n            # Complete task k at time a_k\n            completed_at[k] = a_k\n        \n        # Check if all target tasks are simultaneously completed\n        all_target_completed = True\n        for target_task in target_set:\n            if completed_at[target_task] == -1:\n                all_target_completed = False\n                break\n        \n        if all_target_completed:\n            break\n    \n    print(time_travels % mod)\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i+1))  # (discovery_time, required_time, task_id)\n    \n    # Sort by discovery time\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for i in range(t):\n        target_set.add(int(data[idx+i]))\n    idx += t\n    \n    MOD = 10**9 + 7\n    \n    # Track currently completed tasks: task_id -> completion_time\n    completed = {}  # task_id -> completion_time\n    time_travels = 0\n    \n    # Process tasks in order of discovery time\n    for b, a, task_id in tasks:\n        # Check if this task was already completed at or before time a\n        needs_travel = True\n        if task_id in completed and completed[task_id] <= a:\n            needs_travel = False\n        \n        if needs_travel:\n            # Need to travel back to time a\n            time_travels = (time_travels + 1) % MOD\n            # Complete this task at time a\n            completed[task_id] = a\n            # Remove all tasks that were completed after time a\n            to_remove = []\n            for tid, completion_time in completed.items():\n                if completion_time > a:\n                    to_remove.append(tid)\n            for tid in to_remove:\n                del completed[tid]\n        \n        # Check if all target tasks are completed\n        all_completed = True\n        for target_task in target_set:\n            if target_task not in completed:\n                all_completed = False\n                break\n        \n        if all_completed:\n            print(time_travels)\n            return\n\nif __name__ == \"__main__\":\n    main()", "import sys\nimport bisect\n\nMOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for k in range(1, n + 1):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        idx += 2\n        tasks.append((b, a, k))\n    \n    # Sort by discovery time b\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    s_set = set()\n    for _ in range(t):\n        s_task = int(data[idx])\n        idx += 1\n        s_set.add(s_task)\n    \n    # Track completed tasks\n    completed = [False] * (n + 1)\n    # Track active completions as (a_time, task_id) pairs, kept sorted\n    active_completions = []\n    \n    time_travels = 0\n    \n    for i in range(n):\n        b_time, a_time, task_id = tasks[i]\n        \n        # Check if task is already completed at its due time\n        if not completed[task_id]:\n            # Need to time travel\n            time_travels = (time_travels + 1) % MOD\n            \n            # Remove all completions that happened after a_time\n            # We want to keep completions with time <= a_time\n            pos = bisect.bisect_right(active_completions, (a_time, n+1))\n            to_remove = active_completions[pos:]\n            active_completions = active_completions[:pos]\n            \n            # Mark those tasks as not completed\n            for _, tid in to_remove:\n                completed[tid] = False\n                \n            # Complete current task\n            completed[task_id] = True\n            bisect.insort(active_completions, (a_time, task_id))\n        \n        # Check if all required tasks are completed\n        all_done = True\n        for task in s_set:\n            if not completed[task]:\n                all_done = False\n                break\n        if all_done:\n            break\n    \n    print(time_travels)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom bisect import bisect_left, insort\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((b, a, i+1))  # (discovery_time, required_time, task_index)\n        idx += 2\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    # Sort tasks by discovery time\n    tasks.sort()\n    \n    MOD = 10**9 + 7\n    time_travels = 0\n    \n    # Maintain a list of (a_k, index) for completed tasks, sorted by a_k\n    completed_times = []  # list of (a_k, index)\n    completed_indices = set()  # set of indices for O(1) lookup\n    \n    for b, a, original_index in tasks:\n        # Check if task is already completed\n        if original_index in completed_indices:\n            # Check if all target tasks are completed\n            if target_set.issubset(completed_indices):\n                print(time_travels)\n                return\n            continue\n        \n        # Time travel to a\n        time_travels = (time_travels + 1) % MOD\n        \n        # Remove all tasks completed after time a\n        # Find the first position where a_k > a\n        pos = bisect_left(completed_times, (a, float('inf')))\n        \n        # Remove all tasks with a_k > a\n        to_remove = []\n        for i in range(pos, len(completed_times)):\n            to_remove.append(completed_times[i][1])  # append the index\n        \n        # Actually remove them\n        for idx_to_remove in to_remove:\n            completed_indices.discard(idx_to_remove)\n        \n        # Keep only tasks with a_k <= a\n        completed_times = completed_times[:pos]\n        \n        # Complete the current task\n        insort(completed_times, (a, original_index))\n        completed_indices.add(original_index)\n        \n        # Check if all target tasks are completed\n        if target_set.issubset(completed_indices):\n            print(time_travels)\n            return\n    \n    # If we haven't returned yet, check one final time\n    if target_set.issubset(completed_indices):\n        print(time_travels)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    tasks = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n    \n    # Sort by realization time\n    tasks.sort()\n    \n    t = int(sys.stdin.readline())\n    target_tasks = set(map(int, sys.stdin.readline().split()))\n    \n    MOD = 10**9 + 7\n    \n    # Track currently completed tasks and their completion times\n    completed_tasks = {}  # task_id -> completion_time\n    time_travel_count = 0\n    \n    # Process each task in order of realization time\n    for realization_time, required_time, task_id in tasks:\n        # Check if this task was already completed at or before its required time\n        if task_id in completed_tasks and completed_tasks[task_id] <= required_time:\n            # Task already completed appropriately, do nothing\n            pass\n        else:\n            # Need to time travel\n            time_travel_count = (time_travel_count + 1) % MOD\n            \n            # Remove all tasks that were completed after the required_time\n            # (they become undone due to time travel)\n            tasks_to_remove = []\n            for tid, completion_time in completed_tasks.items():\n                if completion_time > required_time:\n                    tasks_to_remove.append(tid)\n            \n            for tid in tasks_to_remove:\n                del completed_tasks[tid]\n            \n            # Complete current task at its required time\n            completed_tasks[task_id] = required_time\n        \n        # Check if all target tasks are currently completed\n        all_target_completed = True\n        for target_task in target_tasks:\n            if target_task not in completed_tasks:\n                all_target_completed = False\n                break\n        \n        if all_target_completed:\n            break\n    \n    print(time_travel_count)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i+1))  # (realization_time, task_time, index)\n    \n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    s_set = set()\n    for _ in range(t):\n        s_set.add(int(data[idx]))\n        idx += 1\n    \n    MOD = 10**9 + 7\n    \n    # Maintain completed tasks: list of (a_time, index) sorted by a_time\n    completed_tasks = []  # list of (a_time, index) sorted by a_time\n    completed_indices = set()  # set of task indices for quick lookup\n    \n    time_travels = 0\n    \n    for b, a, index in tasks:\n        # Check if there's already a task completed at time 'a'\n        pos = bisect.bisect_left(completed_tasks, (a, 0))\n        already_completed = False\n        \n        # Check if exact match exists\n        if pos < len(completed_tasks) and completed_tasks[pos][0] == a:\n            already_completed = True\n        elif pos > 0 and completed_tasks[pos-1][0] == a:\n            already_completed = True\n        \n        if not already_completed:\n            # Need to time travel\n            time_travels = (time_travels + 1) % MOD\n            \n            # Remove all tasks with a_j > a (they get invalidated)\n            # Find the first position where a_time > a\n            invalidate_pos = bisect.bisect_right(completed_tasks, (a, float('inf')))\n            \n            # Remove invalidated tasks from the set\n            for i in range(invalidate_pos, len(completed_tasks)):\n                _, old_index = completed_tasks[i]\n                completed_indices.discard(old_index)\n            \n            # Keep only tasks with a_j <= a\n            completed_tasks = completed_tasks[:invalidate_pos]\n            \n            # Add current task at the correct position to maintain sorted order\n            insert_pos = bisect.bisect_left(completed_tasks, (a, index))\n            completed_tasks.insert(insert_pos, (a, index))\n            completed_indices.add(index)\n        \n        # Check if all required tasks are completed\n        if s_set.issubset(completed_indices):\n            break\n    \n    print(time_travels)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    tasks = []\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(sys.stdin.readline())\n    target_set = set(map(int, sys.stdin.readline().split()))\n    \n    completed_tasks = set()  # set of task_ids that are currently completed\n    task_required_times = {}  # task_id -> required_time\n    \n    # Pre-populate required times\n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        task_required_times[i + 1] = a\n    \n    # Reset file pointer or re-read? No, let's rebuild from sorted tasks\n    completed_tasks = set()\n    travel_count = 0\n    MOD = 10**9 + 7\n    \n    # Rebuild task_required_times correctly\n    task_required_times = {}\n    for i, (b, a, task_id) in enumerate(tasks):\n        task_required_times[task_id] = a\n    \n    # Reprocess with correct sorting\n    for b, a, task_id in tasks:\n        # Check if this task needs to be completed now\n        needs_completion = False\n        if task_id not in completed_tasks:\n            needs_completion = True\n        else:\n            # Task exists, but we need to verify it wasn't undone by previous time travel\n            # Actually, our logic handles this correctly below\n            pass\n            \n        # Always check if we need to time travel and complete this task\n        # Remove all tasks that were completed after time a (they get undone)\n        tasks_to_remove = []\n        for tid in completed_tasks:\n            if task_required_times[tid] > a:\n                tasks_to_remove.append(tid)\n        \n        for tid in tasks_to_remove:\n            completed_tasks.remove(tid)\n        \n        # Complete this task\n        completed_tasks.add(task_id)\n        travel_count = (travel_count + 1) % MOD\n        \n        # Check if all target tasks are completed\n        if target_set.issubset(completed_tasks):\n            print(travel_count)\n            return\n    \n    # If we reach here, we didn't increment for the final necessary completions\n    # Let me reconsider the logic...\n    \n    # Actually, let's restart with clearer logic:\n\ndef main():\n    import sys\n    \n    n = int(sys.stdin.readline())\n    tasks = []\n    task_info = {}  # task_id -> (required_time, realization_time)\n    \n    for i in range(n):\n        a, b = map(int, sys.stdin.readline().split())\n        tasks.append((b, a, i + 1))  # (realization_time, required_time, task_id)\n        task_info[i + 1] = (a, b)\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(sys.stdin.readline())\n    target_set = set(map(int, sys.stdin.readline().split()))\n    \n    completed_tasks = {}  # task_id -> completion_time\n    travel_count = 0\n    MOD = 10**9 + 7\n    \n    for b, a, task_id in tasks:\n        # Remove tasks completed after time a (they get undone by time travel)\n        tasks_to_remove = []\n        for tid, completion_time in completed_tasks.items():\n            if completion_time > a:\n                tasks_to_remove.append(tid)\n        \n        for tid in tasks_to_remove:\n            del completed_tasks[tid]\n        \n        # If task wasn't completed at time a, we need to time travel\n        if task_id not in completed_tasks:\n            travel_count = (travel_count + 1) % MOD\n            completed_tasks[task_id] = a\n        elif completed_tasks[task_id] > a:\n            # Task was completed but after time a, so it got undone\n            travel_count = (travel_count + 1) % MOD\n            completed_tasks[task_id] = a\n            \n        # Check if all target tasks are completed\n        all_targets_complete = True\n        for target_task in target_set:\n            if target_task not in completed_tasks:\n                all_targets_complete = False\n                break\n        \n        if all_targets_complete:\n            print(travel_count)\n            return\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    # Store tasks as (a_k, b_k, task_number)\n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((a, b, i+1))\n        idx += 2\n    \n    # Sort by discovery time b_k\n    tasks.sort(key=lambda x: x[1])\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    # Track completion times for each task\n    completion_time = [0] * (n + 1)  # completion_time[i] = time when task i was completed (0 if not completed)\n    time_travel_count = 0\n    MOD = 10**9 + 7\n    \n    for a_k, b_k, task_num in tasks:\n        # Check if task is currently completed at the correct time\n        if completion_time[task_num] != a_k:\n            # Need to time travel\n            time_travel_count += 1\n            \n            # Undo all tasks completed after time a_k\n            for j in range(1, n + 1):\n                if completion_time[j] > a_k:\n                    completion_time[j] = 0\n            \n            # Complete current task at time a_k\n            completion_time[task_num] = a_k\n        \n        # Check if all target tasks are completed\n        all_done = True\n        for target_task in target_set:\n            if completion_time[target_task] == 0:\n                all_done = False\n                break\n        \n        if all_done:\n            print(time_travel_count % MOD)\n            return\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((b, a, i+1))  # (realization time, required time, task index)\n        idx += 2\n    \n    tasks.sort()  # Sort by realization time\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    MOD = 10**9 + 7\n    travel_count = 0\n    \n    # Maintain completed tasks as a list of (completion_time, task_index) sorted by time\n    completed = []  # List of (time, task_index) pairs, sorted by time\n    \n    # Keep track of current completion status of each task\n    task_completed_at = {}  # task_index -> completion_time\n    \n    for b_k, a_k, k in tasks:\n        # Check if task k was already completed at or before time a_k\n        if k in task_completed_at and task_completed_at[k] <= a_k:\n            # Task was already completed at required time, no travel needed\n            pass\n        else:\n            # Need to time travel to a_k and complete task k\n            travel_count = (travel_count + 1) % MOD\n            \n            # Remove all tasks completed after time a_k\n            # Find the first task completed after time a_k\n            pos = bisect.bisect_right(completed, (a_k, n+1))\n            \n            # Remove tasks from pos onwards\n            for i in range(pos, len(completed)):\n                time_comp, task_idx = completed[i]\n                del task_completed_at[task_idx]\n            \n            # Truncate the completed list\n            completed = completed[:pos]\n            \n            # Add the new completion\n            bisect.insort(completed, (a_k, k))\n            task_completed_at[k] = a_k\n        \n        # Check if all tasks in target_set are completed\n        all_completed = True\n        for target_task in target_set:\n            if target_task not in task_completed_at:\n                all_completed = False\n                break\n        \n        if all_completed:\n            print(travel_count % MOD)\n            return\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []  # (b_k, a_k, k)\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i))\n    \n    # Sort by realization time b_k\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        s_i = int(data[idx]) - 1  # Convert to 0-indexed\n        idx += 1\n        target_set.add(s_i)\n    \n    # Keep track of when each task was completed (-1 if not completed)\n    completed_at = [-1] * n\n    time_travels = 0\n    mod = 10**9 + 7\n    \n    for b_k, a_k, k in tasks:\n        # Check if task k was completed at time a_k\n        if completed_at[k] != a_k:\n            # Need to time travel\n            time_travels += 1\n            \n            # Rollback: mark all tasks completed after time a_k as incomplete\n            for i in range(n):\n                if completed_at[i] > a_k:\n                    completed_at[i] = -1\n            \n            # Complete task k at time a_k\n            completed_at[k] = a_k\n        \n        # Check if all target tasks are simultaneously completed\n        all_target_completed = True\n        for target_task in target_set:\n            if completed_at[target_task] == -1:\n                all_target_completed = False\n                break\n        \n        if all_target_completed:\n            break\n    \n    print(time_travels % mod)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        tasks.append((b, a, i+1))  # (discovery_time, required_time, task_id)\n    \n    # Sort by discovery time\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for i in range(t):\n        target_set.add(int(data[idx+i]))\n    idx += t\n    \n    MOD = 10**9 + 7\n    \n    # Track currently completed tasks: task_id -> completion_time\n    completed = {}  # task_id -> completion_time\n    time_travels = 0\n    \n    # Process tasks in order of discovery time\n    for b, a, task_id in tasks:\n        # Check if this task was already completed at or before time a\n        needs_travel = True\n        if task_id in completed and completed[task_id] <= a:\n            needs_travel = False\n        \n        if needs_travel:\n            # Need to travel back to time a\n            time_travels = (time_travels + 1) % MOD\n            # Complete this task at time a\n            completed[task_id] = a\n            # Remove all tasks that were completed after time a\n            to_remove = []\n            for tid, completion_time in completed.items():\n                if completion_time > a:\n                    to_remove.append(tid)\n            for tid in to_remove:\n                del completed[tid]\n        \n        # Check if all target tasks are completed\n        all_completed = True\n        for target_task in target_set:\n            if target_task not in completed:\n                all_completed = False\n                break\n        \n        if all_completed:\n            print(time_travels)\n            return\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nimport bisect\n\nMOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for k in range(1, n + 1):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        idx += 2\n        tasks.append((b, a, k))\n    \n    # Sort by discovery time b\n    tasks.sort()\n    \n    t = int(data[idx])\n    idx += 1\n    s_set = set()\n    for _ in range(t):\n        s_task = int(data[idx])\n        idx += 1\n        s_set.add(s_task)\n    \n    # Track completed tasks\n    completed = [False] * (n + 1)\n    # Track active completions as (a_time, task_id) pairs, kept sorted\n    active_completions = []\n    \n    time_travels = 0\n    \n    for i in range(n):\n        b_time, a_time, task_id = tasks[i]\n        \n        # Check if task is already completed at its due time\n        if not completed[task_id]:\n            # Need to time travel\n            time_travels = (time_travels + 1) % MOD\n            \n            # Remove all completions that happened after a_time\n            # We want to keep completions with time <= a_time\n            pos = bisect.bisect_right(active_completions, (a_time, n+1))\n            to_remove = active_completions[pos:]\n            active_completions = active_completions[:pos]\n            \n            # Mark those tasks as not completed\n            for _, tid in to_remove:\n                completed[tid] = False\n                \n            # Complete current task\n            completed[task_id] = True\n            bisect.insort(active_completions, (a_time, task_id))\n        \n        # Check if all required tasks are completed\n        all_done = True\n        for task in s_set:\n            if not completed[task]:\n                all_done = False\n                break\n        if all_done:\n            break\n    \n    print(time_travels)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom bisect import bisect_left, insort\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    \n    tasks = []\n    for i in range(n):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        tasks.append((b, a, i+1))  # (discovery_time, required_time, task_index)\n        idx += 2\n    \n    t = int(data[idx])\n    idx += 1\n    target_set = set()\n    for _ in range(t):\n        target_set.add(int(data[idx]))\n        idx += 1\n    \n    # Sort tasks by discovery time\n    tasks.sort()\n    \n    MOD = 10**9 + 7\n    time_travels = 0\n    \n    # Maintain a list of (a_k, index) for completed tasks, sorted by a_k\n    completed_times = []  # list of (a_k, index)\n    completed_indices = set()  # set of indices for O(1) lookup\n    \n    for b, a, original_index in tasks:\n        # Check if task is already completed\n        if original_index in completed_indices:\n            # Check if all target tasks are completed\n            if target_set.issubset(completed_indices):\n                print(time_travels)\n                return\n            continue\n        \n        # Time travel to a\n        time_travels = (time_travels + 1) % MOD\n        \n        # Remove all tasks completed after time a\n        # Find the first position where a_k > a\n        pos = bisect_left(completed_times, (a, float('inf')))\n        \n        # Remove all tasks with a_k > a\n        to_remove = []\n        for i in range(pos, len(completed_times)):\n            to_remove.append(completed_times[i][1])  # append the index\n        \n        # Actually remove them\n        for idx_to_remove in to_remove:\n            completed_indices.discard(idx_to_remove)\n        \n        # Keep only tasks with a_k <= a\n        completed_times = completed_times[:pos]\n        \n        # Complete the current task\n        insort(completed_times, (a, original_index))\n        completed_indices.add(original_index)\n        \n        # Check if all target tasks are completed\n        if target_set.issubset(completed_indices):\n            print(time_travels)\n            return\n    \n    # If we haven't returned yet, check one final time\n    if target_set.issubset(completed_indices):\n        print(time_travels)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [19846, 20366, 5276, 20004, 20539, 19631, 19280, 20750, 21683, 20312], "completion_tokens": [7852, 7138, 1412, 6552, 6670, 5703, 5696, 7951, 6816, 6372], "no_of_try": 10, "api_calls": 93, "is_solved": false, "language": "Python3", "task_id": 1586}
{"name": "1591_A. Life of a Flower", "description": "Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.\n\nThe flower grows as follows: \n\n  * If the flower isn't watered for two days in a row, it dies. \n  * If the flower is watered in the i-th day, it grows by 1 centimeter. \n  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. \n  * If the flower is not watered in the i-th day, it does not grow. \n\n\n\nAt the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line of each test case contains the only integer n (1 \u2264 n \u2264 100).\n\nThe second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.\n\nOutput\n\nFor each test case print a single integer k \u2014 the flower's height after n days, or -1, if the flower dies.\n\nExample\n\nInput\n\n\n4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 0 1\n1\n0\n\n\nOutput\n\n\n3\n7\n-1\n1", "tags": ["implementation"], "difficulty": 7, "id": 1591, "sample_io": [{"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 0 1\n1\n0\n", "output": ["3\n7\n-1\n1\n"]}], "test_list": [{"input": "1\n10\n1 1 1 1 1 1 1 1 1 1\n", "output": ["47\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 0 1\n1\n1\n", "output": ["3\n7\n-1\n2\n"]}, {"input": "1\n10\n1 1 1 1 0 1 1 1 1 1\n", "output": ["38\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["3\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["3\n-1\n8\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n-1\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 1 1\n1\n0\n", "output": ["3\n7\n8\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n-1\n8\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 1\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n7\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 0 0\n1\n0\n", "output": ["3\n7\n-1\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 0\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n2\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 1 0\n1\n0\n", "output": ["3\n7\n3\n1\n"]}, {"input": "1\n10\n1 1 1 1 0 1 1 1 1 0\n", "output": ["33\n"]}, {"input": "1\n10\n1 1 0 1 0 1 1 1 1 1\n", "output": ["29\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["3\n-1\n8\n2\n"]}, {"input": "4\n3\n0 0 1\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["-1\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 1\n4\n1 0 0 0\n1\n0\n", "output": ["-1\n7\n-1\n1\n"]}, {"input": "4\n3\n0 0 0\n3\n1 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n3\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 0\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n2\n8\n2\n"]}, {"input": "1\n10\n0 1 0 1 0 1 1 1 1 1\n", "output": ["24\n"]}, {"input": "4\n3\n0 1 1\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["7\n-1\n-1\n1\n"]}, {"input": "4\n3\n0 1 1\n3\n0 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["7\n-1\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 1 1\n4\n1 0 0 1\n1\n0\n", "output": ["3\n12\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 1 1 1\n1\n0\n", "output": ["3\n-1\n17\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 1 1\n1\n1\n", "output": ["3\n7\n8\n2\n"]}, {"input": "4\n3\n1 1 0\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["7\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 1 0\n3\n0 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["7\n-1\n8\n2\n"]}, {"input": "1\n10\n1 1 0 1 0 1 1 0 1 1\n", "output": ["20\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n1 0 0 1\n1\n1\n", "output": ["3\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n0 1 1 1\n1\n0\n", "output": ["3\n-1\n12\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["12\n-1\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n0 1 1 0\n1\n0\n", "output": ["3\n-1\n7\n1\n"]}, {"input": "4\n3\n0 0 1\n3\n0 0 1\n4\n0 1 1 0\n1\n0\n", "output": ["-1\n-1\n7\n1\n"]}, {"input": "1\n10\n1 1 0 0 1 1 1 1 1 1\n", "output": ["-1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 1 1\n4\n1 0 1 1\n1\n0\n", "output": ["12\n7\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n0 1 1 1\n1\n1\n", "output": ["3\n7\n12\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n7\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 1\n4\n1 1 1 1\n1\n0\n", "output": ["3\n3\n17\n1\n"]}, {"input": "4\n3\n0 1 0\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["2\n-1\n-1\n2\n"]}, {"input": "4\n3\n0 0 1\n3\n0 0 1\n4\n0 1 1 1\n1\n0\n", "output": ["-1\n-1\n12\n1\n"]}, {"input": "4\n3\n0 1 1\n3\n0 1 1\n4\n1 0 1 1\n1\n0\n", "output": ["7\n7\n8\n1\n"]}, {"input": "1\n10\n0 1 0 1 1 1 1 1 1 0\n", "output": ["28\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 1 1 1\n1\n1\n", "output": ["-1\n7\n17\n2\n"]}, {"input": "4\n3\n0 1 0\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["2\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 0 0\n4\n1 1 1 0\n1\n0\n", "output": ["12\n-1\n12\n1\n"]}, {"input": "4\n3\n1 1 0\n3\n0 0 0\n4\n1 1 1 0\n1\n0\n", "output": ["7\n-1\n12\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 1 1\n4\n1 0 0 1\n1\n1\n", "output": ["3\n12\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["3\n3\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 1 0\n1\n1\n", "output": ["3\n7\n3\n2\n"]}, {"input": "4\n3\n1 1 1\n3\n1 1 1\n4\n1 0 0 1\n1\n0\n", "output": ["12\n12\n-1\n1\n"]}, {"input": "4\n3\n0 0 1\n3\n1 0 1\n4\n0 1 1 1\n1\n0\n", "output": ["-1\n3\n12\n1\n"]}, {"input": "1\n10\n0 1 1 0 1 0 1 1 0 1\n", "output": ["15\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 0\n4\n1 1 1 1\n1\n1\n", "output": ["3\n-1\n17\n2\n"]}, {"input": "1\n10\n0 1 1 1 1 1 1 1 1 1\n", "output": ["42\n"]}, {"input": "4\n3\n0 0 1\n3\n1 1 1\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n12\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 0 1 0\n1\n0\n", "output": ["3\n-1\n3\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 0\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n2\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 0\n4\n1 0 1 1\n1\n1\n", "output": ["3\n2\n8\n2\n"]}, {"input": "4\n3\n0 1 0\n3\n0 0 1\n4\n1 0 1 1\n1\n1\n", "output": ["2\n-1\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 0\n4\n1 0 0 1\n1\n1\n", "output": ["3\n2\n-1\n2\n"]}, {"input": "4\n3\n1 1 1\n3\n0 1 1\n4\n1 0 0 0\n1\n1\n", "output": ["12\n7\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["3\n3\n8\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n1 0 0\n4\n1 1 1 1\n1\n0\n", "output": ["12\n-1\n17\n1\n"]}, {"input": "1\n10\n0 1 1 0 1 0 1 1 1 0\n", "output": ["19\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 0\n4\n1 0 0 1\n1\n0\n", "output": ["3\n2\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n0 1 1 0\n1\n1\n", "output": ["3\n-1\n7\n2\n"]}, {"input": "4\n3\n0 0 1\n3\n0 1 0\n4\n1 0 0 1\n1\n0\n", "output": ["-1\n2\n-1\n1\n"]}, {"input": "4\n3\n0 1 0\n3\n1 0 1\n4\n0 0 0 1\n1\n1\n", "output": ["2\n3\n-1\n2\n"]}, {"input": "4\n3\n0 1 0\n3\n1 0 1\n4\n0 0 0 1\n1\n0\n", "output": ["2\n3\n-1\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n1 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["-1\n3\n-1\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 0 1 0\n1\n0\n", "output": ["-1\n7\n3\n1\n"]}, {"input": "4\n3\n0 0 1\n3\n0 0 1\n4\n0 1 1 0\n1\n1\n", "output": ["-1\n-1\n7\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 1\n4\n1 1 1 1\n1\n1\n", "output": ["-1\n12\n17\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 1\n4\n1 1 1 0\n1\n0\n", "output": ["3\n3\n12\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["3\n3\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 1 0\n4\n1 1 1 1\n1\n0\n", "output": ["3\n7\n17\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 0 1\n4\n0 0 0 1\n1\n1\n", "output": ["12\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 0\n4\n1 1 1 0\n1\n1\n", "output": ["3\n-1\n12\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 0\n4\n1 1 0 1\n1\n0\n", "output": ["3\n2\n8\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n7\n-1\n2\n"]}, {"input": "4\n3\n0 1 0\n3\n1 1 1\n4\n0 0 0 1\n1\n0\n", "output": ["2\n12\n-1\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 1 1\n4\n0 0 0 0\n1\n0\n", "output": ["12\n7\n-1\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n1 0 1\n4\n1 1 1 0\n1\n0\n", "output": ["12\n3\n12\n1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 0 0\n4\n1 1 0 0\n1\n0\n", "output": ["12\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 1 1 1\n1\n0\n", "output": ["-1\n7\n17\n1\n"]}, {"input": "4\n3\n0 0 0\n3\n1 1 1\n4\n0 0 0 1\n1\n0\n", "output": ["-1\n12\n-1\n1\n"]}, {"input": "1\n10\n1 1 0 1 1 1 1 1 1 1\n", "output": ["38\n"]}, {"input": "4\n3\n0 0 0\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n0 0 0 1\n1\n1\n", "output": ["3\n7\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n0 0 1 1\n1\n1\n", "output": ["3\n7\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 1\n4\n1 0 0 0\n1\n1\n", "output": ["-1\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n1 1 0\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n7\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n0 0 1 1\n1\n0\n", "output": ["3\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n1 0 0 1\n1\n0\n", "output": ["3\n-1\n-1\n1\n"]}, {"input": "4\n3\n0 0 0\n3\n0 1 0\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n2\n8\n1\n"]}, {"input": "4\n3\n0 0 1\n3\n0 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n-1\n8\n1\n"]}, {"input": "1\n10\n1 1 1 1 1 1 1 1 0 1\n", "output": ["38\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 0 0 0\n1\n1\n", "output": ["3\n7\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["-1\n-1\n-1\n1\n"]}, {"input": "4\n3\n0 0 0\n3\n0 0 1\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n-1\n8\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n0 0 0 0\n1\n0\n", "output": ["3\n7\n-1\n1\n"]}, {"input": "1\n10\n0 1 0 1 1 1 1 1 1 1\n", "output": ["33\n"]}, {"input": "4\n3\n0 0 0\n3\n1 0 0\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n-1\n-1\n2\n"]}, {"input": "1\n10\n1 1 0 1 0 1 0 0 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 1 1 1 1 1 0 1\n", "output": ["33\n"]}, {"input": "4\n3\n0 0 0\n3\n0 0 1\n4\n1 0 0 1\n1\n0\n", "output": ["-1\n-1\n-1\n1\n"]}, {"input": "4\n3\n0 0 0\n3\n1 0 0\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n-1\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 1 1 0\n1\n0\n", "output": ["3\n-1\n12\n1\n"]}, {"input": "1\n10\n1 1 0 1 0 1 0 0 1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 0 1 1 1 1 0 1\n", "output": ["24\n"]}, {"input": "1\n10\n0 1 0 1 1 1 1 1 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n1 1 1 0\n1\n0\n", "output": ["3\n-1\n12\n1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 0 1 2\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 0\n4\n1 0 0 1\n1\n1\n", "output": ["-1\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 0\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n-1\n8\n1\n"]}, {"input": "1\n10\n1 1 1 1 0 0 1 1 1 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 1\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n7\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["3\n-1\n-1\n2\n"]}, {"input": "1\n10\n1 1 0 0 1 1 1 1 2 1\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 0\n4\n1 1 1 1\n1\n0\n", "output": ["3\n-1\n17\n1\n"]}, {"input": "1\n10\n1 1 0 1 0 1 0 0 0 1\n", "output": ["-1\n"]}, {"input": "4\n3\n0 0 1\n3\n1 0 0\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n-1\n8\n2\n"]}, {"input": "1\n10\n0 1 0 1 1 1 0 1 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 0\n3\n0 0 0\n4\n1 1 1 0\n1\n0\n", "output": ["-1\n-1\n12\n1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 0 1 1\n", "output": ["-1\n"]}, {"input": "4\n3\n0 0 0\n3\n0 0 0\n4\n1 0 1 1\n1\n0\n", "output": ["-1\n-1\n8\n1\n"]}, {"input": "1\n10\n1 1 1 1 0 0 1 1 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 1\n4\n0 0 0 1\n1\n1\n", "output": ["3\n-1\n-1\n2\n"]}, {"input": "1\n10\n0 1 1 0 1 0 1 1 1 1\n", "output": ["24\n"]}, {"input": "1\n10\n0 1 0 1 2 1 0 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 0 0 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 1 1 0 0 1 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 0 0 0 1 1 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 0 0 2 1 0 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 0 -1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 1 1 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 0 0 0 1 1 1 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n7\n1 0 1 1 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 -1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n7\n0 0 1 1 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n2 0 0 1 0 1 -1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n7\n0 0 2 1 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n4 0 0 1 0 1 -1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 0 0 2 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 0 0 2 0 -1 0\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 -1 0 2 0 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n1 1 0 1\n1\n0\n", "output": ["3\n7\n8\n1\n"]}, {"input": "1\n10\n1 1 0 1 1 0 1 1 1 1\n", "output": ["29\n"]}, {"input": "1\n10\n1 1 0 1 0 1 1 1 1 0\n", "output": ["24\n"]}, {"input": "4\n3\n1 0 0\n3\n0 1 1\n4\n1 1 0 0\n1\n0\n", "output": ["-1\n7\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 1 0\n4\n1 0 0 1\n1\n0\n", "output": ["3\n7\n-1\n1\n"]}, {"input": "4\n3\n1 0 1\n3\n1 0 0\n4\n1 0 0 1\n1\n0\n", "output": ["3\n-1\n-1\n1\n"]}, {"input": "4\n3\n1 1 0\n3\n0 0 1\n4\n0 0 0 1\n1\n1\n", "output": ["7\n-1\n-1\n2\n"]}, {"input": "4\n3\n0 0 0\n3\n0 1 0\n4\n1 0 1 1\n1\n1\n", "output": ["-1\n2\n8\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n0 1 1 0\n1\n0\n", "output": ["3\n-1\n7\n1\n"]}, {"input": "1\n10\n1 1 1 1 1 1 1 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 1 0 0 1 1 2 1 1 1\n", "output": ["-1\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 1\n4\n0 0 1 0\n1\n0\n", "output": ["3\n7\n-1\n1\n"]}, {"input": "4\n3\n0 1 1\n3\n0 0 1\n4\n1 0 0 1\n1\n1\n", "output": ["7\n-1\n-1\n2\n"]}, {"input": "1\n10\n1 1 0 1 0 0 0 0 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 1 1 1 0 1 0 1\n", "output": ["24\n"]}, {"input": "4\n3\n1 1 1\n3\n0 0 1\n4\n1 1 1 0\n1\n0\n", "output": ["12\n-1\n12\n1\n"]}, {"input": "1\n10\n0 1 0 1 0 1 0 0 1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 0 1 1 1 1 1 0 1\n", "output": ["24\n"]}, {"input": "4\n3\n1 0 1\n3\n0 0 0\n4\n1 1 0 0\n1\n0\n", "output": ["3\n-1\n-1\n1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 0 -1 1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n1 1 0 1 0 0 1 1 1 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 1 0 1 0 1 0 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 0 1 1 1 0 1 0 1\n", "output": ["15\n"]}, {"input": "1\n10\n1 0 0 1 0 2 0 0 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 1 1 0 0 1 1 1 0\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 1 0 1 1 1 1 1 1\n", "output": ["33\n"]}, {"input": "1\n10\n0 1 0 0 1 1 0 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 2 0 1 0 0 0 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 -1 1 1 0 0 1 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n0 1 0 0 3 1 0 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 -1 0 1 0 1 0 0 -1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 1 2 0 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 1 1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 1 1 -1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n7\n0 0 1 1 0 0 1 1 0 0\n", "output": ["-1\n"]}, {"input": "1\n7\n0 0 2 1 1 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n10\n4 0 0 1 0 0 -1 0 -1 2\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 1 0 1 0 0 0\n", "output": ["-1\n"]}, {"input": "1\n3\n0 0 2 1 -1 0 2 0 0 -1\n", "output": ["-1\n"]}, {"input": "4\n3\n0 0 1\n3\n0 1 1\n4\n1 1 0 1\n1\n0\n", "output": ["-1\n7\n8\n1\n"]}, {"input": "1\n10\n1 1 0 1 0 0 1 1 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n1 1 0 1 0 1 1 1 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n0 0 0\n3\n0 1 1\n4\n1 1 0 0\n1\n0\n", "output": ["-1\n7\n-1\n1\n"]}, {"input": "4\n3\n0 1 0\n3\n0 0 1\n4\n0 0 0 1\n1\n1\n", "output": ["2\n-1\n-1\n2\n"]}, {"input": "4\n3\n1 0 1\n3\n0 1 0\n4\n1 0 0 0\n1\n0\n", "output": ["3\n2\n-1\n1\n"]}, {"input": "1\n10\n1 1 1 1 0 1 1 1 0 0\n", "output": ["-1\n"]}, {"input": "4\n3\n1 1 1\n3\n0 1 1\n4\n0 0 0 0\n1\n1\n", "output": ["12\n7\n-1\n2\n"]}, {"input": "1\n10\n1 1 0 0 1 1 2 1 1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n1 0 0 1 0 0 0 0 1 1\n", "output": ["-1\n"]}, {"input": "1\n10\n0 0 0 1 0 1 0 -1 1 2\n", "output": ["-1\n"]}, {"input": "1\n10\n1 1 0 1 1 0 1 1 1 0\n", "output": ["24\n"]}, {"input": "1\n10\n1 1 0 1 1 1 0 0 0 0\n", "output": ["-1\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    height = 1\n    prev_watered = False\n    \n    for i in range(n):\n        # Check if flower dies (not watered for two consecutive days)\n        if a[i] == 0 and not prev_watered and i > 0:\n            height = -1\n            break\n            \n        # If flower is watered, calculate growth\n        if a[i] == 1:\n            if prev_watered:\n                height += 5\n            else:\n                height += 1\n            prev_watered = True\n        else:\n            prev_watered = False\n            \n    print(height)"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    height = 1\n    prev_watered = False\n    \n    for i in range(n):\n        # Check if flower dies (not watered for two consecutive days)\n        if a[i] == 0 and not prev_watered and i > 0:\n            height = -1\n            break\n            \n        # If flower is watered, calculate growth\n        if a[i] == 1:\n            if prev_watered:\n                height += 5\n            else:\n                height += 1\n            prev_watered = True\n        else:\n            prev_watered = False\n            \n    print(height)\n\n\n"], "prompt_tokens": [10413], "completion_tokens": [6154], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1591}
{"name": "1594_A. Consecutive Sum Riddle", "description": "Theofanis has a riddle for you and if you manage to solve it, he will give you a Cypriot snack halloumi for free (Cypriot cheese).\n\nYou are given an integer n. You need to find two integers l and r such that -10^{18} \u2264 l < r \u2264 10^{18} and l + (l + 1) + \u2026 + (r - 1) + r = n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains a single integer n (1 \u2264 n \u2264 10^{18}).\n\nOutput\n\nFor each test case, print the two integers l and r such that -10^{18} \u2264 l < r \u2264 10^{18} and l + (l + 1) + \u2026 + (r - 1) + r = n. \n\nIt can be proven that an answer always exists. If there are multiple answers, print any.\n\nExample\n\nInput\n\n\n7\n1\n2\n3\n6\n100\n25\n3000000000000\n\n\nOutput\n\n\n0 1\n-1 2 \n1 2 \n1 3 \n18 22\n-2 7\n999999999999 1000000000001\n\nNote\n\nIn the first test case, 0 + 1 = 1.\n\nIn the second test case, (-1) + 0 + 1 + 2 = 2.\n\nIn the fourth test case, 1 + 2 + 3 = 6.\n\nIn the fifth test case, 18 + 19 + 20 + 21 + 22 = 100.\n\nIn the sixth test case, (-2) + (-1) + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 = 25.", "tags": ["math"], "difficulty": 7, "id": 1594, "sample_io": [{"input": "7\n1\n2\n3\n6\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}], "test_list": [{"input": "7\n1\n2\n3\n6\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n4\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-3 4\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n6\n110\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-109 110\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n4\n100\n25\n1991556943611\n", "output": ["0 1\n-1 2\n-2 3\n-3 4\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n6\n110\n25\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-5 6\n-109 110\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n2\n4\n100\n25\n1991556943611\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n3\n110\n25\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-2 3\n-109 110\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n2\n4\n100\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n3\n3\n110\n25\n4838829180358\n", "output": ["0 1\n0 1\n-2 3\n-2 3\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n100\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n6\n3\n110\n25\n4838829180358\n", "output": ["0 1\n0 1\n-5 6\n-2 3\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n6\n3\n110\n29\n4838829180358\n", "output": ["0 1\n0 1\n-5 6\n-2 3\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n11\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-10 11\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n3\n110\n29\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n-2 3\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n11\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n4\n2\n101\n11\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-1 2\n-100 101\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n6\n2\n101\n11\n390536414718\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n-100 101\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n6\n2\n101\n2\n390536414718\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n-100 101\n-1 2\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n3\n12\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-11 12\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n4\n101\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-3 4\n-100 101\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n6\n110\n25\n2677725722785\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-109 110\n-24 25\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n3\n4\n100\n25\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n6\n110\n25\n3572104061323\n", "output": ["0 1\n0 1\n-2 3\n-5 6\n-109 110\n-24 25\n-3572104061322 3572104061323\n"]}, {"input": "7\n1\n2\n2\n4\n100\n38\n1991556943611\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-37 38\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n5\n110\n25\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-109 110\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n2\n1\n100\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-1 2\n0 1\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n6\n4\n110\n25\n4838829180358\n", "output": ["0 1\n0 1\n-5 6\n-3 4\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n111\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-110 111\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n4\n101\n11\n1353142354742\n", "output": ["0 1\n-1 2\n-5 6\n-3 4\n-100 101\n-10 11\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n1\n110\n29\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n0 1\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n15\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-14 15\n-390536414717 390536414718\n"]}, {"input": "7\n2\n2\n4\n2\n101\n11\n390536414718\n", "output": ["-1 2\n-1 2\n-3 4\n-1 2\n-100 101\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n6\n2\n101\n11\n766333686844\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n-100 101\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n6\n2\n001\n2\n390536414718\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n0 1\n-1 2\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n6\n12\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-5 6\n-11 12\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n2\n2\n3\n6\n110\n25\n2677725722785\n", "output": ["-1 2\n-1 2\n-2 3\n-5 6\n-109 110\n-24 25\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n3\n4\n101\n25\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n-100 101\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n2\n6\n110\n25\n3572104061323\n", "output": ["0 1\n0 1\n-1 2\n-5 6\n-109 110\n-24 25\n-3572104061322 3572104061323\n"]}, {"input": "7\n1\n2\n2\n4\n100\n31\n1991556943611\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-30 31\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n5\n100\n25\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n2\n2\n100\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-1 2\n-1 2\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n4\n110\n25\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n-3 4\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n8\n101\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-7 8\n-100 101\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n3\n6\n1\n110\n29\n4838829180358\n", "output": ["0 1\n-2 3\n-5 6\n0 1\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n100\n15\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-99 100\n-14 15\n-390536414717 390536414718\n"]}, {"input": "7\n2\n2\n4\n2\n111\n11\n390536414718\n", "output": ["-1 2\n-1 2\n-3 4\n-1 2\n-110 111\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n1\n3\n6\n2\n101\n11\n766333686844\n", "output": ["0 1\n-2 3\n-5 6\n-1 2\n-100 101\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n6\n2\n001\n2\n133532318784\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n0 1\n-1 2\n-133532318783 133532318784\n"]}, {"input": "7\n2\n2\n1\n6\n110\n25\n2677725722785\n", "output": ["-1 2\n-1 2\n0 1\n-5 6\n-109 110\n-24 25\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n3\n4\n101\n40\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n-100 101\n-39 40\n-1991556943610 1991556943611\n"]}, {"input": "7\n2\n1\n2\n6\n110\n25\n3572104061323\n", "output": ["-1 2\n0 1\n-1 2\n-5 6\n-109 110\n-24 25\n-3572104061322 3572104061323\n"]}, {"input": "7\n1\n2\n3\n2\n100\n25\n1991556943611\n", "output": ["0 1\n-1 2\n-2 3\n-1 2\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n5\n101\n25\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-100 101\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n110\n25\n4838829180358\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n8\n101\n25\n2436703125980\n", "output": ["0 1\n-1 2\n-3 4\n-7 8\n-100 101\n-24 25\n-2436703125979 2436703125980\n"]}, {"input": "7\n1\n3\n6\n1\n100\n29\n4838829180358\n", "output": ["0 1\n-2 3\n-5 6\n0 1\n-99 100\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n100\n15\n390536414718\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-14 15\n-390536414717 390536414718\n"]}, {"input": "7\n2\n2\n8\n2\n111\n11\n390536414718\n", "output": ["-1 2\n-1 2\n-7 8\n-1 2\n-110 111\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n2\n3\n6\n2\n101\n11\n766333686844\n", "output": ["-1 2\n-2 3\n-5 6\n-1 2\n-100 101\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n4\n2\n001\n2\n133532318784\n", "output": ["0 1\n-1 2\n-3 4\n-1 2\n0 1\n-1 2\n-133532318783 133532318784\n"]}, {"input": "7\n2\n2\n1\n6\n110\n28\n2677725722785\n", "output": ["-1 2\n-1 2\n0 1\n-5 6\n-109 110\n-27 28\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n3\n4\n001\n40\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n0 1\n-39 40\n-1991556943610 1991556943611\n"]}, {"input": "7\n2\n1\n2\n6\n110\n25\n2332457974892\n", "output": ["-1 2\n0 1\n-1 2\n-5 6\n-109 110\n-24 25\n-2332457974891 2332457974892\n"]}, {"input": "7\n1\n3\n3\n2\n100\n25\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-1 2\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n5\n101\n50\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-100 101\n-49 50\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n110\n25\n5095734316934\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-109 110\n-24 25\n-5095734316933 5095734316934\n"]}, {"input": "7\n1\n2\n4\n3\n101\n25\n2436703125980\n", "output": ["0 1\n-1 2\n-3 4\n-2 3\n-100 101\n-24 25\n-2436703125979 2436703125980\n"]}, {"input": "7\n1\n3\n12\n1\n100\n29\n4838829180358\n", "output": ["0 1\n-2 3\n-11 12\n0 1\n-99 100\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n100\n15\n210883275658\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-14 15\n-210883275657 210883275658\n"]}, {"input": "7\n2\n1\n8\n2\n111\n11\n390536414718\n", "output": ["-1 2\n0 1\n-7 8\n-1 2\n-110 111\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n2\n3\n6\n2\n001\n11\n766333686844\n", "output": ["-1 2\n-2 3\n-5 6\n-1 2\n0 1\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n8\n2\n001\n2\n133532318784\n", "output": ["0 1\n-1 2\n-7 8\n-1 2\n0 1\n-1 2\n-133532318783 133532318784\n"]}, {"input": "7\n2\n4\n1\n6\n110\n28\n2677725722785\n", "output": ["-1 2\n-3 4\n0 1\n-5 6\n-109 110\n-27 28\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n6\n4\n001\n40\n1991556943611\n", "output": ["0 1\n-2 3\n-5 6\n-3 4\n0 1\n-39 40\n-1991556943610 1991556943611\n"]}, {"input": "7\n2\n1\n2\n6\n110\n25\n2540353946170\n", "output": ["-1 2\n0 1\n-1 2\n-5 6\n-109 110\n-24 25\n-2540353946169 2540353946170\n"]}, {"input": "7\n1\n3\n3\n2\n100\n25\n1288390796923\n", "output": ["0 1\n-2 3\n-2 3\n-1 2\n-99 100\n-24 25\n-1288390796922 1288390796923\n"]}, {"input": "7\n1\n1\n3\n5\n101\n56\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n110\n25\n936172580299\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-109 110\n-24 25\n-936172580298 936172580299\n"]}, {"input": "7\n1\n2\n4\n3\n101\n25\n1275671334659\n", "output": ["0 1\n-1 2\n-3 4\n-2 3\n-100 101\n-24 25\n-1275671334658 1275671334659\n"]}, {"input": "7\n1\n3\n12\n1\n100\n23\n4838829180358\n", "output": ["0 1\n-2 3\n-11 12\n0 1\n-99 100\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n101\n15\n210883275658\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-100 101\n-14 15\n-210883275657 210883275658\n"]}, {"input": "7\n2\n1\n9\n2\n111\n11\n390536414718\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-110 111\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n2\n6\n6\n2\n001\n11\n766333686844\n", "output": ["-1 2\n-5 6\n-5 6\n-1 2\n0 1\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n8\n4\n001\n2\n133532318784\n", "output": ["0 1\n-1 2\n-7 8\n-3 4\n0 1\n-1 2\n-133532318783 133532318784\n"]}, {"input": "7\n1\n4\n1\n6\n110\n28\n2677725722785\n", "output": ["0 1\n-3 4\n0 1\n-5 6\n-109 110\n-27 28\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n6\n4\n011\n40\n1991556943611\n", "output": ["0 1\n-2 3\n-5 6\n-3 4\n-10 11\n-39 40\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n3\n3\n4\n100\n25\n1288390796923\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n-99 100\n-24 25\n-1288390796922 1288390796923\n"]}, {"input": "7\n1\n2\n3\n5\n101\n56\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-4 5\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n110\n25\n1246712055273\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-109 110\n-24 25\n-1246712055272 1246712055273\n"]}, {"input": "7\n1\n2\n4\n3\n101\n25\n747848364006\n", "output": ["0 1\n-1 2\n-3 4\n-2 3\n-100 101\n-24 25\n-747848364005 747848364006\n"]}, {"input": "7\n1\n3\n12\n2\n100\n23\n4838829180358\n", "output": ["0 1\n-2 3\n-11 12\n-1 2\n-99 100\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n100\n15\n294961048161\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-99 100\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n9\n2\n110\n11\n390536414718\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-109 110\n-10 11\n-390536414717 390536414718\n"]}, {"input": "7\n2\n6\n12\n2\n001\n11\n766333686844\n", "output": ["-1 2\n-5 6\n-11 12\n-1 2\n0 1\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n2\n2\n8\n4\n001\n2\n133532318784\n", "output": ["-1 2\n-1 2\n-7 8\n-3 4\n0 1\n-1 2\n-133532318783 133532318784\n"]}, {"input": "7\n1\n4\n1\n6\n110\n28\n300434955457\n", "output": ["0 1\n-3 4\n0 1\n-5 6\n-109 110\n-27 28\n-300434955456 300434955457\n"]}, {"input": "7\n1\n4\n6\n4\n011\n40\n1991556943611\n", "output": ["0 1\n-3 4\n-5 6\n-3 4\n-10 11\n-39 40\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n3\n3\n4\n100\n2\n1288390796923\n", "output": ["0 1\n-2 3\n-2 3\n-3 4\n-99 100\n-1 2\n-1288390796922 1288390796923\n"]}, {"input": "7\n1\n2\n3\n2\n101\n56\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-1 2\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n010\n25\n1246712055273\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-9 10\n-24 25\n-1246712055272 1246712055273\n"]}, {"input": "7\n1\n2\n4\n3\n101\n28\n747848364006\n", "output": ["0 1\n-1 2\n-3 4\n-2 3\n-100 101\n-27 28\n-747848364005 747848364006\n"]}, {"input": "7\n1\n3\n20\n2\n100\n23\n4838829180358\n", "output": ["0 1\n-2 3\n-19 20\n-1 2\n-99 100\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n101\n15\n294961048161\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-100 101\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n9\n2\n110\n11\n678758088380\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-109 110\n-10 11\n-678758088379 678758088380\n"]}, {"input": "7\n4\n6\n12\n2\n001\n11\n766333686844\n", "output": ["-3 4\n-5 6\n-11 12\n-1 2\n0 1\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n2\n2\n8\n4\n001\n2\n171734329532\n", "output": ["-1 2\n-1 2\n-7 8\n-3 4\n0 1\n-1 2\n-171734329531 171734329532\n"]}, {"input": "7\n1\n1\n1\n6\n110\n28\n300434955457\n", "output": ["0 1\n0 1\n0 1\n-5 6\n-109 110\n-27 28\n-300434955456 300434955457\n"]}, {"input": "7\n1\n4\n6\n4\n011\n27\n1991556943611\n", "output": ["0 1\n-3 4\n-5 6\n-3 4\n-10 11\n-26 27\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n6\n3\n4\n100\n2\n1288390796923\n", "output": ["0 1\n-5 6\n-2 3\n-3 4\n-99 100\n-1 2\n-1288390796922 1288390796923\n"]}, {"input": "7\n1\n2\n6\n2\n101\n56\n3000000000000\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n4\n010\n50\n1246712055273\n", "output": ["0 1\n-1 2\n0 1\n-3 4\n-9 10\n-49 50\n-1246712055272 1246712055273\n"]}, {"input": "7\n1\n3\n4\n3\n101\n28\n747848364006\n", "output": ["0 1\n-2 3\n-3 4\n-2 3\n-100 101\n-27 28\n-747848364005 747848364006\n"]}, {"input": "7\n1\n3\n20\n2\n110\n23\n4838829180358\n", "output": ["0 1\n-2 3\n-19 20\n-1 2\n-109 110\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n2\n4\n111\n15\n294961048161\n", "output": ["0 1\n-1 2\n-1 2\n-3 4\n-110 111\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n9\n2\n110\n10\n678758088380\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-109 110\n-9 10\n-678758088379 678758088380\n"]}, {"input": "7\n4\n6\n12\n2\n001\n11\n3201880686\n", "output": ["-3 4\n-5 6\n-11 12\n-1 2\n0 1\n-10 11\n-3201880685 3201880686\n"]}, {"input": "7\n1\n1\n1\n6\n110\n28\n357303383774\n", "output": ["0 1\n0 1\n0 1\n-5 6\n-109 110\n-27 28\n-357303383773 357303383774\n"]}, {"input": "7\n1\n4\n6\n4\n001\n27\n1991556943611\n", "output": ["0 1\n-3 4\n-5 6\n-3 4\n0 1\n-26 27\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n2\n12\n2\n101\n56\n3000000000000\n", "output": ["0 1\n-1 2\n-11 12\n-1 2\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n1\n010\n50\n1246712055273\n", "output": ["0 1\n-1 2\n0 1\n0 1\n-9 10\n-49 50\n-1246712055272 1246712055273\n"]}, {"input": "7\n1\n3\n4\n3\n101\n15\n747848364006\n", "output": ["0 1\n-2 3\n-3 4\n-2 3\n-100 101\n-14 15\n-747848364005 747848364006\n"]}, {"input": "7\n1\n3\n32\n2\n110\n23\n4838829180358\n", "output": ["0 1\n-2 3\n-31 32\n-1 2\n-109 110\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n2\n2\n4\n111\n15\n294961048161\n", "output": ["-1 2\n-1 2\n-1 2\n-3 4\n-110 111\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n9\n2\n100\n10\n678758088380\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-99 100\n-9 10\n-678758088379 678758088380\n"]}, {"input": "7\n4\n6\n12\n2\n001\n11\n2854222004\n", "output": ["-3 4\n-5 6\n-11 12\n-1 2\n0 1\n-10 11\n-2854222003 2854222004\n"]}, {"input": "7\n1\n1\n1\n6\n100\n28\n357303383774\n", "output": ["0 1\n0 1\n0 1\n-5 6\n-99 100\n-27 28\n-357303383773 357303383774\n"]}, {"input": "7\n1\n4\n6\n4\n001\n36\n1991556943611\n", "output": ["0 1\n-3 4\n-5 6\n-3 4\n0 1\n-35 36\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n2\n12\n1\n101\n56\n3000000000000\n", "output": ["0 1\n-1 2\n-11 12\n0 1\n-100 101\n-55 56\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n1\n1\n010\n50\n813243965518\n", "output": ["0 1\n-1 2\n0 1\n0 1\n-9 10\n-49 50\n-813243965517 813243965518\n"]}, {"input": "7\n1\n3\n4\n3\n101\n25\n747848364006\n", "output": ["0 1\n-2 3\n-3 4\n-2 3\n-100 101\n-24 25\n-747848364005 747848364006\n"]}, {"input": "7\n1\n1\n32\n2\n110\n23\n4838829180358\n", "output": ["0 1\n0 1\n-31 32\n-1 2\n-109 110\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n2\n2\n1\n111\n15\n294961048161\n", "output": ["-1 2\n-1 2\n-1 2\n0 1\n-110 111\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n9\n2\n100\n14\n678758088380\n", "output": ["-1 2\n0 1\n-8 9\n-1 2\n-99 100\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n1\n1\n6\n100\n28\n357303383774\n", "output": ["-1 2\n0 1\n0 1\n-5 6\n-99 100\n-27 28\n-357303383773 357303383774\n"]}, {"input": "7\n1\n4\n6\n4\n001\n36\n874723705512\n", "output": ["0 1\n-3 4\n-5 6\n-3 4\n0 1\n-35 36\n-874723705511 874723705512\n"]}, {"input": "7\n1\n4\n1\n1\n010\n50\n813243965518\n", "output": ["0 1\n-3 4\n0 1\n0 1\n-9 10\n-49 50\n-813243965517 813243965518\n"]}, {"input": "7\n1\n3\n4\n3\n101\n25\n28231786989\n", "output": ["0 1\n-2 3\n-3 4\n-2 3\n-100 101\n-24 25\n-28231786988 28231786989\n"]}, {"input": "7\n1\n1\n64\n2\n110\n23\n4838829180358\n", "output": ["0 1\n0 1\n-63 64\n-1 2\n-109 110\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n3\n2\n2\n1\n111\n15\n294961048161\n", "output": ["-2 3\n-1 2\n-1 2\n0 1\n-110 111\n-14 15\n-294961048160 294961048161\n"]}, {"input": "7\n2\n1\n7\n2\n100\n14\n678758088380\n", "output": ["-1 2\n0 1\n-6 7\n-1 2\n-99 100\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n2\n1\n6\n100\n28\n357303383774\n", "output": ["-1 2\n-1 2\n0 1\n-5 6\n-99 100\n-27 28\n-357303383773 357303383774\n"]}, {"input": "7\n1\n4\n1\n1\n010\n50\n150630929683\n", "output": ["0 1\n-3 4\n0 1\n0 1\n-9 10\n-49 50\n-150630929682 150630929683\n"]}, {"input": "7\n1\n1\n64\n2\n010\n23\n4838829180358\n", "output": ["0 1\n0 1\n-63 64\n-1 2\n-9 10\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n2\n7\n2\n100\n14\n678758088380\n", "output": ["-1 2\n-1 2\n-6 7\n-1 2\n-99 100\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n2\n1\n6\n100\n43\n357303383774\n", "output": ["-1 2\n-1 2\n0 1\n-5 6\n-99 100\n-42 43\n-357303383773 357303383774\n"]}, {"input": "7\n1\n4\n1\n1\n011\n50\n150630929683\n", "output": ["0 1\n-3 4\n0 1\n0 1\n-10 11\n-49 50\n-150630929682 150630929683\n"]}, {"input": "7\n1\n1\n64\n1\n110\n23\n4838829180358\n", "output": ["0 1\n0 1\n-63 64\n0 1\n-109 110\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n2\n7\n3\n100\n14\n678758088380\n", "output": ["-1 2\n-1 2\n-6 7\n-2 3\n-99 100\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n2\n2\n6\n100\n43\n357303383774\n", "output": ["-1 2\n-1 2\n-1 2\n-5 6\n-99 100\n-42 43\n-357303383773 357303383774\n"]}, {"input": "7\n1\n5\n1\n1\n011\n50\n150630929683\n", "output": ["0 1\n-4 5\n0 1\n0 1\n-10 11\n-49 50\n-150630929682 150630929683\n"]}, {"input": "7\n1\n1\n64\n1\n010\n23\n4838829180358\n", "output": ["0 1\n0 1\n-63 64\n0 1\n-9 10\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n2\n7\n3\n110\n14\n678758088380\n", "output": ["-1 2\n-1 2\n-6 7\n-2 3\n-109 110\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n2\n4\n6\n100\n43\n357303383774\n", "output": ["-1 2\n-1 2\n-3 4\n-5 6\n-99 100\n-42 43\n-357303383773 357303383774\n"]}, {"input": "7\n1\n1\n66\n1\n010\n23\n4838829180358\n", "output": ["0 1\n0 1\n-65 66\n0 1\n-9 10\n-22 23\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n4\n7\n3\n110\n14\n678758088380\n", "output": ["-1 2\n-3 4\n-6 7\n-2 3\n-109 110\n-13 14\n-678758088379 678758088380\n"]}, {"input": "7\n2\n2\n4\n6\n100\n43\n705629924930\n", "output": ["-1 2\n-1 2\n-3 4\n-5 6\n-99 100\n-42 43\n-705629924929 705629924930\n"]}, {"input": "7\n1\n1\n66\n1\n010\n23\n4753320387781\n", "output": ["0 1\n0 1\n-65 66\n0 1\n-9 10\n-22 23\n-4753320387780 4753320387781\n"]}, {"input": "7\n2\n4\n7\n3\n110\n6\n678758088380\n", "output": ["-1 2\n-3 4\n-6 7\n-2 3\n-109 110\n-5 6\n-678758088379 678758088380\n"]}, {"input": "7\n1\n1\n66\n1\n010\n23\n4190053953232\n", "output": ["0 1\n0 1\n-65 66\n0 1\n-9 10\n-22 23\n-4190053953231 4190053953232\n"]}, {"input": "7\n2\n4\n7\n3\n111\n6\n678758088380\n", "output": ["-1 2\n-3 4\n-6 7\n-2 3\n-110 111\n-5 6\n-678758088379 678758088380\n"]}, {"input": "7\n1\n1\n14\n1\n010\n23\n4190053953232\n", "output": ["0 1\n0 1\n-13 14\n0 1\n-9 10\n-22 23\n-4190053953231 4190053953232\n"]}, {"input": "7\n2\n4\n7\n3\n011\n6\n678758088380\n", "output": ["-1 2\n-3 4\n-6 7\n-2 3\n-10 11\n-5 6\n-678758088379 678758088380\n"]}, {"input": "7\n1\n1\n14\n1\n010\n46\n4190053953232\n", "output": ["0 1\n0 1\n-13 14\n0 1\n-9 10\n-45 46\n-4190053953231 4190053953232\n"]}, {"input": "7\n2\n4\n7\n3\n111\n6\n56293238153\n", "output": ["-1 2\n-3 4\n-6 7\n-2 3\n-110 111\n-5 6\n-56293238152 56293238153\n"]}, {"input": "7\n1\n2\n2\n6\n100\n25\n3000000000000\n", "output": ["0 1\n-1 2\n-1 2\n-5 6\n-99 100\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n6\n100\n25\n4576389190877\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-99 100\n-24 25\n-4576389190876 4576389190877\n"]}, {"input": "7\n1\n2\n3\n6\n110\n37\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-5 6\n-109 110\n-36 37\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n4\n100\n27\n1991556943611\n", "output": ["0 1\n-1 2\n-2 3\n-3 4\n-99 100\n-26 27\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n4\n6\n110\n25\n3000000000000\n", "output": ["0 1\n0 1\n-3 4\n-5 6\n-109 110\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n1\n3\n3\n110\n1\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-2 3\n-109 110\n0 1\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n3\n2\n4\n100\n25\n1353142354742\n", "output": ["0 1\n-2 3\n-1 2\n-3 4\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n3\n5\n110\n25\n4838829180358\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n5\n100\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-3 4\n-4 5\n-99 100\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n1\n8\n3\n110\n25\n4838829180358\n", "output": ["0 1\n0 1\n-7 8\n-2 3\n-109 110\n-24 25\n-4838829180357 4838829180358\n"]}, {"input": "7\n2\n1\n6\n3\n110\n29\n4838829180358\n", "output": ["-1 2\n0 1\n-5 6\n-2 3\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n11\n307434316852\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-10 11\n-307434316851 307434316852\n"]}, {"input": "7\n1\n2\n6\n1\n110\n54\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n0 1\n-109 110\n-53 54\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n101\n12\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-100 101\n-11 12\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n4\n2\n101\n21\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-1 2\n-100 101\n-20 21\n-390536414717 390536414718\n"]}, {"input": "7\n1\n1\n6\n2\n101\n2\n390536414718\n", "output": ["0 1\n0 1\n-5 6\n-1 2\n-100 101\n-1 2\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n3\n12\n100\n31\n3000000000000\n", "output": ["0 1\n-1 2\n-2 3\n-11 12\n-99 100\n-30 31\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n4\n3\n4\n101\n25\n3000000000000\n", "output": ["0 1\n-3 4\n-2 3\n-3 4\n-100 101\n-24 25\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n3\n4\n110\n25\n2677725722785\n", "output": ["0 1\n-1 2\n-2 3\n-3 4\n-109 110\n-24 25\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n3\n8\n100\n25\n1991556943611\n", "output": ["0 1\n-2 3\n-2 3\n-7 8\n-99 100\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n3\n6\n110\n14\n3572104061323\n", "output": ["0 1\n0 1\n-2 3\n-5 6\n-109 110\n-13 14\n-3572104061322 3572104061323\n"]}, {"input": "7\n1\n1\n3\n5\n110\n5\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-109 110\n-4 5\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n4\n4\n4\n111\n25\n1353142354742\n", "output": ["0 1\n-3 4\n-3 4\n-3 4\n-110 111\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n2\n2\n6\n4\n101\n11\n1353142354742\n", "output": ["-1 2\n-1 2\n-5 6\n-3 4\n-100 101\n-10 11\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n2\n110\n29\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n-109 110\n-28 29\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n2\n4\n4\n111\n15\n390536414718\n", "output": ["0 1\n-1 2\n-3 4\n-3 4\n-110 111\n-14 15\n-390536414717 390536414718\n"]}, {"input": "7\n2\n2\n4\n2\n101\n8\n390536414718\n", "output": ["-1 2\n-1 2\n-3 4\n-1 2\n-100 101\n-7 8\n-390536414717 390536414718\n"]}, {"input": "7\n1\n2\n6\n2\n001\n11\n766333686844\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n0 1\n-10 11\n-766333686843 766333686844\n"]}, {"input": "7\n1\n2\n6\n2\n001\n4\n390536414718\n", "output": ["0 1\n-1 2\n-5 6\n-1 2\n0 1\n-3 4\n-390536414717 390536414718\n"]}, {"input": "7\n2\n2\n3\n1\n110\n25\n2677725722785\n", "output": ["-1 2\n-1 2\n-2 3\n0 1\n-109 110\n-24 25\n-2677725722784 2677725722785\n"]}, {"input": "7\n1\n3\n1\n4\n101\n25\n1991556943611\n", "output": ["0 1\n-2 3\n0 1\n-3 4\n-100 101\n-24 25\n-1991556943610 1991556943611\n"]}, {"input": "7\n1\n1\n2\n10\n110\n25\n3572104061323\n", "output": ["0 1\n0 1\n-1 2\n-9 10\n-109 110\n-24 25\n-3572104061322 3572104061323\n"]}, {"input": "7\n1\n1\n3\n5\n100\n8\n3000000000000\n", "output": ["0 1\n0 1\n-2 3\n-4 5\n-99 100\n-7 8\n-2999999999999 3000000000000\n"]}, {"input": "7\n1\n2\n2\n2\n101\n25\n1353142354742\n", "output": ["0 1\n-1 2\n-1 2\n-1 2\n-100 101\n-24 25\n-1353142354741 1353142354742\n"]}, {"input": "7\n1\n2\n6\n4\n110\n28\n4838829180358\n", "output": ["0 1\n-1 2\n-5 6\n-3 4\n-109 110\n-27 28\n-4838829180357 4838829180358\n"]}, {"input": "7\n1\n1\n4\n8\n101\n25\n1353142354742\n", "output": ["0 1\n0 1\n-3 4\n-7 8\n-100 101\n-24 25\n-1353142354741 1353142354742\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    n = int(input())\n    \n    # Try to find a short sequence\n    # For odd n: try two consecutive numbers\n    if n % 2 == 1:\n        l = (n - 1) // 2\n        r = (n + 1) // 2\n        if l < r:\n            print(l, r)\n            continue\n    \n    # Default approach that always works\n    l = 1 - n\n    r = n\n    print(l, r)", "def find_l_r(n):\n    # For sum from l to r: (r-l+1)(l+r)/2 = n\n    # So (r-l+1)(l+r) = 2n\n    # Let length = r-l+1, sum_of_endpoints = l+r\n    # length * sum_of_endpoints = 2n\n    \n    target = 2 * n\n    \n    # Find factors of target\n    # We want length and sum_endpoints such that their product is 2n\n    # Try different lengths starting from small values\n    \n    # Start with length = 2 (most common case)\n    length = 2\n    while length * length <= target:\n        if target % length == 0:\n            sum_endpoints = target // length\n            \n            # Check if we can get integer l and r\n            if (sum_endpoints - length + 1) % 2 == 0:\n                l = (sum_endpoints - length + 1) // 2\n                r = (sum_endpoints + length - 1) // 2\n                if l < r:\n                    return l, r\n            \n            # Also try the complementary factor pair\n            length2 = sum_endpoints\n            sum_endpoints2 = length\n            if length2 != length and (sum_endpoints2 - length2 + 1) % 2 == 0:\n                l = (sum_endpoints2 - length2 + 1) // 2\n                r = (sum_endpoints2 + length2 - 1) // 2\n                if l < r:\n                    return l, r\n        \n        length += 1\n    \n    # If no suitable factors found, use fallback methods\n    # For odd n: use consecutive integers (n-1)/2 and (n+1)/2\n    if n % 2 == 1:\n        mid = n\n        return mid - 1, mid\n    else:\n        # For even n, we can always use: 1 + 2 + ... + (n/2-1) + (n/2+1) = n\n        # But easier: use -n+1, -n+2, ..., 0, ..., n-1, n which sums to n\n        # Even simpler: use length 2 with l = 1-n, r = n\n        return 1 - n, n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        l, r = find_l_r(n)\n        print(l, r)\n\nif __name__ == \"__main__\":\n    main()", "import math\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        \n        # We want l + (l+1) + ... + r = n\n        # This equals (r-l+1)(l+r)/2 = n\n        # So (r-l+1)(l+r) = 2*n\n        \n        target = 2 * n\n        \n        # Try different possible lengths (r-l+1)\n        found = False\n        \n        # Check factors of 2*n\n        for k in range(1, int(math.sqrt(target)) + 2):\n            if target % k == 0:\n                # k is a factor, so is target//k\n                \n                # Case 1: k is the length\n                s = target // k  # s = l + r\n                if (s + k) % 2 == 1:  # Check if we get integer solutions\n                    r = (s + k - 1) // 2\n                    l = (s - k + 1) // 2\n                    if l < r and -10**18 <= l and r <= 10**18:\n                        print(l, r)\n                        found = True\n                        break\n                \n                # Case 2: target//k is the length\n                k2 = target // k\n                s2 = k\n                if k2 != k and (s2 + k2) % 2 == 1:\n                    r = (s2 + k2 - 1) // 2\n                    l = (s2 - k2 + 1) // 2\n                    if l < r and -10**18 <= l and r <= 10**18:\n                        print(l, r)\n                        found = True\n                        break\n        \n        if not found:\n            # Fallback: use 2 consecutive numbers\n            # n = k + (k+1) = 2k + 1, so if n is odd: k = (n-1)/2\n            # n = (-k+1) + (-k+2) + ... + 0 + ... + k = k, so if we want n:\n            # we can do -(n-1) + -(n-2) + ... + -1 + 0 + 1 + ... + (n-1) + n = n\n            print(-(n - 1), n)\n\nsolve()"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    \n    # Try to find a short sequence\n    # For odd n: try two consecutive numbers\n    if n % 2 == 1:\n        l = (n - 1) // 2\n        r = (n + 1) // 2\n        if l < r:\n            print(l, r)\n            continue\n    \n    # Default approach that always works\n    l = 1 - n\n    r = n\n    print(l, r)\n\n\n", "\ndef find_l_r(n):\n    # For sum from l to r: (r-l+1)(l+r)/2 = n\n    # So (r-l+1)(l+r) = 2n\n    # Let length = r-l+1, sum_of_endpoints = l+r\n    # length * sum_of_endpoints = 2n\n    \n    target = 2 * n\n    \n    # Find factors of target\n    # We want length and sum_endpoints such that their product is 2n\n    # Try different lengths starting from small values\n    \n    # Start with length = 2 (most common case)\n    length = 2\n    while length * length <= target:\n        if target % length == 0:\n            sum_endpoints = target // length\n            \n            # Check if we can get integer l and r\n            if (sum_endpoints - length + 1) % 2 == 0:\n                l = (sum_endpoints - length + 1) // 2\n                r = (sum_endpoints + length - 1) // 2\n                if l < r:\n                    return l, r\n            \n            # Also try the complementary factor pair\n            length2 = sum_endpoints\n            sum_endpoints2 = length\n            if length2 != length and (sum_endpoints2 - length2 + 1) % 2 == 0:\n                l = (sum_endpoints2 - length2 + 1) // 2\n                r = (sum_endpoints2 + length2 - 1) // 2\n                if l < r:\n                    return l, r\n        \n        length += 1\n    \n    # If no suitable factors found, use fallback methods\n    # For odd n: use consecutive integers (n-1)/2 and (n+1)/2\n    if n % 2 == 1:\n        mid = n\n        return mid - 1, mid\n    else:\n        # For even n, we can always use: 1 + 2 + ... + (n/2-1) + (n/2+1) = n\n        # But easier: use -n+1, -n+2, ..., 0, ..., n-1, n which sums to n\n        # Even simpler: use length 2 with l = 1-n, r = n\n        return 1 - n, n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        l, r = find_l_r(n)\n        print(l, r)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport math\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        \n        # We want l + (l+1) + ... + r = n\n        # This equals (r-l+1)(l+r)/2 = n\n        # So (r-l+1)(l+r) = 2*n\n        \n        target = 2 * n\n        \n        # Try different possible lengths (r-l+1)\n        found = False\n        \n        # Check factors of 2*n\n        for k in range(1, int(math.sqrt(target)) + 2):\n            if target % k == 0:\n                # k is a factor, so is target//k\n                \n                # Case 1: k is the length\n                s = target // k  # s = l + r\n                if (s + k) % 2 == 1:  # Check if we get integer solutions\n                    r = (s + k - 1) // 2\n                    l = (s - k + 1) // 2\n                    if l < r and -10**18 <= l and r <= 10**18:\n                        print(l, r)\n                        found = True\n                        break\n                \n                # Case 2: target//k is the length\n                k2 = target // k\n                s2 = k\n                if k2 != k and (s2 + k2) % 2 == 1:\n                    r = (s2 + k2 - 1) // 2\n                    l = (s2 - k2 + 1) // 2\n                    if l < r and -10**18 <= l and r <= 10**18:\n                        print(l, r)\n                        found = True\n                        break\n        \n        if not found:\n            # Fallback: use 2 consecutive numbers\n            # n = k + (k+1) = 2k + 1, so if n is odd: k = (n-1)/2\n            # n = (-k+1) + (-k+2) + ... + 0 + ... + k = k, so if we want n:\n            # we can do -(n-1) + -(n-2) + ... + -1 + 0 + 1 + ... + (n-1) + n = n\n            print(-(n - 1), n)\n\nsolve()\n\n\n"], "prompt_tokens": [13233, 10420, 11143], "completion_tokens": [8316, 10280, 10452], "no_of_try": 3, "api_calls": 30, "is_solved": true, "language": "Python3", "task_id": 1594}
{"name": "1598_A. Computer Game", "description": "Monocarp is playing a computer game. Now he wants to complete the first level of this game.\n\nA level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) \u2014 at the intersection of the 1-st row and the 1-st column.\n\nMonocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| \u2264 1 and |y_1 - y_2| \u2264 1. Obviously, it is prohibited to go outside the grid.\n\nThere are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.\n\nTo complete a level, Monocarp's character should reach cell (2, n) \u2014 at the intersection of row 2 and column n.\n\nHelp Monocarp determine if it is possible to complete the level.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then the test cases follow. Each test case consists of three lines.\n\nThe first line contains a single integer n (3 \u2264 n \u2264 100) \u2014 the number of columns.\n\nThe next two lines describe the level. The i-th of these lines describes the i-th line of the level \u2014 the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.\n\nAdditional constraint on the input: cells (1, 1) and (2, n) are safe.\n\nOutput\n\nFor each test case, output YES if it is possible to complete the level, and NO otherwise.\n\nExample\n\nInput\n\n\n4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n1110\n6\n010101\n101010\n\n\nOutput\n\n\nYES\nYES\nNO\nYES\n\nNote\n\nConsider the example from the statement.\n\nIn the first test case, one of the possible paths is (1, 1) \u2192 (2, 2) \u2192 (2, 3).\n\nIn the second test case, one of the possible paths is (1, 1) \u2192 (1, 2) \u2192 (2, 3) \u2192 (2, 4).\n\nIn the fourth test case, one of the possible paths is (1, 1) \u2192 (2, 2) \u2192 (1, 3) \u2192 (2, 4) \u2192 (1, 5) \u2192 (2, 6).", "tags": ["brute force", "dfs and similar", "dp", "implementation"], "difficulty": 7, "id": 1598, "sample_io": [{"input": "4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n1110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}], "test_list": [{"input": "1\n9\n000000010\n000000000\n", "output": ["YES\n"]}, {"input": "1\n9\n000000010\n000100000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000000000000000000000010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n000010010\n000100000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000010000000000000000010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n0110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "4\n3\n010\n010\n4\n0011\n0100\n4\n1111\n0110\n6\n010100\n101010\n", "output": ["NO\nYES\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0111\n0100\n4\n0011\n1110\n6\n010101\n101110\n", "output": ["YES\nNO\nNO\nNO\n"]}, {"input": "4\n3\n010\n010\n4\n0011\n0100\n4\n1111\n0110\n6\n010110\n101010\n", "output": ["NO\nYES\nNO\nNO\n"]}, {"input": "4\n3\n000\n010\n4\n0011\n1110\n4\n0111\n1110\n6\n010100\n100010\n", "output": ["YES\nNO\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0111\n0100\n4\n0011\n1100\n6\n010101\n101110\n", "output": ["YES\nNO\nYES\nNO\n"]}, {"input": "4\n3\n010\n010\n4\n0111\n0100\n4\n1101\n0110\n6\n010110\n101010\n", "output": ["NO\nNO\nNO\nNO\n"]}, {"input": "1\n9\n001010010\n000100000\n", "output": ["YES\n"]}, {"input": "1\n9\n001010010\n000100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110000\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n000000011\n000000000\n", "output": ["YES\n"]}, {"input": "1\n9\n000000000\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000000000000000000000010\n000000000000000000000000001000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n1110\n6\n010101\n101110\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n000011010\n000100000\n", "output": ["YES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0111\n0110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010010\n100100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n000110011\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n000110000\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n100010010\n", "output": ["NO\n"]}, {"input": "1\n9\n111110000\n000010010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000010\n000000000000000000000000001000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0111\n1110\n6\n010101\n101110\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n010011010\n000100000\n", "output": ["YES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1111\n0110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010010\n101100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001100010\n000110000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000010\n000000000000000000000000011000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0011\n1110\n6\n010101\n101110\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1111\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n101010010\n101100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001111010\n000110000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000000000010\n", "output": ["YES\n"]}, {"input": "4\n3\n010\n000\n4\n0011\n0100\n4\n1111\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n111010010\n101100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000000100010\n", "output": ["YES\n"]}, {"input": "4\n3\n010\n000\n4\n0011\n0100\n4\n1111\n0110\n6\n010100\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n001000010\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n010\n4\n0011\n1100\n4\n0111\n1110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n7\n000010010\n000100000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000010000000000000001010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n000111010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n100010000\n", "output": ["NO\n"]}, {"input": "1\n9\n000100011\n000000000\n", "output": ["YES\n"]}, {"input": "1\n9\n001010010\n100110010\n", "output": ["NO\n"]}, {"input": "1\n9\n011010010\n000110011\n", "output": ["NO\n"]}, {"input": "1\n9\n001110011\n000110000\n", "output": ["NO\n"]}, {"input": "1\n9\n111110000\n000010011\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0111\n1110\n6\n000101\n101110\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010110\n101100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001100011\n000110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0011\n1110\n6\n010001\n101110\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n101010000\n101100010\n", "output": ["NO\n"]}, {"input": "1\n9\n011111010\n000110000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000010000010\n", "output": ["YES\n"]}, {"input": "1\n9\n111010010\n111100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000010000000000000000000100010\n", "output": ["NO\n"]}, {"input": "4\n3\n010\n000\n4\n0001\n0100\n4\n1111\n0110\n6\n010100\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n001010010\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000010\n000000000000000000000000000000000000000000000000000000000110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000010000000000000000000010000000000000001010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n100111010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n101010000\n", "output": ["NO\n"]}, {"input": "1\n9\n000100011\n000010000\n", "output": ["YES\n"]}, {"input": "1\n9\n011010010\n000110111\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n000110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n1110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010110\n111100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001100001\n000110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n000101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n101010000\n101100110\n", "output": ["NO\n"]}, {"input": "1\n9\n011111110\n000110000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000010000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000010000010\n", "output": ["YES\n"]}, {"input": "1\n9\n111010010\n011100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n011010010\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000010\n000000000000001000000000000000000000000000000000000000000110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000010000000000000000000010000000000000001010\n000000000000000000000000000000000000000000000000000000001010\n", "output": ["NO\n"]}, {"input": "1\n9\n101010010\n100111010\n", "output": ["NO\n"]}, {"input": "1\n9\n111110010\n101010000\n", "output": ["NO\n"]}, {"input": "1\n9\n000100011\n010010000\n", "output": ["YES\n"]}, {"input": "1\n9\n001010010\n000111000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n1110\n6\n010111\n111010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010110\n101100000\n", "output": ["NO\n"]}, {"input": "1\n9\n001100001\n001110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n001101\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n8\n101010000\n101100110\n", "output": ["NO\n"]}, {"input": "1\n9\n011111110\n000110001\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000010000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000010000110\n", "output": ["YES\n"]}, {"input": "1\n9\n111010010\n001100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000010000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000010\n000000000000001000000000010000000000000000000000000000000110\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n100111010\n", "output": ["NO\n"]}, {"input": "1\n9\n111111010\n101010000\n", "output": ["NO\n"]}, {"input": "1\n9\n000100011\n010010010\n", "output": ["NO\n"]}, {"input": "1\n9\n001000010\n000111010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010110\n111100000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1010\n0110\n6\n001101\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n8\n101010000\n001100110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000010000000000010000000000000000000000000\n000000000010000000000000011000000000000000000000000010000110\n", "output": ["YES\n"]}, {"input": "1\n60\n100000000000000000000000000000000010000000000000000000000000\n000000000000010000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010110\n111000000\n", "output": ["NO\n"]}, {"input": "1\n8\n101010100\n001100110\n", "output": ["NO\n"]}, {"input": "1\n60\n100000000000000000000000000000000010000000000000100000000000\n000000000000010000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010110\n111000001\n", "output": ["NO\n"]}, {"input": "1\n8\n101010100\n001100010\n", "output": ["NO\n"]}, {"input": "1\n60\n100000000000000000000000000000000010000000000000100000000001\n000000000000010000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n8\n101010100\n001100011\n", "output": ["NO\n"]}, {"input": "1\n9\n000000000\n001000000\n", "output": ["YES\n"]}, {"input": "1\n9\n000000010\n100100000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000000000000000000000010\n000000000000010000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n1100\n4\n0111\n1110\n6\n010101\n001010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n000010010\n000100100\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000010000000000000000010\n000000000000000000100000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n1000\n4\n0111\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n001110010\n000100000\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n000111010\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n100110010\n", "output": ["NO\n"]}, {"input": "1\n9\n011110010\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110000\n100010010\n", "output": ["NO\n"]}, {"input": "1\n9\n000100000\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000001000000000000000000000000000000000000000010\n000000000000000000000000001000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n001\n000\n4\n0011\n0100\n4\n0111\n0110\n6\n010111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001110010\n000010000\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n100010011\n", "output": ["NO\n"]}, {"input": "1\n9\n111010000\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n010001010\n000100000\n", "output": ["YES\n"]}, {"input": "1\n9\n011010010\n101100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000010\n000000000000000000000000011000000010000000000000000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n0111\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n001101010\n000110000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000001000000000000000011000000000000000000000000000000010\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000100000000000000000010000000000000000000000000\n000000000000000000000000011000000000000000000000000000100010\n", "output": ["YES\n"]}, {"input": "4\n3\n010\n000\n4\n0011\n0100\n4\n1111\n0110\n6\n010110\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001000010\n100000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000010\n000000000000000000000000000000000000000000000001000000000010\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n010\n4\n0011\n1100\n4\n0111\n1110\n6\n010100\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000010000010000000001010\n000000000000000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n001100011\n000000000\n", "output": ["YES\n"]}, {"input": "1\n9\n011110011\n000110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n010111\n101000\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0000\n4\n0011\n1110\n6\n010001\n101110\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "4\n3\n000\n000\n4\n0010\n0100\n4\n1011\n0110\n6\n010101\n101010\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n7\n101010010\n101100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001111000\n000110000\n", "output": ["NO\n"]}, {"input": "1\n9\n111010110\n111100010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000001000010\n000000000000000000000000000000000000000000000000000000000110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000010000000000000000000010000000000000001010\n000000000010000000000000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n001010010\n101111010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n101000000\n", "output": ["NO\n"]}, {"input": "1\n9\n011000010\n000110111\n", "output": ["NO\n"]}, {"input": "1\n9\n001010110\n000110000\n", "output": ["NO\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n1110\n6\n110111\n101010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n6\n001010110\n111100010\n", "output": ["NO\n"]}, {"input": "1\n9\n001000011\n000110000\n", "output": ["YES\n"]}, {"input": "4\n3\n000\n000\n4\n0011\n0100\n4\n1011\n0110\n6\n000101\n101000\n", "output": ["YES\nYES\nNO\nYES\n"]}, {"input": "1\n9\n101000000\n101100110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000010000000000010000000000000000000000000\n000000001000000000000000011000000000000000000000000010000010\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000000\n000000000000000000000000011000000110000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n8\n011010010\n000000000\n", "output": ["YES\n"]}, {"input": "1\n9\n111110010\n101010001\n", "output": ["NO\n"]}, {"input": "1\n9\n001100011\n010010000\n", "output": ["YES\n"]}, {"input": "4\n3\n000\n000\n4\n0001\n0100\n4\n1011\n1110\n6\n010111\n111010\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "1\n9\n001010110\n001100000\n", "output": ["NO\n"]}, {"input": "1\n9\n001101001\n001110000\n", "output": ["NO\n"]}, {"input": "1\n8\n111010000\n101100110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000100000000000000000000000000000000000000000000011\n000000000000001000000000010000000000000000000000000000000110\n", "output": ["NO\n"]}, {"input": "1\n9\n111101010\n101010000\n", "output": ["NO\n"]}, {"input": "1\n9\n000100010\n010010010\n", "output": ["NO\n"]}, {"input": "1\n9\n001000010\n000111000\n", "output": ["YES\n"]}, {"input": "1\n8\n111010000\n001100110\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000010000000000010000000000000000000000000\n000000001010000000000000011000000000000000000000000010000110\n", "output": ["YES\n"]}, {"input": "1\n9\n001010110\n101000000\n", "output": ["NO\n"]}, {"input": "1\n8\n101010101\n001100110\n", "output": ["NO\n"]}, {"input": "1\n9\n001010111\n111000001\n", "output": ["NO\n"]}, {"input": "1\n60\n100000010000000000000000000000000010000000000000100000000001\n000000000000010000000000011000000010000000000000000000110010\n", "output": ["NO\n"]}, {"input": "1\n9\n000000010\n001000000\n", "output": ["YES\n"]}, {"input": "1\n9\n000000010\n001100000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000000000000000000000010\n000000000000010000100000000000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000000000010000000000000000010\n000000000000000000100000000000000000010000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n001111010\n000100000\n", "output": ["NO\n"]}, {"input": "1\n9\n001110010\n110110010\n", "output": ["NO\n"]}, {"input": "1\n9\n011111010\n000010010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n000110011\n", "output": ["NO\n"]}, {"input": "1\n9\n000100001\n000000000\n", "output": ["YES\n"]}, {"input": "1\n60\n000000000000000001000000000000000000000000000000010000000010\n000000000000000000000000001000000000000000000000000000000010\n", "output": ["NO\n"]}, {"input": "1\n9\n101110010\n000010011\n", "output": ["NO\n"]}, {"input": "1\n9\n011010010\n101100000\n", "output": ["NO\n"]}, {"input": "1\n60\n000000000000000000000000000000000010000000000000000000000010\n000000000000000000000000011000000010000000000000000000010010\n", "output": ["NO\n"]}], "source_codes": ["import sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1, n-1)\n    # Directions for 8-connected neighbors\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    visited = [[False]*n for _ in range(2)]\n    queue = deque()\n    queue.append((0, 0))  # Starting at (1,1) in 0-indexed is (0,0)\n    visited[0][0] = True\n    \n    while queue:\n        r, c = queue.popleft()\n        \n        # If we reached the destination\n        if (r, c) == (1, n-1):\n            return \"YES\"\n            \n        # Explore all 8 directions\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds\n            if 0 <= nr < 2 and 0 <= nc < n:\n                # Check if not visited and not a trap\n                if not visited[nr][nc] and grid[nr][nc] == '0':\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n                    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        row1 = data[index]\n        index += 1\n        row2 = data[index]\n        index += 1\n        grid = [row1, row2]\n        results.append(can_complete_level(n, grid))\n    \n    # Print results - join with newlines only\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "def is_valid(x, y, n):\n    return 1 <= x <= 2 and 1 <= y <= n\n\ndef can_complete_level(n, grid):\n    visited = [[False]*(n+1) for _ in range(3)]\n    queue = deque()\n    queue.append((1, 1))\n    visited[1][1] = True\n    \n    # 8 directions movement\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if we reached the destination\n        if x == 2 and y == n:\n            return \"YES\"\n            \n        # Explore all 8 directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds and if cell is valid\n            if is_valid(nx, ny, n) and not visited[nx][ny] and grid[nx-1][ny-1] == '0':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n                \n    return \"NO\"\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))", "def can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1, n-1)\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    \n    # 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and not visited\n                if grid[nx][ny] == '0' and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    results.append(can_complete_level(n, grid))\n\nfor result in results:\n    print(result)", "def can_complete_level(n, grid):\n    # Convert to 0-indexed for easier handling\n    start = (0, 0)\n    end = (1, n-1)\n    \n    # BFS\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    \n    # 8 directions (including diagonals)\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '0':\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n                \n    return \"NO\"\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))", "import sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed coordinates\n    start = (0, 0)\n    end = (1, n-1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False]*n for _ in range(2)]\n    visited[0][0] = True\n    \n    # 8 directions (including diagonals)\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if reached destination\n        if (x, y) == end:\n            return \"YES\"\n            \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and unvisited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    result = can_complete_level(n, grid)\n    print(result)", "def can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), target at (1, n-1)\n    start = (0, 0)\n    target = (1, n - 1)\n    \n    # Directions for 8-connected neighbors (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False]*n for _ in range(2)]\n    queue = deque()\n    queue.append(start)\n    visited[start[0]][start[1]] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == target:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and not visited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))", "import sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed coordinates\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected movement\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False] * n for _ in range(2)]\n    queue = deque([start])\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n:\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        grid = []\n        grid.append(input().strip())\n        grid.append(input().strip())\n        result = can_complete_level(n, grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1,n-1)\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected movement (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False] * n for _ in range(2)]\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if we've reached the destination\n        if (x, y) == end:\n            return \"YES\"\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if cell is safe and not visited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    \n    return \"NO\"\n\n# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))", "def can_complete_level(n, grid):\n    # Start at (0, 0), target at (1, n-1) - using 0-indexed\n    start = (0, 0)\n    target = (1, n - 1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False] * n for _ in range(2)]\n    visited[0][0] = True\n    \n    # 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if reached target\n        if (x, y) == target:\n            return \"YES\"\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and unvisited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))", "import sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-based indexing\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected neighbors\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False] * n for _ in range(2)]\n    queue = deque([start])\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n:\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        row1 = input().strip()\n        row2 = input().strip()\n        grid = [row1, row2]\n        result = can_complete_level(n, grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nfrom collections import deque\nimport sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1, n-1)\n    # Directions for 8-connected neighbors\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    visited = [[False]*n for _ in range(2)]\n    queue = deque()\n    queue.append((0, 0))  # Starting at (1,1) in 0-indexed is (0,0)\n    visited[0][0] = True\n    \n    while queue:\n        r, c = queue.popleft()\n        \n        # If we reached the destination\n        if (r, c) == (1, n-1):\n            return \"YES\"\n            \n        # Explore all 8 directions\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds\n            if 0 <= nr < 2 and 0 <= nc < n:\n                # Check if not visited and not a trap\n                if not visited[nr][nc] and grid[nr][nc] == '0':\n                    visited[nr][nc] = True\n                    queue.append((nr, nc))\n                    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        row1 = data[index]\n        index += 1\n        row2 = data[index]\n        index += 1\n        grid = [row1, row2]\n        results.append(can_complete_level(n, grid))\n    \n    # Print results - join with newlines only\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nfrom collections import deque\n\ndef is_valid(x, y, n):\n    return 1 <= x <= 2 and 1 <= y <= n\n\ndef can_complete_level(n, grid):\n    visited = [[False]*(n+1) for _ in range(3)]\n    queue = deque()\n    queue.append((1, 1))\n    visited[1][1] = True\n    \n    # 8 directions movement\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if we reached the destination\n        if x == 2 and y == n:\n            return \"YES\"\n            \n        # Explore all 8 directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds and if cell is valid\n            if is_valid(nx, ny, n) and not visited[nx][ny] and grid[nx-1][ny-1] == '0':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n                \n    return \"NO\"\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))\n\n\n", "\nfrom collections import deque\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1, n-1)\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    \n    # 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and not visited\n                if grid[nx][ny] == '0' and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    results.append(can_complete_level(n, grid))\n\nfor result in results:\n    print(result)\n\n\n", "\nfrom collections import deque\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed for easier handling\n    start = (0, 0)\n    end = (1, n-1)\n    \n    # BFS\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    \n    # 8 directions (including diagonals)\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '0':\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n                \n    return \"NO\"\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))\n\n\n", "\nfrom collections import deque\nimport sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed coordinates\n    start = (0, 0)\n    end = (1, n-1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False]*n for _ in range(2)]\n    visited[0][0] = True\n    \n    # 8 directions (including diagonals)\n    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if reached destination\n        if (x, y) == end:\n            return \"YES\"\n            \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and unvisited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    result = can_complete_level(n, grid)\n    print(result)\n\n\n", "\nfrom collections import deque\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), target at (1, n-1)\n    start = (0, 0)\n    target = (1, n - 1)\n    \n    # Directions for 8-connected neighbors (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False]*n for _ in range(2)]\n    queue = deque()\n    queue.append(start)\n    visited[start[0]][start[1]] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == target:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and not visited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\n# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))\n\n\n", "\nfrom collections import deque\nimport sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed coordinates\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected movement\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False] * n for _ in range(2)]\n    queue = deque([start])\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n:\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        grid = []\n        grid.append(input().strip())\n        grid.append(input().strip())\n        result = can_complete_level(n, grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nfrom collections import deque\n\ndef can_complete_level(n, grid):\n    # Convert to 0-indexed: start at (0,0), end at (1,n-1)\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected movement (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False] * n for _ in range(2)]\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if we've reached the destination\n        if (x, y) == end:\n            return \"YES\"\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if cell is safe and not visited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    \n    return \"NO\"\n\n# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))\n\n\n", "\nfrom collections import deque\n\ndef can_complete_level(n, grid):\n    # Start at (0, 0), target at (1, n-1) - using 0-indexed\n    start = (0, 0)\n    target = (1, n - 1)\n    \n    # BFS setup\n    queue = deque([start])\n    visited = [[False] * n for _ in range(2)]\n    visited[0][0] = True\n    \n    # 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Check if reached target\n        if (x, y) == target:\n            return \"YES\"\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check bounds\n            if 0 <= nx < 2 and 0 <= ny < n:\n                # Check if safe and unvisited\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    \n    return \"NO\"\n\n# Read input and process test cases\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    row1 = input().strip()\n    row2 = input().strip()\n    grid = [row1, row2]\n    print(can_complete_level(n, grid))\n\n\n", "\nfrom collections import deque\nimport sys\n\ndef can_complete_level(n, grid):\n    # Convert to 0-based indexing\n    start = (0, 0)\n    end = (1, n - 1)\n    \n    # Directions for 8-connected neighbors\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    visited = [[False] * n for _ in range(2)]\n    queue = deque([start])\n    visited[0][0] = True\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if (x, y) == end:\n            return \"YES\"\n            \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 2 and 0 <= ny < n:\n                if grid[nx][ny] == '0' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n                    \n    return \"NO\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        row1 = input().strip()\n        row2 = input().strip()\n        grid = [row1, row2]\n        result = can_complete_level(n, grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13966, 12665, 12486, 11863, 12963, 12601, 12073, 13058, 12353, 12531], "completion_tokens": [4616, 5532, 4680, 4557, 4379, 5300, 5066, 4611, 5110, 4350], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 1598}
{"name": "1599_A. Weights", "description": "You are given an array A of length N weights of masses A_1, A_2...A_N. No two weights have the same mass. You can put every weight on one side of the balance (left or right). You don't have to put weights in order A_1,...,A_N. There is also a string S consisting of characters \"L\" and \"R\", meaning that after putting the i-th weight (not A_i, but i-th weight of your choice) left or right side of the balance should be heavier. Find the order of putting the weights on the balance such that rules of string S are satisfied. \n\nInput\n\nThe first line contains one integer N (1 \u2264 N \u2264 2*10^5) - the length of the array A The second line contains N distinct integers: A_1, A_2,...,A_N (1 \u2264 A_i \u2264 10^9) - the weights given The third line contains string S of length N consisting only of letters \"L\" and \"R\" - string determining which side of the balance should be heavier after putting the i-th weight of your choice\n\nOutput\n\nThe output contains N lines. In every line, you should print one integer and one letter - integer representing the weight you are putting on the balance in that move and the letter representing the side of the balance where you are putting the weight. If there is no solution, print -1.\n\nExample\n\nInput\n\n\n5\n3 8 2 13 7\nLLRLL\n\n\nOutput\n\n\n3 L\n2 R\n8 R\n13 L\n7 L\n\nNote\n\nExplanation for the test case: \n\nafter the 1st weight: 3 L (left side is heavier)\n\nafter the 2nd weight: 2 R (left side is heavier)\n\nafter the 3rd weight: 8 R (right side is heavier)\n\nafter the 4th weight: 13 L (left side is heavier)\n\nafter the 5th weight: 7 L (left side is heavier)\n\nSo, the rules given by string S are fulfilled and our order of putting the weights is correct.", "tags": ["constructive algorithms", "greedy", "two pointers"], "difficulty": 7, "id": 1599, "sample_io": [{"input": "5\n3 8 2 13 7\nLLRLL\n", "output": ["7 L\n3 R\n8 R\n13 L\n2 L\n"]}], "test_list": [{"input": "5\n3 8 2 13 7\nLLRLL\n", "output": ["7 L\n3 R\n8 R\n13 L\n2 L\n"]}, {"input": "5\n3 4 2 13 7\nLLRLL\n", "output": ["4 L\n3  R\n7  R\n13 L\n2 L\n"]}, {"input": "5\n3 4 2 2 7\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n7 L\n2 L\n"]}, {"input": "5\n6 4 2 2 7\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n7 L\n2 L\n"]}, {"input": "5\n6 4 3 2 7\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n7 L\n2 L\n"]}, {"input": "5\n12 4 3 2 7\nLLRLL\n", "output": ["4 L\n3  R\n7  R\n12 L\n2 L\n"]}, {"input": "5\n3 8 2 20 7\nLLRLL\n", "output": ["7 L\n3  R\n8  R\n20 L\n2 L\n"]}, {"input": "5\n3 8 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n4 4 2 2 7\nLLRLL\n", "output": ["4 L\n2  R\n4  R\n7 L\n2 L\n"]}, {"input": "5\n3 16 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n16 L\n2 L\n"]}, {"input": "5\n3 8 2 13 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n13 L\n2 L\n"]}, {"input": "5\n6 4 1 2 7\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n7 L\n1 L\n"]}, {"input": "5\n6 4 3 2 8\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n8 L\n2 L\n"]}, {"input": "5\n3 16 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n16 L\n1 L\n"]}, {"input": "5\n6 4 3 2 9\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n9 L\n2 L\n"]}, {"input": "5\n6 4 5 2 9\nLLRLL\n", "output": ["5 L\n4  R\n6  R\n9 L\n2 L\n"]}, {"input": "5\n8 4 3 2 7\nLLRLL\n", "output": ["4 L\n3  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n3 6 2 9 7\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n9 L\n2 L\n"]}, {"input": "5\n3 23 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n23 L\n2 L\n"]}, {"input": "5\n3 11 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n4 4 3 2 9\nLLRLL\n", "output": ["4 L\n3  R\n4  R\n9 L\n2 L\n"]}, {"input": "5\n8 4 3 2 2\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n8 L\n2 L\n"]}, {"input": "5\n13 4 3 2 2\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n13 L\n2 L\n"]}, {"input": "5\n6 4 3 2 11\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n11 L\n2 L\n"]}, {"input": "5\n5 8 2 9 7\nLLRLL\n", "output": ["7 L\n5  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n3 17 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n17 L\n1 L\n"]}, {"input": "5\n6 1 5 2 9\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n9 L\n1 L\n"]}, {"input": "5\n3 23 3 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n23 L\n3 L\n"]}, {"input": "5\n13 4 6 2 2\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n13 L\n2 L\n"]}, {"input": "5\n5 8 2 15 7\nLLRLL\n", "output": ["7 L\n5  R\n8  R\n15 L\n2 L\n"]}, {"input": "5\n3 15 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n15 L\n1 L\n"]}, {"input": "5\n13 8 6 2 2\nLLRLL\n", "output": ["6 L\n2  R\n8  R\n13 L\n2 L\n"]}, {"input": "5\n5 8 2 10 7\nLLRLL\n", "output": ["7 L\n5  R\n8  R\n10 L\n2 L\n"]}, {"input": "5\n3 5 2 13 7\nLLRLL\n", "output": ["5 L\n3  R\n7  R\n13 L\n2 L\n"]}, {"input": "5\n5 4 2 2 7\nLLRLL\n", "output": ["4 L\n2  R\n5  R\n7 L\n2 L\n"]}, {"input": "5\n6 4 2 2 12\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n12 L\n2 L\n"]}, {"input": "5\n3 8 2 14 7\nLLRLL\n", "output": ["7 L\n3  R\n8  R\n14 L\n2 L\n"]}, {"input": "5\n5 16 1 9 7\nLLRLL\n", "output": ["7 L\n5  R\n9  R\n16 L\n1 L\n"]}, {"input": "5\n6 4 3 2 16\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n16 L\n2 L\n"]}, {"input": "5\n6 6 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n6  R\n9 L\n2 L\n"]}, {"input": "5\n3 5 2 9 7\nLLRLL\n", "output": ["5 L\n3  R\n7  R\n9 L\n2 L\n"]}, {"input": "5\n4 11 1 9 7\nLLRLL\n", "output": ["7 L\n4  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n4 1 3 2 9\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n9 L\n1 L\n"]}, {"input": "5\n13 4 5 2 2\nLLRLL\n", "output": ["4 L\n2  R\n5  R\n13 L\n2 L\n"]}, {"input": "5\n6 4 3 1 11\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n11 L\n1 L\n"]}, {"input": "5\n5 8 2 9 10\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n10 L\n2 L\n"]}, {"input": "5\n3 30 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n30 L\n1 L\n"]}, {"input": "5\n6 1 5 2 16\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n16 L\n1 L\n"]}, {"input": "5\n3 30 3 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n30 L\n3 L\n"]}, {"input": "5\n13 4 6 2 3\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n13 L\n2 L\n"]}, {"input": "5\n3 15 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n15 L\n2 L\n"]}, {"input": "5\n13 8 8 2 2\nLLRLL\n", "output": ["8 L\n2  R\n8  R\n13 L\n2 L\n"]}, {"input": "5\n3 8 2 6 7\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n1 4 3 2 16\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n16 L\n1 L\n"]}, {"input": "5\n6 10 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n10 L\n2 L\n"]}, {"input": "5\n6 5 2 9 7\nLLRLL\n", "output": ["6 L\n5  R\n7  R\n9 L\n2 L\n"]}, {"input": "5\n4 11 1 9 12\nLLRLL\n", "output": ["9 L\n4  R\n11  R\n12 L\n1 L\n"]}, {"input": "5\n5 8 2 9 8\nLLRLL\n", "output": ["8 L\n5  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n6 1 5 2 26\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n26 L\n1 L\n"]}, {"input": "5\n3 15 2 9 6\nLLRLL\n", "output": ["6 L\n3  R\n9  R\n15 L\n2 L\n"]}, {"input": "5\n1 4 4 2 16\nLLRLL\n", "output": ["4 L\n2  R\n4  R\n16 L\n1 L\n"]}, {"input": "5\n6 10 8 2 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n10 L\n2 L\n"]}, {"input": "5\n6 1 5 2 4\nLLRLL\n", "output": ["4 L\n2  R\n5  R\n6 L\n1 L\n"]}, {"input": "5\n6 12 8 2 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n12 L\n2 L\n"]}, {"input": "5\n1 12 8 2 9\nLLRLL\n", "output": ["8 L\n2  R\n9  R\n12 L\n1 L\n"]}, {"input": "5\n3 6 2 13 7\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n13 L\n2 L\n"]}, {"input": "5\n3 4 2 2 12\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n12 L\n2 L\n"]}, {"input": "5\n6 4 2 2 4\nLLRLL\n", "output": ["4 L\n2  R\n4  R\n6 L\n2 L\n"]}, {"input": "5\n3 8 2 19 7\nLLRLL\n", "output": ["7 L\n3  R\n8  R\n19 L\n2 L\n"]}, {"input": "5\n4 8 2 9 7\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n3 8 4 13 9\nLLRLL\n", "output": ["8 L\n4  R\n9  R\n13 L\n3 L\n"]}, {"input": "5\n6 4 3 2 2\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n6 L\n2 L\n"]}, {"input": "5\n3 16 1 7 7\nLLRLL\n", "output": ["7 L\n3  R\n7  R\n16 L\n1 L\n"]}, {"input": "5\n6 4 2 2 9\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n9 L\n2 L\n"]}, {"input": "5\n6 2 5 2 9\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n9 L\n2 L\n"]}, {"input": "5\n8 5 3 2 7\nLLRLL\n", "output": ["5 L\n3  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n3 11 1 9 8\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n8 4 6 2 2\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n8 L\n2 L\n"]}, {"input": "5\n3 4 3 2 2\nLLRLL\n", "output": ["3 L\n2  R\n3  R\n4 L\n2 L\n"]}, {"input": "5\n5 8 2 4 7\nLLRLL\n", "output": ["5 L\n4  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n3 27 1 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n27 L\n1 L\n"]}, {"input": "5\n6 1 4 2 9\nLLRLL\n", "output": ["4 L\n2  R\n6  R\n9 L\n1 L\n"]}, {"input": "5\n5 8 2 15 10\nLLRLL\n", "output": ["8 L\n5  R\n10  R\n15 L\n2 L\n"]}, {"input": "5\n13 8 6 4 2\nLLRLL\n", "output": ["6 L\n4  R\n8  R\n13 L\n2 L\n"]}, {"input": "5\n6 8 2 2 12\nLLRLL\n", "output": ["6 L\n2  R\n8  R\n12 L\n2 L\n"]}, {"input": "5\n6 7 3 2 16\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n16 L\n2 L\n"]}, {"input": "5\n6 12 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n12 L\n2 L\n"]}, {"input": "5\n4 1 3 2 6\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n6 L\n1 L\n"]}, {"input": "5\n6 4 3 1 4\nLLRLL\n", "output": ["4 L\n3  R\n4  R\n6 L\n1 L\n"]}, {"input": "5\n3 30 5 9 7\nLLRLL\n", "output": ["7 L\n5  R\n9  R\n30 L\n3 L\n"]}, {"input": "5\n3 17 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n17 L\n2 L\n"]}, {"input": "5\n6 11 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n11 L\n2 L\n"]}, {"input": "5\n4 14 1 9 12\nLLRLL\n", "output": ["9 L\n4  R\n12  R\n14 L\n1 L\n"]}, {"input": "5\n6 1 5 2 45\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n45 L\n1 L\n"]}, {"input": "5\n6 16 8 2 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n16 L\n2 L\n"]}, {"input": "5\n6 12 8 3 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n12 L\n3 L\n"]}, {"input": "5\n3 14 2 4 7\nLLRLL\n", "output": ["4 L\n3  R\n7  R\n14 L\n2 L\n"]}, {"input": "5\n6 4 1 2 4\nLLRLL\n", "output": ["4 L\n2  R\n4  R\n6 L\n1 L\n"]}, {"input": "5\n4 8 2 6 7\nLLRLL\n", "output": ["6 L\n4  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n5 8 4 13 9\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n13 L\n4 L\n"]}, {"input": "5\n8 5 3 2 1\nLLRLL\n", "output": ["3 L\n2  R\n5  R\n8 L\n1 L\n"]}, {"input": "5\n5 11 1 9 8\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n10 8 2 4 7\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n10 L\n2 L\n"]}, {"input": "5\n6 1 8 2 9\nLLRLL\n", "output": ["6 L\n2  R\n8  R\n9 L\n1 L\n"]}, {"input": "5\n5 8 2 15 8\nLLRLL\n", "output": ["8 L\n5  R\n8  R\n15 L\n2 L\n"]}, {"input": "5\n6 8 2 4 12\nLLRLL\n", "output": ["6 L\n4  R\n8  R\n12 L\n2 L\n"]}, {"input": "5\n6 12 5 4 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n12 L\n4 L\n"]}, {"input": "5\n6 4 3 1 7\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n7 L\n1 L\n"]}, {"input": "5\n3 30 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n30 L\n2 L\n"]}, {"input": "5\n3 21 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n9  R\n21 L\n2 L\n"]}, {"input": "5\n5 16 8 2 9\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n16 L\n2 L\n"]}, {"input": "5\n6 19 8 3 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n19 L\n3 L\n"]}, {"input": "5\n3 1 2 4 7\nLLRLL\n", "output": ["3 L\n2  R\n4  R\n7 L\n1 L\n"]}, {"input": "5\n5 4 2 2 4\nLLRLL\n", "output": ["4 L\n2  R\n4  R\n5 L\n2 L\n"]}, {"input": "5\n4 8 1 6 7\nLLRLL\n", "output": ["6 L\n4  R\n7  R\n8 L\n1 L\n"]}, {"input": "5\n5 8 4 16 9\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n16 L\n4 L\n"]}, {"input": "5\n5 11 1 9 6\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n6 1 8 2 10\nLLRLL\n", "output": ["6 L\n2  R\n8  R\n10 L\n1 L\n"]}, {"input": "5\n7 8 2 4 12\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n12 L\n2 L\n"]}, {"input": "5\n6 13 5 4 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n13 L\n4 L\n"]}, {"input": "5\n3 7 2 9 7\nLLRLL\n", "output": ["7 L\n3  R\n7  R\n9 L\n2 L\n"]}, {"input": "5\n5 21 2 9 7\nLLRLL\n", "output": ["7 L\n5  R\n9  R\n21 L\n2 L\n"]}, {"input": "5\n5 16 8 2 13\nLLRLL\n", "output": ["8 L\n5  R\n13  R\n16 L\n2 L\n"]}, {"input": "5\n4 19 8 3 9\nLLRLL\n", "output": ["8 L\n4  R\n9  R\n19 L\n3 L\n"]}, {"input": "5\n4 8 2 7 7\nLLRLL\n", "output": ["7 L\n4  R\n7  R\n8 L\n2 L\n"]}, {"input": "5\n6 8 4 16 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n16 L\n4 L\n"]}, {"input": "5\n5 11 1 18 6\nLLRLL\n", "output": ["6 L\n5  R\n11  R\n18 L\n1 L\n"]}, {"input": "5\n6 1 8 3 10\nLLRLL\n", "output": ["6 L\n3  R\n8  R\n10 L\n1 L\n"]}, {"input": "5\n6 16 5 4 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n16 L\n4 L\n"]}, {"input": "5\n3 7 2 10 7\nLLRLL\n", "output": ["7 L\n3  R\n7  R\n10 L\n2 L\n"]}, {"input": "5\n5 21 2 9 12\nLLRLL\n", "output": ["9 L\n5  R\n12  R\n21 L\n2 L\n"]}, {"input": "5\n2 19 8 3 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n19 L\n2 L\n"]}, {"input": "5\n4 8 2 13 7\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n13 L\n2 L\n"]}, {"input": "5\n5 2 4 16 9\nLLRLL\n", "output": ["5 L\n4  R\n9  R\n16 L\n2 L\n"]}, {"input": "5\n6 1 8 3 16\nLLRLL\n", "output": ["6 L\n3  R\n8  R\n16 L\n1 L\n"]}, {"input": "5\n5 21 3 9 12\nLLRLL\n", "output": ["9 L\n5  R\n12  R\n21 L\n3 L\n"]}, {"input": "5\n2 10 8 3 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n10 L\n2 L\n"]}, {"input": "5\n4 8 2 19 7\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n19 L\n2 L\n"]}, {"input": "5\n5 21 3 9 9\nLLRLL\n", "output": ["9 L\n5  R\n9  R\n21 L\n3 L\n"]}, {"input": "5\n3 8 2 34 7\nLLRLL\n", "output": ["7 L\n3  R\n8  R\n34 L\n2 L\n"]}, {"input": "5\n3 8 1 13 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n13 L\n1 L\n"]}, {"input": "5\n3 23 2 4 7\nLLRLL\n", "output": ["4 L\n3  R\n7  R\n23 L\n2 L\n"]}, {"input": "5\n3 11 1 9 9\nLLRLL\n", "output": ["9 L\n3  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n4 4 3 2 6\nLLRLL\n", "output": ["4 L\n3  R\n4  R\n6 L\n2 L\n"]}, {"input": "5\n6 7 3 2 11\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n11 L\n2 L\n"]}, {"input": "5\n5 8 2 9 13\nLLRLL\n", "output": ["8 L\n5  R\n9  R\n13 L\n2 L\n"]}, {"input": "5\n6 1 5 1 9\nLLRLL\n", "output": ["5 L\n1  R\n6  R\n9 L\n1 L\n"]}, {"input": "5\n3 6 3 4 7\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n7 L\n3 L\n"]}, {"input": "5\n4 23 3 9 7\nLLRLL\n", "output": ["7 L\n4  R\n9  R\n23 L\n3 L\n"]}, {"input": "5\n3 15 1 9 10\nLLRLL\n", "output": ["9 L\n3  R\n10  R\n15 L\n1 L\n"]}, {"input": "5\n5 8 2 10 13\nLLRLL\n", "output": ["8 L\n5  R\n10  R\n13 L\n2 L\n"]}, {"input": "5\n3 5 2 13 4\nLLRLL\n", "output": ["4 L\n3  R\n5  R\n13 L\n2 L\n"]}, {"input": "5\n2 16 1 9 7\nLLRLL\n", "output": ["7 L\n2  R\n9  R\n16 L\n1 L\n"]}, {"input": "5\n8 6 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n4 11 1 6 7\nLLRLL\n", "output": ["6 L\n4  R\n7  R\n11 L\n1 L\n"]}, {"input": "5\n13 4 3 4 2\nLLRLL\n", "output": ["4 L\n3  R\n4  R\n13 L\n2 L\n"]}, {"input": "5\n5 16 2 9 10\nLLRLL\n", "output": ["9 L\n5  R\n10  R\n16 L\n2 L\n"]}, {"input": "5\n3 30 3 9 8\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n30 L\n3 L\n"]}, {"input": "5\n18 4 6 2 3\nLLRLL\n", "output": ["4 L\n3  R\n6  R\n18 L\n2 L\n"]}, {"input": "5\n13 7 8 2 2\nLLRLL\n", "output": ["7 L\n2  R\n8  R\n13 L\n2 L\n"]}, {"input": "5\n6 10 5 1 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n10 L\n1 L\n"]}, {"input": "5\n6 5 3 9 7\nLLRLL\n", "output": ["6 L\n5  R\n7  R\n9 L\n3 L\n"]}, {"input": "5\n4 11 1 9 23\nLLRLL\n", "output": ["9 L\n4  R\n11  R\n23 L\n1 L\n"]}, {"input": "5\n6 1 5 4 26\nLLRLL\n", "output": ["5 L\n4  R\n6  R\n26 L\n1 L\n"]}, {"input": "5\n3 30 2 9 6\nLLRLL\n", "output": ["6 L\n3  R\n9  R\n30 L\n2 L\n"]}, {"input": "5\n6 3 2 9 10\nLLRLL\n", "output": ["6 L\n3  R\n9  R\n10 L\n2 L\n"]}, {"input": "5\n6 2 5 2 4\nLLRLL\n", "output": ["4 L\n2  R\n5  R\n6 L\n2 L\n"]}, {"input": "5\n1 12 8 4 9\nLLRLL\n", "output": ["8 L\n4  R\n9  R\n12 L\n1 L\n"]}, {"input": "5\n1 6 2 13 7\nLLRLL\n", "output": ["6 L\n2  R\n7  R\n13 L\n1 L\n"]}, {"input": "5\n3 8 4 19 7\nLLRLL\n", "output": ["7 L\n4  R\n8  R\n19 L\n3 L\n"]}, {"input": "5\n3 14 4 13 9\nLLRLL\n", "output": ["9 L\n4  R\n13  R\n14 L\n3 L\n"]}, {"input": "5\n6 4 8 2 9\nLLRLL\n", "output": ["6 L\n4  R\n8  R\n9 L\n2 L\n"]}, {"input": "5\n2 11 1 9 8\nLLRLL\n", "output": ["8 L\n2  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n5 8 1 4 7\nLLRLL\n", "output": ["5 L\n4  R\n7  R\n8 L\n1 L\n"]}, {"input": "5\n5 8 2 28 10\nLLRLL\n", "output": ["8 L\n5  R\n10  R\n28 L\n2 L\n"]}, {"input": "5\n2 8 2 7 14\nLLRLL\n", "output": ["7 L\n2  R\n8  R\n14 L\n2 L\n"]}, {"input": "5\n6 7 3 2 28\nLLRLL\n", "output": ["6 L\n3  R\n7  R\n28 L\n2 L\n"]}, {"input": "5\n6 23 5 2 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n23 L\n2 L\n"]}, {"input": "5\n6 11 5 4 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n11 L\n4 L\n"]}, {"input": "5\n6 12 8 4 9\nLLRLL\n", "output": ["8 L\n6  R\n9  R\n12 L\n4 L\n"]}, {"input": "5\n5 14 2 4 7\nLLRLL\n", "output": ["5 L\n4  R\n7  R\n14 L\n2 L\n"]}, {"input": "5\n5 8 4 13 4\nLLRLL\n", "output": ["5 L\n4  R\n8  R\n13 L\n4 L\n"]}, {"input": "5\n8 5 6 2 1\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n8 L\n1 L\n"]}, {"input": "5\n5 11 1 9 16\nLLRLL\n", "output": ["9 L\n5  R\n11  R\n16 L\n1 L\n"]}, {"input": "5\n10 8 2 6 7\nLLRLL\n", "output": ["7 L\n6  R\n8  R\n10 L\n2 L\n"]}, {"input": "5\n8 1 8 2 9\nLLRLL\n", "output": ["8 L\n2  R\n8  R\n9 L\n1 L\n"]}, {"input": "5\n6 18 5 4 9\nLLRLL\n", "output": ["6 L\n5  R\n9  R\n18 L\n4 L\n"]}, {"input": "5\n4 16 8 2 9\nLLRLL\n", "output": ["8 L\n4  R\n9  R\n16 L\n2 L\n"]}, {"input": "5\n6 19 12 3 9\nLLRLL\n", "output": ["9 L\n6  R\n12  R\n19 L\n3 L\n"]}, {"input": "5\n5 8 4 16 10\nLLRLL\n", "output": ["8 L\n5  R\n10  R\n16 L\n4 L\n"]}, {"input": "5\n9 11 1 9 6\nLLRLL\n", "output": ["9 L\n6  R\n9  R\n11 L\n1 L\n"]}, {"input": "5\n6 1 8 2 12\nLLRLL\n", "output": ["6 L\n2  R\n8  R\n12 L\n1 L\n"]}, {"input": "5\n7 8 2 8 12\nLLRLL\n", "output": ["8 L\n7  R\n8  R\n12 L\n2 L\n"]}, {"input": "5\n5 2 1 18 6\nLLRLL\n", "output": ["5 L\n2  R\n6  R\n18 L\n1 L\n"]}, {"input": "5\n5 1 8 3 10\nLLRLL\n", "output": ["5 L\n3  R\n8  R\n10 L\n1 L\n"]}, {"input": "5\n12 16 5 4 9\nLLRLL\n", "output": ["9 L\n5  R\n12  R\n16 L\n4 L\n"]}, {"input": "5\n3 19 8 3 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n19 L\n3 L\n"]}, {"input": "5\n5 4 4 16 9\nLLRLL\n", "output": ["5 L\n4  R\n9  R\n16 L\n4 L\n"]}, {"input": "5\n5 38 3 9 12\nLLRLL\n", "output": ["9 L\n5  R\n12  R\n38 L\n3 L\n"]}, {"input": "5\n3 10 8 3 9\nLLRLL\n", "output": ["8 L\n3  R\n9  R\n10 L\n3 L\n"]}, {"input": "5\n1 8 2 19 7\nLLRLL\n", "output": ["7 L\n2  R\n8  R\n19 L\n1 L\n"]}], "source_codes": ["import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort the weights\n    A.sort()\n    left_idx = 0\n    right_idx = N - 1\n    \n    result = [None] * N\n    \n    # Process from right to left (last constraint is most important)\n    for i in range(N-1, -1, -1):\n        char = S[i]\n        \n        if char == 'L':\n            # We want left side to be heavier at this point\n            # Place the heaviest available weight on the left\n            result[i] = (A[right_idx], 'L')\n            right_idx -= 1\n        else:  # char == 'R'\n            # We want right side to be heavier at this point\n            # Place the heaviest available weight on the right\n            result[i] = (A[right_idx], 'R')\n            right_idx -= 1\n    \n    # Verify the solution\n    left_sum = 0\n    right_sum = 0\n    valid = True\n    \n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            left_sum += weight\n        else:\n            right_sum += weight\n            \n        if S[i] == 'L' and left_sum <= right_sum:\n            valid = False\n            break\n        elif S[i] == 'R' and right_sum <= left_sum:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n        return\n        \n    # Output the result\n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights to enable greedy selection\n    weights = sorted(A)\n    result = []\n    \n    # Two pointers for available weights\n    left_ptr = 0\n    right_ptr = N - 1\n    \n    # Current balance: positive means left heavier, negative means right heavier\n    balance = 0\n    \n    # Process each requirement\n    for i in range(N):\n        if S[i] == 'L':\n            # Need left side to be heavier (balance > 0)\n            if balance <= 0:\n                # Currently right side is heavier or equal, need significant weight on left\n                weight = weights[right_ptr]\n                right_ptr -= 1\n                balance += weight\n                result.append((weight, 'L'))\n            else:\n                # Left is already heavier, we can add small weight to left to preserve big weights\n                weight = weights[left_ptr]\n                left_ptr += 1\n                balance += weight\n                result.append((weight, 'L'))\n        else:  # S[i] == 'R'\n            # Need right side to be heavier (balance < 0)\n            if balance >= 0:\n                # Currently left side is heavier or equal, need significant weight on right\n                weight = weights[right_ptr]\n                right_ptr -= 1\n                balance -= weight\n                result.append((weight, 'R'))\n            else:\n                # Right is already heavier, we can add small weight to right to preserve big weights\n                weight = weights[left_ptr]\n                left_ptr += 1\n                balance -= weight\n                result.append((weight, 'R'))\n    \n    # Output results\n    for val, side in result:\n        print(val, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights\n    A.sort()\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Current difference (L_weight - R_weight)\n    diff = 0\n    result = []\n    \n    for ch in S:\n        if ch == 'L':\n            # We want left side to be heavier (diff > 0)\n            # Place the heaviest available weight on left\n            weight = A[right_idx]\n            right_idx -= 1\n            diff += weight\n            result.append((weight, 'L'))\n        else:\n            # ch == 'R', we want right side to be heavier (diff < 0)\n            # Place the heaviest available weight on right\n            weight = A[right_idx]\n            right_idx -= 1\n            diff -= weight\n            result.append((weight, 'R'))\n    \n    # Verify the solution\n    valid = True\n    temp_diff = 0\n    for i in range(len(S)):\n        weight, side = result[i]\n        if side == 'L':\n            temp_diff += weight\n        else:\n            temp_diff -= weight\n            \n        if (S[i] == 'L' and temp_diff <= 0) or (S[i] == 'R' and temp_diff >= 0):\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n        return\n        \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Create a list of (weight, original_index) and sort by weight\n    weights = sorted([(A[i], i+1) for i in range(N)])\n    \n    # Two pointers\n    left = 0   # points to smallest available weight\n    right = N-1  # points to largest available weight\n    used = [False] * N  # to mark which weights are used\n    \n    balance = 0  # difference (left_weight - right_weight)\n    result = []\n    \n    for ch in S:\n        chosen = -1\n        side = ''\n        \n        if ch == 'L':\n            # We want left side to be heavier (balance > 0)\n            # Try from heaviest to lightest\n            # First try putting the heaviest available weight on the left\n            if not used[right]:\n                new_balance = balance + weights[right][0]\n                if new_balance > 0:\n                    chosen = right\n                    side = 'L'\n            \n            # If that doesn't work, try putting the lightest on the left\n            if chosen == -1 and not used[left]:\n                new_balance = balance + weights[left][0]\n                if new_balance > 0:\n                    chosen = left\n                    side = 'L'\n            \n            # If still doesn't work, try putting the heaviest on the right \n            # (this makes it harder for left to be heavier, but might be necessary)\n            if chosen == -1 and not used[right]:\n                chosen = right\n                side = 'R'\n            \n            # Finally try putting the lightest on the right\n            if chosen == -1 and not used[left]:\n                chosen = left\n                side = 'R'\n                \n        else:  # ch == 'R'\n            # We want right side to be heavier (balance < 0)\n            # Try from heaviest to lightest\n            # First try putting the heaviest available weight on the right\n            if not used[right]:\n                new_balance = balance - weights[right][0]\n                if new_balance < 0:\n                    chosen = right\n                    side = 'R'\n            \n            # If that doesn't work, try putting the lightest on the right\n            if chosen == -1 and not used[left]:\n                new_balance = balance - weights[left][0]\n                if new_balance < 0:\n                    chosen = left\n                    side = 'R'\n            \n            # If still doesn't work, try putting the heaviest on the left\n            if chosen == -1 and not used[right]:\n                chosen = right\n                side = 'L'\n            \n            # Finally try putting the lightest on the left\n            if chosen == -1 and not used[left]:\n                chosen = left\n                side = 'L'\n        \n        # If no valid choice found\n        if chosen == -1 or used[chosen]:\n            print(-1)\n            return\n        \n        # Apply the chosen move\n        if side == 'L':\n            balance += weights[chosen][0]\n        else:\n            balance -= weights[chosen][0]\n            \n        used[chosen] = True\n        result.append((weights[chosen][1], side))  # original index, side\n        \n        # Move pointers to next unused\n        while left < N and used[left]:\n            left += 1\n        while right >= 0 and used[right]:\n            right -= 1\n    \n    # Output the result\n    for idx, s in result:\n        print(idx, s)\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights\n    A.sort()\n    \n    # Two pointers\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Result storage\n    result = []\n    \n    # Current difference (left_sum - right_sum)\n    current_diff = 0\n    \n    # Process each character in S\n    for i in range(N):\n        target = S[i]\n        \n        if target == 'L':\n            # Want left side to be heavier (current_diff > 0)\n            # Try placing the largest weight on the left to maximize the chance of making it heavier\n            if right_idx >= left_idx:\n                weight = A[right_idx]\n                right_idx -= 1\n                result.append((weight, 'L'))\n                current_diff += weight\n            else:\n                # Fallback - place smallest on left\n                weight = A[left_idx]\n                left_idx += 1\n                result.append((weight, 'L'))\n                current_diff += weight\n        else:\n            # target == 'R', want right side to be heavier (current_diff < 0)\n            # Try placing the largest weight on the right to maximize the chance of making it heavier\n            if right_idx >= left_idx:\n                weight = A[right_idx]\n                right_idx -= 1\n                result.append((weight, 'R'))\n                current_diff -= weight\n            else:\n                # Fallback - place smallest on right\n                weight = A[left_idx]\n                left_idx += 1\n                result.append((weight, 'R'))\n                current_diff -= weight\n    \n    # Validate solution\n    temp_diff = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            temp_diff += weight\n        else:\n            temp_diff -= weight\n            \n        if S[i] == 'L' and temp_diff <= 0:\n            valid = False\n            break\n        elif S[i] == 'R' and temp_diff >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        # Try alternative approach - always use extreme elements\n        result = []\n        A_sorted = sorted(A)\n        left_idx = 0\n        right_idx = N - 1\n        current_diff = 0\n        \n        for i in range(N):\n            target = S[i]\n            \n            if target == 'L':\n                # Want left heavier\n                if current_diff <= 0:\n                    # Need significant change - use largest weight on left\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'L'))\n                    current_diff += weight\n                else:\n                    # Already left heavy, but place optimally\n                    # Use the largest remaining to maintain maximum flexibility\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'L'))\n                    current_diff += weight\n            else:\n                # Want right heavier\n                if current_diff >= 0:\n                    # Need significant change - use largest weight on right\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'R'))\n                    current_diff -= weight\n                else:\n                    # Already right heavy, but place optimally\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'R'))\n                    current_diff -= weight\n        \n        # Validate again\n        temp_diff = 0\n        valid = True\n        for i in range(N):\n            weight, side = result[i]\n            if side == 'L':\n                temp_diff += weight\n            else:\n                temp_diff -= weight\n                \n            if S[i] == 'L' and temp_diff <= 0:\n                valid = False\n                break\n            elif S[i] == 'R' and temp_diff >= 0:\n                valid = False\n                break\n        \n        if not valid:\n            print(-1)\n            return\n    \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights and keep track of them in a deque\n    weights = sorted(A)\n    dq = deque(weights)\n    \n    result = []\n    left_sum = 0\n    right_sum = 0\n    \n    for i in range(N):\n        direction = S[i]\n        diff = left_sum - right_sum  # positive means left heavier\n        \n        if direction == 'L':  # Need left side heavier (diff > 0)\n            # Try placing the largest weight on left\n            if dq and (diff + dq[-1]) > 0:\n                weight = dq.pop()\n                result.append((weight, 'L'))\n                left_sum += weight\n            # Try placing the smallest weight on right\n            elif dq and (diff - dq[0]) > 0:\n                weight = dq.popleft()\n                result.append((weight, 'R'))\n                right_sum += weight\n            else:\n                # Special case: if both sides are equal and we need left heavier,\n                # we must place something on left\n                if dq and diff == 0:\n                    weight = dq.pop()  # Take the largest\n                    result.append((weight, 'L'))\n                    left_sum += weight\n                else:\n                    print(-1)\n                    return\n        else:  # direction == 'R', need right side heavier (diff < 0)\n            # Try placing the largest weight on right\n            if dq and (diff - dq[-1]) < 0:\n                weight = dq.pop()\n                result.append((weight, 'R'))\n                right_sum += weight\n            # Try placing the smallest weight on left\n            elif dq and (diff + dq[0]) < 0:\n                weight = dq.popleft()\n                result.append((weight, 'L'))\n                left_sum += weight\n            else:\n                # Special case: if both sides are equal and we need right heavier,\n                # we must place something on right\n                if dq and diff == 0:\n                    weight = dq.pop()  # Take the largest\n                    result.append((weight, 'R'))\n                    right_sum += weight\n                else:\n                    print(-1)\n                    return\n    \n    # Output result\n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights for greedy selection\n    sorted_weights = sorted(A)\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Track cumulative weights on each side\n    left_sum = 0\n    right_sum = 0\n    \n    result = []\n    \n    for i in range(N):\n        ch = S[i]\n        if ch == 'L':\n            # We want left side to be heavier after this move\n            if left_sum >= right_sum:\n                # Left is already heavier or equal, put smallest weight on left to maintain minimal advantage\n                w = sorted_weights[left_idx]\n                left_idx += 1\n                result.append((w, 'L'))\n                left_sum += w\n            else:\n                # Left is lighter, we need to make it heavier - put largest weight on left\n                w = sorted_weights[right_idx]\n                right_idx -= 1\n                result.append((w, 'L'))\n                left_sum += w\n        else:  # ch == 'R'\n            # We want right side to be heavier after this move\n            if right_sum >= left_sum:\n                # Right is already heavier or equal, put smallest weight on right to maintain minimal advantage\n                w = sorted_weights[left_idx]\n                left_idx += 1\n                result.append((w, 'R'))\n                right_sum += w\n            else:\n                # Right is lighter, we need to make it heavier - put largest weight on right\n                w = sorted_weights[right_idx]\n                right_idx -= 1\n                result.append((w, 'R'))\n                right_sum += w\n    \n    for w, side in result:\n        print(w, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights and use deque for efficient popping from both ends\n    weights = deque(sorted(A))\n    balance = 0  # left_sum - right_sum\n    result = []\n    \n    for i in range(N):\n        char = S[i]\n        \n        if char == 'L':  # Need left side to be heavier (balance > 0)\n            # Try using the largest available weight on the left\n            if weights:\n                weight = weights.pop()  # Take the largest\n                new_balance = balance + weight\n                if new_balance > 0:\n                    result.append((weight, 'L'))\n                    balance = new_balance\n                else:\n                    # If even the largest doesn't work, try the smallest on left as last resort\n                    if weights:\n                        weights.append(weight)  # Put back the large weight\n                        weight = weights.popleft()  # Take the smallest\n                        result.append((weight, 'L'))\n                        balance = balance + weight\n                    else:\n                        # Only the large weight is left, use it anyway\n                        result.append((weight, 'L'))\n                        balance = new_balance\n            else:\n                # This shouldn't happen\n                pass\n        else:  # Need right side to be heavier (balance < 0)\n            # Try using the largest available weight on the right\n            if weights:\n                weight = weights.pop()  # Take the largest\n                new_balance = balance - weight\n                if new_balance < 0:\n                    result.append((weight, 'R'))\n                    balance = new_balance\n                else:\n                    # If even the largest doesn't work, try the smallest on right as last resort\n                    if weights:\n                        weights.append(weight)  # Put back the large weight\n                        weight = weights.popleft()  # Take the smallest\n                        result.append((weight, 'R'))\n                        balance = balance - weight\n                    else:\n                        # Only the large weight is left, use it anyway\n                        result.append((weight, 'R'))\n                        balance = new_balance\n            else:\n                # This shouldn't happen\n                pass\n    \n    # Verify the solution\n    current_balance = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            current_balance += weight\n        else:\n            current_balance -= weight\n        \n        # Check if the requirement is met\n        required = S[i]\n        if required == 'L' and current_balance <= 0:\n            valid = False\n            break\n        elif required == 'R' and current_balance >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n    else:\n        for weight, side in result:\n            print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights in descending order\n    weights = sorted(A, reverse=True)\n    weights_deque = deque(weights)\n    \n    left_sum = 0\n    right_sum = 0\n    result = []\n    \n    for char in S:\n        if not weights_deque:\n            print(-1)\n            return\n            \n        if char == 'L':\n            # We want left side to be heavier\n            if left_sum >= right_sum:\n                # Left is already heavier or equal, add a heavy weight to left to maintain advantage\n                weight = weights_deque.popleft()\n                left_sum += weight\n                result.append((weight, 'L'))\n            else:\n                # Right is heavier, we need to add enough weight to left to make it heavier\n                # Use the heaviest available weight on left\n                weight = weights_deque.popleft()\n                left_sum += weight\n                result.append((weight, 'L'))\n                # Check if we succeeded\n                if left_sum <= right_sum:\n                    print(-1)\n                    return\n        else:  # char == 'R'\n            # We want right side to be heavier\n            if right_sum >= left_sum:\n                # Right is already heavier or equal, add a heavy weight to right to maintain advantage\n                weight = weights_deque.popleft()\n                right_sum += weight\n                result.append((weight, 'R'))\n            else:\n                # Left is heavier, we need to add enough weight to right to make it heavier\n                # Use the heaviest available weight on right\n                weight = weights_deque.popleft()\n                right_sum += weight\n                result.append((weight, 'R'))\n                # Check if we succeeded\n                if right_sum <= left_sum:\n                    print(-1)\n                    return\n    \n    # Verify all constraints are met\n    left_sum = 0\n    right_sum = 0\n    for i, (weight, side) in enumerate(result):\n        if side == 'L':\n            left_sum += weight\n        else:\n            right_sum += weight\n        \n        if S[i] == 'L' and left_sum <= right_sum:\n            print(-1)\n            return\n        elif S[i] == 'R' and right_sum <= left_sum:\n            print(-1)\n            return\n    \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights for greedy selection\n    sorted_weights = sorted(A)\n    \n    # Pointers for lightest and heaviest available weights\n    left_ptr = 0\n    right_ptr = N - 1\n    \n    # Track current balance: positive = left heavier, negative = right heavier\n    balance = 0\n    \n    result = []\n    \n    # Process each requirement in S\n    for i in range(N):\n        if S[i] == 'L':\n            # Need left side to be heavier after this move\n            if balance > 0:\n                # Left already heavier, add heaviest to left to maintain advantage\n                weight = sorted_weights[right_ptr]\n                right_ptr -= 1\n                result.append((weight, 'L'))\n                balance += weight\n            else:\n                # Left not heavier, need to make it heavier\n                # Try the heaviest weight on left\n                weight = sorted_weights[right_ptr]\n                new_balance = balance + weight\n                if new_balance > 0:\n                    right_ptr -= 1\n                    result.append((weight, 'L'))\n                    balance = new_balance\n                else:\n                    # Even heaviest isn't enough, try lightest on right to reduce deficit\n                    weight = sorted_weights[left_ptr]\n                    left_ptr += 1\n                    result.append((weight, 'R'))\n                    balance -= weight\n        else:\n            # Need right side to be heavier after this move\n            if balance < 0:\n                # Right already heavier, add heaviest to right to maintain advantage\n                weight = sorted_weights[right_ptr]\n                right_ptr -= 1\n                result.append((weight, 'R'))\n                balance -= weight\n            else:\n                # Right not heavier, need to make it heavier\n                # Try the heaviest weight on right\n                weight = sorted_weights[right_ptr]\n                new_balance = balance - weight\n                if new_balance < 0:\n                    right_ptr -= 1\n                    result.append((weight, 'R'))\n                    balance = new_balance\n                else:\n                    # Even heaviest isn't enough, try lightest on left to reduce surplus\n                    weight = sorted_weights[left_ptr]\n                    left_ptr += 1\n                    result.append((weight, 'L'))\n                    balance += weight\n    \n    # Verify the solution\n    temp_balance = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            temp_balance += weight\n        else:\n            temp_balance -= weight\n        \n        # Check if requirement is met\n        if S[i] == 'L' and temp_balance <= 0:\n            valid = False\n            break\n        if S[i] == 'R' and temp_balance >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n    else:\n        for weight, side in result:\n            print(weight, side)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort the weights\n    A.sort()\n    left_idx = 0\n    right_idx = N - 1\n    \n    result = [None] * N\n    \n    # Process from right to left (last constraint is most important)\n    for i in range(N-1, -1, -1):\n        char = S[i]\n        \n        if char == 'L':\n            # We want left side to be heavier at this point\n            # Place the heaviest available weight on the left\n            result[i] = (A[right_idx], 'L')\n            right_idx -= 1\n        else:  # char == 'R'\n            # We want right side to be heavier at this point\n            # Place the heaviest available weight on the right\n            result[i] = (A[right_idx], 'R')\n            right_idx -= 1\n    \n    # Verify the solution\n    left_sum = 0\n    right_sum = 0\n    valid = True\n    \n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            left_sum += weight\n        else:\n            right_sum += weight\n            \n        if S[i] == 'L' and left_sum <= right_sum:\n            valid = False\n            break\n        elif S[i] == 'R' and right_sum <= left_sum:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n        return\n        \n    # Output the result\n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights to enable greedy selection\n    weights = sorted(A)\n    result = []\n    \n    # Two pointers for available weights\n    left_ptr = 0\n    right_ptr = N - 1\n    \n    # Current balance: positive means left heavier, negative means right heavier\n    balance = 0\n    \n    # Process each requirement\n    for i in range(N):\n        if S[i] == 'L':\n            # Need left side to be heavier (balance > 0)\n            if balance <= 0:\n                # Currently right side is heavier or equal, need significant weight on left\n                weight = weights[right_ptr]\n                right_ptr -= 1\n                balance += weight\n                result.append((weight, 'L'))\n            else:\n                # Left is already heavier, we can add small weight to left to preserve big weights\n                weight = weights[left_ptr]\n                left_ptr += 1\n                balance += weight\n                result.append((weight, 'L'))\n        else:  # S[i] == 'R'\n            # Need right side to be heavier (balance < 0)\n            if balance >= 0:\n                # Currently left side is heavier or equal, need significant weight on right\n                weight = weights[right_ptr]\n                right_ptr -= 1\n                balance -= weight\n                result.append((weight, 'R'))\n            else:\n                # Right is already heavier, we can add small weight to right to preserve big weights\n                weight = weights[left_ptr]\n                left_ptr += 1\n                balance -= weight\n                result.append((weight, 'R'))\n    \n    # Output results\n    for val, side in result:\n        print(val, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights\n    A.sort()\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Current difference (L_weight - R_weight)\n    diff = 0\n    result = []\n    \n    for ch in S:\n        if ch == 'L':\n            # We want left side to be heavier (diff > 0)\n            # Place the heaviest available weight on left\n            weight = A[right_idx]\n            right_idx -= 1\n            diff += weight\n            result.append((weight, 'L'))\n        else:\n            # ch == 'R', we want right side to be heavier (diff < 0)\n            # Place the heaviest available weight on right\n            weight = A[right_idx]\n            right_idx -= 1\n            diff -= weight\n            result.append((weight, 'R'))\n    \n    # Verify the solution\n    valid = True\n    temp_diff = 0\n    for i in range(len(S)):\n        weight, side = result[i]\n        if side == 'L':\n            temp_diff += weight\n        else:\n            temp_diff -= weight\n            \n        if (S[i] == 'L' and temp_diff <= 0) or (S[i] == 'R' and temp_diff >= 0):\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n        return\n        \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Create a list of (weight, original_index) and sort by weight\n    weights = sorted([(A[i], i+1) for i in range(N)])\n    \n    # Two pointers\n    left = 0   # points to smallest available weight\n    right = N-1  # points to largest available weight\n    used = [False] * N  # to mark which weights are used\n    \n    balance = 0  # difference (left_weight - right_weight)\n    result = []\n    \n    for ch in S:\n        chosen = -1\n        side = ''\n        \n        if ch == 'L':\n            # We want left side to be heavier (balance > 0)\n            # Try from heaviest to lightest\n            # First try putting the heaviest available weight on the left\n            if not used[right]:\n                new_balance = balance + weights[right][0]\n                if new_balance > 0:\n                    chosen = right\n                    side = 'L'\n            \n            # If that doesn't work, try putting the lightest on the left\n            if chosen == -1 and not used[left]:\n                new_balance = balance + weights[left][0]\n                if new_balance > 0:\n                    chosen = left\n                    side = 'L'\n            \n            # If still doesn't work, try putting the heaviest on the right \n            # (this makes it harder for left to be heavier, but might be necessary)\n            if chosen == -1 and not used[right]:\n                chosen = right\n                side = 'R'\n            \n            # Finally try putting the lightest on the right\n            if chosen == -1 and not used[left]:\n                chosen = left\n                side = 'R'\n                \n        else:  # ch == 'R'\n            # We want right side to be heavier (balance < 0)\n            # Try from heaviest to lightest\n            # First try putting the heaviest available weight on the right\n            if not used[right]:\n                new_balance = balance - weights[right][0]\n                if new_balance < 0:\n                    chosen = right\n                    side = 'R'\n            \n            # If that doesn't work, try putting the lightest on the right\n            if chosen == -1 and not used[left]:\n                new_balance = balance - weights[left][0]\n                if new_balance < 0:\n                    chosen = left\n                    side = 'R'\n            \n            # If still doesn't work, try putting the heaviest on the left\n            if chosen == -1 and not used[right]:\n                chosen = right\n                side = 'L'\n            \n            # Finally try putting the lightest on the left\n            if chosen == -1 and not used[left]:\n                chosen = left\n                side = 'L'\n        \n        # If no valid choice found\n        if chosen == -1 or used[chosen]:\n            print(-1)\n            return\n        \n        # Apply the chosen move\n        if side == 'L':\n            balance += weights[chosen][0]\n        else:\n            balance -= weights[chosen][0]\n            \n        used[chosen] = True\n        result.append((weights[chosen][1], side))  # original index, side\n        \n        # Move pointers to next unused\n        while left < N and used[left]:\n            left += 1\n        while right >= 0 and used[right]:\n            right -= 1\n    \n    # Output the result\n    for idx, s in result:\n        print(idx, s)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights\n    A.sort()\n    \n    # Two pointers\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Result storage\n    result = []\n    \n    # Current difference (left_sum - right_sum)\n    current_diff = 0\n    \n    # Process each character in S\n    for i in range(N):\n        target = S[i]\n        \n        if target == 'L':\n            # Want left side to be heavier (current_diff > 0)\n            # Try placing the largest weight on the left to maximize the chance of making it heavier\n            if right_idx >= left_idx:\n                weight = A[right_idx]\n                right_idx -= 1\n                result.append((weight, 'L'))\n                current_diff += weight\n            else:\n                # Fallback - place smallest on left\n                weight = A[left_idx]\n                left_idx += 1\n                result.append((weight, 'L'))\n                current_diff += weight\n        else:\n            # target == 'R', want right side to be heavier (current_diff < 0)\n            # Try placing the largest weight on the right to maximize the chance of making it heavier\n            if right_idx >= left_idx:\n                weight = A[right_idx]\n                right_idx -= 1\n                result.append((weight, 'R'))\n                current_diff -= weight\n            else:\n                # Fallback - place smallest on right\n                weight = A[left_idx]\n                left_idx += 1\n                result.append((weight, 'R'))\n                current_diff -= weight\n    \n    # Validate solution\n    temp_diff = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            temp_diff += weight\n        else:\n            temp_diff -= weight\n            \n        if S[i] == 'L' and temp_diff <= 0:\n            valid = False\n            break\n        elif S[i] == 'R' and temp_diff >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        # Try alternative approach - always use extreme elements\n        result = []\n        A_sorted = sorted(A)\n        left_idx = 0\n        right_idx = N - 1\n        current_diff = 0\n        \n        for i in range(N):\n            target = S[i]\n            \n            if target == 'L':\n                # Want left heavier\n                if current_diff <= 0:\n                    # Need significant change - use largest weight on left\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'L'))\n                    current_diff += weight\n                else:\n                    # Already left heavy, but place optimally\n                    # Use the largest remaining to maintain maximum flexibility\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'L'))\n                    current_diff += weight\n            else:\n                # Want right heavier\n                if current_diff >= 0:\n                    # Need significant change - use largest weight on right\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'R'))\n                    current_diff -= weight\n                else:\n                    # Already right heavy, but place optimally\n                    weight = A_sorted[right_idx]\n                    right_idx -= 1\n                    result.append((weight, 'R'))\n                    current_diff -= weight\n        \n        # Validate again\n        temp_diff = 0\n        valid = True\n        for i in range(N):\n            weight, side = result[i]\n            if side == 'L':\n                temp_diff += weight\n            else:\n                temp_diff -= weight\n                \n            if S[i] == 'L' and temp_diff <= 0:\n                valid = False\n                break\n            elif S[i] == 'R' and temp_diff >= 0:\n                valid = False\n                break\n        \n        if not valid:\n            print(-1)\n            return\n    \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights and keep track of them in a deque\n    weights = sorted(A)\n    dq = deque(weights)\n    \n    result = []\n    left_sum = 0\n    right_sum = 0\n    \n    for i in range(N):\n        direction = S[i]\n        diff = left_sum - right_sum  # positive means left heavier\n        \n        if direction == 'L':  # Need left side heavier (diff > 0)\n            # Try placing the largest weight on left\n            if dq and (diff + dq[-1]) > 0:\n                weight = dq.pop()\n                result.append((weight, 'L'))\n                left_sum += weight\n            # Try placing the smallest weight on right\n            elif dq and (diff - dq[0]) > 0:\n                weight = dq.popleft()\n                result.append((weight, 'R'))\n                right_sum += weight\n            else:\n                # Special case: if both sides are equal and we need left heavier,\n                # we must place something on left\n                if dq and diff == 0:\n                    weight = dq.pop()  # Take the largest\n                    result.append((weight, 'L'))\n                    left_sum += weight\n                else:\n                    print(-1)\n                    return\n        else:  # direction == 'R', need right side heavier (diff < 0)\n            # Try placing the largest weight on right\n            if dq and (diff - dq[-1]) < 0:\n                weight = dq.pop()\n                result.append((weight, 'R'))\n                right_sum += weight\n            # Try placing the smallest weight on left\n            elif dq and (diff + dq[0]) < 0:\n                weight = dq.popleft()\n                result.append((weight, 'L'))\n                left_sum += weight\n            else:\n                # Special case: if both sides are equal and we need right heavier,\n                # we must place something on right\n                if dq and diff == 0:\n                    weight = dq.pop()  # Take the largest\n                    result.append((weight, 'R'))\n                    right_sum += weight\n                else:\n                    print(-1)\n                    return\n    \n    # Output result\n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights for greedy selection\n    sorted_weights = sorted(A)\n    left_idx = 0\n    right_idx = N - 1\n    \n    # Track cumulative weights on each side\n    left_sum = 0\n    right_sum = 0\n    \n    result = []\n    \n    for i in range(N):\n        ch = S[i]\n        if ch == 'L':\n            # We want left side to be heavier after this move\n            if left_sum >= right_sum:\n                # Left is already heavier or equal, put smallest weight on left to maintain minimal advantage\n                w = sorted_weights[left_idx]\n                left_idx += 1\n                result.append((w, 'L'))\n                left_sum += w\n            else:\n                # Left is lighter, we need to make it heavier - put largest weight on left\n                w = sorted_weights[right_idx]\n                right_idx -= 1\n                result.append((w, 'L'))\n                left_sum += w\n        else:  # ch == 'R'\n            # We want right side to be heavier after this move\n            if right_sum >= left_sum:\n                # Right is already heavier or equal, put smallest weight on right to maintain minimal advantage\n                w = sorted_weights[left_idx]\n                left_idx += 1\n                result.append((w, 'R'))\n                right_sum += w\n            else:\n                # Right is lighter, we need to make it heavier - put largest weight on right\n                w = sorted_weights[right_idx]\n                right_idx -= 1\n                result.append((w, 'R'))\n                right_sum += w\n    \n    for w, side in result:\n        print(w, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights and use deque for efficient popping from both ends\n    weights = deque(sorted(A))\n    balance = 0  # left_sum - right_sum\n    result = []\n    \n    for i in range(N):\n        char = S[i]\n        \n        if char == 'L':  # Need left side to be heavier (balance > 0)\n            # Try using the largest available weight on the left\n            if weights:\n                weight = weights.pop()  # Take the largest\n                new_balance = balance + weight\n                if new_balance > 0:\n                    result.append((weight, 'L'))\n                    balance = new_balance\n                else:\n                    # If even the largest doesn't work, try the smallest on left as last resort\n                    if weights:\n                        weights.append(weight)  # Put back the large weight\n                        weight = weights.popleft()  # Take the smallest\n                        result.append((weight, 'L'))\n                        balance = balance + weight\n                    else:\n                        # Only the large weight is left, use it anyway\n                        result.append((weight, 'L'))\n                        balance = new_balance\n            else:\n                # This shouldn't happen\n                pass\n        else:  # Need right side to be heavier (balance < 0)\n            # Try using the largest available weight on the right\n            if weights:\n                weight = weights.pop()  # Take the largest\n                new_balance = balance - weight\n                if new_balance < 0:\n                    result.append((weight, 'R'))\n                    balance = new_balance\n                else:\n                    # If even the largest doesn't work, try the smallest on right as last resort\n                    if weights:\n                        weights.append(weight)  # Put back the large weight\n                        weight = weights.popleft()  # Take the smallest\n                        result.append((weight, 'R'))\n                        balance = balance - weight\n                    else:\n                        # Only the large weight is left, use it anyway\n                        result.append((weight, 'R'))\n                        balance = new_balance\n            else:\n                # This shouldn't happen\n                pass\n    \n    # Verify the solution\n    current_balance = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            current_balance += weight\n        else:\n            current_balance -= weight\n        \n        # Check if the requirement is met\n        required = S[i]\n        if required == 'L' and current_balance <= 0:\n            valid = False\n            break\n        elif required == 'R' and current_balance >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n    else:\n        for weight, side in result:\n            print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights in descending order\n    weights = sorted(A, reverse=True)\n    weights_deque = deque(weights)\n    \n    left_sum = 0\n    right_sum = 0\n    result = []\n    \n    for char in S:\n        if not weights_deque:\n            print(-1)\n            return\n            \n        if char == 'L':\n            # We want left side to be heavier\n            if left_sum >= right_sum:\n                # Left is already heavier or equal, add a heavy weight to left to maintain advantage\n                weight = weights_deque.popleft()\n                left_sum += weight\n                result.append((weight, 'L'))\n            else:\n                # Right is heavier, we need to add enough weight to left to make it heavier\n                # Use the heaviest available weight on left\n                weight = weights_deque.popleft()\n                left_sum += weight\n                result.append((weight, 'L'))\n                # Check if we succeeded\n                if left_sum <= right_sum:\n                    print(-1)\n                    return\n        else:  # char == 'R'\n            # We want right side to be heavier\n            if right_sum >= left_sum:\n                # Right is already heavier or equal, add a heavy weight to right to maintain advantage\n                weight = weights_deque.popleft()\n                right_sum += weight\n                result.append((weight, 'R'))\n            else:\n                # Left is heavier, we need to add enough weight to right to make it heavier\n                # Use the heaviest available weight on right\n                weight = weights_deque.popleft()\n                right_sum += weight\n                result.append((weight, 'R'))\n                # Check if we succeeded\n                if right_sum <= left_sum:\n                    print(-1)\n                    return\n    \n    # Verify all constraints are met\n    left_sum = 0\n    right_sum = 0\n    for i, (weight, side) in enumerate(result):\n        if side == 'L':\n            left_sum += weight\n        else:\n            right_sum += weight\n        \n        if S[i] == 'L' and left_sum <= right_sum:\n            print(-1)\n            return\n        elif S[i] == 'R' and right_sum <= left_sum:\n            print(-1)\n            return\n    \n    for weight, side in result:\n        print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Sort weights for greedy selection\n    sorted_weights = sorted(A)\n    \n    # Pointers for lightest and heaviest available weights\n    left_ptr = 0\n    right_ptr = N - 1\n    \n    # Track current balance: positive = left heavier, negative = right heavier\n    balance = 0\n    \n    result = []\n    \n    # Process each requirement in S\n    for i in range(N):\n        if S[i] == 'L':\n            # Need left side to be heavier after this move\n            if balance > 0:\n                # Left already heavier, add heaviest to left to maintain advantage\n                weight = sorted_weights[right_ptr]\n                right_ptr -= 1\n                result.append((weight, 'L'))\n                balance += weight\n            else:\n                # Left not heavier, need to make it heavier\n                # Try the heaviest weight on left\n                weight = sorted_weights[right_ptr]\n                new_balance = balance + weight\n                if new_balance > 0:\n                    right_ptr -= 1\n                    result.append((weight, 'L'))\n                    balance = new_balance\n                else:\n                    # Even heaviest isn't enough, try lightest on right to reduce deficit\n                    weight = sorted_weights[left_ptr]\n                    left_ptr += 1\n                    result.append((weight, 'R'))\n                    balance -= weight\n        else:\n            # Need right side to be heavier after this move\n            if balance < 0:\n                # Right already heavier, add heaviest to right to maintain advantage\n                weight = sorted_weights[right_ptr]\n                right_ptr -= 1\n                result.append((weight, 'R'))\n                balance -= weight\n            else:\n                # Right not heavier, need to make it heavier\n                # Try the heaviest weight on right\n                weight = sorted_weights[right_ptr]\n                new_balance = balance - weight\n                if new_balance < 0:\n                    right_ptr -= 1\n                    result.append((weight, 'R'))\n                    balance = new_balance\n                else:\n                    # Even heaviest isn't enough, try lightest on left to reduce surplus\n                    weight = sorted_weights[left_ptr]\n                    left_ptr += 1\n                    result.append((weight, 'L'))\n                    balance += weight\n    \n    # Verify the solution\n    temp_balance = 0\n    valid = True\n    for i in range(N):\n        weight, side = result[i]\n        if side == 'L':\n            temp_balance += weight\n        else:\n            temp_balance -= weight\n        \n        # Check if requirement is met\n        if S[i] == 'L' and temp_balance <= 0:\n            valid = False\n            break\n        if S[i] == 'R' and temp_balance >= 0:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n    else:\n        for weight, side in result:\n            print(weight, side)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13013, 13134, 12860, 12843, 9567, 11864, 11775, 13450, 12768, 13159], "completion_tokens": [6256, 7666, 5290, 7574, 7407, 6034, 5754, 7154, 7579, 7101], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 1599}
{"name": "1600_E. Array Game", "description": "Alice and Bob are playing a game. They are given an array A of length N. The array consists of integers. They are building a sequence together. In the beginning, the sequence is empty. In one turn a player can remove a number from the left or right side of the array and append it to the sequence. The rule is that the sequence they are building must be strictly increasing. The winner is the player that makes the last move. Alice is playing first. Given the starting array, under the assumption that they both play optimally, who wins the game?\n\nInput\n\nThe first line contains one integer N (1 \u2264 N \u2264 2*10^5) - the length of the array A.\n\nThe second line contains N integers A_1, A_2,...,A_N (0 \u2264 A_i \u2264 10^9)\n\nOutput\n\nThe first and only line of output consists of one string, the name of the winner. If Alice won, print \"Alice\", otherwise, print \"Bob\".\n\nExamples\n\nInput\n\n\n1\n5\n\n\nOutput\n\n\nAlice\n\n\nInput\n\n\n3\n5 4 5\n\n\nOutput\n\n\nAlice\n\n\nInput\n\n\n6\n5 8 2 1 10 9\n\n\nOutput\n\n\nBob", "tags": ["games", "greedy", "two pointers"], "difficulty": 11, "id": 1600, "sample_io": [{"input": "6\n5 8 2 1 10 9\n", "output": ["Bob\n"]}, {"input": "3\n5 4 5\n", "output": ["Alice\n"]}, {"input": "1\n5\n", "output": ["Alice\n"]}], "test_list": [{"input": "3\n5 6 5\n", "output": ["Bob\n"]}, {"input": "2\n5 12\n", "output": ["Alice\n"]}, {"input": "3\n5 6 9\n", "output": ["Alice\n"]}, {"input": "6\n2 6 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "2\n5 2\n", "output": ["Alice\n"]}, {"input": "6\n5 4 2 1 10 9\n", "output": ["Alice\n"]}, {"input": "3\n5 1 5\n", "output": ["Alice\n"]}, {"input": "1\n2\n", "output": ["Alice\n"]}, {"input": "3\n5 6 10\n", "output": ["Alice\n"]}, {"input": "2\n5 3\n", "output": ["Alice\n"]}, {"input": "6\n4 4 2 1 10 9\n", "output": ["Alice\n"]}, {"input": "3\n7 1 5\n", "output": ["Alice\n"]}, {"input": "1\n3\n", "output": ["Alice\n"]}, {"input": "2\n5 5\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 1 10 9\n", "output": ["Alice\n"]}, {"input": "3\n7 1 3\n", "output": ["Alice\n"]}, {"input": "1\n1\n", "output": ["Alice\n"]}, {"input": "2\n5 7\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 0 10 9\n", "output": ["Alice\n"]}, {"input": "3\n7 1 1\n", "output": ["Alice\n"]}, {"input": "1\n0\n", "output": ["Alice\n"]}, {"input": "2\n5 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 0 12 9\n", "output": ["Alice\n"]}, {"input": "3\n7 1 2\n", "output": ["Alice\n"]}, {"input": "1\n4\n", "output": ["Alice\n"]}, {"input": "2\n10 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 0 0 12 9\n", "output": ["Alice\n"]}, {"input": "3\n13 1 2\n", "output": ["Alice\n"]}, {"input": "2\n0 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 0 0 12 6\n", "output": ["Alice\n"]}, {"input": "3\n13 1 4\n", "output": ["Alice\n"]}, {"input": "2\n1 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 0 0 14 6\n", "output": ["Alice\n"]}, {"input": "3\n13 2 4\n", "output": ["Alice\n"]}, {"input": "2\n1 1\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 0 14 6\n", "output": ["Alice\n"]}, {"input": "3\n13 0 4\n", "output": ["Alice\n"]}, {"input": "2\n0 1\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 0 14 5\n", "output": ["Alice\n"]}, {"input": "3\n4 0 4\n", "output": ["Alice\n"]}, {"input": "2\n0 2\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 0 14 5\n", "output": ["Alice\n"]}, {"input": "3\n4 0 0\n", "output": ["Alice\n"]}, {"input": "2\n0 4\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 0 17 5\n", "output": ["Alice\n"]}, {"input": "3\n6 0 0\n", "output": ["Alice\n"]}, {"input": "2\n1 4\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 0 17 6\n", "output": ["Alice\n"]}, {"input": "3\n6 1 0\n", "output": ["Alice\n"]}, {"input": "2\n2 4\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 0 17 11\n", "output": ["Alice\n"]}, {"input": "3\n6 1 -1\n", "output": ["Alice\n"]}, {"input": "2\n1 8\n", "output": ["Alice\n"]}, {"input": "6\n7 6 0 0 17 11\n", "output": ["Alice\n"]}, {"input": "3\n6 1 -2\n", "output": ["Alice\n"]}, {"input": "2\n1 -1\n", "output": ["Alice\n"]}, {"input": "6\n7 6 0 0 17 12\n", "output": ["Alice\n"]}, {"input": "3\n6 0 -2\n", "output": ["Alice\n"]}, {"input": "2\n0 -1\n", "output": ["Alice\n"]}, {"input": "6\n6 6 0 0 17 12\n", "output": ["Alice\n"]}, {"input": "3\n9 0 0\n", "output": ["Alice\n"]}, {"input": "2\n0 -2\n", "output": ["Alice\n"]}, {"input": "6\n6 6 0 0 5 12\n", "output": ["Alice\n"]}, {"input": "3\n15 0 0\n", "output": ["Alice\n"]}, {"input": "6\n2 6 0 0 5 12\n", "output": ["Alice\n"]}, {"input": "3\n15 1 0\n", "output": ["Alice\n"]}, {"input": "3\n15 0 1\n", "output": ["Alice\n"]}, {"input": "6\n2 9 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "6\n2 12 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "6\n2 7 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "6\n2 7 0 0 2 0\n", "output": ["Bob\n"]}, {"input": "6\n2 7 1 0 2 0\n", "output": ["Bob\n"]}, {"input": "6\n1 7 1 0 2 0\n", "output": ["Bob\n"]}, {"input": "6\n1 0 1 0 2 0\n", "output": ["Alice\n"]}, {"input": "6\n1 0 2 0 2 0\n", "output": ["Alice\n"]}, {"input": "6\n0 0 2 0 2 0\n", "output": ["Alice\n"]}, {"input": "3\n5 7 10\n", "output": ["Alice\n"]}, {"input": "2\n4 12\n", "output": ["Alice\n"]}, {"input": "6\n5 8 0 1 10 9\n", "output": ["Bob\n"]}, {"input": "3\n5 8 5\n", "output": ["Bob\n"]}, {"input": "1\n8\n", "output": ["Alice\n"]}, {"input": "3\n5 6 11\n", "output": ["Alice\n"]}, {"input": "2\n3 2\n", "output": ["Alice\n"]}, {"input": "6\n5 4 4 1 10 9\n", "output": ["Alice\n"]}, {"input": "3\n2 1 5\n", "output": ["Alice\n"]}, {"input": "3\n5 8 10\n", "output": ["Alice\n"]}, {"input": "2\n9 3\n", "output": ["Alice\n"]}, {"input": "6\n4 8 2 1 10 9\n", "output": ["Bob\n"]}, {"input": "3\n7 2 5\n", "output": ["Alice\n"]}, {"input": "2\n-1 2\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 1 0 9\n", "output": ["Alice\n"]}, {"input": "3\n6 1 3\n", "output": ["Alice\n"]}, {"input": "2\n9 7\n", "output": ["Alice\n"]}, {"input": "6\n4 0 2 0 10 9\n", "output": ["Alice\n"]}, {"input": "3\n7 1 0\n", "output": ["Alice\n"]}, {"input": "2\n5 1\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 0 12 11\n", "output": ["Alice\n"]}, {"input": "3\n7 0 2\n", "output": ["Alice\n"]}, {"input": "1\n6\n", "output": ["Alice\n"]}, {"input": "2\n16 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 0 -1 12 9\n", "output": ["Alice\n"]}, {"input": "3\n17 1 2\n", "output": ["Alice\n"]}, {"input": "2\n-1 0\n", "output": ["Alice\n"]}, {"input": "6\n6 3 0 0 12 6\n", "output": ["Alice\n"]}, {"input": "3\n21 1 4\n", "output": ["Alice\n"]}, {"input": "2\n2 -1\n", "output": ["Alice\n"]}, {"input": "6\n1 3 0 0 14 6\n", "output": ["Bob\n"]}, {"input": "3\n23 2 4\n", "output": ["Alice\n"]}, {"input": "2\n1 2\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 -1 14 6\n", "output": ["Alice\n"]}, {"input": "3\n17 0 4\n", "output": ["Alice\n"]}, {"input": "2\n0 3\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 0 28 5\n", "output": ["Alice\n"]}, {"input": "3\n4 0 5\n", "output": ["Alice\n"]}, {"input": "2\n1 3\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 1 14 5\n", "output": ["Alice\n"]}, {"input": "3\n7 0 0\n", "output": ["Alice\n"]}, {"input": "2\n1 -2\n", "output": ["Alice\n"]}, {"input": "6\n7 4 -1 0 17 5\n", "output": ["Alice\n"]}, {"input": "3\n6 1 1\n", "output": ["Alice\n"]}, {"input": "2\n1 7\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 1 17 6\n", "output": ["Alice\n"]}, {"input": "3\n8 1 0\n", "output": ["Alice\n"]}, {"input": "2\n2 2\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 0 17 7\n", "output": ["Alice\n"]}, {"input": "3\n11 0 0\n", "output": ["Alice\n"]}, {"input": "2\n2 8\n", "output": ["Alice\n"]}, {"input": "6\n4 6 0 0 17 11\n", "output": ["Bob\n"]}, {"input": "3\n7 0 -2\n", "output": ["Alice\n"]}, {"input": "2\n2 -2\n", "output": ["Alice\n"]}, {"input": "6\n7 6 0 0 17 5\n", "output": ["Alice\n"]}, {"input": "3\n11 0 -2\n", "output": ["Alice\n"]}, {"input": "2\n-1 1\n", "output": ["Alice\n"]}, {"input": "6\n0 6 0 0 17 12\n", "output": ["Bob\n"]}, {"input": "3\n9 1 0\n", "output": ["Alice\n"]}, {"input": "6\n6 6 0 0 5 10\n", "output": ["Alice\n"]}, {"input": "3\n5 0 0\n", "output": ["Alice\n"]}, {"input": "6\n2 7 0 0 5 12\n", "output": ["Alice\n"]}, {"input": "3\n15 2 0\n", "output": ["Alice\n"]}, {"input": "6\n2 6 0 0 4 0\n", "output": ["Bob\n"]}, {"input": "3\n15 1 1\n", "output": ["Alice\n"]}, {"input": "6\n3 9 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "6\n1 12 0 0 5 0\n", "output": ["Bob\n"]}, {"input": "6\n2 7 0 0 7 0\n", "output": ["Bob\n"]}, {"input": "6\n2 7 0 0 3 0\n", "output": ["Bob\n"]}, {"input": "6\n2 0 1 0 2 0\n", "output": ["Alice\n"]}, {"input": "6\n1 6 1 0 2 0\n", "output": ["Bob\n"]}, {"input": "6\n1 0 3 0 2 0\n", "output": ["Alice\n"]}, {"input": "3\n10 7 10\n", "output": ["Alice\n"]}, {"input": "2\n1 12\n", "output": ["Alice\n"]}, {"input": "6\n8 8 0 1 10 9\n", "output": ["Alice\n"]}, {"input": "1\n10\n", "output": ["Alice\n"]}, {"input": "3\n8 6 11\n", "output": ["Alice\n"]}, {"input": "2\n3 4\n", "output": ["Alice\n"]}, {"input": "6\n5 4 4 2 10 9\n", "output": ["Alice\n"]}, {"input": "3\n2 2 5\n", "output": ["Alice\n"]}, {"input": "3\n5 9 10\n", "output": ["Alice\n"]}, {"input": "2\n14 3\n", "output": ["Alice\n"]}, {"input": "6\n4 8 4 1 10 9\n", "output": ["Bob\n"]}, {"input": "3\n10 2 5\n", "output": ["Alice\n"]}, {"input": "2\n-1 3\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 1 0 13\n", "output": ["Alice\n"]}, {"input": "3\n6 0 3\n", "output": ["Alice\n"]}, {"input": "2\n15 7\n", "output": ["Alice\n"]}, {"input": "6\n4 1 2 0 10 9\n", "output": ["Alice\n"]}, {"input": "3\n7 2 0\n", "output": ["Alice\n"]}, {"input": "2\n2 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 2 0 8 11\n", "output": ["Alice\n"]}, {"input": "3\n3 0 2\n", "output": ["Alice\n"]}, {"input": "1\n9\n", "output": ["Alice\n"]}, {"input": "2\n4 0\n", "output": ["Alice\n"]}, {"input": "6\n4 3 0 -1 6 9\n", "output": ["Alice\n"]}, {"input": "3\n17 2 2\n", "output": ["Alice\n"]}, {"input": "2\n-2 0\n", "output": ["Alice\n"]}, {"input": "6\n5 3 0 0 12 6\n", "output": ["Alice\n"]}, {"input": "3\n21 1 5\n", "output": ["Alice\n"]}, {"input": "2\n2 1\n", "output": ["Alice\n"]}, {"input": "6\n1 3 1 0 14 6\n", "output": ["Bob\n"]}, {"input": "3\n23 3 4\n", "output": ["Alice\n"]}, {"input": "2\n-1 4\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 -1 14 0\n", "output": ["Alice\n"]}, {"input": "2\n0 8\n", "output": ["Alice\n"]}, {"input": "6\n7 3 0 -1 28 5\n", "output": ["Alice\n"]}, {"input": "3\n4 0 1\n", "output": ["Alice\n"]}, {"input": "2\n1 5\n", "output": ["Alice\n"]}, {"input": "6\n7 4 1 1 14 5\n", "output": ["Alice\n"]}, {"input": "3\n12 0 0\n", "output": ["Alice\n"]}, {"input": "2\n1 -3\n", "output": ["Alice\n"]}, {"input": "6\n7 4 -1 0 17 1\n", "output": ["Alice\n"]}, {"input": "3\n0 1 1\n", "output": ["Alice\n"]}, {"input": "2\n1 11\n", "output": ["Alice\n"]}, {"input": "6\n7 4 0 1 17 5\n", "output": ["Alice\n"]}, {"input": "3\n5 1 0\n", "output": ["Alice\n"]}, {"input": "2\n-1 5\n", "output": ["Alice\n"]}, {"input": "6\n7 0 0 0 17 7\n", "output": ["Alice\n"]}, {"input": "3\n11 1 0\n", "output": ["Alice\n"]}, {"input": "2\n3 8\n", "output": ["Alice\n"]}, {"input": "6\n4 6 0 0 17 3\n", "output": ["Bob\n"]}, {"input": "2\n4 -1\n", "output": ["Alice\n"]}, {"input": "6\n7 4 1 0 17 5\n", "output": ["Alice\n"]}, {"input": "3\n9 0 -2\n", "output": ["Alice\n"]}, {"input": "2\n-2 1\n", "output": ["Alice\n"]}], "source_codes": ["import sys\nimport threading\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    \n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    memo = {}\n    \n    def can_win(l, r, last):\n        if l > r:\n            return False  # No elements left, current player loses\n            \n        if (l, r, last) in memo:\n            return memo[(l, r, last)]\n        \n        # Try taking from left\n        if A[l] > last:\n            if not can_win(l + 1, r, A[l]):\n                memo[(l, r, last)] = True\n                return True\n        \n        # Try taking from right\n        if A[r] > last:\n            if not can_win(l, r - 1, A[r]):\n                memo[(l, r, last)] = True\n                return True\n                \n        memo[(l, r, last)] = False\n        return False\n    \n    if can_win(0, N - 1, -1):\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nthreading.Thread(target=main).start()"], "responses": ["\nimport sys\nimport threading\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    \n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    memo = {}\n    \n    def can_win(l, r, last):\n        if l > r:\n            return False  # No elements left, current player loses\n            \n        if (l, r, last) in memo:\n            return memo[(l, r, last)]\n        \n        # Try taking from left\n        if A[l] > last:\n            if not can_win(l + 1, r, A[l]):\n                memo[(l, r, last)] = True\n                return True\n        \n        # Try taking from right\n        if A[r] > last:\n            if not can_win(l, r - 1, A[r]):\n                memo[(l, r, last)] = True\n                return True\n                \n        memo[(l, r, last)] = False\n        return False\n    \n    if can_win(0, N - 1, -1):\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nthreading.Thread(target=main).start()\n\n\n"], "prompt_tokens": [9060], "completion_tokens": [5197], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1600}
{"name": "1601_A. Array Elimination", "description": "You are given array a_1, a_2, \u2026, a_n, consisting of non-negative integers.\n\nLet's define operation of \"elimination\" with integer parameter k (1 \u2264 k \u2264 n) as follows:\n\n  * Choose k distinct array indices 1 \u2264 i_1 < i_2 < \u2026 < i_k \u2264 n. \n  * Calculate x = a_{i_1} ~ \\& ~ a_{i_2} ~ \\& ~ \u2026 ~ \\& ~ a_{i_k}, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND) (notes section contains formal definition). \n  * Subtract x from each of a_{i_1}, a_{i_2}, \u2026, a_{i_k}; all other elements remain untouched. \n\n\n\nFind all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.\n\nNote that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 200 000) \u2014 the length of array a.\n\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i < 2^{30}) \u2014 array a itself.\n\nIt's guaranteed that the sum of n over all test cases doesn't exceed 200 000.\n\nOutput\n\nFor each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.\n\nPrint them in increasing order.\n\nExample\n\nInput\n\n\n5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n\n\nOutput\n\n\n1 2 4\n1 2\n1\n1\n1 2 3 4 5\n\nNote\n\nIn the first test case:\n\n  * If k = 1, we can make four elimination operations with sets of indices \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}. Since \\& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. \n  * If k = 2, we can make two elimination operations with, for example, sets of indices \\{1, 3\\} and \\{2, 4\\}: x = a_1 ~ \\& ~ a_3 = a_2 ~ \\& ~ a_4 = 4 ~ \\& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation \u2014 a_2 - x = 0 and a_4 - x = 0. \n  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. \n  * If k = 4, we can make one operation with set \\{1, 2, 3, 4\\}, because x = a_1 ~ \\& ~ a_2 ~ \\& ~ a_3 ~ \\& ~ a_4 = 4. \n\n\n\nIn the second test case, if k = 2 then we can make the following elimination operations:\n\n  * Operation with indices \\{1, 3\\}: x = a_1 ~ \\& ~ a_3 = 13 ~ \\& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. \n  * Operation with indices \\{3, 4\\}: x = a_3 ~ \\& ~ a_4 = 16 ~ \\& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. \n  * Operation with indices \\{2, 4\\}: x = a_2 ~ \\& ~ a_4 = 7 ~ \\& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. \n  * Operation with indices \\{1, 2\\}: x = a_1 ~ \\& ~ a_2 = 4 ~ \\& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. \n\n\n\nFormal definition of bitwise AND:\n\nLet's define bitwise AND (\\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \\& ~ y is a result of operation \\& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:\n\n$$$ r_i = \\begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\\\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \\end{cases} $$$", "tags": ["bitmasks", "greedy", "math", "number theory"], "difficulty": 7, "id": 1601, "sample_io": [{"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4 \n1 2 \n1 \n1 \n1 2 3 4 5 \n"]}], "test_list": [{"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 4 4\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 4\n4\n23 7 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 19\n6\n0 5 3 1 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 2\n4\n13 7 25 19\n6\n0 5 3 2 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 4 4\n4\n13 7 50 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 3\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 3 4 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1 2\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n0 4 4 4\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 3\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n1 1 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 8 3 2 8 1\n1\n1\n5\n0 0 0 0 2\n", "output": ["1 2 4\n1 2\n1 2\n1\n1\n"]}, {"input": "5\n4\n4 0 8 6\n4\n23 9 5 19\n6\n3 5 3 1 8 1\n1\n1\n5\n1 1 0 0 0\n", "output": ["1\n1\n1\n1\n1 2\n"]}, {"input": "5\n4\n1 4 4 4\n4\n13 11 25 19\n6\n3 4 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1 2\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 2 4 4\n4\n13 7 25 19\n6\n0 8 3 2 8 1\n1\n1\n5\n0 0 0 0 2\n", "output": ["1\n1 2\n1 2\n1\n1\n"]}, {"input": "5\n4\n1 4 4 4\n4\n13 11 25 19\n6\n3 4 3 1 7 2\n1\n2\n5\n0 0 0 1 0\n", "output": ["1\n1\n1 2\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 21\n6\n0 5 3 1 13 1\n1\n0\n5\n0 1 1 0 1\n", "output": ["1 2 4\n1\n1\n1\n1 3\n"]}, {"input": "5\n4\n4 9 8 5\n4\n23 7 32 32\n6\n3 0 2 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 8 4\n4\n13 7 25 19\n6\n3 5 3 1 13 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 6 3 1 13 0\n1\n1\n5\n0 0 0 1 1\n", "output": ["1 2 4\n1 2\n1\n1\n1 2\n"]}, {"input": "5\n4\n0 4 4 4\n4\n13 7 25 19\n1\n0 6 3 1 13 0\n1\n1\n5\n0 0 0 1 1\n", "output": ["1 3\n1 2\n1\n1\n1 2\n"]}, {"input": "5\n4\n4 4 7 4\n4\n13 7 25 19\n6\n0 6 3 1 13 0\n1\n1\n5\n0 0 0 1 1\n", "output": ["1\n1 2\n1\n1\n1 2\n"]}, {"input": "5\n4\n4 4 8 4\n4\n13 7 25 23\n6\n3 5 3 1 6 1\n1\n1\n5\n0 1 1 0 1\n", "output": ["1\n1\n1\n1\n1 3\n"]}, {"input": "5\n4\n8 4 8 4\n4\n13 7 25 14\n6\n3 5 3 1 6 1\n1\n1\n5\n0 1 1 0 1\n", "output": ["1 2\n1\n1\n1\n1 3\n"]}, {"input": "5\n4\n8 4 8 4\n4\n13 7 25 14\n6\n3 5 3 1 6 1\n1\n1\n5\n1 1 1 0 1\n", "output": ["1 2\n1\n1\n1\n1 2 4\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 7 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1 2\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n1 1 4 4\n4\n13 5 25 19\n6\n6 9 3 2 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n0 4 4 4\n4\n13 0 25 19\n1\n0 6 3 1 13 0\n1\n1\n5\n0 0 0 1 1\n", "output": ["1 3\n1\n1\n1\n1 2\n"]}, {"input": "5\n4\n8 4 8 2\n4\n13 7 25 14\n6\n3 5 3 1 6 1\n1\n1\n5\n1 1 1 0 1\n", "output": ["1\n1\n1\n1\n1 2 4\n"]}, {"input": "5\n4\n4 4 0 4\n4\n13 7 25 19\n6\n3 9 5 1 11 1\n1\n1\n5\n0 1 0 0 0\n", "output": ["1 3\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n8 4 8 4\n4\n3 7 25 14\n6\n3 5 3 1 6 2\n1\n1\n5\n0 2 1 0 1\n", "output": ["1 2\n1\n1 2\n1\n1\n"]}, {"input": "5\n4\n8 2 8 2\n4\n13 7 25 14\n6\n3 5 3 2 6 1\n1\n1\n5\n1 1 1 0 1\n", "output": ["1 2\n1\n1 2\n1\n1 2 4\n"]}, {"input": "5\n4\n4 4 0 4\n4\n13 7 25 28\n6\n3 5 3 1 1 1\n1\n1\n5\n1 1 1 0 0\n", "output": ["1 3\n1\n1\n1\n1 3\n"]}, {"input": "5\n4\n8 2 8 4\n4\n13 7 25 14\n6\n3 5 3 2 6 1\n1\n1\n5\n1 1 1 0 1\n", "output": ["1\n1\n1 2\n1\n1 2 4\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 38 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n23 7 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 38 19\n6\n6 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 5 4 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 4\n4\n23 7 25 18\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n2 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n1 5 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 2 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n23 7 25 19\n6\n3 9 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 4 4\n4\n13 7 25 34\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 1 0 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 6\n4\n23 7 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 18 19\n6\n3 5 4 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 4\n4\n23 7 25 18\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 50 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 25 19\n6\n1 5 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 19\n6\n0 5 1 1 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n23 7 25 19\n6\n3 9 3 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 2 4 4\n4\n13 7 25 34\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 8 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 1 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 6\n4\n23 9 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 25 18\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 25 19\n6\n1 7 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 2\n4\n13 7 25 19\n6\n0 5 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 25 19\n6\n3 9 3 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 8 25 19\n6\n0 5 3 1 8 1\n1\n0\n5\n0 1 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 6\n4\n23 9 39 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 25 32\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 4\n4\n13 7 50 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 25 19\n6\n1 7 0 1 8 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 5 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 25 19\n6\n3 9 3 1 5 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 8 25 20\n6\n0 5 3 1 8 1\n1\n0\n5\n0 1 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 8 6\n4\n23 9 39 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 30 32\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 4\n4\n13 7 50 19\n6\n6 5 1 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 25 19\n6\n1 7 0 1 4 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 27 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 3 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 5\n4\n46 7 25 19\n6\n3 9 3 1 5 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 7 25 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 1 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 8 6\n4\n23 9 5 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 30 32\n6\n3 0 6 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 4\n4\n13 7 50 19\n6\n0 5 1 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 25 19\n6\n1 7 0 1 4 2\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n17 7 27 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 3 6 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 30 32\n6\n3 0 2 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 4\n4\n13 7 50 19\n6\n0 5 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n17 7 27 19\n6\n3 5 3 1 1 2\n1\n3\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 1 6 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 50 19\n6\n0 5 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n0 5 4 2\n4\n13 7 25 19\n6\n0 1 6 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 50 19\n6\n0 4 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 50 19\n6\n0 4 0 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 38 19\n6\n0 4 0 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 16\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 2 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n7 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n2 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n1 7 38 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 3 4 4\n4\n23 7 25 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 8 4 4\n4\n13 7 25 19\n6\n1 5 3 1 8 0\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 7 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 13 38 19\n6\n6 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 8 4\n4\n23 7 25 18\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n1 4 4 4\n4\n13 7 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 7 4\n4\n13 7 25 19\n6\n1 5 0 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n1 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 19\n6\n0 5 3 2 8 1\n1\n1\n5\n0 0 0 0 2\n", "output": ["1 2 4\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 19\n6\n0 5 3 1 13 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n23 7 25 19\n6\n3 9 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 4 4\n4\n13 7 25 55\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 6\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 1 0 0 0\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 6\n4\n23 7 25 19\n6\n3 5 3 1 8 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 2\n4\n13 7 25 19\n6\n0 5 3 2 4 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 5 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 2 4 4\n4\n13 7 25 34\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 8 6\n4\n23 9 25 7\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 25 0\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 25 19\n6\n3 9 3 1 8 1\n1\n4\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 8 5\n4\n23 7 25 32\n6\n3 1 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 4\n4\n13 7 50 19\n6\n6 5 3 1 8 1\n1\n1\n5\n0 0 0 1 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n17 14 25 19\n6\n1 7 0 1 8 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 17 19\n6\n3 5 3 0 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 13\n6\n0 5 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 43 19\n6\n3 9 3 1 5 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 6\n4\n13 8 25 20\n6\n0 5 3 1 8 1\n1\n0\n5\n0 1 0 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 8 6\n4\n18 9 39 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 26 19\n6\n1 7 0 1 4 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 3 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n1 3 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 5\n4\n46 7 25 19\n6\n3 15 3 1 5 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 8 6\n4\n23 9 5 19\n6\n3 5 3 1 8 1\n1\n1\n5\n0 1 0 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 4\n4\n13 14 25 19\n6\n1 7 0 1 4 2\n1\n0\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n6 4 4 4\n4\n17 7 27 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 3 6 2 11 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 8 5\n4\n23 7 30 32\n6\n3 0 2 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 2 4 4\n4\n17 7 27 19\n6\n3 5 3 1 1 2\n1\n3\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 50 19\n6\n0 5 0 1 8 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 54 19\n6\n0 4 0 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 38 28\n6\n0 4 0 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 16\n6\n3 5 3 1 8 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 8\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 5 4\n4\n13 7 17 19\n6\n3 5 3 1 2 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n8 7 25 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n2 4 4 4\n4\n13 7 25 19\n6\n0 5 3 0 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 8\n4\n1 7 38 19\n6\n3 5 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 3 4 4\n4\n23 7 25 5\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 6\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 8 4 3\n4\n13 7 25 19\n6\n1 5 3 1 8 0\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 7 4 4\n4\n13 7 47 19\n6\n0 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 13 38 19\n6\n6 4 3 1 7 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n24 7 25 19\n6\n3 3 4 1 7 2\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1 2\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n1 4 4 4\n4\n13 11 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 21\n6\n0 5 3 1 13 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n0 4 4 4\n4\n24 7 25 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 3\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 8 4 4\n4\n13 7 48 55\n6\n1 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 2\n4\n13 7 25 19\n6\n0 5 3 2 4 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n22 5 16 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 1 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 7 5\n4\n23 7 25 0\n6\n3 0 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 25 19\n6\n3 9 3 1 5 1\n1\n4\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 4\n4\n13 7 17 19\n6\n3 5 3 0 0 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 18 13\n6\n0 5 3 2 8 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n46 7 12 19\n6\n3 9 3 1 5 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 8 6\n4\n18 9 39 19\n6\n3 5 3 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 14 26 19\n6\n1 7 0 1 4 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 0\n4\n13 7 3 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 4\n4\n13 14 25 19\n6\n1 7 0 1 4 2\n1\n0\n5\n0 0 0 0 1\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n6 4 4 4\n4\n5 7 27 19\n6\n3 5 3 1 1 2\n1\n2\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 5 4 2\n4\n13 7 25 19\n6\n0 3 5 2 11 1\n1\n2\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n4 8 8 5\n4\n23 7 32 32\n6\n3 0 2 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 2 4 4\n4\n17 7 27 19\n6\n1 5 3 1 1 2\n1\n3\n5\n0 0 1 0 0\n", "output": ["1\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 54 19\n6\n0 4 0 2 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 0 6 1\n4\n13 7 38 28\n6\n0 4 0 1 8 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 25 16\n6\n3 0 3 1 8 1\n1\n0\n5\n0 0 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n3 4 4 8\n4\n13 7 25 19\n6\n1 5 3 1 8 1\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1 2\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 5 4\n4\n13 7 29 19\n6\n3 5 3 1 2 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n8 7 25 19\n6\n0 2 3 1 8 1\n1\n1\n5\n0 0 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n1 4 4 4\n4\n13 7 25 19\n6\n0 5 3 1 8 1\n1\n0\n5\n0 0 0 0 1\n", "output": ["1\n1 2\n1\n1\n1\n"]}, {"input": "5\n4\n7 3 4 4\n4\n23 7 25 5\n6\n3 5 3 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 6\n4\n24 8 25 19\n6\n3 5 3 1 7 2\n1\n2\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 8 4 3\n4\n13 7 12 19\n6\n1 5 3 1 8 0\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 7 4 4\n4\n13 7 47 19\n6\n0 5 4 1 8 1\n1\n1\n5\n0 0 0 0 0\n", "output": ["1\n1\n1\n1\n1 2 3 4 5\n"]}, {"input": "5\n4\n4 4 4 4\n4\n13 7 17 19\n6\n3 5 3 1 1 2\n1\n1\n5\n1 2 0 0 0\n", "output": ["1 2 4\n1\n1\n1\n1\n"]}, {"input": "5\n4\n4 4 4 4\n4\n5 7 25 21\n6\n0 5 3 1 13 1\n1\n0\n5\n0 1 0 0 1\n", "output": ["1 2 4\n1\n1\n1\n1 2\n"]}, {"input": "5\n4\n0 4 4 4\n4\n24 7 37 19\n6\n3 5 3 1 7 2\n1\n1\n5\n0 0 0 0 0\n", "output": ["1 3\n1\n1\n1\n1 2 3 4 5\n"]}], "source_codes": ["import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        # Count number of elements with each bit set\n        bit_count = [0] * 30\n        for num in a:\n            for i in range(30):\n                if num & (1 << i):\n                    bit_count[i] += 1\n        \n        # Find all k such that all bit counts are divisible by k\n        valid_ks = []\n        for k in range(1, n+1):\n            if all(count % k == 0 for count in bit_count):\n                valid_ks.append(k)\n        \n        # Convert to string without trailing space\n        results.append(' '.join(map(str, valid_ks)))\n    \n    # Print all results with proper newlines\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        # Count number of elements with each bit set\n        bit_count = [0] * 30\n        for num in a:\n            for i in range(30):\n                if num & (1 << i):\n                    bit_count[i] += 1\n        \n        # Find all k such that all bit counts are divisible by k\n        valid_ks = []\n        for k in range(1, n+1):\n            if all(count % k == 0 for count in bit_count):\n                valid_ks.append(k)\n        \n        # Convert to string without trailing space\n        results.append(' '.join(map(str, valid_ks)))\n    \n    # Print all results with proper newlines\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [20389], "completion_tokens": [3431], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1601}
