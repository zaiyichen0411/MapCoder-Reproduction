{"name": "1615_H. Reindeer Games", "description": "There are n reindeer at the North Pole, all battling for the highest spot on the \"Top Reindeer\" leaderboard on the front page of CodeNorses (a popular competitive reindeer gaming website). Interestingly, the \"Top Reindeer\" title is just a measure of upvotes and has nothing to do with their skill level in the reindeer games, but they still give it the utmost importance.\n\nCurrently, the i-th reindeer has a score of a_i. You would like to influence the leaderboard with some operations. In an operation, you can choose a reindeer, and either increase or decrease his score by 1 unit. Negative scores are allowed.\n\nYou have m requirements for the resulting scores. Each requirement is given by an ordered pair (u, v), meaning that after all operations, the score of reindeer u must be less than or equal to the score of reindeer v.\n\nYour task is to perform the minimum number of operations so that all requirements will be satisfied.\n\nInput\n\nThe first line contains two integers n and m (2\u2264 n\u2264 1000; 1\u2264 m\u2264 1000) \u2014 the number of reindeer and requirements, respectively.\n\nThe second line contains n integers a_1,\u2026, a_n (1\u2264 a_i\u2264 10^9), where a_i is the current score of reindeer i.\n\nThe next m lines describe the requirements.\n\nThe i-th of these lines contains two integers u_i and v_i (1\u2264 u_i, v_i\u2264 n; u_i\u2260 v_i) \u2014 the two reindeer of the i-th requirement.\n\nOutput\n\nPrint n integers b_1,\u2026, b_n (-10^{15}\u2264 b_i\u2264 10^{15}), where b_i is the score of the i-th reindeer after all operations.\n\nIf there are multiple solutions achieving the minimum number of operations, you may output any.\n\nWe can prove that there is always an optimal solution such that |b_i|\u2264 10^{15} for all i.\n\nExamples\n\nInput\n\n\n7 6\n3 1 4 9 2 5 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n\n\nOutput\n\n\n1 1 4 4 4 5 6 \n\n\nInput\n\n\n4 6\n6 5 8 2\n3 1\n4 1\n3 2\n1 2\n2 3\n3 1\n\n\nOutput\n\n\n6 6 6 2 \n\n\nInput\n\n\n10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n\n\nOutput\n\n\n204 204 195 182 180 167 176 172 169 167 ", "tags": ["binary search", "constructive algorithms", "data structures", "divide and conquer", "flows", "graphs", "shortest paths"], "difficulty": 14, "id": 1615, "sample_io": [{"input": "7 6\n3 1 4 9 2 5 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 4 4 4 5 6 \n"]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 \n"]}, {"input": "4 6\n6 5 8 2\n3 1\n4 1\n3 2\n1 2\n2 3\n3 1\n", "output": ["6 6 6 2 \n"]}], "test_list": [{"input": "2 1\n1 1000000000\n1 2\n", "output": ["1 1000000000 \n"]}, {"input": "2 1\n1 1\n1 2\n", "output": ["1 1 \n"]}, {"input": "7 6\n3 1 4 9 2 5 6\n1 1\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["3 1 4 4 4 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 172 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 176 182 180 167 176 176 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "2 1\n2 1\n1 2\n", "output": ["1 1 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 137 137 176 172 169 167 "]}, {"input": "4 6\n6 5 8 2\n3 2\n4 1\n3 2\n1 2\n2 3\n3 1\n", "output": ["6 6 6 2 "]}, {"input": "7 6\n3 2 4 9 2 5 6\n1 1\n2 3\n3 4\n4 5\n4 6\n6 7\n", "output": ["3 2 4 4 4 5 6 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 182 137 137 176 172 169 167 "]}, {"input": "7 6\n3 1 4 9 2 5 6\n1 1\n2 3\n3 1\n4 5\n5 3\n6 7\n", "output": ["3 1 3 2 2 5 6 "]}, {"input": "7 6\n3 2 4 9 2 5 6\n1 1\n2 3\n3 7\n4 5\n4 6\n6 7\n", "output": ["3 2 4 2 2 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 111 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 172 182 180 111 111 172 169 167 "]}, {"input": "10 18\n214 204 93 182 180 260 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 167 182 180 167 167 172 169 167 "]}, {"input": "2 0\n3 1\n1 2\n", "output": ["3 1 "]}, {"input": "4 6\n6 5 13 2\n3 2\n4 1\n3 4\n1 2\n2 3\n3 1\n", "output": ["5 5 5 5 "]}, {"input": "3 0\n3 1\n1 2\n", "output": ["3 1 1 "]}, {"input": "3 0\n3 1\n2 2\n", "output": ["3 1 2 "]}, {"input": "10 18\n192 204 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 204 182 180 167 176 172 169 167 "]}, {"input": "4 0\n3 1\n2 2\n", "output": ["3 1 2 2 "]}, {"input": "4 0\n3 1\n4 2\n", "output": ["3 1 4 2 "]}, {"input": "7 6\n3 1 7 9 2 5 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 5 5 5 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 200 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 200 172 169 167 "]}, {"input": "7 6\n1 1 4 9 2 5 6\n1 1\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 4 4 4 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n3 9\n6 10\n", "output": ["204 204 169 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 180 182 180 167 176 180 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["172 204 195 182 180 167 176 172 169 167 "]}, {"input": "2 0\n2 1\n1 2\n", "output": ["2 1 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 134 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 137 134 176 172 134 167 "]}, {"input": "7 6\n3 1 4 9 2 5 6\n1 1\n2 3\n3 4\n5 5\n5 3\n6 7\n", "output": ["3 1 4 9 2 5 6 "]}, {"input": "10 18\n192 204 195 182 180 176 326 172 169 167\n1 2\n3 2\n4 2\n5 2\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 195 172 169 167 "]}, {"input": "2 1\n3 2\n1 2\n", "output": ["2 2 "]}, {"input": "10 18\n214 204 195 182 180 176 111 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n6 9\n6 10\n", "output": ["180 204 180 182 180 167 180 180 169 167 "]}, {"input": "2 0\n5 1\n1 2\n", "output": ["5 1 "]}, {"input": "10 18\n214 204 93 182 180 260 14 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 93 182 180 14 14 172 169 167 "]}, {"input": "3 0\n6 1\n1 2\n", "output": ["6 1 1 "]}, {"input": "10 18\n214 204 93 182 180 260 176 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 4\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n1 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["180 204 167 182 180 167 167 172 169 167 "]}, {"input": "4 0\n6 1\n4 2\n", "output": ["6 1 4 2 "]}, {"input": "10 18\n192 30 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n6 10\n", "output": ["192 192 192 182 180 167 176 172 169 167 "]}, {"input": "7 6\n3 1 7 9 2 1 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 2 2 2 2 6 "]}, {"input": "7 6\n1 1 4 9 2 5 6\n1 1\n2 3\n3 4\n4 2\n5 6\n6 7\n", "output": ["1 4 4 4 2 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n2 9\n6 10\n", "output": ["204 204 180 182 180 167 176 180 204 167 "]}, {"input": "10 3\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 176 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 1\n6 8\n6 9\n6 7\n", "output": ["204 204 195 182 180 169 176 172 169 167 "]}, {"input": "7 6\n3 1 4 12 2 5 6\n1 1\n2 3\n3 4\n5 5\n5 3\n6 7\n", "output": ["3 1 4 12 2 5 6 "]}, {"input": "10 18\n192 204 195 182 180 176 326 172 169 60\n1 2\n3 2\n4 2\n5 2\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 60 195 172 169 60 "]}, {"input": "10 18\n214 204 195 324 137 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n2 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 204 137 137 176 172 169 167 "]}, {"input": "7 6\n3 2 4 12 2 5 6\n1 2\n2 3\n3 7\n4 5\n4 6\n6 7\n", "output": ["2 2 4 2 2 5 6 "]}, {"input": "1 0\n5 1\n1 2\n", "output": ["5 "]}, {"input": "3 0\n5 1\n1 2\n", "output": ["5 1 1 "]}, {"input": "10 18\n192 30 348 52 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n6 10\n", "output": ["192 192 192 167 180 167 176 167 169 167 "]}, {"input": "10 18\n339 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 180 167 176 172 169 167 "]}, {"input": "1 0\n2 1\n0 2\n", "output": ["2 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 203 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 137 137 176 172 203 167 "]}, {"input": "7 6\n3 1 4 12 2 4 6\n1 1\n2 3\n3 4\n5 5\n5 3\n6 7\n", "output": ["3 1 4 12 2 4 6 "]}, {"input": "10 18\n192 204 195 182 180 176 326 146 169 60\n1 2\n3 2\n4 2\n5 2\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 60 195 146 169 60 "]}, {"input": "10 18\n214 204 195 324 137 176 176 172 17 167\n1 2\n3 2\n4 2\n5 2\n2 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 204 137 17 176 172 17 167 "]}, {"input": "10 18\n214 204 195 182 180 176 111 172 169 167\n1 2\n3 2\n4 3\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 5\n6 4\n6 5\n1 7\n3 8\n6 9\n6 10\n", "output": ["180 204 182 182 180 167 180 182 169 167 "]}, {"input": "1 0\n9 1\n1 2\n", "output": ["9 "]}, {"input": "10 18\n339 204 195 182 96 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 96 176 172 169 167 "]}, {"input": "10 18\n176 204 195 182 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n2 9\n6 10\n", "output": ["176 182 180 182 180 167 176 180 182 167 "]}, {"input": "10 3\n214 204 195 182 180 176 176 113 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n7 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 176 176 113 169 167 "]}, {"input": "1 0\n1 1\n0 2\n", "output": ["1 "]}, {"input": "10 18\n214 204 195 324 54 176 176 172 17 167\n1 2\n3 2\n4 2\n5 2\n2 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 204 54 17 176 172 17 167 "]}, {"input": "7 6\n3 1 4 10 2 1 6\n1 2\n2 3\n3 3\n4 5\n5 6\n6 7\n", "output": ["1 1 4 2 2 2 6 "]}, {"input": "10 18\n176 204 195 182 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n8 7\n3 8\n2 9\n6 10\n", "output": ["176 182 176 182 176 167 176 176 182 167 "]}, {"input": "10 3\n214 204 195 182 180 227 176 113 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n7 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n214 204 195 182 60 176 176 172 203 167\n1 2\n3 2\n4 3\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 60 60 176 172 203 167 "]}, {"input": "10 18\n78 204 93 182 180 260 14 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 10\n", "output": ["78 204 78 182 180 14 14 172 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 46 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 192 192 167 180 167 46 167 169 167 "]}, {"input": "7 6\n3 1 4 10 2 1 6\n1 2\n2 3\n3 3\n1 5\n5 6\n6 7\n", "output": ["1 1 4 10 1 1 6 "]}, {"input": "10 18\n214 262 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 2\n10 2\n10 1\n6 2\n6 4\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["214 262 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n78 204 93 182 180 260 18 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 10\n", "output": ["78 204 78 182 180 18 18 172 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 46 172 169 167\n2 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 180 180 167 180 167 46 167 169 167 "]}, {"input": "10 3\n214 69 195 182 180 227 176 113 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["195 195 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 46 172 169 167\n2 2\n3 2\n4 2\n2 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 169 169 167 180 167 46 167 169 167 "]}, {"input": "10 18\n339 204 195 182 96 33 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 33 176 172 169 167 "]}, {"input": "10 18\n176 204 226 356 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 2\n8 7\n3 8\n2 9\n6 10\n", "output": ["176 204 176 204 176 167 176 176 204 167 "]}, {"input": "10 18\n214 204 195 182 60 176 176 172 203 167\n1 2\n3 2\n4 3\n5 2\n6 2\n7 2\n8 2\n9 1\n10 2\n6 1\n6 2\n6 3\n6 6\n10 5\n6 7\n6 8\n7 9\n6 10\n", "output": ["204 204 195 182 167 167 176 172 203 167 "]}, {"input": "10 18\n214 262 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 1\n10 2\n10 1\n6 2\n6 6\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["214 214 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 46 172 78 167\n2 2\n3 2\n4 2\n2 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 167 167 78 180 78 46 78 78 167 "]}, {"input": "10 3\n214 69 195 182 180 227 176 113 169 167\n1 2\n3 3\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 4\n1 8\n6 9\n6 10\n", "output": ["182 182 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n214 262 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 1\n10 2\n10 1\n6 2\n6 6\n8 4\n6 10\n6 7\n6 8\n6 9\n8 10\n", "output": ["214 214 195 182 180 169 176 169 169 169 "]}, {"input": "10 18\n78 204 93 182 180 260 18 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 3\n10 2\n3 1\n6 4\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 4\n", "output": ["93 204 93 182 180 18 18 172 93 167 "]}, {"input": "10 18\n339 204 195 182 96 33 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n9 2\n6 3\n6 4\n1 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["96 204 169 182 96 33 176 172 169 167 "]}, {"input": "10 18\n78 118 93 182 180 260 18 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 3\n10 2\n3 1\n6 4\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 4\n", "output": ["93 167 93 182 167 18 18 172 93 167 "]}, {"input": "10 18\n214 262 143 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 1\n4 2\n10 1\n6 2\n6 6\n8 4\n6 10\n6 7\n6 8\n6 9\n8 10\n", "output": ["214 214 169 182 180 169 169 169 169 169 "]}, {"input": "10 3\n214 131 195 182 180 227 176 113 169 149\n1 4\n3 3\n4 2\n0 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 2\n2 3\n6 4\n16 5\n6 4\n1 8\n2 9\n6 6\n", "output": ["182 182 195 182 180 227 176 113 169 149 "]}, {"input": "10 3\n214 131 195 182 180 227 176 113 169 149\n1 1\n3 3\n4 2\n0 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 2\n2 3\n6 4\n16 5\n6 4\n1 8\n2 9\n6 6\n", "output": ["214 131 195 131 180 227 176 113 169 149 "]}, {"input": "10 3\n214 131 195 182 180 227 176 61 169 149\n1 1\n3 3\n4 2\n0 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 1\n2 3\n6 4\n16 5\n6 8\n1 8\n2 9\n6 6\n", "output": ["214 131 195 131 180 227 176 61 169 149 "]}, {"input": "10 3\n214 131 195 182 180 227 176 61 88 149\n1 1\n3 3\n4 2\n0 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 1\n2 3\n6 4\n16 5\n6 8\n1 8\n2 9\n6 6\n", "output": ["214 131 195 131 180 227 176 61 88 149 "]}, {"input": "10 3\n214 131 195 182 180 328 176 61 88 149\n1 1\n3 3\n4 2\n1 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 1\n2 3\n6 4\n16 5\n6 12\n2 8\n2 9\n6 6\n", "output": ["214 131 195 131 180 328 176 61 88 149 "]}, {"input": "10 3\n214 131 195 182 180 328 176 61 88 149\n1 1\n1 3\n4 2\n1 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n10 1\n2 3\n6 4\n16 5\n6 12\n2 8\n2 9\n6 6\n", "output": ["195 131 195 131 180 328 176 61 88 149 "]}, {"input": "10 3\n214 131 239 182 180 328 176 61 88 149\n1 1\n1 3\n4 2\n1 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n18 1\n2 3\n6 4\n16 5\n6 12\n2 8\n2 9\n6 6\n", "output": ["214 131 239 131 180 328 176 61 88 149 "]}, {"input": "10 0\n214 131 239 182 180 328 176 61 88 149\n1 1\n1 3\n4 2\n1 2\n6 2\n7 3\n14 2\n9 3\n4 1\n6 0\n18 1\n2 3\n6 4\n16 5\n6 12\n2 8\n2 9\n6 6\n", "output": ["214 131 239 182 180 328 176 61 88 149 "]}, {"input": "10 1\n214 131 239 182 180 328 275 61 88 149\n1 1\n1 3\n4 2\n1 2\n6 3\n4 3\n14 2\n9 6\n4 1\n6 0\n18 1\n2 3\n12 4\n16 7\n6 12\n2 8\n2 9\n6 4\n", "output": ["214 131 239 182 180 328 275 61 88 149 "]}, {"input": "10 1\n214 131 239 198 180 328 275 61 88 149\n1 1\n1 3\n4 2\n1 2\n6 3\n4 3\n14 2\n9 6\n4 1\n6 0\n18 1\n2 3\n12 4\n16 7\n6 12\n2 8\n2 9\n6 4\n", "output": ["214 131 239 198 180 328 275 61 88 149 "]}, {"input": "10 1\n214 131 239 198 180 328 275 118 88 149\n1 1\n1 3\n4 2\n1 2\n2 3\n4 3\n14 2\n9 6\n4 1\n6 0\n18 1\n2 3\n12 4\n16 7\n10 12\n2 8\n2 9\n6 4\n", "output": ["214 131 239 198 180 328 275 118 88 149 "]}, {"input": "10 1\n214 131 239 198 180 328 275 38 88 149\n1 1\n1 3\n4 2\n0 2\n2 3\n4 3\n14 2\n9 6\n4 1\n6 0\n18 1\n2 3\n12 4\n16 7\n10 12\n2 8\n2 9\n6 4\n", "output": ["214 131 239 198 180 328 275 38 88 149 "]}, {"input": "10 1\n214 131 239 198 180 328 275 38 88 34\n1 1\n3 3\n6 1\n0 2\n2 3\n7 3\n14 2\n9 6\n4 1\n6 0\n31 1\n0 3\n12 4\n16 11\n10 12\n2 8\n2 9\n2 8\n", "output": ["214 131 239 198 180 328 275 38 88 34 "]}, {"input": "10 1\n214 131 239 198 180 328 275 38 90 34\n1 1\n3 3\n6 1\n0 2\n2 3\n7 3\n14 2\n9 6\n4 1\n6 0\n31 1\n0 3\n12 4\n16 11\n10 12\n4 8\n2 9\n2 8\n", "output": ["214 131 239 198 180 328 275 38 90 34 "]}, {"input": "10 1\n214 131 239 198 180 72 275 38 90 34\n1 1\n3 3\n6 1\n0 4\n2 3\n7 3\n14 2\n9 6\n4 1\n6 0\n31 1\n0 3\n12 4\n16 11\n10 12\n4 8\n2 9\n2 8\n", "output": ["214 131 239 198 180 72 275 38 90 34 "]}, {"input": "10 1\n214 131 239 198 180 72 275 38 90 34\n1 2\n3 3\n6 1\n0 4\n2 3\n8 3\n14 2\n9 6\n4 1\n6 0\n31 1\n0 3\n12 4\n16 11\n10 12\n4 8\n2 9\n2 8\n", "output": ["131 131 239 198 180 72 275 38 90 34 "]}, {"input": "10 1\n214 131 239 198 180 72 128 38 90 34\n1 2\n0 3\n6 1\n0 5\n0 3\n8 2\n14 2\n11 6\n6 1\n1 0\n31 0\n0 3\n4 0\n16 11\n6 12\n4 8\n4 9\n2 6\n", "output": ["131 131 239 198 180 72 128 38 90 34 "]}, {"input": "10 1\n214 131 239 198 73 72 128 38 90 34\n1 2\n0 3\n11 1\n0 7\n0 3\n8 2\n14 2\n11 6\n9 1\n1 0\n31 0\n0 3\n4 0\n13 11\n6 12\n4 8\n4 9\n2 12\n", "output": ["131 131 239 198 73 72 128 38 90 34 "]}, {"input": "10 0\n214 131 239 198 73 72 128 38 90 34\n1 2\n0 3\n11 1\n0 7\n0 3\n8 2\n14 2\n11 6\n9 1\n1 0\n57 0\n0 3\n4 0\n13 11\n6 12\n4 8\n4 9\n2 12\n", "output": ["214 131 239 198 73 72 128 38 90 34 "]}, {"input": "10 0\n214 131 239 198 130 72 128 38 90 34\n1 2\n0 3\n11 1\n0 7\n1 3\n8 2\n14 2\n11 6\n13 1\n1 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 8\n4 5\n2 12\n", "output": ["214 131 239 198 130 72 128 38 90 34 "]}, {"input": "10 0\n214 131 239 198 130 72 128 27 90 34\n1 2\n0 3\n11 1\n0 7\n1 3\n8 2\n14 2\n11 6\n13 1\n1 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 8\n4 5\n2 12\n", "output": ["214 131 239 198 130 72 128 27 90 34 "]}, {"input": "10 0\n214 131 239 198 130 61 128 27 90 34\n1 2\n0 3\n11 1\n0 7\n1 3\n8 2\n14 2\n11 6\n13 1\n1 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 8\n4 5\n2 12\n", "output": ["214 131 239 198 130 61 128 27 90 34 "]}, {"input": "10 0\n214 131 239 198 130 61 195 27 90 34\n1 2\n0 3\n11 1\n0 7\n1 3\n8 2\n14 2\n11 6\n13 1\n0 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 8\n4 5\n2 12\n", "output": ["214 131 239 198 130 61 195 27 90 34 "]}, {"input": "10 0\n214 131 239 198 130 61 195 15 90 34\n1 2\n0 3\n13 1\n0 6\n1 3\n5 2\n14 2\n11 6\n13 1\n0 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 11\n4 5\n2 12\n", "output": ["214 131 239 198 130 61 195 15 90 34 "]}, {"input": "10 0\n214 131 239 198 130 61 195 15 90 47\n1 2\n0 3\n13 1\n0 6\n1 3\n5 2\n14 2\n11 6\n13 1\n0 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 11\n4 5\n2 12\n", "output": ["214 131 239 198 130 61 195 15 90 47 "]}, {"input": "10 0\n214 97 239 198 130 61 195 15 90 47\n2 2\n0 3\n13 1\n0 6\n1 3\n2 2\n14 2\n11 6\n13 1\n0 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 11\n3 5\n2 12\n", "output": ["214 97 239 198 130 61 195 15 90 47 "]}, {"input": "10 0\n214 97 457 198 130 61 195 15 90 47\n2 2\n0 3\n13 1\n0 6\n1 3\n2 2\n18 2\n11 6\n13 2\n0 0\n57 0\n0 5\n4 0\n9 11\n8 12\n1 11\n3 5\n2 12\n", "output": ["214 97 457 198 130 61 195 15 90 47 "]}, {"input": "8 0\n214 97 457 198 130 61 195 15 90 47\n2 2\n0 3\n13 1\n0 6\n1 3\n2 3\n18 2\n11 6\n13 2\n-1 0\n57 -1\n0 5\n4 0\n16 14\n8 12\n1 11\n6 5\n2 12\n", "output": ["214 97 457 198 130 61 195 15 "]}, {"input": "8 0\n214 97 457 198 99 61 195 15 90 47\n1 2\n0 3\n13 1\n0 6\n0 3\n2 3\n18 1\n11 6\n13 2\n-1 0\n30 -1\n0 5\n4 -1\n16 14\n8 12\n1 11\n6 5\n2 12\n", "output": ["214 97 457 198 99 61 195 15 "]}, {"input": "8 0\n214 97 596 198 99 61 195 15 90 47\n1 2\n0 3\n13 1\n-1 0\n0 3\n2 6\n34 1\n11 3\n13 1\n-1 0\n30 -1\n0 5\n4 -1\n16 14\n8 9\n2 11\n4 5\n2 10\n", "output": ["214 97 596 198 99 61 195 15 "]}, {"input": "8 0\n214 97 872 198 99 61 195 15 90 47\n1 2\n0 3\n13 1\n-1 0\n0 3\n2 6\n34 1\n11 3\n13 1\n-1 0\n30 -1\n0 5\n4 -1\n16 14\n8 9\n2 11\n4 5\n2 10\n", "output": ["214 97 872 198 99 61 195 15 "]}, {"input": "8 0\n214 97 872 198 126 61 195 15 90 47\n1 2\n0 3\n13 1\n-1 -1\n0 3\n2 6\n34 1\n1 3\n13 1\n-1 0\n30 -1\n1 5\n4 -1\n16 14\n2 9\n3 11\n4 5\n2 10\n", "output": ["214 97 872 198 126 61 195 15 "]}, {"input": "8 0\n214 97 1603 198 126 61 195 15 89 47\n1 2\n0 3\n18 1\n-1 -2\n0 5\n2 6\n34 1\n1 3\n24 1\n-1 0\n35 -1\n1 5\n4 -1\n12 14\n2 9\n1 11\n4 5\n2 10\n", "output": ["214 97 1603 198 126 61 195 15 "]}, {"input": "8 0\n214 97 1603 198 126 61 41 15 89 47\n1 2\n0 3\n18 0\n-1 -2\n0 5\n2 6\n34 1\n1 3\n24 1\n-1 0\n35 -1\n1 5\n4 -1\n12 14\n2 9\n1 11\n4 5\n1 10\n", "output": ["214 97 1603 198 126 61 41 15 "]}, {"input": "4 0\n214 97 1603 198 126 61 41 15 89 47\n1 0\n-1 3\n18 0\n-2 -2\n0 5\n2 5\n34 2\n1 3\n24 2\n-1 0\n35 -1\n2 5\n2 -1\n12 0\n1 9\n1 12\n4 5\n1 8\n", "output": ["214 97 1603 198 "]}, {"input": "4 0\n214 75 1603 198 126 61 41 15 89 7\n1 -1\n-1 3\n18 0\n-2 -2\n0 5\n2 1\n34 2\n1 3\n24 2\n-1 0\n35 -2\n2 5\n0 -1\n18 -1\n2 8\n1 12\n8 5\n1 8\n", "output": ["214 75 1603 198 "]}, {"input": "4 0\n214 142 1603 198 126 61 41 15 89 7\n1 -1\n-1 3\n18 0\n-2 -2\n0 5\n2 1\n34 2\n1 3\n24 2\n-1 0\n35 -2\n0 5\n0 -1\n18 -1\n2 8\n1 12\n8 5\n1 8\n", "output": ["214 142 1603 198 "]}, {"input": "7 6\n3 1 4 9 2 5 6\n1 1\n2 3\n3 4\n4 5\n4 6\n6 7\n", "output": ["3 1 4 4 4 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "7 6\n3 1 4 9 2 5 6\n1 1\n2 3\n3 4\n4 5\n5 3\n6 7\n", "output": ["3 1 4 4 4 5 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 176 182 180 167 176 176 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n2 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 260 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "2 1\n3 1\n1 2\n", "output": ["1 1 "]}, {"input": "4 6\n6 5 13 2\n3 2\n4 1\n3 2\n1 2\n2 3\n3 1\n", "output": ["6 6 6 2 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 137 207 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 182 137 137 176 172 169 167 "]}, {"input": "10 18\n214 204 93 182 180 260 176 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 167 182 180 167 167 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 93 182 180 260 176 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 4\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 167 182 180 167 167 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 3\n8 4\n6 5\n6 10\n6 8\n6 9\n6 10\n", "output": ["192 204 204 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n6 10\n", "output": ["192 204 204 182 180 167 176 172 169 167 "]}, {"input": "4 6\n6 5 8 2\n3 1\n4 1\n3 1\n1 2\n2 3\n3 1\n", "output": ["6 6 6 2 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 1\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n6 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "4 6\n6 5 8 2\n3 4\n4 1\n3 2\n1 2\n2 3\n3 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n5 2\n4 2\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n6 9\n6 10\n", "output": ["204 204 176 182 180 167 176 176 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n2 2\n10 2\n6 1\n6 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n2 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 182 137 137 176 172 169 167 "]}, {"input": "7 6\n3 2 4 12 2 5 6\n1 1\n2 3\n3 7\n4 5\n4 6\n6 7\n", "output": ["3 2 4 2 2 5 6 "]}, {"input": "10 18\n214 204 93 182 180 260 176 172 169 167\n1 2\n3 1\n4 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 167 182 180 167 167 172 169 167 "]}, {"input": "10 18\n214 204 195 182 137 207 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 3\n6 3\n6 4\n6 5\n1 7\n6 8\n6 9\n6 10\n", "output": ["176 204 195 182 137 137 176 172 169 167 "]}, {"input": "4 6\n6 5 13 2\n3 2\n4 1\n3 4\n1 2\n2 3\n2 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 3\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n5 1\n7 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 4\n8 2\n9 2\n10 2\n6 1\n7 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 204 182 180 167 176 172 169 167 "]}, {"input": "10 18\n192 204 348 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 3\n6 1\n7 2\n6 3\n8 4\n6 5\n6 10\n6 8\n6 9\n6 10\n", "output": ["192 204 204 182 180 167 176 172 169 167 "]}, {"input": "10 18\n339 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n3 9\n6 10\n", "output": ["204 204 169 182 180 167 176 172 169 167 "]}, {"input": "10 18\n339 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n9 2\n7 3\n6 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "2 0\n2 1\n0 2\n", "output": ["2 1 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 134 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 137 134 176 172 134 167 "]}, {"input": "4 6\n6 5 8 2\n3 4\n4 1\n3 2\n1 3\n2 3\n3 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n2 2\n10 2\n6 1\n6 2\n6 4\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 111 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 5\n6 4\n6 5\n1 7\n3 8\n6 9\n6 10\n", "output": ["180 204 180 182 180 167 180 180 169 167 "]}, {"input": "4 6\n11 5 13 2\n3 2\n4 1\n3 4\n1 2\n2 3\n2 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n214 204 93 182 180 260 14 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 93 182 180 14 14 172 169 167 "]}, {"input": "10 18\n192 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n5 1\n12 2\n6 3\n8 4\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["192 204 195 182 180 167 176 172 169 167 "]}, {"input": "7 6\n3 1 7 10 2 1 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 2 2 2 2 6 "]}, {"input": "10 18\n214 204 195 182 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n6 7\n3 8\n2 9\n6 10\n", "output": ["204 204 180 182 180 167 176 180 204 167 "]}, {"input": "10 3\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n7 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 176 176 172 169 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n2 2\n10 2\n6 1\n6 2\n6 4\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "4 6\n22 5 13 2\n3 2\n4 1\n3 4\n1 2\n2 3\n2 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n214 204 93 182 180 260 14 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 2\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 10\n", "output": ["204 204 93 182 180 14 14 172 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n10 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 192 192 167 180 167 176 167 169 167 "]}, {"input": "7 6\n3 1 4 10 2 1 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": ["1 1 2 2 2 2 6 "]}, {"input": "10 18\n214 204 195 182 137 176 176 172 203 167\n1 2\n3 2\n4 3\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 137 137 176 172 203 167 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n2 2\n10 2\n10 1\n6 2\n6 4\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "4 6\n22 5 13 0\n3 2\n4 1\n3 4\n1 2\n2 3\n2 1\n", "output": ["5 5 5 5 "]}, {"input": "10 18\n214 204 93 182 180 260 14 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 10\n", "output": ["204 204 93 182 180 14 14 172 169 167 "]}, {"input": "10 18\n192 30 348 52 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 192 192 167 180 167 176 167 169 167 "]}, {"input": "10 18\n339 204 195 182 96 183 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 96 176 172 169 167 "]}, {"input": "1 0\n1 2\n0 2\n", "output": ["1 "]}, {"input": "10 18\n214 204 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 2\n10 2\n10 1\n6 2\n6 4\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n339 204 195 182 96 183 176 172 169 167\n1 2\n3 2\n4 2\n5 4\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 96 176 172 169 167 "]}, {"input": "10 18\n176 204 195 182 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 2\n8 7\n3 8\n2 9\n6 10\n", "output": ["176 182 176 182 176 167 176 176 182 167 "]}, {"input": "10 3\n214 204 195 182 180 227 176 113 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 7\n1 8\n6 9\n6 10\n", "output": ["204 204 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n214 204 195 182 60 176 176 172 203 167\n1 2\n3 2\n4 3\n5 2\n6 2\n7 2\n8 2\n9 1\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n6 9\n6 10\n", "output": ["204 204 195 182 60 60 176 172 203 167 "]}, {"input": "10 18\n339 204 195 182 96 183 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 96 176 172 169 167 "]}, {"input": "10 18\n176 204 226 182 180 176 176 82 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 2\n8 7\n3 8\n2 9\n6 10\n", "output": ["176 182 176 182 176 167 176 176 182 167 "]}, {"input": "10 18\n214 204 195 182 60 176 176 172 203 167\n1 2\n3 2\n4 3\n5 2\n6 2\n7 2\n8 2\n9 1\n10 2\n6 1\n6 2\n6 3\n6 6\n6 5\n6 7\n6 8\n7 9\n6 10\n", "output": ["204 204 195 182 60 60 176 172 203 167 "]}, {"input": "10 18\n214 262 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 2\n10 2\n10 1\n6 2\n6 6\n8 4\n6 10\n6 7\n6 8\n6 9\n6 10\n", "output": ["214 262 195 182 180 167 176 172 169 167 "]}, {"input": "10 18\n78 204 93 182 180 260 18 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 2\n10 2\n3 1\n6 2\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 4\n", "output": ["78 204 78 182 180 18 18 172 169 167 "]}, {"input": "10 3\n214 69 195 182 180 227 176 113 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 4\n1 8\n6 9\n6 10\n", "output": ["195 195 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n78 204 93 182 180 260 18 172 169 167\n1 2\n3 2\n7 2\n5 2\n9 2\n7 3\n8 4\n9 2\n10 2\n3 1\n6 4\n6 3\n6 4\n6 5\n6 7\n10 8\n6 9\n6 4\n", "output": ["78 204 78 182 180 18 18 172 169 167 "]}, {"input": "10 18\n339 204 195 182 96 33 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 2\n8 2\n9 2\n10 2\n6 1\n9 2\n6 3\n6 4\n6 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["176 204 169 182 96 33 176 172 169 167 "]}, {"input": "10 18\n176 204 226 356 180 176 176 82 169 167\n1 2\n5 2\n4 2\n5 2\n6 2\n5 3\n8 2\n9 2\n10 2\n6 1\n6 2\n6 3\n6 4\n6 2\n8 7\n3 8\n2 9\n6 10\n", "output": ["176 204 176 204 176 167 176 176 204 167 "]}, {"input": "10 18\n192 30 348 52 180 176 46 172 78 167\n2 2\n3 2\n2 2\n2 3\n10 2\n7 3\n8 2\n9 2\n6 2\n6 1\n7 2\n6 6\n8 4\n6 5\n6 10\n6 8\n6 9\n4 10\n", "output": ["192 167 167 78 180 78 46 78 78 167 "]}, {"input": "10 3\n214 69 195 182 180 227 176 113 169 167\n1 2\n3 3\n4 2\n0 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 4\n1 8\n6 9\n6 10\n", "output": ["182 182 195 182 180 227 176 113 169 167 "]}, {"input": "10 18\n214 262 195 182 180 176 176 172 169 167\n1 2\n3 2\n4 2\n5 2\n6 2\n7 3\n8 4\n2 1\n4 2\n10 1\n6 2\n6 6\n8 4\n6 10\n6 7\n6 8\n6 9\n8 10\n", "output": ["214 214 195 182 180 169 176 169 169 169 "]}, {"input": "10 18\n339 204 195 182 96 33 176 172 169 167\n1 2\n3 2\n4 2\n5 1\n6 2\n7 2\n8 2\n9 2\n3 2\n6 1\n9 2\n6 3\n6 4\n1 5\n1 7\n3 8\n3 9\n6 10\n", "output": ["96 204 169 182 96 33 176 172 169 167 "]}, {"input": "10 3\n214 131 195 182 180 227 176 113 169 167\n1 2\n3 3\n4 2\n0 2\n6 2\n7 3\n8 2\n9 2\n10 2\n6 1\n6 2\n2 3\n6 4\n7 5\n6 4\n1 8\n6 9\n6 10\n", "output": ["182 182 195 182 180 227 176 113 169 167 "]}], "source_codes": ["import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        indegree[v] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Compute lower bounds (forward pass)\n    lower_bound = a[:]\n    for node in topo_order:\n        for neighbor in graph[node]:\n            lower_bound[neighbor] = max(lower_bound[neighbor], lower_bound[node])\n    \n    # Compute upper bounds (backward pass)\n    upper_bound = a[:]\n    for node in reversed(topo_order):\n        for prev_node in reverse_graph[node]:\n            upper_bound[prev_node] = min(upper_bound[prev_node], upper_bound[node])\n    \n    # For each node, choose the value that minimizes operations\n    result = [0] * (n + 1)\n    for i in range(1, n + 1):\n        lower = lower_bound[i]\n        upper = upper_bound[i]\n        original = a[i]\n        \n        # Choose the value in [lower, upper] closest to original\n        if original < lower:\n            result[i] = lower\n        elif original > upper:\n            result[i] = upper\n        else:\n            result[i] = original\n    \n    print(' '.join(map(str, result[1:])))\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, edges):\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n    \n    visited = [False] * (n + 1)\n    stack = []\n    \n    def dfs1(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        stack.append(node)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    visited = [False] * (n + 1)\n    scc = [0] * (n + 1)\n    scc_nodes = []\n    scc_index = 0\n    \n    def dfs2(node):\n        visited[node] = True\n        scc[node] = scc_index\n        scc_group.append(node)\n        for neighbor in reverse_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor)\n    \n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            scc_group = []\n            scc_index += 1\n            dfs2(node)\n            scc_nodes.append(scc_group)\n    \n    return scc, scc_nodes, scc_index\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        edges.append((u, v))\n    \n    scc, scc_nodes, num_scc = find_scc(n, edges)\n    \n    # Build SCC graph\n    scc_graph = defaultdict(set)\n    in_degree = defaultdict(int)\n    scc_scores = {}\n    \n    # For each SCC, store nodes in it\n    scc_to_nodes = defaultdict(list)\n    for i in range(1, n + 1):\n        scc_to_nodes[scc[i]].append(i)\n    \n    # Build SCC dependency graph\n    for u, v in edges:\n        scc_u = scc[u]\n        scc_v = scc[v]\n        if scc_u != scc_v and scc_v not in scc_graph[scc_u]:\n            scc_graph[scc_u].add(scc_v)\n            in_degree[scc_v] += 1\n    \n    # Ensure all SCCs are in in_degree\n    all_scc_ids = set(range(1, num_scc + 1))\n    for scc_id in all_scc_ids:\n        if scc_id not in in_degree:\n            in_degree[scc_id] = 0\n    \n    # Topological sort\n    queue = deque()\n    for scc_id in all_scc_ids:\n        if in_degree[scc_id] == 0:\n            queue.append(scc_id)\n    \n    topo_order = []\n    while queue:\n        current = queue.popleft()\n        topo_order.append(current)\n        for neighbor in scc_graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Initialize SCC scores\n    scc_final_scores = {}\n    \n    # Process SCCs in topological order\n    for scc_id in topo_order:\n        # Get all initial scores in this SCC\n        nodes_in_scc = scc_to_nodes[scc_id]\n        scores_in_scc = [a[node] for node in nodes_in_scc]\n        \n        # Determine the minimum valid score for this SCC\n        min_valid_score = float('-inf')\n        for prev_scc in range(1, scc_id):  # Check all previous SCCs\n            if scc_id in scc_graph[prev_scc]:  # If there's an edge from prev_scc to scc_id\n                if prev_scc in scc_final_scores:\n                    min_valid_score = max(min_valid_score, scc_final_scores[prev_scc])\n        \n        # For nodes within the same SCC, they must have the same value\n        # We want to minimize sum of |original_score - chosen_value|\n        # The optimal value is the median, but constrained by min_valid_score\n        \n        scores_in_scc.sort()\n        median = scores_in_scc[len(scores_in_scc) // 2]\n        \n        # Choose the best value that satisfies constraints\n        optimal_score = max(min_valid_score, median) if min_valid_score != float('-inf') else median\n        \n        # But we should be more careful - we want to minimize total operations\n        # Let's check a few candidates around the median\n        best_score = optimal_score\n        min_cost = sum(abs(score - optimal_score) for score in scores_in_scc)\n        \n        # Check values around median that might be better\n        candidates = [optimal_score]\n        if len(scores_in_scc) > 0:\n            candidates.extend(scores_in_scc)\n            if min_valid_score != float('-inf'):\n                candidates.append(min_valid_score)\n        \n        for candidate in candidates:\n            if min_valid_score != float('-inf') and candidate < min_valid_score:\n                continue\n            cost = sum(abs(score - candidate) for score in scores_in_scc)\n            if cost < min_cost:\n                min_cost = cost\n                best_score = candidate\n        \n        scc_final_scores[scc_id] = best_score\n    \n    # Handle remaining SCCs (those with cycles that weren't processed properly)\n    # Actually, let's redo this with proper constraint propagation\n    \n    # Reset and do it properly\n    scc_final_scores = {}\n    \n    # First pass: forward propagation\n    for scc_id in topo_order:\n        nodes_in_scc = scc_to_nodes[scc_id]\n        scores_in_scc = [a[node] for node in nodes_in_scc]\n        scores_in_scc.sort()\n        \n        # Minimum value this SCC can have based on predecessors\n        min_val = float('-inf')\n        for prev_scc in all_scc_ids:\n            if scc_id in scc_graph[prev_scc] and prev_scc in scc_final_scores:\n                min_val = max(min_val, scc_final_scores[prev_scc])\n        \n        # Find optimal value for this SCC\n        if scores_in_scc:\n            # Median minimizes sum of absolute deviations\n            median_val = scores_in_scc[len(scores_in_scc) // 2]\n            scc_final_scores[scc_id] = max(min_val, median_val) if min_val != float('-inf') else median_val\n        else:\n            scc_final_scores[scc_id] = 0\n    \n    # Second pass: backward propagation to refine\n    for scc_id in reversed(topo_order):\n        max_val = float('inf')\n        for next_scc in scc_graph[scc_id]:\n            if next_scc in scc_final_scores:\n                max_val = min(max_val, scc_final_scores[next_scc])\n        \n        if max_val != float('inf') and scc_id in scc_final_scores:\n            scc_final_scores[scc_id] = min(scc_final_scores[scc_id], max_val)\n    \n    result = [0] * (n + 1)\n    for i in range(1, n + 1):\n        result[i] = scc_final_scores[scc[i]]\n    \n    print(' '.join(map(str, result[1:])))\n\nsolve()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and reverse graph\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    index = 2 + n\n    for _ in range(m):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        index += 2\n    \n    # Initialize result array\n    b = a[:]\n    \n    # Forward pass: ensure each node is >= max of its predecessors\n    # Topological sort for forward propagation\n    indegree = [0] * n\n    for i in range(n):\n        for neighbor in graph[i]:\n            indegree[neighbor] += 1\n    \n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            b[v] = max(b[v], b[u])\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    # Backward pass: ensure each node is <= min of its successors\n    # Topological sort for backward propagation\n    outdegree = [0] * n\n    for i in range(n):\n        outdegree[i] = len(graph[i])\n    \n    queue = deque()\n    for i in range(n):\n        if outdegree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        v = queue.popleft()\n        # Find the minimum upper bound from all successors\n        if graph[v]:  # if v has successors\n            min_successor = min(b[succ] for succ in graph[v])\n            b[v] = min(b[v], min_successor)\n        \n        # Process predecessors\n        for pred in reverse_graph[v]:\n            outdegree[pred] -= 1\n            if outdegree[pred] == 0:\n                queue.append(pred)\n    \n    # Final adjustment: for each node, try to bring it closer to original value\n    # while respecting constraints\n    changed = True\n    while changed:\n        changed = False\n        \n        # Forward pass\n        for u in range(n):\n            for v in graph[u]:\n                if b[u] > b[v]:\n                    b[v] = b[u]\n                    changed = True\n        \n        # Backward pass\n        for v in range(n):\n            if graph[v]:  # if v has successors\n                min_succ = min(b[succ] for succ in graph[v])\n                if b[v] > min_succ:\n                    b[v] = min_succ\n                    changed = True\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, edges):\n    # Build adjacency list and reverse adjacency list\n    graph = defaultdict(list)\n    rev_graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        rev_graph[v].append(u)\n    \n    # Step 1: First DFS to get finishing times\n    visited = [False] * (n + 1)\n    finish_stack = []\n    \n    def dfs1(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        finish_stack.append(node)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Step 2: Second DFS on reversed graph in order of decreasing finishing times\n    visited = [False] * (n + 1)\n    scc_map = {}\n    scc_id = 0\n    \n    def dfs2(node, sid):\n        visited[node] = True\n        scc_map[node] = sid\n        for neighbor in rev_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, sid)\n    \n    while finish_stack:\n        node = finish_stack.pop()\n        if not visited[node]:\n            dfs2(node, scc_id)\n            scc_id += 1\n    \n    return scc_map, scc_id\n\ndef find_median(values):\n    \"\"\"Find the value that minimizes sum of absolute differences\"\"\"\n    sorted_vals = sorted(values)\n    n = len(sorted_vals)\n    if n % 2 == 1:\n        return sorted_vals[n // 2]\n    else:\n        # For even length, any value between the two middle elements is optimal\n        # We'll pick the lower middle element\n        return sorted_vals[n // 2 - 1]\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    a = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed\n    \n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v))\n    \n    # Find SCCs\n    scc_map, num_scc = find_scc(n, edges)\n    \n    # Group nodes by SCC\n    scc_nodes = defaultdict(list)\n    for node in range(1, n + 1):\n        scc_nodes[scc_map[node]].append(node)\n    \n    # Build SCC graph and compute in-degrees\n    scc_graph = defaultdict(set)\n    in_degree = [0] * num_scc\n    \n    for u, v in edges:\n        scc_u, scc_v = scc_map[u], scc_map[v]\n        if scc_u != scc_v:\n            if scc_v not in scc_graph[scc_u]:  # Avoid duplicate edges\n                scc_graph[scc_u].add(scc_v)\n                in_degree[scc_v] += 1\n    \n    # For each SCC, collect original values\n    scc_values_list = defaultdict(list)\n    for node in range(1, n + 1):\n        sid = scc_map[node]\n        scc_values_list[sid].append(a[node])\n    \n    # Find optimal unconstrained value for each SCC (median)\n    scc_unconstrained_optimal = [0] * num_scc\n    for i in range(num_scc):\n        scc_unconstrained_optimal[i] = find_median(scc_values_list[i])\n    \n    # Topological sort processing\n    # Convert sets to lists for consistent iteration\n    scc_graph = {k: list(v) for k, v in scc_graph.items()}\n    \n    # Initialize with unconstrained optima\n    scc_optimal_value = scc_unconstrained_optimal[:]\n    \n    # Then do topological sort to enforce constraints\n    in_degree_copy = in_degree[:]\n    queue = deque()\n    for i in range(num_scc):\n        if in_degree_copy[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        curr_scc = queue.popleft()\n        \n        # Propagate constraint to neighbors\n        for next_scc in scc_graph.get(curr_scc, []):\n            # next_scc's value must be >= curr_scc's value\n            scc_optimal_value[next_scc] = max(scc_optimal_value[next_scc], scc_optimal_value[curr_scc])\n            in_degree_copy[next_scc] -= 1\n            if in_degree_copy[next_scc] == 0:\n                queue.append(next_scc)\n    \n    # Assign final values\n    result = [0] * (n + 1)\n    for node in range(1, n + 1):\n        sid = scc_map[node]\n        result[node] = scc_optimal_value[sid]\n    \n    print(' '.join(map(str, result[1:])))\n\nsolve()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [int(data[idx + i]) for i in range(n)]\n    idx += n\n    \n    # Build graph and compute in-degrees\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    in_degree = [0] * n\n    \n    for _ in range(m):\n        u = int(data[idx]) - 1\n        v = int(data[idx+1]) - 1\n        idx += 2\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        in_degree[v] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    in_degree_copy = in_degree[:]\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            in_degree_copy[neighbor] -= 1\n            if in_degree_copy[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Initialize result array\n    b = a[:]\n    \n    # Forward pass: ensure each node >= all its predecessors\n    for node in topo_order:\n        for neighbor in graph[node]:\n            b[neighbor] = max(b[neighbor], b[node])\n    \n    # Backward pass: ensure each node <= all its successors\n    for node in reversed(topo_order):\n        for predecessor in reverse_graph[node]:\n            b[predecessor] = min(b[predecessor], b[node])\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and compute in-degrees\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    indegree = [0] * n\n    outdegree = [0] * n\n    \n    idx = 2 + n\n    for _ in range(m):\n        u = int(data[idx]) - 1  # Convert to 0-indexed\n        v = int(data[idx+1]) - 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        indegree[v] += 1\n        outdegree[u] += 1\n        idx += 2\n\n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Also get reverse topological order\n    queue = deque()\n    for i in range(n):\n        if outdegree[i] == 0:\n            queue.append(i)\n    \n    reverse_topo_order = []\n    outdegree_copy = outdegree[:]\n    while queue:\n        node = queue.popleft()\n        reverse_topo_order.append(node)\n        for predecessor in reverse_graph[node]:\n            outdegree_copy[predecessor] -= 1\n            if outdegree_copy[predecessor] == 0:\n                queue.append(predecessor)\n    \n    # Compute bounds\n    min_bound = [-float('inf')] * n\n    max_bound = [float('inf')] * n\n    \n    # Set initial bounds based on no constraints\n    for i in range(n):\n        min_bound[i] = a[i]\n        max_bound[i] = a[i]\n    \n    # Forward pass: propagate minimum values\n    for node in topo_order:\n        for neighbor in graph[node]:\n            min_bound[neighbor] = max(min_bound[neighbor], min_bound[node])\n    \n    # Backward pass: propagate maximum values\n    for node in reverse_topo_order:\n        for predecessor in reverse_graph[node]:\n            max_bound[predecessor] = min(max_bound[predecessor], max_bound[node])\n    \n    # Final result: for each node, choose value closest to original within bounds\n    b = [0] * n\n    for i in range(n):\n        # Clamp the original value between min and max bounds\n        b[i] = max(min_bound[i], min(max_bound[i], a[i]))\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, graph):\n    # Kosaraju's algorithm\n    visited = [False] * n\n    order = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Transpose graph\n    transposed = defaultdict(list)\n    for u in graph:\n        for v in graph[u]:\n            transposed[v].append(u)\n    \n    visited = [False] * n\n    scc = [-1] * n\n    scc_id = 0\n    \n    def dfs2(u):\n        visited[u] = True\n        scc[u] = scc_id\n        for v in transposed[u]:\n            if not visited[v]:\n                dfs2(v)\n    \n    while order:\n        u = order.pop()\n        if not visited[u]:\n            dfs2(u)\n            scc_id += 1\n    \n    return scc, scc_id\n\ndef build_scc_dag(n, graph, scc):\n    # Build DAG of SCCs\n    dag = defaultdict(set)\n    in_degree = defaultdict(int)\n    \n    for u in range(n):\n        for v in graph[u]:\n            if scc[u] != scc[v]:\n                if scc[v] not in dag[scc[u]]:\n                    dag[scc[u]].add(scc[v])\n                    in_degree[scc[v]] += 1\n    \n    # Ensure all SCCs are in in_degree dict\n    unique_sccs = set(scc)\n    for scc_id in unique_sccs:\n        if scc_id not in in_degree:\n            in_degree[scc_id] = 0\n    \n    return dag, in_degree\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    \n    # Find SCCs\n    scc, scc_count = find_scc(n, graph)\n    \n    # Group nodes by SCC\n    scc_nodes = defaultdict(list)\n    for i in range(n):\n        scc_nodes[scc[i]].append(i)\n    \n    # Build DAG of SCCs\n    dag, in_degree = build_scc_dag(n, graph, scc)\n    \n    # Topological sort of SCCs\n    queue = deque()\n    unique_sccs = list(set(scc))\n    \n    for scc_id in unique_sccs:\n        if in_degree[scc_id] == 0:\n            queue.append(scc_id)\n    \n    topo_order = []\n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in dag[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    # Initialize SCC values with median of original values\n    scc_values = {}\n    for scc_id in unique_sccs:\n        nodes = scc_nodes[scc_id]\n        values = [a[node] for node in nodes]\n        values.sort()\n        scc_values[scc_id] = values[len(values) // 2]  # median\n    \n    # Process SCCs in topological order to satisfy constraints\n    # For each SCC, its value must be >= all predecessors' values\n    for scc_id in topo_order:\n        # Check all predecessors in the DAG\n        for pred_scc in unique_sccs:\n            if scc_id in dag[pred_scc]:  # pred_scc -> scc_id\n                scc_values[scc_id] = max(scc_values[scc_id], scc_values[pred_scc])\n    \n    # Assign final values\n    result = [0] * n\n    for i in range(n):\n        result[i] = scc_values[scc[i]]\n    \n    print(' '.join(map(str, result)))\n\nsolve()", "import sys\nfrom collections import defaultdict, deque\n\ndef kosaraju(n, edges):\n    # Build adjacency list and reverse adjacency list\n    adj = defaultdict(list)\n    rev_adj = defaultdict(list)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        rev_adj[v].append(u)\n    \n    # Step 1: Order vertices by finish time in DFS\n    visited = [False] * (n + 1)\n    finish_stack = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        finish_stack.append(u)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Step 2: Transpose DFS on reversed graph in order of decreasing finish times\n    visited = [False] * (n + 1)\n    sccs = []\n    scc_map = {}\n    \n    def dfs2(u, current_scc):\n        visited[u] = True\n        current_scc.append(u)\n        for v in rev_adj[u]:\n            if not visited[v]:\n                dfs2(v, current_scc)\n    \n    while finish_stack:\n        u = finish_stack.pop()\n        if not visited[u]:\n            current_scc = []\n            dfs2(u, current_scc)\n            sccs.append(current_scc)\n            for node in current_scc:\n                scc_map[node] = len(sccs) - 1\n    \n    return sccs, scc_map\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        edges.append((u, v))\n    \n    # Find SCCs\n    sccs, scc_map = kosaraju(n, edges)\n    k = len(sccs)\n    \n    # Build condensed graph\n    condensed_adj = defaultdict(list)\n    condensed_rev_adj = defaultdict(list)\n    condensed_indegree = [0] * k\n    condensed_edges = set()\n    \n    for u, v in edges:\n        scc_u = scc_map[u]\n        scc_v = scc_map[v]\n        if scc_u != scc_v and (scc_u, scc_v) not in condensed_edges:\n            condensed_adj[scc_u].append(scc_v)\n            condensed_rev_adj[scc_v].append(scc_u)\n            condensed_indegree[scc_v] += 1\n            condensed_edges.add((scc_u, scc_v))\n    \n    # Topological sort of SCCs\n    queue = deque()\n    for i in range(k):\n        if condensed_indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in condensed_adj[u]:\n            condensed_indegree[v] -= 1\n            if condensed_indegree[v] == 0:\n                queue.append(v)\n    \n    # Initialize result array\n    b = [0] * (n + 1)\n    \n    # For each SCC, compute the optimal value\n    # min_limit tracks the minimum value an SCC can have based on predecessors\n    min_limit = [-float('inf')] * k\n    \n    # Process SCCs in topological order\n    for scc_id in topo_order:\n        scc = sccs[scc_id]\n        # Collect all original values in this SCC\n        vals = [a[node] for node in scc]\n        vals.sort()\n        # Median minimizes sum of absolute deviations\n        median = vals[len(vals) // 2]\n        \n        # The final value must be at least min_limit[scc_id] \n        # and respect the median choice\n        final_value = max(min_limit[scc_id], median)\n        \n        # Assign this value to all nodes in SCC\n        for node in scc:\n            b[node] = final_value\n        \n        # Update min_limit for successors\n        for succ in condensed_adj[scc_id]:\n            if min_limit[succ] < final_value:\n                min_limit[succ] = final_value\n    \n    # Output results without trailing space\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(b[i]))\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and in-degree count\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    idx = 2 + n\n    for _ in range(m):\n        u = int(data[idx]) - 1  # Convert to 0-indexed\n        v = int(data[idx+1]) - 1  # Convert to 0-indexed\n        graph[u].append(v)\n        indegree[v] += 1\n        idx += 2\n    \n    # Initialize result array with original scores\n    b = a[:]\n    \n    # Kahn's algorithm for topological sorting\n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    # Store topological order\n    topo_order = []\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Forward pass: ensure each node is at least as large as its predecessors\n    for node in topo_order:\n        for neighbor in graph[node]:\n            b[neighbor] = max(b[neighbor], b[node])\n    \n    # Backward pass: ensure each node is at most as large as its successors\n    # Process in reverse topological order\n    for node in reversed(topo_order):\n        for neighbor in graph[node]:\n            b[node] = min(b[node], b[neighbor])\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import defaultdict, deque\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    n, m = read_ints()\n    a = [0] + read_ints()  # 1-indexed\n    \n    # Read constraints\n    edges = []\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    for _ in range(m):\n        u, v = read_ints()\n        edges.append((u, v))\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n    \n    # Find SCCs using Kosaraju's algorithm\n    def dfs1(node, visited, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor, visited, stack)\n        stack.append(node)\n    \n    def dfs2(node, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in reverse_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, visited, component)\n    \n    # First DFS\n    visited = [False] * (n + 1)\n    stack = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i, visited, stack)\n    \n    # Second DFS on reverse graph\n    visited = [False] * (n + 1)\n    sccs = []\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs2(node, visited, component)\n            sccs.append(component)\n    \n    # Create mapping from node to SCC index\n    node_to_scc = [0] * (n + 1)\n    for i, component in enumerate(sccs):\n        for node in component:\n            node_to_scc[node] = i\n    \n    # Build condensed graph\n    condensed_graph = defaultdict(set)\n    condensed_reverse = defaultdict(set)\n    \n    for u, v in edges:\n        scc_u = node_to_scc[u]\n        scc_v = node_to_scc[v]\n        if scc_u != scc_v:\n            condensed_graph[scc_u].add(scc_v)\n            condensed_reverse[scc_v].add(scc_u)\n    \n    # Calculate indegree for topological sort\n    condensed_indegree = [0] * len(sccs)\n    for i in range(len(sccs)):\n        condensed_indegree[i] = len(condensed_reverse[i])\n    \n    # Calculate result for each SCC using topological sort\n    scc_result = [0] * len(sccs)\n    \n    # Initialize queue for topological sort\n    queue = deque()\n    for i in range(len(sccs)):\n        if condensed_indegree[i] == 0:\n            queue.append(i)\n    \n    # Process SCCs in topological order\n    while queue:\n        scc_idx = queue.popleft()\n        \n        # For this SCC, the value should be at least the maximum of all initial values in this SCC\n        max_initial = max(a[node] for node in sccs[scc_idx])\n        \n        # Also, it should be at least as large as any predecessor SCC\n        min_required = max_initial\n        for prev_scc in condensed_reverse[scc_idx]:\n            min_required = max(min_required, scc_result[prev_scc])\n        \n        scc_result[scc_idx] = min_required\n        \n        # Update neighbors\n        for next_scc in condensed_graph[scc_idx]:\n            condensed_indegree[next_scc] -= 1\n            if condensed_indegree[next_scc] == 0:\n                queue.append(next_scc)\n    \n    # Assign results to nodes\n    result = [0] * (n + 1)\n    for i, component in enumerate(sccs):\n        for node in component:\n            result[node] = scc_result[i]\n    \n    print(' '.join(map(str, result[1:])))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        indegree[v] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Compute lower bounds (forward pass)\n    lower_bound = a[:]\n    for node in topo_order:\n        for neighbor in graph[node]:\n            lower_bound[neighbor] = max(lower_bound[neighbor], lower_bound[node])\n    \n    # Compute upper bounds (backward pass)\n    upper_bound = a[:]\n    for node in reversed(topo_order):\n        for prev_node in reverse_graph[node]:\n            upper_bound[prev_node] = min(upper_bound[prev_node], upper_bound[node])\n    \n    # For each node, choose the value that minimizes operations\n    result = [0] * (n + 1)\n    for i in range(1, n + 1):\n        lower = lower_bound[i]\n        upper = upper_bound[i]\n        original = a[i]\n        \n        # Choose the value in [lower, upper] closest to original\n        if original < lower:\n            result[i] = lower\n        elif original > upper:\n            result[i] = upper\n        else:\n            result[i] = original\n    \n    print(' '.join(map(str, result[1:])))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, edges):\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n    \n    visited = [False] * (n + 1)\n    stack = []\n    \n    def dfs1(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        stack.append(node)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    visited = [False] * (n + 1)\n    scc = [0] * (n + 1)\n    scc_nodes = []\n    scc_index = 0\n    \n    def dfs2(node):\n        visited[node] = True\n        scc[node] = scc_index\n        scc_group.append(node)\n        for neighbor in reverse_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor)\n    \n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            scc_group = []\n            scc_index += 1\n            dfs2(node)\n            scc_nodes.append(scc_group)\n    \n    return scc, scc_nodes, scc_index\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        edges.append((u, v))\n    \n    scc, scc_nodes, num_scc = find_scc(n, edges)\n    \n    # Build SCC graph\n    scc_graph = defaultdict(set)\n    in_degree = defaultdict(int)\n    scc_scores = {}\n    \n    # For each SCC, store nodes in it\n    scc_to_nodes = defaultdict(list)\n    for i in range(1, n + 1):\n        scc_to_nodes[scc[i]].append(i)\n    \n    # Build SCC dependency graph\n    for u, v in edges:\n        scc_u = scc[u]\n        scc_v = scc[v]\n        if scc_u != scc_v and scc_v not in scc_graph[scc_u]:\n            scc_graph[scc_u].add(scc_v)\n            in_degree[scc_v] += 1\n    \n    # Ensure all SCCs are in in_degree\n    all_scc_ids = set(range(1, num_scc + 1))\n    for scc_id in all_scc_ids:\n        if scc_id not in in_degree:\n            in_degree[scc_id] = 0\n    \n    # Topological sort\n    queue = deque()\n    for scc_id in all_scc_ids:\n        if in_degree[scc_id] == 0:\n            queue.append(scc_id)\n    \n    topo_order = []\n    while queue:\n        current = queue.popleft()\n        topo_order.append(current)\n        for neighbor in scc_graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Initialize SCC scores\n    scc_final_scores = {}\n    \n    # Process SCCs in topological order\n    for scc_id in topo_order:\n        # Get all initial scores in this SCC\n        nodes_in_scc = scc_to_nodes[scc_id]\n        scores_in_scc = [a[node] for node in nodes_in_scc]\n        \n        # Determine the minimum valid score for this SCC\n        min_valid_score = float('-inf')\n        for prev_scc in range(1, scc_id):  # Check all previous SCCs\n            if scc_id in scc_graph[prev_scc]:  # If there's an edge from prev_scc to scc_id\n                if prev_scc in scc_final_scores:\n                    min_valid_score = max(min_valid_score, scc_final_scores[prev_scc])\n        \n        # For nodes within the same SCC, they must have the same value\n        # We want to minimize sum of |original_score - chosen_value|\n        # The optimal value is the median, but constrained by min_valid_score\n        \n        scores_in_scc.sort()\n        median = scores_in_scc[len(scores_in_scc) // 2]\n        \n        # Choose the best value that satisfies constraints\n        optimal_score = max(min_valid_score, median) if min_valid_score != float('-inf') else median\n        \n        # But we should be more careful - we want to minimize total operations\n        # Let's check a few candidates around the median\n        best_score = optimal_score\n        min_cost = sum(abs(score - optimal_score) for score in scores_in_scc)\n        \n        # Check values around median that might be better\n        candidates = [optimal_score]\n        if len(scores_in_scc) > 0:\n            candidates.extend(scores_in_scc)\n            if min_valid_score != float('-inf'):\n                candidates.append(min_valid_score)\n        \n        for candidate in candidates:\n            if min_valid_score != float('-inf') and candidate < min_valid_score:\n                continue\n            cost = sum(abs(score - candidate) for score in scores_in_scc)\n            if cost < min_cost:\n                min_cost = cost\n                best_score = candidate\n        \n        scc_final_scores[scc_id] = best_score\n    \n    # Handle remaining SCCs (those with cycles that weren't processed properly)\n    # Actually, let's redo this with proper constraint propagation\n    \n    # Reset and do it properly\n    scc_final_scores = {}\n    \n    # First pass: forward propagation\n    for scc_id in topo_order:\n        nodes_in_scc = scc_to_nodes[scc_id]\n        scores_in_scc = [a[node] for node in nodes_in_scc]\n        scores_in_scc.sort()\n        \n        # Minimum value this SCC can have based on predecessors\n        min_val = float('-inf')\n        for prev_scc in all_scc_ids:\n            if scc_id in scc_graph[prev_scc] and prev_scc in scc_final_scores:\n                min_val = max(min_val, scc_final_scores[prev_scc])\n        \n        # Find optimal value for this SCC\n        if scores_in_scc:\n            # Median minimizes sum of absolute deviations\n            median_val = scores_in_scc[len(scores_in_scc) // 2]\n            scc_final_scores[scc_id] = max(min_val, median_val) if min_val != float('-inf') else median_val\n        else:\n            scc_final_scores[scc_id] = 0\n    \n    # Second pass: backward propagation to refine\n    for scc_id in reversed(topo_order):\n        max_val = float('inf')\n        for next_scc in scc_graph[scc_id]:\n            if next_scc in scc_final_scores:\n                max_val = min(max_val, scc_final_scores[next_scc])\n        \n        if max_val != float('inf') and scc_id in scc_final_scores:\n            scc_final_scores[scc_id] = min(scc_final_scores[scc_id], max_val)\n    \n    result = [0] * (n + 1)\n    for i in range(1, n + 1):\n        result[i] = scc_final_scores[scc[i]]\n    \n    print(' '.join(map(str, result[1:])))\n\nsolve()\n\n\n", "\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and reverse graph\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    index = 2 + n\n    for _ in range(m):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        index += 2\n    \n    # Initialize result array\n    b = a[:]\n    \n    # Forward pass: ensure each node is >= max of its predecessors\n    # Topological sort for forward propagation\n    indegree = [0] * n\n    for i in range(n):\n        for neighbor in graph[i]:\n            indegree[neighbor] += 1\n    \n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            b[v] = max(b[v], b[u])\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    # Backward pass: ensure each node is <= min of its successors\n    # Topological sort for backward propagation\n    outdegree = [0] * n\n    for i in range(n):\n        outdegree[i] = len(graph[i])\n    \n    queue = deque()\n    for i in range(n):\n        if outdegree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        v = queue.popleft()\n        # Find the minimum upper bound from all successors\n        if graph[v]:  # if v has successors\n            min_successor = min(b[succ] for succ in graph[v])\n            b[v] = min(b[v], min_successor)\n        \n        # Process predecessors\n        for pred in reverse_graph[v]:\n            outdegree[pred] -= 1\n            if outdegree[pred] == 0:\n                queue.append(pred)\n    \n    # Final adjustment: for each node, try to bring it closer to original value\n    # while respecting constraints\n    changed = True\n    while changed:\n        changed = False\n        \n        # Forward pass\n        for u in range(n):\n            for v in graph[u]:\n                if b[u] > b[v]:\n                    b[v] = b[u]\n                    changed = True\n        \n        # Backward pass\n        for v in range(n):\n            if graph[v]:  # if v has successors\n                min_succ = min(b[succ] for succ in graph[v])\n                if b[v] > min_succ:\n                    b[v] = min_succ\n                    changed = True\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, edges):\n    # Build adjacency list and reverse adjacency list\n    graph = defaultdict(list)\n    rev_graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        rev_graph[v].append(u)\n    \n    # Step 1: First DFS to get finishing times\n    visited = [False] * (n + 1)\n    finish_stack = []\n    \n    def dfs1(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor)\n        finish_stack.append(node)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Step 2: Second DFS on reversed graph in order of decreasing finishing times\n    visited = [False] * (n + 1)\n    scc_map = {}\n    scc_id = 0\n    \n    def dfs2(node, sid):\n        visited[node] = True\n        scc_map[node] = sid\n        for neighbor in rev_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, sid)\n    \n    while finish_stack:\n        node = finish_stack.pop()\n        if not visited[node]:\n            dfs2(node, scc_id)\n            scc_id += 1\n    \n    return scc_map, scc_id\n\ndef find_median(values):\n    \"\"\"Find the value that minimizes sum of absolute differences\"\"\"\n    sorted_vals = sorted(values)\n    n = len(sorted_vals)\n    if n % 2 == 1:\n        return sorted_vals[n // 2]\n    else:\n        # For even length, any value between the two middle elements is optimal\n        # We'll pick the lower middle element\n        return sorted_vals[n // 2 - 1]\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    a = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed\n    \n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v))\n    \n    # Find SCCs\n    scc_map, num_scc = find_scc(n, edges)\n    \n    # Group nodes by SCC\n    scc_nodes = defaultdict(list)\n    for node in range(1, n + 1):\n        scc_nodes[scc_map[node]].append(node)\n    \n    # Build SCC graph and compute in-degrees\n    scc_graph = defaultdict(set)\n    in_degree = [0] * num_scc\n    \n    for u, v in edges:\n        scc_u, scc_v = scc_map[u], scc_map[v]\n        if scc_u != scc_v:\n            if scc_v not in scc_graph[scc_u]:  # Avoid duplicate edges\n                scc_graph[scc_u].add(scc_v)\n                in_degree[scc_v] += 1\n    \n    # For each SCC, collect original values\n    scc_values_list = defaultdict(list)\n    for node in range(1, n + 1):\n        sid = scc_map[node]\n        scc_values_list[sid].append(a[node])\n    \n    # Find optimal unconstrained value for each SCC (median)\n    scc_unconstrained_optimal = [0] * num_scc\n    for i in range(num_scc):\n        scc_unconstrained_optimal[i] = find_median(scc_values_list[i])\n    \n    # Topological sort processing\n    # Convert sets to lists for consistent iteration\n    scc_graph = {k: list(v) for k, v in scc_graph.items()}\n    \n    # Initialize with unconstrained optima\n    scc_optimal_value = scc_unconstrained_optimal[:]\n    \n    # Then do topological sort to enforce constraints\n    in_degree_copy = in_degree[:]\n    queue = deque()\n    for i in range(num_scc):\n        if in_degree_copy[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        curr_scc = queue.popleft()\n        \n        # Propagate constraint to neighbors\n        for next_scc in scc_graph.get(curr_scc, []):\n            # next_scc's value must be >= curr_scc's value\n            scc_optimal_value[next_scc] = max(scc_optimal_value[next_scc], scc_optimal_value[curr_scc])\n            in_degree_copy[next_scc] -= 1\n            if in_degree_copy[next_scc] == 0:\n                queue.append(next_scc)\n    \n    # Assign final values\n    result = [0] * (n + 1)\n    for node in range(1, n + 1):\n        sid = scc_map[node]\n        result[node] = scc_optimal_value[sid]\n    \n    print(' '.join(map(str, result[1:])))\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [int(data[idx + i]) for i in range(n)]\n    idx += n\n    \n    # Build graph and compute in-degrees\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    in_degree = [0] * n\n    \n    for _ in range(m):\n        u = int(data[idx]) - 1\n        v = int(data[idx+1]) - 1\n        idx += 2\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        in_degree[v] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    in_degree_copy = in_degree[:]\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            in_degree_copy[neighbor] -= 1\n            if in_degree_copy[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Initialize result array\n    b = a[:]\n    \n    # Forward pass: ensure each node >= all its predecessors\n    for node in topo_order:\n        for neighbor in graph[node]:\n            b[neighbor] = max(b[neighbor], b[node])\n    \n    # Backward pass: ensure each node <= all its successors\n    for node in reversed(topo_order):\n        for predecessor in reverse_graph[node]:\n            b[predecessor] = min(b[predecessor], b[node])\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and compute in-degrees\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    indegree = [0] * n\n    outdegree = [0] * n\n    \n    idx = 2 + n\n    for _ in range(m):\n        u = int(data[idx]) - 1  # Convert to 0-indexed\n        v = int(data[idx+1]) - 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        indegree[v] += 1\n        outdegree[u] += 1\n        idx += 2\n\n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Also get reverse topological order\n    queue = deque()\n    for i in range(n):\n        if outdegree[i] == 0:\n            queue.append(i)\n    \n    reverse_topo_order = []\n    outdegree_copy = outdegree[:]\n    while queue:\n        node = queue.popleft()\n        reverse_topo_order.append(node)\n        for predecessor in reverse_graph[node]:\n            outdegree_copy[predecessor] -= 1\n            if outdegree_copy[predecessor] == 0:\n                queue.append(predecessor)\n    \n    # Compute bounds\n    min_bound = [-float('inf')] * n\n    max_bound = [float('inf')] * n\n    \n    # Set initial bounds based on no constraints\n    for i in range(n):\n        min_bound[i] = a[i]\n        max_bound[i] = a[i]\n    \n    # Forward pass: propagate minimum values\n    for node in topo_order:\n        for neighbor in graph[node]:\n            min_bound[neighbor] = max(min_bound[neighbor], min_bound[node])\n    \n    # Backward pass: propagate maximum values\n    for node in reverse_topo_order:\n        for predecessor in reverse_graph[node]:\n            max_bound[predecessor] = min(max_bound[predecessor], max_bound[node])\n    \n    # Final result: for each node, choose value closest to original within bounds\n    b = [0] * n\n    for i in range(n):\n        # Clamp the original value between min and max bounds\n        b[i] = max(min_bound[i], min(max_bound[i], a[i]))\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_scc(n, graph):\n    # Kosaraju's algorithm\n    visited = [False] * n\n    order = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs1(v)\n        order.append(u)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Transpose graph\n    transposed = defaultdict(list)\n    for u in graph:\n        for v in graph[u]:\n            transposed[v].append(u)\n    \n    visited = [False] * n\n    scc = [-1] * n\n    scc_id = 0\n    \n    def dfs2(u):\n        visited[u] = True\n        scc[u] = scc_id\n        for v in transposed[u]:\n            if not visited[v]:\n                dfs2(v)\n    \n    while order:\n        u = order.pop()\n        if not visited[u]:\n            dfs2(u)\n            scc_id += 1\n    \n    return scc, scc_id\n\ndef build_scc_dag(n, graph, scc):\n    # Build DAG of SCCs\n    dag = defaultdict(set)\n    in_degree = defaultdict(int)\n    \n    for u in range(n):\n        for v in graph[u]:\n            if scc[u] != scc[v]:\n                if scc[v] not in dag[scc[u]]:\n                    dag[scc[u]].add(scc[v])\n                    in_degree[scc[v]] += 1\n    \n    # Ensure all SCCs are in in_degree dict\n    unique_sccs = set(scc)\n    for scc_id in unique_sccs:\n        if scc_id not in in_degree:\n            in_degree[scc_id] = 0\n    \n    return dag, in_degree\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    \n    # Find SCCs\n    scc, scc_count = find_scc(n, graph)\n    \n    # Group nodes by SCC\n    scc_nodes = defaultdict(list)\n    for i in range(n):\n        scc_nodes[scc[i]].append(i)\n    \n    # Build DAG of SCCs\n    dag, in_degree = build_scc_dag(n, graph, scc)\n    \n    # Topological sort of SCCs\n    queue = deque()\n    unique_sccs = list(set(scc))\n    \n    for scc_id in unique_sccs:\n        if in_degree[scc_id] == 0:\n            queue.append(scc_id)\n    \n    topo_order = []\n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in dag[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    # Initialize SCC values with median of original values\n    scc_values = {}\n    for scc_id in unique_sccs:\n        nodes = scc_nodes[scc_id]\n        values = [a[node] for node in nodes]\n        values.sort()\n        scc_values[scc_id] = values[len(values) // 2]  # median\n    \n    # Process SCCs in topological order to satisfy constraints\n    # For each SCC, its value must be >= all predecessors' values\n    for scc_id in topo_order:\n        # Check all predecessors in the DAG\n        for pred_scc in unique_sccs:\n            if scc_id in dag[pred_scc]:  # pred_scc -> scc_id\n                scc_values[scc_id] = max(scc_values[scc_id], scc_values[pred_scc])\n    \n    # Assign final values\n    result = [0] * n\n    for i in range(n):\n        result[i] = scc_values[scc[i]]\n    \n    print(' '.join(map(str, result)))\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef kosaraju(n, edges):\n    # Build adjacency list and reverse adjacency list\n    adj = defaultdict(list)\n    rev_adj = defaultdict(list)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        rev_adj[v].append(u)\n    \n    # Step 1: Order vertices by finish time in DFS\n    visited = [False] * (n + 1)\n    finish_stack = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs1(v)\n        finish_stack.append(u)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i)\n    \n    # Step 2: Transpose DFS on reversed graph in order of decreasing finish times\n    visited = [False] * (n + 1)\n    sccs = []\n    scc_map = {}\n    \n    def dfs2(u, current_scc):\n        visited[u] = True\n        current_scc.append(u)\n        for v in rev_adj[u]:\n            if not visited[v]:\n                dfs2(v, current_scc)\n    \n    while finish_stack:\n        u = finish_stack.pop()\n        if not visited[u]:\n            current_scc = []\n            dfs2(u, current_scc)\n            sccs.append(current_scc)\n            for node in current_scc:\n                scc_map[node] = len(sccs) - 1\n    \n    return sccs, scc_map\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        edges.append((u, v))\n    \n    # Find SCCs\n    sccs, scc_map = kosaraju(n, edges)\n    k = len(sccs)\n    \n    # Build condensed graph\n    condensed_adj = defaultdict(list)\n    condensed_rev_adj = defaultdict(list)\n    condensed_indegree = [0] * k\n    condensed_edges = set()\n    \n    for u, v in edges:\n        scc_u = scc_map[u]\n        scc_v = scc_map[v]\n        if scc_u != scc_v and (scc_u, scc_v) not in condensed_edges:\n            condensed_adj[scc_u].append(scc_v)\n            condensed_rev_adj[scc_v].append(scc_u)\n            condensed_indegree[scc_v] += 1\n            condensed_edges.add((scc_u, scc_v))\n    \n    # Topological sort of SCCs\n    queue = deque()\n    for i in range(k):\n        if condensed_indegree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in condensed_adj[u]:\n            condensed_indegree[v] -= 1\n            if condensed_indegree[v] == 0:\n                queue.append(v)\n    \n    # Initialize result array\n    b = [0] * (n + 1)\n    \n    # For each SCC, compute the optimal value\n    # min_limit tracks the minimum value an SCC can have based on predecessors\n    min_limit = [-float('inf')] * k\n    \n    # Process SCCs in topological order\n    for scc_id in topo_order:\n        scc = sccs[scc_id]\n        # Collect all original values in this SCC\n        vals = [a[node] for node in scc]\n        vals.sort()\n        # Median minimizes sum of absolute deviations\n        median = vals[len(vals) // 2]\n        \n        # The final value must be at least min_limit[scc_id] \n        # and respect the median choice\n        final_value = max(min_limit[scc_id], median)\n        \n        # Assign this value to all nodes in SCC\n        for node in scc:\n            b[node] = final_value\n        \n        # Update min_limit for successors\n        for succ in condensed_adj[scc_id]:\n            if min_limit[succ] < final_value:\n                min_limit[succ] = final_value\n    \n    # Output results without trailing space\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(b[i]))\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    # Build graph and in-degree count\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    idx = 2 + n\n    for _ in range(m):\n        u = int(data[idx]) - 1  # Convert to 0-indexed\n        v = int(data[idx+1]) - 1  # Convert to 0-indexed\n        graph[u].append(v)\n        indegree[v] += 1\n        idx += 2\n    \n    # Initialize result array with original scores\n    b = a[:]\n    \n    # Kahn's algorithm for topological sorting\n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    # Store topological order\n    topo_order = []\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Forward pass: ensure each node is at least as large as its predecessors\n    for node in topo_order:\n        for neighbor in graph[node]:\n            b[neighbor] = max(b[neighbor], b[node])\n    \n    # Backward pass: ensure each node is at most as large as its successors\n    # Process in reverse topological order\n    for node in reversed(topo_order):\n        for neighbor in graph[node]:\n            b[node] = min(b[node], b[neighbor])\n    \n    print(' '.join(map(str, b)))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    n, m = read_ints()\n    a = [0] + read_ints()  # 1-indexed\n    \n    # Read constraints\n    edges = []\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    for _ in range(m):\n        u, v = read_ints()\n        edges.append((u, v))\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n    \n    # Find SCCs using Kosaraju's algorithm\n    def dfs1(node, visited, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs1(neighbor, visited, stack)\n        stack.append(node)\n    \n    def dfs2(node, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in reverse_graph[node]:\n            if not visited[neighbor]:\n                dfs2(neighbor, visited, component)\n    \n    # First DFS\n    visited = [False] * (n + 1)\n    stack = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs1(i, visited, stack)\n    \n    # Second DFS on reverse graph\n    visited = [False] * (n + 1)\n    sccs = []\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs2(node, visited, component)\n            sccs.append(component)\n    \n    # Create mapping from node to SCC index\n    node_to_scc = [0] * (n + 1)\n    for i, component in enumerate(sccs):\n        for node in component:\n            node_to_scc[node] = i\n    \n    # Build condensed graph\n    condensed_graph = defaultdict(set)\n    condensed_reverse = defaultdict(set)\n    \n    for u, v in edges:\n        scc_u = node_to_scc[u]\n        scc_v = node_to_scc[v]\n        if scc_u != scc_v:\n            condensed_graph[scc_u].add(scc_v)\n            condensed_reverse[scc_v].add(scc_u)\n    \n    # Calculate indegree for topological sort\n    condensed_indegree = [0] * len(sccs)\n    for i in range(len(sccs)):\n        condensed_indegree[i] = len(condensed_reverse[i])\n    \n    # Calculate result for each SCC using topological sort\n    scc_result = [0] * len(sccs)\n    \n    # Initialize queue for topological sort\n    queue = deque()\n    for i in range(len(sccs)):\n        if condensed_indegree[i] == 0:\n            queue.append(i)\n    \n    # Process SCCs in topological order\n    while queue:\n        scc_idx = queue.popleft()\n        \n        # For this SCC, the value should be at least the maximum of all initial values in this SCC\n        max_initial = max(a[node] for node in sccs[scc_idx])\n        \n        # Also, it should be at least as large as any predecessor SCC\n        min_required = max_initial\n        for prev_scc in condensed_reverse[scc_idx]:\n            min_required = max(min_required, scc_result[prev_scc])\n        \n        scc_result[scc_idx] = min_required\n        \n        # Update neighbors\n        for next_scc in condensed_graph[scc_idx]:\n            condensed_indegree[next_scc] -= 1\n            if condensed_indegree[next_scc] == 0:\n                queue.append(next_scc)\n    \n    # Assign results to nodes\n    result = [0] * (n + 1)\n    for i, component in enumerate(sccs):\n        for node in component:\n            result[node] = scc_result[i]\n    \n    print(' '.join(map(str, result[1:])))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [15300, 20002, 17045, 18249, 16747, 15438, 19433, 18222, 14665, 16790], "completion_tokens": [6173, 11632, 6156, 9400, 6091, 7152, 11537, 9495, 6003, 7606], "no_of_try": 10, "api_calls": 100, "is_solved": false, "language": "Python3", "task_id": 1615}
{"name": "1617_A. Forbidden Subsequence", "description": "You are given strings S and T, consisting of lowercase English letters. It is guaranteed that T is a permutation of the string abc. \n\nFind string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.\n\nString a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings.\n\nA string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) elements.\n\nA string a is lexicographically smaller than a string b if and only if one of the following holds:\n\n  * a is a prefix of b, but a \u2260 b;\n  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n\nInput\n\nEach test contains multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains a string S (1 \u2264 |S| \u2264 100), consisting of lowercase English letters.\n\nThe second line of each test case contains a string T that is a permutation of the string abc. (Hence, |T| = 3).\n\nNote that there is no limit on the sum of |S| across all test cases.\n\nOutput\n\nFor each test case, output a single string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.\n\nExample\n\nInput\n\n\n7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n\n\nOutput\n\n\naaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n\nNote\n\nIn the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.\n\nIn the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.\n\nIn the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.", "tags": ["constructive algorithms", "greedy", "sortings", "strings"], "difficulty": 7, "id": 1617, "sample_io": [{"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}], "test_list": [{"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nbc\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabd\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndasic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nacdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\nddddddddcddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndasic\nbac\nabracadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nacdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabacaca\nabc\ncccba\nbca\nebsic\ncab\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaaccb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndasic\ncab\nabsacadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nacdis\naaaaaacbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\nabracadabra\nabc\ndddddddddddd\nabc\ncbc\nabc\nad\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nad\n"]}, {"input": "7\nabababb\ncaa\ncccba\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nacb\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\ncba\neddddddddddd\ncab\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\naaacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n", "output": ["aaaaacb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbac\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nabababa\nabc\nccbba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabbcc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nbac\nbac\ncba\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nabababb\ncaa\nccabc\nbca\ndbsic\nbac\nabracadaara\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbcc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nacb\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\nedddddddddcd\nacb\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncdddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\narbadacarba\ncba\neddddddddddd\ndab\nbcc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddde\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nibtdc\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdit\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\nddddddddeddd\nabc\nbbc\ncba\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nccc\nabc\ncb\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nccc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncac\ncba\nbc\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nacc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccaa\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nbc\nabc\n", "output": ["aaaacbb\naaccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\nddcddddddddd\ncba\ndbc\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbcd\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nacb\ndddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nacb\ndasic\ncab\nabascadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbc\nabccc\nacdis\naaaaaacbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\neasic\nbac\ncbraaadabra\ncba\neddddddddddd\ncab\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\naceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\narbadacarba\ncba\nedddddddddde\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\nabccc\nbca\nebsic\ncab\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabqa\nabc\ndddddddddddd\ncba\ncac\ncba\nbc\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdqr\ndddddddddddd\nacc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\necsib\nbac\nabbacrdabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nabc\n", "output": ["aaaabbc\nabccc\nbceis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccaa\nbca\ndbsic\nbac\nabracadabra\nabc\ndddedddddddd\ncba\nbbc\nabd\nbc\nabc\n", "output": ["aaaacbb\naaccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccbb\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabd\nac\nbac\n", "output": ["aaaacbb\nbbccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\naaababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabb\nac\nabc\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabqa\nabc\ndddddddddddd\nabc\nbac\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdqr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nabababa\nabc\nccbba\ncab\ndbsic\ncab\nabracadabra\ncba\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabbcc\nbcdis\naaaaabbcdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbric\ncab\nabracadabra\nabc\ndddddddddddd\nbac\nbac\ncba\nca\nabc\n", "output": ["aaaabbb\nabccc\nbcdir\naaaaacbbdrr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nabacaab\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\nedddeddddddd\nbac\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nccbba\nbca\ncisbe\nbac\narabdacarba\ncba\neddddddddddd\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\ncisbd\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabe\nac\nabc\n", "output": ["aaaabbc\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\ncba\nbc\nacb\n", "output": ["aaaabbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccbb\nacb\ndbsic\nbac\nabracadabra\nabc\nddeddddddddd\nabc\nbbb\nabd\nac\nbac\n", "output": ["aaaacbb\nbbccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\narbadacarba\nabc\ndddddddddddd\nabc\nacc\nabc\nad\nbca\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nacc\nad\n"]}, {"input": "7\nabababb\ncba\nccabc\nbca\ndcsic\naac\nabracadaara\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nccdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbcc\nbca\nebsic\nbac\nabracbdabra\nabc\neddddddddddd\naca\nbbc\nbca\nac\ncba\n", "output": ["aaaacbb\nabbcc\nbceis\naaaacbbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaab\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\nedddeddddddd\nbac\nbbb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddee\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\narbadacarba\ncba\neddddddddddd\ndab\ncbb\nbca\nbc\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\nabbcc\nbca\nebsic\nbac\nabracbdabra\nabc\neddddddddddd\naca\nbbc\nbca\nbc\ncba\n", "output": ["aaaacbb\nabbcc\nbceis\naaaacbbbdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\ndcsib\nbac\nabbacrdabra\nabc\ndddddddddddd\ncba\ncbc\nabd\ncb\nabc\n", "output": ["aaaabbc\nabccc\nbcdis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nababaaa\ncba\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddcdddd\nabc\nbbb\nabb\nac\nabc\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\ncddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\ndasic\ncab\nabascadaara\nabc\nddeddddddddd\nacb\nbbc\ncba\nac\nabc\n", "output": ["aaaabbc\nabccc\nacdis\naaaaaacbdrs\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccca\ncba\ncisbd\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabf\nac\nabc\n", "output": ["aaaabbc\nacccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabaaaba\ncba\ncccba\nbca\ndbsic\nbac\narbadacarba\nabc\nddddddddeddd\nabc\nbbc\ncab\nac\ncba\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccbb\nacb\nchsbd\nbac\nabracadabra\nabc\ndddddddddedd\nabc\nbbb\nabd\nac\nbac\n", "output": ["aaaacbb\nbbccc\nbcdhs\naaaaacbbdrr\nddddddddddde\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nabc\narbadacarba\ncba\neddddddddded\ndab\ncbb\nbca\ncb\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddee\nbbc\nbc\n"]}, {"input": "7\nabaaaba\ncba\ncccba\nbca\ndbsic\nbac\narbadacarba\nabc\nddddddddeddd\nabc\nbbb\ncab\nac\ncba\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbb\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\ncba\ndcsia\nbac\nabbacrdabra\nabc\ndddddddddddd\ncba\ncbc\nabd\ncb\nabc\n", "output": ["aaaabbc\nabccc\nacdis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccca\nabc\ncisbd\nbac\nabracaeabra\nabc\ndddddddddddd\ncba\nbbc\nabf\nac\nabc\n", "output": ["aaaabbc\nacccc\nbcdis\naaaaacbberr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\ncba\ndbsia\nbac\nabbacrdabra\nabc\ndddddddddddd\ncba\ncbc\nabd\ncb\nabc\n", "output": ["aaaabbc\nabccc\nabdis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabaaabb\ncab\nccabc\nbca\ndiscc\naac\nabracadaara\nabc\ndddddddddddd\ncba\ncbb\nabd\nac\nbca\n", "output": ["aaaabbb\nabccc\nccdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbcc\ncba\nebsic\nbca\nabracbdaarb\nabc\neddddddddddd\n`ca\nbbc\nbca\ncc\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaacbbbdrr\nddddddddddde\nbbc\ncc\n"]}, {"input": "7\nabacaba\nabc\nabbcc\ncba\nebsic\nbca\nabracbdbarb\nabc\neddddddddddd\n`ca\nbcb\nbca\ncc\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaacbbbbdrr\nddddddddddde\nbbc\ncc\n"]}, {"input": "7\nabacaba\ncba\nabbcc\ncba\nebsic\nbca\nbrabdbcarba\nabc\neddddddddddd\n`ca\nbcb\nbca\ncc\nabc\n", "output": ["aaaabbc\nabbcc\nbceis\naaacbbbbdrr\nddddddddddde\nbbc\ncc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nabc\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nacccb\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndcsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nccdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ndbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcd\nac\n"]}, {"input": "7\naaacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaaacb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabbcaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nacb\n", "output": ["aaacbbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadbbra\nabc\ndddddddddddd\nabc\nbbb\nabd\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaacbbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndasic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nab\nabc\n", "output": ["aaaacbb\nabccc\nacdis\naaaaacbbdrr\ndddddddddddd\nbbc\nab\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\ncab\nabracadabra\ncba\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncdcba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nbc\ncba\n", "output": ["aaaacbb\nabccd\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebshc\nbac\nabracadabra\nabc\ndddddddddddd\nabc\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbcehs\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaca\nabc\ncccba\nbca\nfbsic\ncab\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaaccb\nabccc\nbcfis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\nbbb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\nabracadabra\nabc\nddcddddddddd\nabc\ncbc\nabc\nad\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbcc\nad\n"]}, {"input": "7\nabababb\ncaa\ncccba\nbca\ndbsic\nbac\nabracadabra\ncba\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaabbcdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\nabccc\nacb\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebric\nbac\nabracadabra\nabc\neddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceir\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabrbcadabra\nabc\neddddddddddd\nacb\ncbb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaacbbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\narbadadarba\ncba\neddddddddddd\ndab\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbddrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\necsic\nbac\nabracadabra\nabc\nddddddcddddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\ncceis\naaaaacbbdrr\ncddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadbbra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabra\ncba\ndddddddddddd\ncba\ncbc\ncba\nbc\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaabbcdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaaa\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabd\nac\nbac\n", "output": ["aaaaacb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\nebsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbbb\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\naaacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbac\nacb\nac\nabc\n", "output": ["aaaaacb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nacababa\nabc\nccbba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaacbb\nabbcc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabacaba\nabc\nbccba\nacb\ndasic\ncab\nabracadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabbcc\nacdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\nabracadabra\nabc\ndddddddddddd\nabc\ncbd\nabc\nad\nbca\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcd\nad\n"]}, {"input": "7\nabacaba\nabc\nabdcc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nadb\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccd\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaab\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\ncab\nbca\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nabc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\ncbraaadabra\ncba\neddddddddddd\ncab\nacb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\nddddddddddde\nabc\nac\n"]}, {"input": "7\naaaacba\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nabc\n", "output": ["aaaaabc\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabadaba\nabc\ncccba\nacb\ncisbd\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabe\nac\nabc\n", "output": ["aaaabbd\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\nddddddcddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nacb\nddddddddeddd\nabc\nbbc\ncba\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaaa\nabc\nabccc\nacb\nebsic\nbac\nabracadabra\nabc\nddddddddddde\nbca\nbbc\nbca\nac\ncba\n", "output": ["aaaaacb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabababb\ncba\nccabc\nbca\ndbsic\nbac\nabracadaara\nabc\nddddddddddcd\ncba\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaaacbdrr\ncddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\nabbcc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nacb\nbbc\nbca\nac\ncba\n", "output": ["aaaabbc\nabbcc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\nabccc\nbca\nebsic\ncab\nabracadabra\nabc\nedddddddddcd\nacb\nbcb\nbca\nac\nabc\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ncdddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabcdc\nbca\neasic\nbac\ncbraaadabra\ncba\neddddddddddd\ncab\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccd\naceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\ncisbe\nbac\narabdacarba\ncba\neddddddddddd\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaabbc\nabccc\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebric\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\ncba\nbc\nacb\n", "output": ["aaaacbb\nabccc\nbceir\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccaa\nbca\ndbsic\nbac\nabracadabra\nabc\ndddedddddddd\ncba\nbbc\nabd\nac\nabc\n", "output": ["aaaacbb\naaccc\nbcdis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebshc\naac\nabracadabra\nabc\nddddddddcddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbcehs\naaaaacbbdrr\ncddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaca\ncba\ncccba\nacb\ndasic\ncab\nabascadaara\nabc\ndddddddddddd\nabc\nbbc\ncba\nac\nabc\n", "output": ["aaaabcc\nabccc\nacdis\naaaaaacbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nacb\nebsic\nbac\narbadacarba\nabc\nddddddddddde\nbca\nbbc\nbca\nab\ncba\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nab\n"]}, {"input": "7\nabacaab\nabc\nabccc\nbca\nebric\nbac\nabracadabra\nabc\nedddeddddddd\nbac\nbcb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceir\naaaaacbbdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncdbba\nbca\ncisbe\nbac\narabdacarba\ncba\neddddddddddd\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaacbb\nabbcd\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ncbsic\nbac\nabracadabra\nabc\nddddddddeddd\nabc\nbbc\ncab\nac\ncba\n", "output": ["aaaabbb\nabccc\nbccis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\naac\narbadacarba\nacb\nddddddddcddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\ncddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\ncab\ndddddddddddd\nbba\nbbc\nbca\nab\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaabbcdrr\ndddddddddddd\nbbc\nab\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\narbadacarba\nabc\neddddddddddd\ndab\ncbb\nbca\nbc\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabababa\nabc\nabccc\nbca\naesic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\ncba\nbc\nacb\n", "output": ["aaaabbb\nabccc\naceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccaa\nbca\ncisdb\nbac\nabracadabra\nabc\ndddededddddd\ncba\nbbc\nabd\nbc\nabc\n", "output": ["aaaacbb\naaccc\nbcdis\naaaaacbbdrr\nddddddddddee\nbbc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\ncba\ncisbd\nbac\nabsacadabra\nabc\ndddddddddddd\ncba\nbbc\nabf\nac\nabc\n", "output": ["aaaabbc\nabccc\nbcdis\naaaaacbbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbdc\nbca\nebsic\nbac\nabracbdabra\nabc\neddddddddddd\naca\nbbc\nbca\nbc\ncba\n", "output": ["aaaacbb\nabbcd\nbceis\naaaacbbbdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\nabbcc\nbca\nebsic\nbca\nabracbdabra\nabc\nedddddeddddd\naca\nbbc\nbca\nbc\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaacbbbdrr\nddddddddddee\nbbc\nbc\n"]}, {"input": "7\nabaaaba\ncba\ncccba\nbca\ndbsic\nbac\narbadacarba\nabc\nddddddddedcd\nabc\nbbb\ncab\nac\ncba\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\ncdddddddddde\nbbb\nac\n"]}, {"input": "7\nbbbbaaa\nabc\nabccc\nbca\nbesic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\nbba\nbc\ncab\n", "output": ["aaabbbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\ncba\ndbsia\nbac\nabbacrdabra\nabc\ndddddddddddd\ncba\ncbc\nabd\ncb\nabc\n", "output": ["aaaacbb\nabccc\nabdis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\ncba\nacccc\nabc\ncisad\nbac\nabracaeabra\nabc\ndddddddddddd\ncba\nbbc\nabf\nac\nabc\n", "output": ["aaaabbc\nacccc\nacdis\naaaaacbberr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabbbaaa\nabc\nacbcc\nbca\nbesic\nbac\nabracadabra\nabc\ndddddddddddd\nbba\ncbc\nbba\nac\ncab\n", "output": ["aaaabbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabaaabb\ncab\nccabc\nbca\ndiscc\naac\nabracadaara\nabc\ndddddddddddd\ncba\nbbb\nabd\nac\nbca\n", "output": ["aaaabbb\nabccc\nccdis\naaaaaacbdrr\ndddddddddddd\nbbb\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ndbc\nabc\nac\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcd\nac\n"]}, {"input": "7\nabbcaba\nabc\ncccba\nbca\nebsic\nbac\nabracbdabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nacb\n", "output": ["aaacbbb\nabccc\nbceis\naaaacbbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebtic\ncab\nabracadabra\ncba\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceit\naaaaabbcdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\ncba\nbccba\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nacb\nbbc\nabc\nac\nacb\n", "output": ["aaaabbb\nabbcc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\ncba\ndddddddddddd\nbca\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaabbcdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabababa\ncaa\ncccba\nacb\ndbsic\nbac\nabracbdabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaaabbb\nabccc\nbcdis\naaaacbbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nccbba\nacb\ndasic\ncab\nabsacadaara\nabc\ndddddddddddd\nabc\nbbc\naac\nac\nabc\n", "output": ["aaaacbb\nabbcc\nacdis\naaaaaacbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\necsic\nbac\nabracaeabra\nabc\nddddddcddddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\ncceis\naaaaacbberr\ncddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsid\nbac\nabracadabra\nabc\ndddddddddddd\nacc\nbbc\ncba\nac\nabc\n", "output": ["aaaabbb\nabccc\nbddis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacbba\nabc\ncccba\nbca\nebsic\nbac\nacracadabra\nabc\ndddddddddddd\ncba\ncbc\nabc\ncb\nacb\n", "output": ["aaacbbb\nabccc\nbceis\naaaaaccbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nacababa\nacb\nccbba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaabbc\nabbcc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabacaba\nacb\ncccba\nacb\ndasic\ncab\nabascadaara\nabc\ndddddddddddd\nabc\nbac\nabc\nac\nabc\n", "output": ["aaaabbc\nabccc\nacdis\naaaaaacbdrs\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nababaca\nabc\nabbcc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nacb\nabc\nbca\nac\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaaacbbdrr\nddddddddddde\nabc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nacb\nddddddddeddd\nabc\nabc\ncba\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaabbcdrr\nddddddddddde\nabc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\ncddddddddddd\ncba\ncbc\ncba\nbc\nbca\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadacra\nabc\ndddddddddddd\nabc\ncac\ncba\nbc\nacb\n", "output": ["aaaabbc\nabccc\nbceis\naaaaaccbdrr\ndddddddddddd\nacc\nbc\n"]}, {"input": "7\nabacaba\ncba\nbccba\nbca\necsib\nbac\nabaacrdabra\nabc\ndddddddddddd\ncba\ncac\ncba\ncb\nabc\n", "output": ["aaaabbc\nabbcc\nbceis\naaaaacbbdrr\ndddddddddddd\nacc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\nddcddddddddd\ncba\ndbc\nacb\nab\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nbcd\nab\n"]}, {"input": "7\nabacaba\ncba\ncccba\nacb\ndbsic\ncba\nabascadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbc\nabccc\nbcdis\naaaaaacbdrs\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsib\nbac\narbadacarba\ncba\nedddddddddde\ndab\nbcb\nacb\nca\nabc\n", "output": ["aaaacbb\nabccc\nbbeis\naaaaabbcdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncdcba\nbca\ncisbe\nbac\narabdacarba\ncba\neddddddddddd\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaabbc\nabccd\nbceis\naaaaabbcdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebric\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\ncba\nbd\nacb\n", "output": ["aaaacbb\nabccc\nbceir\naaaaacbbdrr\ndddddddddddd\nbcc\nbd\n"]}, {"input": "7\nabacaba\ncba\ncccca\nbca\nebsic\nbac\naqbadacarba\nabc\ndddddddddddd\ncba\ncac\ncba\nbc\nacb\n", "output": ["aaaabbc\nacccc\nbceis\naaaaacbbdqr\ndddddddddddd\nacc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncdbba\nbca\ncisbe\nbac\narabdacarba\ncba\nedddddeddddd\ndab\nbcb\nbca\nca\nabc\n", "output": ["aaaacbb\nabbcd\nbceis\naaaaabbcdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\ncccca\nacb\ndbric\ncab\nabracadabra\nabc\ndddddddddddd\nbac\nbac\ncba\nca\nbba\n", "output": ["aaaabbb\nacccc\nbcdir\naaaaacbbdrr\ndddddddddddd\nabc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\nabracadabra\nabc\ndddddddddddc\nabc\nacc\nabc\nad\nbca\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ncddddddddddd\nacc\nad\n"]}, {"input": "7\nabacaab\nabc\nbbccc\nbca\nebsic\nabc\nabracadabra\nabc\nedddeddddddd\nbac\nbbb\nbca\nac\nabc\n", "output": ["aaaacbb\nbbccc\nbceis\naaaaacbbdrr\nddddddddddee\nbbb\nac\n"]}, {"input": "7\nbbababa\nabc\nabccc\nbca\naesic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\ncbc\ncba\nbc\nacb\n", "output": ["aaabbbb\nabccc\naceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\nccdbb\nacb\ncisbd\nbac\nabracadabra\nabc\nddeddddddddd\nabc\nbbb\ndba\nac\nbac\n", "output": ["aaaacbb\nbbccd\nbcdis\naaaaacbbdrr\nddddddddddde\nbbb\nac\n"]}, {"input": "7\nabababb\ncba\ncbacc\nbca\nddsic\naac\nabracadaara\nabc\ndddddddddddd\ncba\nbbc\nabd\nac\nacb\n", "output": ["aaabbbb\nabccc\ncddis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\ndasic\ncab\nacascadaara\nabc\nddeddddddddd\nacb\ncbb\ncba\nac\nabc\n", "output": ["aaaabbc\nabccc\nacdis\naaaaaaccdrs\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbdc\nbca\ndbsic\nbac\nabracbdabra\nabc\neddddddddddd\naca\nbbc\nbca\nbc\ncba\n", "output": ["aaaacbb\nabbcd\nbcdis\naaaacbbbdrr\nddddddddddde\nbbc\nbc\n"]}, {"input": "7\nabaaaba\ncba\ncccba\nbca\ndbsic\nbac\narbadacarba\nabc\ndddddddeeddd\nabc\nbbc\ncab\nca\ncba\n", "output": ["aaaaabb\nabccc\nbcdis\naaaaacbbdrr\nddddddddddee\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabbcc\nbca\nebsic\nbca\nabracbdabra\ncba\nedddddeddddd\naca\nbbc\nbca\nbc\nabc\n", "output": ["aaaacbb\nabbcc\nbceis\naaaabbbcdrr\nddddddddddee\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabd\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nca\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\ncba\ncccba\nbca\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\ncb\nabc\n", "output": ["aaaabbc\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nabc\nbc\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nbc\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nbca\nebsic\ncab\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\ncba\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nbc\ncba\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\ncba\ncccba\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nababaca\nabc\ncccba\nacb\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabd\nbc\ncba\n", "output": ["aaaacbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nbc\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\nbbc\nacb\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\ndasic\ncab\nabracadaara\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nabc\n", "output": ["aaaacbb\nabccc\nacdis\naaaaaacbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\naac\nabracadabra\nabc\ndddddddddddd\nabc\ncbc\nabc\nac\nacb\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabababa\nabc\ncccba\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nbac\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabababa\ncaa\ncccba\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaca\nabc\ncccba\nbca\nebsic\ncab\nabracadabra\nabc\ndddddddddddd\ncba\ncbc\nbca\nac\nacb\n", "output": ["aaaaccb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbcc\nac\n"]}, {"input": "7\nabacaba\nabc\ncccba\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababa\nabc\nbccca\nacb\ndbsic\ncab\nabracadabra\nabc\ndddddddddddd\nbac\nbac\nabc\nac\nabc\n", "output": ["aaaabbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nacb\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nacb\nebsic\nbac\nabracadabra\nabc\ndddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababb\ncaa\nccabc\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\nabc\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabababb\ncaa\nccabc\nbca\ndbsic\nbac\nabracadabra\nabc\ndddddddddddd\ncba\nbbc\nabc\nac\nacb\n", "output": ["aaabbbb\nabccc\nbcdis\naaaaacbbdrr\ndddddddddddd\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nbca\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nacb\nbbc\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}, {"input": "7\nabacaba\nabc\nabccc\nbca\nebsic\nbac\nabracadabra\nabc\neddddddddddd\nacb\ncbb\nbca\nac\nabc\n", "output": ["aaaacbb\nabccc\nbceis\naaaaacbbdrr\nddddddddddde\nbbc\nac\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    S = input().strip()\n    T = input().strip()\n    \n    # Count frequency of each character in S\n    freq = {}\n    for c in S:\n        freq[c] = freq.get(c, 0) + 1\n    \n    # Identify the three characters in T\n    x, y, z = T[0], T[1], T[2]\n    \n    # Try different strategies to avoid subsequence xyz\n    \n    # Strategy 1: Put all z at the beginning\n    result1 = []\n    if z in freq:\n        result1.append(z * freq[z])\n        remaining_freq1 = freq.copy()\n        del remaining_freq1[z]\n        for char in sorted(remaining_freq1.keys()):\n            result1.append(char * remaining_freq1[char])\n    else:\n        for char in sorted(freq.keys()):\n            result1.append(char * freq[char])\n    \n    # Strategy 2: Put all x at the end  \n    result2 = []\n    if x in freq:\n        remaining_freq2 = freq.copy()\n        x_count = remaining_freq2[x]\n        del remaining_freq2[x]\n        for char in sorted(remaining_freq2.keys()):\n            result2.append(char * remaining_freq2[char])\n        result2.append(x * x_count)\n    else:\n        for char in sorted(freq.keys()):\n            result2.append(char * freq[char])\n            \n    # Strategy 3: Put all y at the beginning\n    result3 = []\n    if y in freq:\n        result3.append(y * freq[y])\n        remaining_freq3 = freq.copy()\n        del remaining_freq3[y]\n        for char in sorted(remaining_freq3.keys()):\n            result3.append(char * remaining_freq3[char])\n    else:\n        for char in sorted(freq.keys()):\n            result3.append(char * freq[char])\n    \n    # Choose the lexicographically smallest result\n    results = [''.join(result1), ''.join(result2), ''.join(result3)]\n    print(min(results))", "def solve():\n    from collections import Counter\n\n    t = int(input())\n    \n    for _ in range(t):\n        S = input().strip()\n        T = input().strip()\n        \n        count = Counter(S)\n        \n        # Extract counts for a, b, c\n        a_count = count.get('a', 0)\n        b_count = count.get('b', 0)\n        c_count = count.get('c', 0)\n        \n        # Remove a, b, c from count and sort the rest\n        count.pop('a', None)\n        count.pop('b', None)\n        count.pop('c', None)\n        \n        others = []\n        for char, cnt in sorted(count.items()):\n            others.append(char * cnt)\n        \n        others_str = ''.join(others)\n        \n        # Depending on T, arrange a, b, c to prevent subsequence\n        if T == \"abc\":\n            # To prevent abc, we can place all c's before b's\n            # So the pattern is: others + a* + c* + b*\n            res = others_str + 'a' * a_count + 'c' * c_count + 'b' * b_count\n        elif T == \"acb\":\n            # Prevent a...c...b, so place b's before c's\n            # Pattern: others + a* + b* + c*\n            res = others_str + 'a' * a_count + 'b' * b_count + 'c' * c_count\n        elif T == \"bac\":\n            # Prevent b...a...c, so place c's before a's\n            # Pattern: others + b* + c* + a*\n            res = others_str + 'b' * b_count + 'c' * c_count + 'a' * a_count\n        elif T == \"bca\":\n            # Prevent b...c...a, so place a's before c's\n            # Pattern: others + b* + a* + c*\n            res = others_str + 'b' * b_count + 'a' * a_count + 'c' * c_count\n        elif T == \"cab\":\n            # Prevent c...a...b, so place b's before a's\n            # Pattern: others + c* + b* + a*\n            res = others_str + 'c' * c_count + 'b' * b_count + 'a' * a_count\n        elif T == \"cba\":\n            # Prevent c...b...a, so place a's before b's\n            # Pattern: others + c* + a* + b*\n            res = others_str + 'c' * c_count + 'a' * a_count + 'b' * b_count\n        \n        print(res)\n\nsolve()", "import sys\nfrom collections import Counter\n\ndef solve():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        S = sys.stdin.readline().strip()\n        T = sys.stdin.readline().strip()\n        \n        count = Counter(S)\n        a = count.get('a', 0)\n        b = count.get('b', 0)\n        c = count.get('c', 0)\n        \n        # Collect all other characters\n        other_chars = []\n        for ch in sorted(count.keys()):\n            if ch not in 'abc':\n                other_chars.append(ch * count[ch])\n        \n        # If any of a, b, c is zero, we can just sort S\n        if a == 0 or b == 0 or c == 0:\n            print(''.join(sorted(S)))\n            continue\n        \n        # Handle different patterns of T to avoid creating T as subsequence\n        if T == \"abc\":\n            # To avoid a...b...c pattern, we can do a...c...b\n            result = ['a' * a, 'c' * c, 'b' * b]\n        elif T == \"acb\":\n            # To avoid a...c...b pattern, we can do a...b...c  \n            result = ['a' * a, 'b' * b, 'c' * c]\n        elif T == \"bac\":\n            # To avoid b...a...c pattern, we can do b...c...a or c...b...a or a...b...c\n            # We want lex smallest, so try a...b...c first\n            result = ['a' * a, 'b' * b, 'c' * c]\n        elif T == \"bca\":\n            # To avoid b...c...a pattern, we can do b...a...c\n            result = ['b' * b, 'a' * a, 'c' * c]\n        elif T == \"cab\":\n            # To avoid c...a...b pattern, we can do c...b...a\n            result = ['c' * c, 'b' * b, 'a' * a]\n        elif T == \"cba\":\n            # To avoid c...b...a pattern, we can do c...a...b\n            result = ['c' * c, 'a' * a, 'b' * b]\n            \n        print(''.join(other_chars + result))\n\nsolve()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of all characters in S\n        count = [0] * 26\n        for ch in S:\n            count[ord(ch) - ord('a')] += 1\n            \n        # Separate characters not in {'a', 'b', 'c'}\n        other_chars = []\n        for i in range(26):\n            if i not in [0, 1, 2]:  # Not 'a', 'b', 'c'\n                ch = chr(i + ord('a'))\n                other_chars.extend([ch] * count[i])\n        \n        # Sort other characters\n        other_chars.sort()\n                \n        # Get counts of 'a', 'b', 'c'\n        ca, cb, cc = count[0], count[1], count[2]\n        \n        # If any of a,b,c is missing, just sort everything\n        if ca == 0 or cb == 0 or cc == 0:\n            total = sorted(S)\n            results.append(''.join(total))\n            continue\n            \n        # Depending on T, arrange a,b,c to prevent subsequence\n        if T == \"abc\":\n            # To prevent abc: put all 'c's before 'b's  \n            part_abc = 'a' * ca + 'c' * cc + 'b' * cb\n        elif T == \"acb\":\n            # To prevent acb: put all 'b's before 'c's\n            part_abc = 'a' * ca + 'b' * cb + 'c' * cc\n        elif T == \"bac\":\n            # To prevent bac: put all 'c's before 'a's\n            part_abc = 'b' * cb + 'c' * cc + 'a' * ca\n        elif T == \"bca\":\n            # To prevent bca: put all 'a's before 'c's\n            part_abc = 'b' * cb + 'a' * ca + 'c' * cc\n        elif T == \"cab\":\n            # To prevent cab: put all 'b's before 'a's\n            part_abc = 'c' * cc + 'b' * cb + 'a' * ca\n        elif T == \"cba\":\n            # To prevent cba: put all 'a's before 'b's\n            part_abc = 'c' * cc + 'a' * ca + 'b' * cb\n            \n        results.append(''.join(other_chars) + part_abc)\n    \n    # Print each result on a new line\n    for result in results:\n        print(result)\n\nsolve()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of all characters in S\n        from collections import Counter\n        count_S = Counter(S)\n        \n        # Identify the three characters in T\n        x, y, z = T[0], T[1], T[2]\n        \n        # If any of x, y, z are missing from S, T cannot be a subsequence\n        # So the lex smallest permutation is simply the sorted S\n        if count_S[x] == 0 or count_S[y] == 0 or count_S[z] == 0:\n            res = ''.join(sorted(S))\n            results.append(res)\n            continue\n            \n        # Collect other characters and sort them\n        other_chars = []\n        for char, cnt in count_S.items():\n            if char != x and char != y and char != z:\n                other_chars.extend([char] * cnt)\n        other_chars.sort()\n        part_other = ''.join(other_chars)\n        \n        # Get counts of T characters\n        cx, cy, cz = count_S[x], count_S[y], count_S[z]\n        \n        # To prevent T from being a subsequence, arrange T characters as:\n        # T[0] * count + T[2] * count + T[1] * count\n        # This breaks the pattern T[0] -> T[1] -> T[2]\n        arranged_T_chars = x * cx + z * cz + y * cy\n        \n        res = part_other + arranged_T_chars\n        results.append(res)\n        \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of characters in S\n        freq = [0] * 26\n        for ch in S:\n            freq[ord(ch) - ord('a')] += 1\n            \n        # Get the three characters in T\n        x = T[0]\n        y = T[1]\n        z = T[2]\n        \n        # Convert to indices\n        ix = ord(x) - ord('a')\n        iy = ord(y) - ord('a')\n        iz = ord(z) - ord('a')\n        \n        # Strategy:\n        # To make sure T is NOT a subsequence, we must ensure that\n        # we do NOT have x ... y ... z appearing in that order.\n        # The best way to do this lex smallest is:\n        # Place all characters < x first.\n        # Then place all x's\n        # Then all characters between x and y\n        # Then all y's\n        # Then all characters between y and z\n        # Then all z's\n        # Then remaining characters >= z\n        \n        # But simpler approach:\n        # We want to break the xyz sequence.\n        # Try to delay one of x,y,z as much as possible.\n        \n        # Optimal strategy:\n        # Place all characters except the last one in T in their sorted order,\n        # then place the last character of T, then the rest.\n        # OR better yet: identify which of x,y,z we can delay.\n        \n        # Best method:\n        # We want to avoid x appearing before y appearing before z.\n        # So among x,y,z, we should try to put the last one (in T) first.\n        # That is, put all z's first, then others in order.\n        \n        # Even better:\n        # Among the three characters, move the one that appears LAST in T to the front.\n        # This breaks the subsequence.\n        \n        res = []\n        \n        # Find the last character in T\n        last_char = T[2]\n        last_index = ord(last_char) - ord('a')\n        \n        # If there are any of the last char, place them first\n        res.append(last_char * freq[last_index])\n        freq[last_index] = 0\n        \n        # Now append everything else in alphabetical order\n        for i in range(26):\n            if freq[i] > 0:\n                res.append(chr(i + ord('a')) * freq[i])\n                \n        results.append(''.join(res))\n        \n    print('\\n'.join(results))\n\nsolve()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequency of each character in S\n        freq = [0] * 26\n        for ch in S:\n            freq[ord(ch) - ord('a')] += 1\n            \n        # Get characters of T\n        a, b, c = T[0], T[1], T[2]\n        \n        # Convert to indices\n        ia = ord(a) - ord('a')\n        ib = ord(b) - ord('a')\n        ic = ord(c) - ord('a')\n        \n        # Build prefix with characters not in T\n        prefix = []\n        for i in range(26):\n            if i != ia and i != ib and i != ic:\n                prefix.extend([chr(i + ord('a'))] * freq[i])\n        \n        # Try different arrangements of a, b, c characters to avoid T as subsequence\n        # We want the lexicographically smallest valid arrangement\n        candidates = []\n        \n        # Generate arrangements that break the subsequence\n        arrangements = [\n            [a] * freq[ia] + [b] * freq[ib] + [c] * freq[ic],  # abc\n            [a] * freq[ia] + [c] * freq[ic] + [b] * freq[ib],  # acb\n            [b] * freq[ib] + [a] * freq[ia] + [c] * freq[ic],  # bac\n            [b] * freq[ib] + [c] * freq[ic] + [a] * freq[ia],  # bca\n            [c] * freq[ic] + [a] * freq[ia] + [b] * freq[ib],  # cab\n            [c] * freq[ic] + [b] * freq[ib] + [a] * freq[ia]   # cba\n        ]\n        \n        # Check each arrangement to see if it avoids T as subsequence\n        for arr in arrangements:\n            candidate = prefix + arr\n            candidate_str = ''.join(candidate)\n            \n            # Check if T is NOT a subsequence\n            if not is_subsequence(T, candidate_str):\n                candidates.append(candidate_str)\n        \n        # Pick lexicographically smallest valid candidate\n        if candidates:\n            results.append(min(candidates))\n        else:\n            # If no arrangement works, use a fallback that should work\n            # Place c's first among abc characters to break the pattern\n            res = prefix + [c] * freq[ic] + [a] * freq[ia] + [b] * freq[ib]\n            results.append(''.join(res))\n        \n    print('\\n'.join(results))\n\ndef is_subsequence(pattern, text):\n    \"\"\"Check if pattern is a subsequence of text\"\"\"\n    i = 0  # pattern index\n    for j in range(len(text)):\n        if i < len(pattern) and text[j] == pattern[i]:\n            i += 1\n    return i == len(pattern)\n\nsolve()", "import sys\nfrom collections import Counter\n\ndef contains_subseq(s, t):\n    i = 0\n    for ch in s:\n        if i < len(t) and ch == t[i]:\n            i += 1\n    return i == len(t)\n\ndef solve(S, T):\n    count = Counter(S)\n    first, second, third = T[0], T[1], T[2]\n    \n    # Characters not in T\n    other_chars = []\n    for ch in sorted(count.keys()):\n        if ch not in T:\n            other_chars.append(ch * count[ch])\n    \n    others = ''.join(other_chars)\n    \n    # Create different arrangements of a, b, c characters\n    a_count = count['a']\n    b_count = count['b']\n    c_count = count['c']\n    \n    # Possible arrangements of a, b, c that break the subsequence\n    arrangements = []\n    \n    # Strategy: try various arrangements that break the subsequence\n    # The key is to make sure third character of T doesn't come before second character\n    \n    # Arrangement 1: first* + third* + second*\n    s1 = first * count[first] + third * count[third] + second * count[second]\n    \n    # Arrangement 2: second* + first* + third*  \n    s2 = second * count[second] + first * count[first] + third * count[third]\n    \n    # Arrangement 3: third* + first* + second*\n    s3 = third * count[third] + first * count[first] + second * count[second]\n    \n    # Arrangement 4: first* + second* + third* but reordered\n    s4 = first * count[first] + second * count[second] + third * count[third]\n    \n    # Arrangement 5: second* + third* + first*\n    s5 = second * count[second] + third * count[third] + first * count[first]\n    \n    # Arrangement 6: third* + second* + first*\n    s6 = third * count[third] + second * count[second] + first * count[first]\n    \n    candidates = [s1, s2, s3, s4, s5, s6]\n    \n    valid_arrangements = []\n    for candidate in candidates:\n        if not contains_subseq(others + candidate, T):\n            valid_arrangements.append(others + candidate)\n    \n    if valid_arrangements:\n        return min(valid_arrangements)\n    else:\n        # If no arrangement works, just return the sorted string\n        # This happens when it's impossible to avoid the subsequence\n        # But the problem guarantees a solution exists\n        chars = []\n        for ch in sorted(count.keys()):\n            chars.append(ch * count[ch])\n        return ''.join(chars)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        results.append(solve(S, T))\n        index += 2\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def solve():\n    import sys\n    from collections import Counter\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        count = Counter(S)\n        \n        # Get counts of a, b, c\n        a_count = count.get('a', 0)\n        b_count = count.get('b', 0)\n        c_count = count.get('c', 0)\n        \n        # Build the part of the string without a, b, c\n        other_chars = []\n        for ch in sorted(count.keys()):\n            if ch not in 'abc':\n                other_chars.extend([ch] * count[ch])\n        \n        # Depending on T, we arrange a, b, c to avoid subsequence\n        if T == 'abc':\n            # To avoid abc, we can place all c's before b's: a*c*b*\n            abc_part = 'a' * a_count + 'c' * c_count + 'b' * b_count\n        elif T == 'acb':\n            # To avoid acb, place b's before c's: a*b*c*\n            abc_part = 'a' * a_count + 'b' * b_count + 'c' * c_count\n        elif T == 'bac':\n            # To avoid bac, place c's before a's: b*c*a*\n            abc_part = 'b' * b_count + 'c' * c_count + 'a' * a_count\n        elif T == 'bca':\n            # To avoid bca, place a's before c's: b*a*c*\n            abc_part = 'b' * b_count + 'a' * a_count + 'c' * c_count\n        elif T == 'cab':\n            # To avoid cab, place b's before a's: c*b*a*\n            abc_part = 'c' * c_count + 'b' * b_count + 'a' * a_count\n        elif T == 'cba':\n            # To avoid cba, place a's before b's: c*a*b*\n            abc_part = 'c' * c_count + 'a' * a_count + 'b' * b_count\n        else:\n            # This shouldn't happen as per problem statement\n            abc_part = 'a' * a_count + 'b' * b_count + 'c' * c_count\n        \n        # Now we need to merge other_chars and abc_part optimally to get lex smallest\n        # We'll do this by comparing character by character\n        result_chars = []\n        i, j = 0, 0\n        \n        while i < len(other_chars) and j < len(abc_part):\n            if other_chars[i] <= abc_part[j]:\n                result_chars.append(other_chars[i])\n                i += 1\n            else:\n                result_chars.append(abc_part[j])\n                j += 1\n        \n        # Add remaining characters\n        while i < len(other_chars):\n            result_chars.append(other_chars[i])\n            i += 1\n        while j < len(abc_part):\n            result_chars.append(abc_part[j])\n            j += 1\n            \n        result = ''.join(result_chars)\n        results.append(result)\n    \n    print('\\n'.join(results))\n\nsolve()", "import sys\nfrom collections import Counter\n\ndef solve():\n    t = int(sys.stdin.readline())\n    \n    for _ in range(t):\n        S = sys.stdin.readline().strip()\n        T = sys.stdin.readline().strip()\n        \n        # Count frequency of each character in S\n        freq = Counter(S)\n        \n        # Separate characters into special (a,b,c) and others\n        others = []\n        for ch in sorted(freq.keys()):\n            if ch not in 'abc':\n                others.append(ch * freq[ch])\n        \n        # Get counts of a, b, c\n        count_a = freq.get('a', 0)\n        count_b = freq.get('b', 0)\n        count_c = freq.get('c', 0)\n        \n        # Determine the best arrangement of a,b,c to avoid T as subsequence\n        if T == \"abc\":\n            # To avoid a.*b.*c, we can put all c's before all b's: a*c*b*\n            result = ''.join(others) + 'a' * count_a + 'c' * count_c + 'b' * count_b\n        elif T == \"acb\":\n            # To avoid a.*c.*b, we can put all b's before all c's: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"bac\":\n            # To avoid b.*a.*c, we can put all c's before all a's: b*c*a* \n            # Or put all a's before all b's: a*b*c*\n            # Choose lexicographically smaller: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"bca\":\n            # To avoid b.*c.*a, we can put all a's before all b's: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"cab\":\n            # To avoid c.*a.*b, we can put all b's before all a's: c*b*a*\n            # Or put all a's before all b's: c*a*b*\n            # Choose lexicographically smaller when possible\n            if count_a > 0 and count_b > 0:\n                # We have both a and b, so c*b*a* vs c*a*b*, choose c*a*b* (smaller)\n                result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n            else:\n                # If missing a or b, simpler arrangements work\n                result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n        elif T == \"cba\":\n            # To avoid c.*b.*a, we can put all a's before all b's: c*a*b*\n            result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n        \n        print(result)\n\nsolve()"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    S = input().strip()\n    T = input().strip()\n    \n    # Count frequency of each character in S\n    freq = {}\n    for c in S:\n        freq[c] = freq.get(c, 0) + 1\n    \n    # Identify the three characters in T\n    x, y, z = T[0], T[1], T[2]\n    \n    # Try different strategies to avoid subsequence xyz\n    \n    # Strategy 1: Put all z at the beginning\n    result1 = []\n    if z in freq:\n        result1.append(z * freq[z])\n        remaining_freq1 = freq.copy()\n        del remaining_freq1[z]\n        for char in sorted(remaining_freq1.keys()):\n            result1.append(char * remaining_freq1[char])\n    else:\n        for char in sorted(freq.keys()):\n            result1.append(char * freq[char])\n    \n    # Strategy 2: Put all x at the end  \n    result2 = []\n    if x in freq:\n        remaining_freq2 = freq.copy()\n        x_count = remaining_freq2[x]\n        del remaining_freq2[x]\n        for char in sorted(remaining_freq2.keys()):\n            result2.append(char * remaining_freq2[char])\n        result2.append(x * x_count)\n    else:\n        for char in sorted(freq.keys()):\n            result2.append(char * freq[char])\n            \n    # Strategy 3: Put all y at the beginning\n    result3 = []\n    if y in freq:\n        result3.append(y * freq[y])\n        remaining_freq3 = freq.copy()\n        del remaining_freq3[y]\n        for char in sorted(remaining_freq3.keys()):\n            result3.append(char * remaining_freq3[char])\n    else:\n        for char in sorted(freq.keys()):\n            result3.append(char * freq[char])\n    \n    # Choose the lexicographically smallest result\n    results = [''.join(result1), ''.join(result2), ''.join(result3)]\n    print(min(results))\n\n\n", "\ndef solve():\n    from collections import Counter\n\n    t = int(input())\n    \n    for _ in range(t):\n        S = input().strip()\n        T = input().strip()\n        \n        count = Counter(S)\n        \n        # Extract counts for a, b, c\n        a_count = count.get('a', 0)\n        b_count = count.get('b', 0)\n        c_count = count.get('c', 0)\n        \n        # Remove a, b, c from count and sort the rest\n        count.pop('a', None)\n        count.pop('b', None)\n        count.pop('c', None)\n        \n        others = []\n        for char, cnt in sorted(count.items()):\n            others.append(char * cnt)\n        \n        others_str = ''.join(others)\n        \n        # Depending on T, arrange a, b, c to prevent subsequence\n        if T == \"abc\":\n            # To prevent abc, we can place all c's before b's\n            # So the pattern is: others + a* + c* + b*\n            res = others_str + 'a' * a_count + 'c' * c_count + 'b' * b_count\n        elif T == \"acb\":\n            # Prevent a...c...b, so place b's before c's\n            # Pattern: others + a* + b* + c*\n            res = others_str + 'a' * a_count + 'b' * b_count + 'c' * c_count\n        elif T == \"bac\":\n            # Prevent b...a...c, so place c's before a's\n            # Pattern: others + b* + c* + a*\n            res = others_str + 'b' * b_count + 'c' * c_count + 'a' * a_count\n        elif T == \"bca\":\n            # Prevent b...c...a, so place a's before c's\n            # Pattern: others + b* + a* + c*\n            res = others_str + 'b' * b_count + 'a' * a_count + 'c' * c_count\n        elif T == \"cab\":\n            # Prevent c...a...b, so place b's before a's\n            # Pattern: others + c* + b* + a*\n            res = others_str + 'c' * c_count + 'b' * b_count + 'a' * a_count\n        elif T == \"cba\":\n            # Prevent c...b...a, so place a's before b's\n            # Pattern: others + c* + a* + b*\n            res = others_str + 'c' * c_count + 'a' * a_count + 'b' * b_count\n        \n        print(res)\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import Counter\n\ndef solve():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        S = sys.stdin.readline().strip()\n        T = sys.stdin.readline().strip()\n        \n        count = Counter(S)\n        a = count.get('a', 0)\n        b = count.get('b', 0)\n        c = count.get('c', 0)\n        \n        # Collect all other characters\n        other_chars = []\n        for ch in sorted(count.keys()):\n            if ch not in 'abc':\n                other_chars.append(ch * count[ch])\n        \n        # If any of a, b, c is zero, we can just sort S\n        if a == 0 or b == 0 or c == 0:\n            print(''.join(sorted(S)))\n            continue\n        \n        # Handle different patterns of T to avoid creating T as subsequence\n        if T == \"abc\":\n            # To avoid a...b...c pattern, we can do a...c...b\n            result = ['a' * a, 'c' * c, 'b' * b]\n        elif T == \"acb\":\n            # To avoid a...c...b pattern, we can do a...b...c  \n            result = ['a' * a, 'b' * b, 'c' * c]\n        elif T == \"bac\":\n            # To avoid b...a...c pattern, we can do b...c...a or c...b...a or a...b...c\n            # We want lex smallest, so try a...b...c first\n            result = ['a' * a, 'b' * b, 'c' * c]\n        elif T == \"bca\":\n            # To avoid b...c...a pattern, we can do b...a...c\n            result = ['b' * b, 'a' * a, 'c' * c]\n        elif T == \"cab\":\n            # To avoid c...a...b pattern, we can do c...b...a\n            result = ['c' * c, 'b' * b, 'a' * a]\n        elif T == \"cba\":\n            # To avoid c...b...a pattern, we can do c...a...b\n            result = ['c' * c, 'a' * a, 'b' * b]\n            \n        print(''.join(other_chars + result))\n\nsolve()\n\n\n", "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of all characters in S\n        count = [0] * 26\n        for ch in S:\n            count[ord(ch) - ord('a')] += 1\n            \n        # Separate characters not in {'a', 'b', 'c'}\n        other_chars = []\n        for i in range(26):\n            if i not in [0, 1, 2]:  # Not 'a', 'b', 'c'\n                ch = chr(i + ord('a'))\n                other_chars.extend([ch] * count[i])\n        \n        # Sort other characters\n        other_chars.sort()\n                \n        # Get counts of 'a', 'b', 'c'\n        ca, cb, cc = count[0], count[1], count[2]\n        \n        # If any of a,b,c is missing, just sort everything\n        if ca == 0 or cb == 0 or cc == 0:\n            total = sorted(S)\n            results.append(''.join(total))\n            continue\n            \n        # Depending on T, arrange a,b,c to prevent subsequence\n        if T == \"abc\":\n            # To prevent abc: put all 'c's before 'b's  \n            part_abc = 'a' * ca + 'c' * cc + 'b' * cb\n        elif T == \"acb\":\n            # To prevent acb: put all 'b's before 'c's\n            part_abc = 'a' * ca + 'b' * cb + 'c' * cc\n        elif T == \"bac\":\n            # To prevent bac: put all 'c's before 'a's\n            part_abc = 'b' * cb + 'c' * cc + 'a' * ca\n        elif T == \"bca\":\n            # To prevent bca: put all 'a's before 'c's\n            part_abc = 'b' * cb + 'a' * ca + 'c' * cc\n        elif T == \"cab\":\n            # To prevent cab: put all 'b's before 'a's\n            part_abc = 'c' * cc + 'b' * cb + 'a' * ca\n        elif T == \"cba\":\n            # To prevent cba: put all 'a's before 'b's\n            part_abc = 'c' * cc + 'a' * ca + 'b' * cb\n            \n        results.append(''.join(other_chars) + part_abc)\n    \n    # Print each result on a new line\n    for result in results:\n        print(result)\n\nsolve()\n\n\n", "\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of all characters in S\n        from collections import Counter\n        count_S = Counter(S)\n        \n        # Identify the three characters in T\n        x, y, z = T[0], T[1], T[2]\n        \n        # If any of x, y, z are missing from S, T cannot be a subsequence\n        # So the lex smallest permutation is simply the sorted S\n        if count_S[x] == 0 or count_S[y] == 0 or count_S[z] == 0:\n            res = ''.join(sorted(S))\n            results.append(res)\n            continue\n            \n        # Collect other characters and sort them\n        other_chars = []\n        for char, cnt in count_S.items():\n            if char != x and char != y and char != z:\n                other_chars.extend([char] * cnt)\n        other_chars.sort()\n        part_other = ''.join(other_chars)\n        \n        # Get counts of T characters\n        cx, cy, cz = count_S[x], count_S[y], count_S[z]\n        \n        # To prevent T from being a subsequence, arrange T characters as:\n        # T[0] * count + T[2] * count + T[1] * count\n        # This breaks the pattern T[0] -> T[1] -> T[2]\n        arranged_T_chars = x * cx + z * cz + y * cy\n        \n        res = part_other + arranged_T_chars\n        results.append(res)\n        \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequencies of characters in S\n        freq = [0] * 26\n        for ch in S:\n            freq[ord(ch) - ord('a')] += 1\n            \n        # Get the three characters in T\n        x = T[0]\n        y = T[1]\n        z = T[2]\n        \n        # Convert to indices\n        ix = ord(x) - ord('a')\n        iy = ord(y) - ord('a')\n        iz = ord(z) - ord('a')\n        \n        # Strategy:\n        # To make sure T is NOT a subsequence, we must ensure that\n        # we do NOT have x ... y ... z appearing in that order.\n        # The best way to do this lex smallest is:\n        # Place all characters < x first.\n        # Then place all x's\n        # Then all characters between x and y\n        # Then all y's\n        # Then all characters between y and z\n        # Then all z's\n        # Then remaining characters >= z\n        \n        # But simpler approach:\n        # We want to break the xyz sequence.\n        # Try to delay one of x,y,z as much as possible.\n        \n        # Optimal strategy:\n        # Place all characters except the last one in T in their sorted order,\n        # then place the last character of T, then the rest.\n        # OR better yet: identify which of x,y,z we can delay.\n        \n        # Best method:\n        # We want to avoid x appearing before y appearing before z.\n        # So among x,y,z, we should try to put the last one (in T) first.\n        # That is, put all z's first, then others in order.\n        \n        # Even better:\n        # Among the three characters, move the one that appears LAST in T to the front.\n        # This breaks the subsequence.\n        \n        res = []\n        \n        # Find the last character in T\n        last_char = T[2]\n        last_index = ord(last_char) - ord('a')\n        \n        # If there are any of the last char, place them first\n        res.append(last_char * freq[last_index])\n        freq[last_index] = 0\n        \n        # Now append everything else in alphabetical order\n        for i in range(26):\n            if freq[i] > 0:\n                res.append(chr(i + ord('a')) * freq[i])\n                \n        results.append(''.join(res))\n        \n    print('\\n'.join(results))\n\nsolve()\n\n\n", "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        # Count frequency of each character in S\n        freq = [0] * 26\n        for ch in S:\n            freq[ord(ch) - ord('a')] += 1\n            \n        # Get characters of T\n        a, b, c = T[0], T[1], T[2]\n        \n        # Convert to indices\n        ia = ord(a) - ord('a')\n        ib = ord(b) - ord('a')\n        ic = ord(c) - ord('a')\n        \n        # Build prefix with characters not in T\n        prefix = []\n        for i in range(26):\n            if i != ia and i != ib and i != ic:\n                prefix.extend([chr(i + ord('a'))] * freq[i])\n        \n        # Try different arrangements of a, b, c characters to avoid T as subsequence\n        # We want the lexicographically smallest valid arrangement\n        candidates = []\n        \n        # Generate arrangements that break the subsequence\n        arrangements = [\n            [a] * freq[ia] + [b] * freq[ib] + [c] * freq[ic],  # abc\n            [a] * freq[ia] + [c] * freq[ic] + [b] * freq[ib],  # acb\n            [b] * freq[ib] + [a] * freq[ia] + [c] * freq[ic],  # bac\n            [b] * freq[ib] + [c] * freq[ic] + [a] * freq[ia],  # bca\n            [c] * freq[ic] + [a] * freq[ia] + [b] * freq[ib],  # cab\n            [c] * freq[ic] + [b] * freq[ib] + [a] * freq[ia]   # cba\n        ]\n        \n        # Check each arrangement to see if it avoids T as subsequence\n        for arr in arrangements:\n            candidate = prefix + arr\n            candidate_str = ''.join(candidate)\n            \n            # Check if T is NOT a subsequence\n            if not is_subsequence(T, candidate_str):\n                candidates.append(candidate_str)\n        \n        # Pick lexicographically smallest valid candidate\n        if candidates:\n            results.append(min(candidates))\n        else:\n            # If no arrangement works, use a fallback that should work\n            # Place c's first among abc characters to break the pattern\n            res = prefix + [c] * freq[ic] + [a] * freq[ia] + [b] * freq[ib]\n            results.append(''.join(res))\n        \n    print('\\n'.join(results))\n\ndef is_subsequence(pattern, text):\n    \"\"\"Check if pattern is a subsequence of text\"\"\"\n    i = 0  # pattern index\n    for j in range(len(text)):\n        if i < len(pattern) and text[j] == pattern[i]:\n            i += 1\n    return i == len(pattern)\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import Counter\n\ndef contains_subseq(s, t):\n    i = 0\n    for ch in s:\n        if i < len(t) and ch == t[i]:\n            i += 1\n    return i == len(t)\n\ndef solve(S, T):\n    count = Counter(S)\n    first, second, third = T[0], T[1], T[2]\n    \n    # Characters not in T\n    other_chars = []\n    for ch in sorted(count.keys()):\n        if ch not in T:\n            other_chars.append(ch * count[ch])\n    \n    others = ''.join(other_chars)\n    \n    # Create different arrangements of a, b, c characters\n    a_count = count['a']\n    b_count = count['b']\n    c_count = count['c']\n    \n    # Possible arrangements of a, b, c that break the subsequence\n    arrangements = []\n    \n    # Strategy: try various arrangements that break the subsequence\n    # The key is to make sure third character of T doesn't come before second character\n    \n    # Arrangement 1: first* + third* + second*\n    s1 = first * count[first] + third * count[third] + second * count[second]\n    \n    # Arrangement 2: second* + first* + third*  \n    s2 = second * count[second] + first * count[first] + third * count[third]\n    \n    # Arrangement 3: third* + first* + second*\n    s3 = third * count[third] + first * count[first] + second * count[second]\n    \n    # Arrangement 4: first* + second* + third* but reordered\n    s4 = first * count[first] + second * count[second] + third * count[third]\n    \n    # Arrangement 5: second* + third* + first*\n    s5 = second * count[second] + third * count[third] + first * count[first]\n    \n    # Arrangement 6: third* + second* + first*\n    s6 = third * count[third] + second * count[second] + first * count[first]\n    \n    candidates = [s1, s2, s3, s4, s5, s6]\n    \n    valid_arrangements = []\n    for candidate in candidates:\n        if not contains_subseq(others + candidate, T):\n            valid_arrangements.append(others + candidate)\n    \n    if valid_arrangements:\n        return min(valid_arrangements)\n    else:\n        # If no arrangement works, just return the sorted string\n        # This happens when it's impossible to avoid the subsequence\n        # But the problem guarantees a solution exists\n        chars = []\n        for ch in sorted(count.keys()):\n            chars.append(ch * count[ch])\n        return ''.join(chars)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        results.append(solve(S, T))\n        index += 2\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n", "\ndef solve():\n    import sys\n    from collections import Counter\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        count = Counter(S)\n        \n        # Get counts of a, b, c\n        a_count = count.get('a', 0)\n        b_count = count.get('b', 0)\n        c_count = count.get('c', 0)\n        \n        # Build the part of the string without a, b, c\n        other_chars = []\n        for ch in sorted(count.keys()):\n            if ch not in 'abc':\n                other_chars.extend([ch] * count[ch])\n        \n        # Depending on T, we arrange a, b, c to avoid subsequence\n        if T == 'abc':\n            # To avoid abc, we can place all c's before b's: a*c*b*\n            abc_part = 'a' * a_count + 'c' * c_count + 'b' * b_count\n        elif T == 'acb':\n            # To avoid acb, place b's before c's: a*b*c*\n            abc_part = 'a' * a_count + 'b' * b_count + 'c' * c_count\n        elif T == 'bac':\n            # To avoid bac, place c's before a's: b*c*a*\n            abc_part = 'b' * b_count + 'c' * c_count + 'a' * a_count\n        elif T == 'bca':\n            # To avoid bca, place a's before c's: b*a*c*\n            abc_part = 'b' * b_count + 'a' * a_count + 'c' * c_count\n        elif T == 'cab':\n            # To avoid cab, place b's before a's: c*b*a*\n            abc_part = 'c' * c_count + 'b' * b_count + 'a' * a_count\n        elif T == 'cba':\n            # To avoid cba, place a's before b's: c*a*b*\n            abc_part = 'c' * c_count + 'a' * a_count + 'b' * b_count\n        else:\n            # This shouldn't happen as per problem statement\n            abc_part = 'a' * a_count + 'b' * b_count + 'c' * c_count\n        \n        # Now we need to merge other_chars and abc_part optimally to get lex smallest\n        # We'll do this by comparing character by character\n        result_chars = []\n        i, j = 0, 0\n        \n        while i < len(other_chars) and j < len(abc_part):\n            if other_chars[i] <= abc_part[j]:\n                result_chars.append(other_chars[i])\n                i += 1\n            else:\n                result_chars.append(abc_part[j])\n                j += 1\n        \n        # Add remaining characters\n        while i < len(other_chars):\n            result_chars.append(other_chars[i])\n            i += 1\n        while j < len(abc_part):\n            result_chars.append(abc_part[j])\n            j += 1\n            \n        result = ''.join(result_chars)\n        results.append(result)\n    \n    print('\\n'.join(results))\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import Counter\n\ndef solve():\n    t = int(sys.stdin.readline())\n    \n    for _ in range(t):\n        S = sys.stdin.readline().strip()\n        T = sys.stdin.readline().strip()\n        \n        # Count frequency of each character in S\n        freq = Counter(S)\n        \n        # Separate characters into special (a,b,c) and others\n        others = []\n        for ch in sorted(freq.keys()):\n            if ch not in 'abc':\n                others.append(ch * freq[ch])\n        \n        # Get counts of a, b, c\n        count_a = freq.get('a', 0)\n        count_b = freq.get('b', 0)\n        count_c = freq.get('c', 0)\n        \n        # Determine the best arrangement of a,b,c to avoid T as subsequence\n        if T == \"abc\":\n            # To avoid a.*b.*c, we can put all c's before all b's: a*c*b*\n            result = ''.join(others) + 'a' * count_a + 'c' * count_c + 'b' * count_b\n        elif T == \"acb\":\n            # To avoid a.*c.*b, we can put all b's before all c's: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"bac\":\n            # To avoid b.*a.*c, we can put all c's before all a's: b*c*a* \n            # Or put all a's before all b's: a*b*c*\n            # Choose lexicographically smaller: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"bca\":\n            # To avoid b.*c.*a, we can put all a's before all b's: a*b*c*\n            result = ''.join(others) + 'a' * count_a + 'b' * count_b + 'c' * count_c\n        elif T == \"cab\":\n            # To avoid c.*a.*b, we can put all b's before all a's: c*b*a*\n            # Or put all a's before all b's: c*a*b*\n            # Choose lexicographically smaller when possible\n            if count_a > 0 and count_b > 0:\n                # We have both a and b, so c*b*a* vs c*a*b*, choose c*a*b* (smaller)\n                result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n            else:\n                # If missing a or b, simpler arrangements work\n                result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n        elif T == \"cba\":\n            # To avoid c.*b.*a, we can put all a's before all b's: c*a*b*\n            result = ''.join(others) + 'c' * count_c + 'a' * count_a + 'b' * count_b\n        \n        print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [11790, 13345, 12566, 13097, 16579, 6269, 12700, 22478, 13189, 13614], "completion_tokens": [6951, 9768, 6682, 8938, 9141, 4575, 7711, 8581, 8110, 6409], "no_of_try": 10, "api_calls": 96, "is_solved": false, "language": "Python3", "task_id": 1617}
{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "source_codes": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    \n    results = []\n    for _ in range(t):\n        b = list(map(int, data[idx:idx+7]))\n        idx += 7\n        \n        # The smallest element must be one of the original elements\n        x = b[0]\n        # The largest element is the sum of all three\n        total = b[6]\n        # So the sum of the other two elements is total - x\n        sum_yz = total - x\n        \n        # Now I need to find y and z such that:\n        # y + z = sum_yz\n        # And all the subset sums match the given array b\n        \n        # The set b should contain: x, y, z, x+y, x+z, y+z, x+y+z\n        # We know x, total, and sum_yz\n        # So we need to identify y and z from the remaining elements\n        \n        # Try different combinations\n        # Since b[0] = x, and we have b[1], b[2], ... b[5] left to analyze\n        # One of b[1] or b[2] should be y or z (the next smallest element)\n        \n        # The second smallest element could be:\n        # - another single element (y)\n        # - or x + (smallest of y,z)\n        \n        # Let's try assuming b[1] is the second smallest single element\n        y = b[1]\n        z = sum_yz - y\n        \n        # Verify this works by checking if all subset sums match\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n            \n        # If that doesn't work, let's try a different approach\n        # b[1] might be x + (second smallest element)\n        # So the second smallest single element would be b[1] - x\n        y = b[1] - x\n        z = sum_yz - y\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n            \n        # Try b[2] - x as the second element  \n        y = b[2] - x\n        z = sum_yz - y\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n    \n    print('\\n'.join(results))\n\nsolve()"], "responses": ["\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    \n    results = []\n    for _ in range(t):\n        b = list(map(int, data[idx:idx+7]))\n        idx += 7\n        \n        # The smallest element must be one of the original elements\n        x = b[0]\n        # The largest element is the sum of all three\n        total = b[6]\n        # So the sum of the other two elements is total - x\n        sum_yz = total - x\n        \n        # Now I need to find y and z such that:\n        # y + z = sum_yz\n        # And all the subset sums match the given array b\n        \n        # The set b should contain: x, y, z, x+y, x+z, y+z, x+y+z\n        # We know x, total, and sum_yz\n        # So we need to identify y and z from the remaining elements\n        \n        # Try different combinations\n        # Since b[0] = x, and we have b[1], b[2], ... b[5] left to analyze\n        # One of b[1] or b[2] should be y or z (the next smallest element)\n        \n        # The second smallest element could be:\n        # - another single element (y)\n        # - or x + (smallest of y,z)\n        \n        # Let's try assuming b[1] is the second smallest single element\n        y = b[1]\n        z = sum_yz - y\n        \n        # Verify this works by checking if all subset sums match\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n            \n        # If that doesn't work, let's try a different approach\n        # b[1] might be x + (second smallest element)\n        # So the second smallest single element would be b[1] - x\n        y = b[1] - x\n        z = sum_yz - y\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n            \n        # Try b[2] - x as the second element  \n        y = b[2] - x\n        z = sum_yz - y\n        expected_sums = sorted([x, y, z, x+y, x+z, y+z, x+y+z])\n        if expected_sums == b:\n            results.append(f\"{x} {y} {z}\")\n            continue\n    \n    print('\\n'.join(results))\n\nsolve()\n\n\n"], "prompt_tokens": [16256], "completion_tokens": [7918], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1618}
{"name": "1619_A. Square String?", "description": "A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square.\n\nFor a given string s determine if it is square.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "tags": ["implementation", "strings"], "difficulty": 7, "id": 1619, "sample_io": [{"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}], "test_list": [{"input": "1\nacascnakcn\n", "output": ["NO\n"]}, {"input": "1\nababab\n", "output": ["NO\n"]}, {"input": "1\nzz\n", "output": ["YES\n"]}, {"input": "1\nacascnajcn\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\n{{\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nxyxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\nb\nb`\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxx\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nd\n`c\nbab\ncaa_\nbaba\nccabc`\n_baceac\nwxxy\nwuwy\nw|wz\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n`babab\n", "output": ["NO\n"]}, {"input": "1\nz{\n", "output": ["NO\n"]}, {"input": "1\nacascankcn\n", "output": ["NO\n"]}, {"input": "1\n`babbb\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscankcn\n", "output": ["NO\n"]}, {"input": "1\n_babbb\n", "output": ["NO\n"]}, {"input": "1\n{|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxxyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscakncn\n", "output": ["NO\n"]}, {"input": "1\n_baabb\n", "output": ["NO\n"]}, {"input": "1\n|{\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nabbscakncn\n", "output": ["NO\n"]}, {"input": "1\n^baabb\n", "output": ["NO\n"]}, {"input": "1\n||\n", "output": ["YES\n"]}, {"input": "1\nabbscakmcn\n", "output": ["NO\n"]}, {"input": "1\n^baacb\n", "output": ["NO\n"]}, {"input": "1\nz|\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbba\n", "output": ["NO\n"]}, {"input": "1\n^b`acb\n", "output": ["NO\n"]}, {"input": "1\n|z\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b^\n", "output": ["NO\n"]}, {"input": "1\nz}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nncmlacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b_\n", "output": ["NO\n"]}, {"input": "1\n}z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlansbca\n", "output": ["NO\n"]}, {"input": "1\n`cabb_\n", "output": ["NO\n"]}, {"input": "1\n{}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n_bbac`\n", "output": ["NO\n"]}, {"input": "1\n{z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n`bbac`\n", "output": ["NO\n"]}, {"input": "1\nyz\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbda\n", "output": ["NO\n"]}, {"input": "1\n`cabb`\n", "output": ["NO\n"]}, {"input": "1\nzy\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`cabc`\n", "output": ["NO\n"]}, {"input": "1\nzx\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaalmcb\n", "output": ["NO\n"]}, {"input": "1\n_cabc`\n", "output": ["NO\n"]}, {"input": "1\nxz\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaakmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbc`\n", "output": ["NO\n"]}, {"input": "1\nyy\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaajmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbd`\n", "output": ["NO\n"]}, {"input": "1\ny{\n", "output": ["NO\n"]}, {"input": "1\nbcmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbc_\n", "output": ["NO\n"]}, {"input": "1\ny|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbbmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbb_\n", "output": ["NO\n"]}, {"input": "1\nx|\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmjaasbbm\n", "output": ["NO\n"]}, {"input": "1\nadbbb_\n", "output": ["NO\n"]}, {"input": "1\nx}\n", "output": ["NO\n"]}, {"input": "1\nbdmj`asbbm\n", "output": ["NO\n"]}, {"input": "1\na_bbbd\n", "output": ["NO\n"]}, {"input": "1\nw}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmj`ascbm\n", "output": ["NO\n"]}, {"input": "1\na_cbbd\n", "output": ["NO\n"]}, {"input": "1\n}w\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdma`jscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcd\n", "output": ["NO\n"]}, {"input": "1\n}x\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcc\n", "output": ["NO\n"]}, {"input": "1\ny}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cbbc\n", "output": ["NO\n"]}, {"input": "1\n}y\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdl`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cabc\n", "output": ["NO\n"]}, {"input": "1\n~y\n", "output": ["NO\n"]}, {"input": "1\nbbl`ajscdl\n", "output": ["NO\n"]}, {"input": "1\na`cabc\n", "output": ["NO\n"]}, {"input": "1\ny~\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcsja`lbb\n", "output": ["NO\n"]}, {"input": "1\na`cbbc\n", "output": ["NO\n"]}, {"input": "1\ny\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lbb\n", "output": ["NO\n"]}, {"input": "1\naacbbc\n", "output": ["NO\n"]}, {"input": "1\n\u007fy\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lab\n", "output": ["NO\n"]}, {"input": "1\naacbbb\n", "output": ["NO\n"]}, {"input": "1\nx\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lab\n", "output": ["NO\n"]}, {"input": "1\naadbbb\n", "output": ["NO\n"]}, {"input": "1\nx~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebbb\n", "output": ["NO\n"]}, {"input": "1\nz~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebab\n", "output": ["NO\n"]}, {"input": "1\n~z\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lac\n", "output": ["NO\n"]}, {"input": "1\nbabeaa\n", "output": ["NO\n"]}, {"input": "1\nz\u007f\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddrja`lac\n", "output": ["NO\n"]}, {"input": "1\naabeaa\n", "output": ["NO\n"]}, {"input": "1\n\u007fz\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddm\n", "output": ["NO\n"]}, {"input": "1\naaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajqddm\n", "output": ["NO\n"]}, {"input": "1\nbaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`aiqddm\n", "output": ["NO\n"]}, {"input": "1\naabeab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`lac\n", "output": ["NO\n"]}, {"input": "1\nbaebab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`lad\n", "output": ["NO\n"]}, {"input": "1\nbafbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`mad\n", "output": ["NO\n"]}, {"input": "1\nbagbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ndam`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\nbagbaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`m`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\naagbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`c`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`b`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbb`\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`b`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`gb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`c`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\nb`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`can\n", "output": ["NO\n"]}, {"input": "1\na_hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cmn\n", "output": ["NO\n"]}, {"input": "1\nbabh_a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cnn\n", "output": ["NO\n"]}, {"input": "1\nbabh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`aiqdda\n", "output": ["NO\n"]}, {"input": "1\nbbbh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`ajqdda\n", "output": ["NO\n"]}, {"input": "1\nabbh^b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqja`cnn\n", "output": ["NO\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    s = input().strip()\n    n = len(s)\n    if n % 2 != 0:\n        print(\"NO\")\n    else:\n        mid = n // 2\n        if s[:mid] == s[mid:]:\n            print(\"YES\")\n        else:\n            print(\"NO\")"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    s = input().strip()\n    n = len(s)\n    if n % 2 != 0:\n        print(\"NO\")\n    else:\n        mid = n // 2\n        if s[:mid] == s[mid:]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\n"], "prompt_tokens": [7249], "completion_tokens": [2285], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1619}
{"name": "1620_A. Equal or Not Equal", "description": "You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not.\n\nUnfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Next t cases follow.\n\nThe first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 \u2264 n \u2264 50. For each i from 1 to n: \n\n  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); \n  * if s_i = N then a_i is not equal to a_{i + 1} (a_n \u2260 a_1 for i = n). \n\nOutput\n\nFor each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.\n\nIt can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.\n\nExample\n\nInput\n\n\n4\nEEE\nEN\nENNEENE\nNENN\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\n\nNote\n\nIn the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.\n\nIn the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.\n\nIn the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].\n\nIn the fourth test case, you can, for example, choose a = [1, 3, 3, 7].", "tags": ["constructive algorithms", "dsu", "implementation"], "difficulty": 7, "id": 1620, "sample_io": [{"input": "4\nEEE\nEN\nENNEENE\nNENN\n", "output": ["YES\nNO\nYES\nYES\n"]}], "test_list": [{"input": "1\nNEEEEEEEEEEEEEEEEEEEEEEEEEEEEENNNNEENNE\n", "output": ["YES\n"]}, {"input": "2\nEEEEEEN\nEEEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "2\nEEEEEN\nEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "2\nEEEEEN\nEE\n", "output": ["NO\nYES\n"]}, {"input": "1\nNEEEEEEEFEEEEEEEEEEEEEEEEEEEEENNNNEENNE\n", "output": ["YES\n"]}, {"input": "2\nNEEEEEE\nEEEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "2\nEENEEE\nEE\n", "output": ["NO\nYES\n"]}, {"input": "4\nEEE\nNE\nENNEENE\nNENN\n", "output": ["YES\nNO\nYES\nYES\n"]}, {"input": "2\nNEEEEE\nEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "1\nNEEFEEEEFEEEEEEEEEEEEEEEEEEEEENNNNEENNE\n", "output": ["YES\n"]}, {"input": "2\nNEEEEEE\nNEEEEEEE\n", "output": ["NO\nNO\n"]}, {"input": "1\nENNEENNNNEEEEEEEEEEEEEEEEEEEEEFEEEEFEEN\n", "output": ["YES\n"]}, {"input": "2\nEEEEENE\nNEEEEEEE\n", "output": ["NO\nNO\n"]}, {"input": "1\nENNEENNNNEEEEEEEEEEEFEEEEEEEEEFEEEEFEEN\n", "output": ["YES\n"]}, {"input": "2\nEEEEENE\nEEEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "1\nENNEENNNEEEEEEEEEEEEFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "2\nENEEEEE\nEEEEEEEN\n", "output": ["NO\nNO\n"]}, {"input": "1\nENNEENNNEEEEEEEEEEFEFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEENFEEEEEEEEEFEFEEEEEEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEEEEEEEEFFFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEENFEEEEEEEEEFFFEEEEEEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEENFEEEEEEEEEFFFEEEFEEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENFEEEEEEEEEFFFEEEFEEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENFEEEEEEEEEFFFEEEFEEFEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEFNEEEEEEEEEEFFFEEEFEEFEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFEEFEEEFFFEEEEEEEEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFEEFEEEFFFEEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFEEFEEEFFFDEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFFEFEEEFFFDEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENOEENNNEEEFFEFEEEFFFDEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEFNEEEFEEEEEDFFFEEEFEFFEEENNNEEONE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEDFFFEEFFEFFEEENNNEEONE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEFFFFEEDFEFFEEENNNEEONE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEFFFFEEDFEFFEEENNNDEONE\n", "output": ["YES\n"]}, {"input": "1\nENOEDNNNEEEFFEFDEEFFFFEEEEEFEEENEEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNNEEEFFEFDEEFFFFEEEEEFEEENEEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEFFFFEEDFEFFEEENNNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEEDEEEFEEEEEFFFFEENFEFFEEENNNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEEDEEEFEEEEEFFFFEENFEFFEEEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEEDEEEFEEEEEFFFFEENFEEFEEEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNFDFEEEDEEEFEEEEEFEFFEENFEEFEEEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEEEEFEEEDEEEFDFN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEDEEFEEEDEEEFDFN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEDEEFEEEDEEEFDFM\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEDEEFEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEFEFEEFNEEFFEFEEDEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEFEFFEENFEEFEFEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEFEFFEENFEEFEGEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEGEFFEENFEEFEGEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEGEFFEENFEEFEGEONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEGEFEEFNEEFFEGEEDEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEFEFEEFNEEFFEGEEDEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEGEFFEENFEEFEFEONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEFEFEEFOEEFFEGEEDEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEGEFFEEOFEEFEFEONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEGEFFEEOFEEFEFDONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEEEEDEEGEFFEEOFEEFEFDONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNODFEFEEFOEEFFEGEEDEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nFNPDDNNODFEFEEFOEEFFEGEEEEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nFMPDDNNODFEFEEFOEEFFEGEEEEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEEEEEEEGEFFEEOFEEFEFDONNDDPMF\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEEEEEFEGEFFEEOFEEFEFDONNDDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDDNNODFEFEEFOEEFFEGEFEEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDDNEODFNFEEFOEEFFEGEFEEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDDNEODFNFEEFOEEFFEGEFEEEDEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEDEEEFEGEFFEEOFEEFNFDOENDDPME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFEGEFFEEOFEEFNFDOENDDPME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFDGEFFEEOFEEFNFDOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFDGEFFEEOFEEFNFEOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEOEFNFEEFOEEFFEGDFEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEOEFNFEEFOEFFFEGDFEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFDGEFFFEOFEEFNFEOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEFNFEEFOEFFFEGDFEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEDNFEEFOEFFFEGFFEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEDNFEEFOEFFFEGFFEEDDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMEDENEPEDNFEEFOEFFFEGFFEEDDEEPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMEDENEPEDNEEEFOEFFFEGFFEEDDEEPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMEDENEPEDNEEEFOEEFFEGFFEEDDEFPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMDDENEPEDNEEEFOEEFFEGFFEEDEEFPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMDDENEPEDNEEEFOFEFFEGFFEEDEEFPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDEEFFGEFFEFOFEEENDEPENEDDME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDEEFFGEFFEFOFEEENDEPENFDDME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDEEFFGEFFEFOFEEENDEPENFDDLE\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDEEFFGEFFEFOFEEENDEPENFDCLE\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPEEEDEEFFGEFFEFOFEEENDEPENFDCLF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEDPEEEDEEFFGEFFEFOFEEENDEPENFDFLF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEDPEEEDEEFFGEFFEFOFEEENDEPENFDFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEDPEEEDEEFFGEFFEFOFEFENDEPENFDFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEDPEEEDEEFFGEFFEFOFEFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEDEDPEEEDEEFFGEFFEFOFEFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEDEDPEEEDEEFFGEFFEFOFDFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEDECPEEEDEEFFGEFFEFOFDFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEPEDNEFDFOFEFFEGFFEEDEEEPCEDECEGM\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEPEDNEFDFOFEFFEGFGEEDEEEPCEDECEGM\n", "output": ["YES\n"]}, {"input": "1\nMGECEDECPEEEDEEGFGEFFEFOFDFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEPDDNEFDFOFEFFEGFGEEDEEEPCEEECEGM\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEPDDNEFDFOFEFFEGFGEEDEEEPCEEFCEGM\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEFDDNEPDFOFEFFEGFGEEDEEEPCEEFCEGM\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEGFGEFFEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEGFGEFEEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEFFGEFEEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECQEEEDEEFFGEFEEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNNEEEEEEEEEEEEEEEEEEEEEEEEEEEEEN\n", "output": ["YES\n"]}, {"input": "4\nEEE\nEN\nENNEENE\nNNEN\n", "output": ["YES\nNO\nYES\nYES\n"]}, {"input": "1\nNEEEEEEEFEEEEEEDEEEEEEEEEEEEEENNNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEEEFEEEEEEEEEEEEEEEEEEEENENNNEENNE\n", "output": ["YES\n"]}, {"input": "2\nEEEEEEN\nNEEEEEEE\n", "output": ["NO\nNO\n"]}, {"input": "1\nEEEFEEEEFEEEEEEEEEEEEEEEEENEEENNNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENOEENNNNEEEEEEEEEEEFEEEEEEEEEFEEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nEONEENNNEEEEEEEEEEEEFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEEEEEEEEFEFEEEEEEEEEFNEEEFEEM\n", "output": ["YES\n"]}, {"input": "1\nENNEENMNEEEEEEEEEEFEFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEEEDEEEEFFFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nENOEENNNEEEEEEEEEEFFFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEEEEFEEEFFFEEEEEEEEEFNEEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENONEEEEEEFEEEFFFEEEEEEEEEFNEEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDEEEENFEEEEEEEEEFFFEEEFEEFEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFEEEEEFFFFEEEEEEEEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEFEEFFEEFFFEEEEEEEEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEFEFEEFEEEFFFEEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENONEEEFEEFEEEFFFDEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEFNEEEFEEEEEDFFFEEEFEFFEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENOEFNNNEEEFFEFEEEFFFDEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEFNEEEFEEEEEDFFFEEEFEFFEEENNNEEOME\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEDFFFEEFFEFFEEENNNEEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEDENEEEFEEEEEFFFFEEDFEFFEEENNNEEONE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEENEEEFEEEEEEFFFEEDFEFFEEENNNDEONE\n", "output": ["YES\n"]}, {"input": "1\nENOEDNNNEEEGFEFDEEFFFFEEEEEFEEENEEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNNEEEFFEFDEEEFFFEEEEEFEEENFEEFDEN\n", "output": ["YES\n"]}, {"input": "1\nNEDFFEENEEEFEEEEEFFFFEEDFEFFEEENNNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDGEEEDEEEFEEEEEFFFFEENFEFFEEENNNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEEDEEEFEEEEEFFFFEENFEFFEEEOMNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNEDFEEEDEEEFEEEEEGFFFEENFEEFEEEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nNFDFEEEDEEEFEEEEEFEFFEENFEFFEEEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEEEEFEEEDFEEFDFN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNDEFFEFEEDEEFEEEDEEEFDFN\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEEEFEEFNEEFFEFEEDEEFEEDDEEEFDFM\n", "output": ["YES\n"]}, {"input": "1\nENPEDNMOEEEFEEFNEEFFEFEEDEEFEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nENPEDNNOEFEFEEFNEEFFEFFEDEEEEEEDEEDFEEM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEFEEEEDEEFEEFEENFEEFEFEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDFEFEFFEENFEEFEGEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEEEEGEFFEENFEEFEGEONNDEPNE\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEGEFEEFNEEFFEGEEDEEEEEEDEECFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEDEEFEFFEENFEEFEGEONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEFEFEEFNEEFFEGEEDEEEEEDDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFEEEDEEEEEEDEEGEFFEENFEEFEFEONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEFEDEEFOEEFFEGEEFEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nFNPEDNNOEFEFEDFOEEFFEGEEDEEEEEEDEEDFEFM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEFDEEEEEEDEEGEFFEEOFEEFEFDONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEEEFDEEGEFFEEOFEEFEFDONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nMHEFDEEDEEEEEEDEEGEFFEEOFEEFEFDONNDEPNF\n", "output": ["YES\n"]}, {"input": "1\nFNPDDENODFEFEEFOEEFFEGNEEEEEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nFMPDDNNODFEFEEFOEEFFEGEEEEDEEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nMFEFDEEDEEEEEEEEEGEFFEEOFEEFEFDONNDDPMF\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFEGEFFEEOFEEFEFDONNDDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDDNNODFEFEFFOEEFFEGEFEEEEEEEDEEDEEGM\n", "output": ["YES\n"]}, {"input": "1\nEMQDDNEODFNFEEFOEEFFEGEFEEEDEEEDEEDFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFDEEDEEEDEEEFEGEFFEEOFEEFNEDOENDDPME\n", "output": ["YES\n"]}, {"input": "1\nMFEFEEEDEEEDEEEFEGEFFEEOFEEFNGDOENDDPME\n", "output": ["YES\n"]}, {"input": "1\nMGEFFEEDEEEDEEEFDGEFFEEOEEEFNFDOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDEEEDEEEFDGEFFEEOFEFFNFEOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEOEFNFEEFOEEFFEGDFEEEEEEDDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEOEFNFEEFOEFFFEGDGEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEEEEDDEEEFDGEFFFEOFEEFNFEOENEDPME\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEFNFEEFOEFFFEGDFEEEDDEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEDNFDEFOEFFFEGFFEEEDEEEDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMPDENEPEDNFEEFOEFFFEGFFEEDDEEEDEFEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPEEDDEEFFGEFFFEOFEEFNDEPENEDEME\n", "output": ["YES\n"]}, {"input": "1\nEMEDENEPEDNEEEFOEFFFEHFFEEDDEEPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEDDEEFFGEFFEEOFEEENDEPENEDEME\n", "output": ["YES\n"]}, {"input": "1\nEMDDENEPDDNEEEFOEEFFEGFFEEDEEFPEEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nEMEDENDPEDNEEEFOFEFFEGFFEEDEEFPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDDEFFGEFFEFOFEEENDEPENEDDME\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEDPFEEDEEFFGEFFDFOFEEENDEPENFDDME\n", "output": ["YES\n"]}, {"input": "1\nMHEFEEEDPFEEDEEFFGEFFEFOFEEENDEPENFDDLE\n", "output": ["YES\n"]}, {"input": "1\nMGEFEEEEPFEEDEEFFGEFFEFOFEEENDEPENFDCLE\n", "output": ["YES\n"]}, {"input": "1\nFLCDFNEPEDNEEEFOFEFFEGFFEEDEEEPDEEEFEGM\n", "output": ["YES\n"]}, {"input": "1\nFKFDFNEPEDNEEEFOFEFFEGFFEEDEEEPDEEECEGM\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEEPEEEDEEFFGEFFEFOFEEENDEPENFDFKF\n", "output": ["YES\n"]}, {"input": "1\nMFECEEEDPEEEDEEFFGEFFEFOFEFENDEPENFDFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEEDOEEEDEEFFGEFFEFOFEFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEDEDPEEEDEEEFGEFFEFOFEFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEDEDPEEEDEEFFGEFGEFOFDFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEPEDNEFDFNFEFFEGFFEEDEEEPCEDECEGM\n", "output": ["YES\n"]}, {"input": "1\nFKFEDNEPEDNEFDFOFEFFEGFFEEDEEEPCEDECEGM\n", "output": ["YES\n"]}, {"input": "1\nMGECEDECPEEEDEEGFGEFFEEOFDFENDEPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECEEECPEEEDEEGFGEFFEFOFDFENDDPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEGFGEFFEFOFDFENDDPENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nFKFFDNEFDDNEPDFOFEFFEGFGEEDEEEOCEEFCEGM\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEGFGEEFEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEENFGEFEEFOFDPENDDFEGDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECPEEEDEEFFGEFEEFOFDPENDCFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nMGECFEECQEEEDEEFGGEFEEFOFDPENDDFENDFFKF\n", "output": ["YES\n"]}, {"input": "1\nNEEEEEEEEEEEEEEEEEEEEEEEEEEEEENNNNDENNE\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNNEEEEEEEEEEEEEEDEEEEEEFEEEEEEEN\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEEEFEEEEEEEEEFEEEEEEEEEENENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nEEEFEEEEFEEEEEEEEEEEEEEEEENEEENNMNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENOEENNNNEEEEEEEEEEEFEEEEEEEEEGEEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nEONEENNNEEEEEEEEEEEEFEEEEEEEEFFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nMEEFEEENFEEEEEEEEEFEFEEEEEEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENNEEMMNEEEEEEEEEEFEFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nNEEFEEENFEEEEEEEEEFFFEEEEDEEEEENNNEENNE\n", "output": ["YES\n"]}, {"input": "1\nENOEENNNEEEEEEEEFEFFFEEEEEEEEEFNEEEFEEN\n", "output": ["YES\n"]}, {"input": "1\nENNEENNNEEEEEEFEEDFFFEEEEEEEEEFNEEEFDEN\n", "output": ["YES\n"]}], "source_codes": ["def solve():\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        n = len(s)\n        \n        # Use coloring approach: 0 = unvisited, 1 = color1, -1 = color2\n        color = [0] * n\n        valid = True\n        \n        # Process each component\n        for start in range(n):\n            if color[start] != 0:\n                continue\n            \n            # Start BFS from this unvisited node\n            color[start] = 1\n            queue = [start]\n            \n            while queue and valid:\n                u = queue.pop(0)\n                current_color = color[u]\n                \n                # Check left neighbor: (u-1+n)%n \n                # The constraint is s[(u-1+n)%n] which represents edge from (u-1) to u\n                left = (u - 1 + n) % n\n                left_constraint = s[left]  # constraint between left and u\n                \n                if left_constraint == 'E':\n                    expected_color = current_color\n                else:  # 'N'\n                    expected_color = -current_color\n                \n                if color[left] == 0:\n                    color[left] = expected_color\n                    queue.append(left)\n                elif color[left] != expected_color:\n                    valid = False\n                    break\n                \n                # Check right neighbor: (u+1)%n\n                # The constraint is s[u] which represents edge from u to (u+1)\n                right = (u + 1) % n\n                right_constraint = s[u]  # constraint between u and right\n                \n                if right_constraint == 'E':\n                    expected_color = current_color\n                else:  # 'N'\n                    expected_color = -current_color\n                \n                if color[right] == 0:\n                    color[right] = expected_color\n                    queue.append(right)\n                elif color[right] != expected_color:\n                    valid = False\n                    break\n        \n        print(\"YES\" if valid else \"NO\")\n\nsolve()", "import sys\nfrom collections import defaultdict, deque\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n\ndef solve(s):\n    n = len(s)\n    \n    # Union-Find to group equal elements\n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Union all E neighbors\n    for i in range(n):\n        if s[i] == 'E':\n            union(parent, rank, i, (i + 1) % n)\n    \n    # Build constraint graph between components\n    graph = defaultdict(set)\n    \n    # Add N constraints between components\n    for i in range(n):\n        if s[i] == 'N':\n            u = find(parent, i)\n            v = find(parent, (i + 1) % n)\n            if u == v:\n                # Same component but marked as Not equal - impossible\n                return \"NO\"\n            graph[u].add(v)\n            graph[v].add(u)\n    \n    # Check if constraint graph is bipartite\n    color = {}\n    \n    # Get all components\n    all_components = set()\n    for i in range(n):\n        all_components.add(find(parent, i))\n    \n    # Check bipartiteness for each connected component in constraint graph\n    visited = set()\n    \n    for comp in all_components:\n        if comp in visited:\n            continue\n            \n        # BFS to check if this component of constraint graph is bipartite\n        queue = deque([comp])\n        color[comp] = 0\n        visited.add(comp)\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    color[neighbor] = 1 - color[node]\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input and process test cases\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    s = sys.stdin.readline().strip()\n    print(solve(s))", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\ndef solve(s):\n    n = len(s)\n    uf = UnionFind(n)\n    \n    # Process equality constraints - group indices that must be equal\n    for i in range(n):\n        if s[i] == 'E':\n            uf.union(i, (i + 1) % n)\n    \n    # Check inequality constraints\n    for i in range(n):\n        if s[i] == 'N':\n            root1 = uf.find(i)\n            root2 = uf.find((i + 1) % n)\n            \n            # If two elements that should be different are in the same group, it's impossible\n            if root1 == root2:\n                return \"NO\"\n    \n    # Build a graph of inequality constraints between groups\n    group_adj = {}\n    \n    # Add all inequality edges\n    for i in range(n):\n        if s[i] == 'N':\n            root1 = uf.find(i)\n            root2 = uf.find((i + 1) % n)\n            \n            # Add edges to adjacency list for group graph\n            if root1 not in group_adj:\n                group_adj[root1] = set()\n            if root2 not in group_adj:\n                group_adj[root2] = set()\n            \n            group_adj[root1].add(root2)\n            group_adj[root2].add(root1)\n    \n    # Now check if the group graph is bipartite (2-colorable)\n    group_color = {}\n    \n    def is_bipartite(node, color):\n        if node in group_color:\n            return group_color[node] == color\n        \n        group_color[node] = color\n        \n        if node in group_adj:\n            for neighbor in group_adj[node]:\n                if not is_bipartite(neighbor, 1 - color):\n                    return False\n        return True\n    \n    # Check all components of the group graph\n    for node in group_adj:\n        if node not in group_color:\n            if not is_bipartite(node, 0):\n                return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    s = input().strip()\n    print(solve(s))", "def solve():\n    import sys\n    from collections import defaultdict, deque\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    \n    index = 1\n    for _ in range(t):\n        s = data[index]\n        index += 1\n        n = len(s)\n        \n        # Build adjacency list for equality constraints (E edges)\n        adj_equal = [[] for _ in range(n)]\n        for i in range(n):\n            if s[i] == 'E':\n                adj_equal[i].append((i+1) % n)\n                adj_equal[(i+1) % n].append(i)\n        \n        # Find connected components using Union-Find or BFS\n        # Nodes in same component must have same value\n        color = [-1] * n\n        component_id = 0\n        \n        for i in range(n):\n            if color[i] == -1:\n                # BFS to color all nodes in this component\n                queue = deque([i])\n                color[i] = component_id\n                \n                while queue:\n                    u = queue.popleft()\n                    for v in adj_equal[u]:\n                        if color[v] == -1:\n                            color[v] = component_id\n                            queue.append(v)\n                \n                component_id += 1\n        \n        # Now check if inequality constraints are satisfied\n        # For each N edge, the endpoints must be in different components\n        valid = True\n        for i in range(n):\n            if s[i] == 'N':\n                if color[i] == color[(i+1) % n]:\n                    valid = False\n                    break\n        \n        if valid:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"], "responses": ["\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        n = len(s)\n        \n        # Use coloring approach: 0 = unvisited, 1 = color1, -1 = color2\n        color = [0] * n\n        valid = True\n        \n        # Process each component\n        for start in range(n):\n            if color[start] != 0:\n                continue\n            \n            # Start BFS from this unvisited node\n            color[start] = 1\n            queue = [start]\n            \n            while queue and valid:\n                u = queue.pop(0)\n                current_color = color[u]\n                \n                # Check left neighbor: (u-1+n)%n \n                # The constraint is s[(u-1+n)%n] which represents edge from (u-1) to u\n                left = (u - 1 + n) % n\n                left_constraint = s[left]  # constraint between left and u\n                \n                if left_constraint == 'E':\n                    expected_color = current_color\n                else:  # 'N'\n                    expected_color = -current_color\n                \n                if color[left] == 0:\n                    color[left] = expected_color\n                    queue.append(left)\n                elif color[left] != expected_color:\n                    valid = False\n                    break\n                \n                # Check right neighbor: (u+1)%n\n                # The constraint is s[u] which represents edge from u to (u+1)\n                right = (u + 1) % n\n                right_constraint = s[u]  # constraint between u and right\n                \n                if right_constraint == 'E':\n                    expected_color = current_color\n                else:  # 'N'\n                    expected_color = -current_color\n                \n                if color[right] == 0:\n                    color[right] = expected_color\n                    queue.append(right)\n                elif color[right] != expected_color:\n                    valid = False\n                    break\n        \n        print(\"YES\" if valid else \"NO\")\n\nsolve()\n\n\n", "\nimport sys\nfrom collections import defaultdict, deque\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    px, py = find(parent, x), find(parent, y)\n    if px == py:\n        return\n    if rank[px] < rank[py]:\n        px, py = py, px\n    parent[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n\ndef solve(s):\n    n = len(s)\n    \n    # Union-Find to group equal elements\n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Union all E neighbors\n    for i in range(n):\n        if s[i] == 'E':\n            union(parent, rank, i, (i + 1) % n)\n    \n    # Build constraint graph between components\n    graph = defaultdict(set)\n    \n    # Add N constraints between components\n    for i in range(n):\n        if s[i] == 'N':\n            u = find(parent, i)\n            v = find(parent, (i + 1) % n)\n            if u == v:\n                # Same component but marked as Not equal - impossible\n                return \"NO\"\n            graph[u].add(v)\n            graph[v].add(u)\n    \n    # Check if constraint graph is bipartite\n    color = {}\n    \n    # Get all components\n    all_components = set()\n    for i in range(n):\n        all_components.add(find(parent, i))\n    \n    # Check bipartiteness for each connected component in constraint graph\n    visited = set()\n    \n    for comp in all_components:\n        if comp in visited:\n            continue\n            \n        # BFS to check if this component of constraint graph is bipartite\n        queue = deque([comp])\n        color[comp] = 0\n        visited.add(comp)\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    color[neighbor] = 1 - color[node]\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input and process test cases\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    s = sys.stdin.readline().strip()\n    print(solve(s))\n\n\n", "\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\ndef solve(s):\n    n = len(s)\n    uf = UnionFind(n)\n    \n    # Process equality constraints - group indices that must be equal\n    for i in range(n):\n        if s[i] == 'E':\n            uf.union(i, (i + 1) % n)\n    \n    # Check inequality constraints\n    for i in range(n):\n        if s[i] == 'N':\n            root1 = uf.find(i)\n            root2 = uf.find((i + 1) % n)\n            \n            # If two elements that should be different are in the same group, it's impossible\n            if root1 == root2:\n                return \"NO\"\n    \n    # Build a graph of inequality constraints between groups\n    group_adj = {}\n    \n    # Add all inequality edges\n    for i in range(n):\n        if s[i] == 'N':\n            root1 = uf.find(i)\n            root2 = uf.find((i + 1) % n)\n            \n            # Add edges to adjacency list for group graph\n            if root1 not in group_adj:\n                group_adj[root1] = set()\n            if root2 not in group_adj:\n                group_adj[root2] = set()\n            \n            group_adj[root1].add(root2)\n            group_adj[root2].add(root1)\n    \n    # Now check if the group graph is bipartite (2-colorable)\n    group_color = {}\n    \n    def is_bipartite(node, color):\n        if node in group_color:\n            return group_color[node] == color\n        \n        group_color[node] = color\n        \n        if node in group_adj:\n            for neighbor in group_adj[node]:\n                if not is_bipartite(neighbor, 1 - color):\n                    return False\n        return True\n    \n    # Check all components of the group graph\n    for node in group_adj:\n        if node not in group_color:\n            if not is_bipartite(node, 0):\n                return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    s = input().strip()\n    print(solve(s))\n\n\n", "\ndef solve():\n    import sys\n    from collections import defaultdict, deque\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    \n    index = 1\n    for _ in range(t):\n        s = data[index]\n        index += 1\n        n = len(s)\n        \n        # Build adjacency list for equality constraints (E edges)\n        adj_equal = [[] for _ in range(n)]\n        for i in range(n):\n            if s[i] == 'E':\n                adj_equal[i].append((i+1) % n)\n                adj_equal[(i+1) % n].append(i)\n        \n        # Find connected components using Union-Find or BFS\n        # Nodes in same component must have same value\n        color = [-1] * n\n        component_id = 0\n        \n        for i in range(n):\n            if color[i] == -1:\n                # BFS to color all nodes in this component\n                queue = deque([i])\n                color[i] = component_id\n                \n                while queue:\n                    u = queue.popleft()\n                    for v in adj_equal[u]:\n                        if color[v] == -1:\n                            color[v] = component_id\n                            queue.append(v)\n                \n                component_id += 1\n        \n        # Now check if inequality constraints are satisfied\n        # For each N edge, the endpoints must be in different components\n        valid = True\n        for i in range(n):\n            if s[i] == 'N':\n                if color[i] == color[(i+1) % n]:\n                    valid = False\n                    break\n        \n        if valid:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()\n\n\n"], "prompt_tokens": [13395, 14060, 12214, 14213], "completion_tokens": [4598, 7639, 7409, 5105], "no_of_try": 4, "api_calls": 40, "is_solved": true, "language": "Python3", "task_id": 1620}
{"name": "1622_A. Construct a Rectangle", "description": "There are three sticks with integer lengths l_1, l_2 and l_3.\n\nYou are asked to break exactly one of them into two pieces in such a way that: \n\n  * both pieces have positive (strictly greater than 0) integer length; \n  * the total length of the pieces is equal to the original length of the stick; \n  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. \n\n\n\nA square is also considered a rectangle.\n\nDetermine if it's possible to do that.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe only line of each testcase contains three integers l_1, l_2, l_3 (1 \u2264 l_i \u2264 10^8) \u2014 the lengths of the sticks.\n\nOutput\n\nFor each testcase, print \"YES\" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print \"NO\".\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).\n\nExample\n\nInput\n\n\n4\n6 1 5\n2 5 2\n2 4 2\n5 5 4\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\n\nNote\n\nIn the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.\n\nIn the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.\n\nIn the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).\n\nIn the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.", "tags": ["geometry", "math"], "difficulty": 7, "id": 1622, "sample_io": [{"input": "4\n6 1 5\n2 5 2\n2 4 2\n5 5 4\n", "output": ["YES\nNO\nYES\nYES\n"]}], "test_list": [{"input": "2\n1 2 3\n2 2 4\n", "output": ["YES\nYES\n"]}, {"input": "1\n1 98 99\n", "output": ["YES\n"]}, {"input": "3\n1 1 1\n2 1 3\n5 6 7\n", "output": ["NO\nYES\nNO\n"]}, {"input": "6\n2 2 4\n1 1 2\n3 5 6\n1 2 3\n6 7 8\n10 10 20\n", "output": ["YES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "4\n6 1 5\n2 5 2\n2 4 2\n7 101 108\n", "output": ["YES\nNO\nYES\nYES\n"]}, {"input": "1\n100000 100000 100000\n", "output": ["YES\n"]}, {"input": "1\n12344 1 1\n", "output": ["YES\n"]}, {"input": "68\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n", "output": ["YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "2\n1 2 3\n4 5 6\n", "output": ["YES\nNO\n"]}, {"input": "2\n1 3 3\n2 2 4\n", "output": ["NO\nYES\n"]}, {"input": "1\n1 98 186\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 2\n5 6 7\n", "output": ["NO\nNO\nNO\n"]}, {"input": "6\n2 2 4\n1 1 2\n3 5 6\n1 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "4\n6 1 10\n2 5 2\n2 4 2\n7 101 108\n", "output": ["NO\nNO\nYES\nYES\n"]}, {"input": "1\n100000 100000 100100\n", "output": ["YES\n"]}, {"input": "68\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 1\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n", "output": ["YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "2\n1 1 3\n4 5 6\n", "output": ["NO\nNO\n"]}, {"input": "4\n6 1 5\n2 5 2\n2 4 2\n5 9 4\n", "output": ["YES\nNO\nYES\nYES\n"]}, {"input": "4\n6 1 10\n2 5 2\n2 4 2\n7 101 179\n", "output": ["NO\nNO\nYES\nNO\n"]}, {"input": "68\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n2 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 1\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n", "output": ["YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "2\n2 1 3\n1 5 6\n", "output": ["YES\nYES\n"]}, {"input": "4\n6 1 10\n2 6 2\n2 4 2\n7 101 144\n", "output": ["NO\nYES\nYES\nNO\n"]}, {"input": "3\n2 1 1\n2 1 2\n3 8 12\n", "output": ["YES\nNO\nNO\n"]}, {"input": "68\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 3\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n1 1 2\n", "output": ["YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "2\n1 2 3\n4 8 6\n", "output": ["YES\nNO\n"]}, {"input": "3\n1 1 1\n1 1 2\n5 6 12\n", "output": ["NO\nYES\nNO\n"]}, {"input": "4\n6 1 10\n2 6 2\n3 4 2\n7 101 144\n", "output": ["NO\nYES\nNO\nNO\n"]}, {"input": "3\n2 1 1\n1 1 2\n5 6 12\n", "output": ["YES\nYES\nNO\n"]}, {"input": "6\n2 2 6\n1 1 2\n3 10 6\n2 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "3\n3 1 1\n2 1 2\n1 8 9\n", "output": ["NO\nNO\nYES\n"]}, {"input": "6\n2 2 4\n1 1 1\n3 5 18\n1 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "4\n1 1 10\n2 6 2\n3 4 2\n7 101 144\n", "output": ["YES\nYES\nNO\nNO\n"]}, {"input": "3\n3 1 1\n2 2 2\n1 8 9\n", "output": ["NO\nYES\nYES\n"]}, {"input": "1\n12344 2 1\n", "output": ["NO\n"]}, {"input": "1\n2 98 186\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 2\n5 6 12\n", "output": ["NO\nNO\nNO\n"]}, {"input": "6\n2 2 4\n1 1 2\n3 10 6\n1 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "1\n100010 100000 100100\n", "output": ["NO\n"]}, {"input": "1\n20237 2 1\n", "output": ["NO\n"]}, {"input": "2\n1 1 3\n1 5 6\n", "output": ["NO\nYES\n"]}, {"input": "1\n2 98 239\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 2\n5 8 12\n", "output": ["NO\nNO\nNO\n"]}, {"input": "4\n6 1 10\n2 5 2\n2 4 2\n7 101 144\n", "output": ["NO\nNO\nYES\nNO\n"]}, {"input": "1\n100110 100000 100100\n", "output": ["NO\n"]}, {"input": "1\n20237 4 1\n", "output": ["NO\n"]}, {"input": "1\n1 98 239\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 2\n3 8 12\n", "output": ["NO\nNO\nNO\n"]}, {"input": "1\n100110 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n20237 3 1\n", "output": ["NO\n"]}, {"input": "1\n100111 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n21851 3 1\n", "output": ["NO\n"]}, {"input": "3\n2 1 1\n2 1 2\n1 8 12\n", "output": ["YES\nNO\nNO\n"]}, {"input": "1\n100011 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n21851 3 2\n", "output": ["NO\n"]}, {"input": "1\n100011 101001 100100\n", "output": ["NO\n"]}, {"input": "1\n100011 101001 100000\n", "output": ["NO\n"]}, {"input": "1\n110011 101001 100000\n", "output": ["NO\n"]}, {"input": "1\n110011 001001 100000\n", "output": ["NO\n"]}, {"input": "1\n110011 001001 110000\n", "output": ["NO\n"]}, {"input": "1\n100011 001001 110000\n", "output": ["NO\n"]}, {"input": "1\n100011 001001 111000\n", "output": ["NO\n"]}, {"input": "1\n100011 001101 111000\n", "output": ["NO\n"]}, {"input": "1\n100011 001101 111001\n", "output": ["NO\n"]}, {"input": "1\n100011 001101 111011\n", "output": ["NO\n"]}, {"input": "1\n100011 001111 111011\n", "output": ["NO\n"]}, {"input": "1\n100011 001110 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 001110 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 001010 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 001011 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 000011 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 000011 111111\n", "output": ["NO\n"]}, {"input": "1\n110011 000011 011111\n", "output": ["NO\n"]}, {"input": "1\n110011 000011 011101\n", "output": ["NO\n"]}, {"input": "1\n110011 100011 011101\n", "output": ["NO\n"]}, {"input": "1\n110011 100011 011100\n", "output": ["NO\n"]}, {"input": "1\n110011 100011 011000\n", "output": ["NO\n"]}, {"input": "1\n110011 100011 001100\n", "output": ["NO\n"]}, {"input": "1\n010011 100011 001100\n", "output": ["NO\n"]}, {"input": "1\n010111 100011 001100\n", "output": ["NO\n"]}, {"input": "1\n010111 100011 001000\n", "output": ["NO\n"]}, {"input": "1\n010111 000011 001000\n", "output": ["NO\n"]}, {"input": "1\n010111 000011 001001\n", "output": ["NO\n"]}, {"input": "1\n010111 000010 001001\n", "output": ["NO\n"]}, {"input": "1\n010111 100010 001001\n", "output": ["NO\n"]}, {"input": "1\n010111 100010 000001\n", "output": ["NO\n"]}, {"input": "1\n010111 000010 000001\n", "output": ["NO\n"]}, {"input": "1\n010111 000010 000011\n", "output": ["NO\n"]}, {"input": "1\n000111 000010 000011\n", "output": ["NO\n"]}, {"input": "1\n000111 000010 100011\n", "output": ["NO\n"]}, {"input": "1\n000111 000010 101011\n", "output": ["NO\n"]}, {"input": "1\n000111 000010 101010\n", "output": ["NO\n"]}, {"input": "1\n000111 000011 101010\n", "output": ["NO\n"]}, {"input": "1\n000111 100011 101010\n", "output": ["NO\n"]}, {"input": "1\n000111 101011 101010\n", "output": ["NO\n"]}, {"input": "1\n000111 101001 101010\n", "output": ["NO\n"]}, {"input": "1\n010111 101001 101010\n", "output": ["NO\n"]}, {"input": "1\n010111 101101 101010\n", "output": ["NO\n"]}, {"input": "1\n010111 001101 101010\n", "output": ["NO\n"]}, {"input": "1\n010111 001101 101110\n", "output": ["NO\n"]}, {"input": "1\n010101 001101 101110\n", "output": ["NO\n"]}, {"input": "1\n010101 001101 101010\n", "output": ["NO\n"]}, {"input": "1\n110101 001101 101010\n", "output": ["NO\n"]}, {"input": "1\n110101 001101 101110\n", "output": ["NO\n"]}, {"input": "1\n110101 101101 101110\n", "output": ["NO\n"]}, {"input": "1\n110111 101101 101110\n", "output": ["NO\n"]}, {"input": "1\n110111 101100 101110\n", "output": ["NO\n"]}, {"input": "1\n110111 101110 101110\n", "output": ["NO\n"]}, {"input": "1\n110111 101110 101010\n", "output": ["NO\n"]}, {"input": "1\n111111 101110 101010\n", "output": ["NO\n"]}, {"input": "1\n111111 101110 101011\n", "output": ["NO\n"]}, {"input": "1\n111111 101110 100011\n", "output": ["NO\n"]}, {"input": "1\n111111 101110 100010\n", "output": ["NO\n"]}, {"input": "1\n011111 101110 100010\n", "output": ["NO\n"]}, {"input": "1\n010111 101110 100010\n", "output": ["NO\n"]}, {"input": "1\n010111 101100 100010\n", "output": ["NO\n"]}, {"input": "1\n010111 111110 100010\n", "output": ["NO\n"]}, {"input": "1\n010111 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n000111 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n100111 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n001111 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n001101 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n000101 011110 100010\n", "output": ["NO\n"]}, {"input": "1\n000101 011111 100010\n", "output": ["NO\n"]}, {"input": "1\n000101 011101 100010\n", "output": ["NO\n"]}, {"input": "1\n000101 111101 100010\n", "output": ["NO\n"]}, {"input": "1\n000001 111101 100010\n", "output": ["NO\n"]}, {"input": "1\n000001 111101 100011\n", "output": ["NO\n"]}, {"input": "1\n000001 111101 100000\n", "output": ["NO\n"]}, {"input": "1\n000001 111001 100000\n", "output": ["NO\n"]}, {"input": "1\n000001 111001 100010\n", "output": ["NO\n"]}, {"input": "1\n000001 111001 000010\n", "output": ["NO\n"]}, {"input": "1\n000011 111001 000010\n", "output": ["NO\n"]}, {"input": "1\n000011 111001 000011\n", "output": ["NO\n"]}, {"input": "1\n100011 111001 000011\n", "output": ["NO\n"]}, {"input": "1\n100011 111001 000010\n", "output": ["NO\n"]}, {"input": "1\n100011 111101 000010\n", "output": ["NO\n"]}, {"input": "1\n100011 111101 001010\n", "output": ["NO\n"]}, {"input": "1\n100011 111100 001010\n", "output": ["NO\n"]}, {"input": "1\n100011 110100 001010\n", "output": ["NO\n"]}, {"input": "1\n100011 111100 011010\n", "output": ["NO\n"]}, {"input": "1\n100011 110100 011010\n", "output": ["NO\n"]}, {"input": "1\n101011 110100 011010\n", "output": ["NO\n"]}, {"input": "1\n101111 110100 011010\n", "output": ["NO\n"]}, {"input": "1\n101111 110100 011110\n", "output": ["NO\n"]}, {"input": "1\n001111 110100 011110\n", "output": ["NO\n"]}, {"input": "1\n101111 010100 011110\n", "output": ["NO\n"]}, {"input": "1\n101111 010100 011010\n", "output": ["NO\n"]}, {"input": "1\n101111 010000 011010\n", "output": ["NO\n"]}, {"input": "1\n101111 010000 111010\n", "output": ["NO\n"]}, {"input": "1\n101111 010000 111011\n", "output": ["NO\n"]}, {"input": "1\n001111 010000 111011\n", "output": ["NO\n"]}, {"input": "1\n001111 010000 111001\n", "output": ["NO\n"]}, {"input": "2\n1 4 3\n2 2 4\n", "output": ["YES\nYES\n"]}, {"input": "1\n1 98 108\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 4\n5 6 7\n", "output": ["NO\nNO\nNO\n"]}, {"input": "1\n100010 100000 100000\n", "output": ["YES\n"]}, {"input": "1\n2465 1 1\n", "output": ["NO\n"]}, {"input": "4\n6 2 5\n2 5 2\n2 4 2\n5 5 4\n", "output": ["NO\nNO\nYES\nYES\n"]}, {"input": "2\n1 3 3\n4 2 4\n", "output": ["NO\nYES\n"]}, {"input": "1\n3 98 186\n", "output": ["NO\n"]}, {"input": "3\n2 1 1\n2 1 2\n5 6 7\n", "output": ["YES\nNO\nNO\n"]}, {"input": "6\n2 2 4\n1 1 2\n3 5 10\n1 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "4\n6 1 10\n2 3 2\n2 4 2\n7 101 108\n", "output": ["NO\nNO\nYES\nYES\n"]}, {"input": "1\n100010 100001 100000\n", "output": ["NO\n"]}, {"input": "1\n19251 2 1\n", "output": ["NO\n"]}, {"input": "2\n1 1 3\n4 5 1\n", "output": ["NO\nYES\n"]}, {"input": "4\n9 1 5\n2 5 2\n2 4 2\n5 9 4\n", "output": ["NO\nNO\nYES\nYES\n"]}, {"input": "6\n2 2 6\n1 1 2\n3 10 6\n1 2 3\n6 7 8\n10 11 20\n", "output": ["YES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "4\n10 1 10\n2 5 2\n2 4 2\n7 101 179\n", "output": ["NO\nNO\nYES\nNO\n"]}, {"input": "1\n110010 100000 100100\n", "output": ["NO\n"]}, {"input": "1\n8323 2 1\n", "output": ["NO\n"]}, {"input": "1\n3 98 239\n", "output": ["NO\n"]}, {"input": "3\n1 1 1\n2 1 4\n5 8 12\n", "output": ["NO\nNO\nNO\n"]}, {"input": "4\n6 1 9\n2 5 2\n2 4 2\n7 101 144\n", "output": ["NO\nNO\nYES\nNO\n"]}, {"input": "1\n101110 100000 100100\n", "output": ["NO\n"]}, {"input": "1\n21283 4 1\n", "output": ["NO\n"]}, {"input": "2\n2 1 3\n1 5 5\n", "output": ["YES\nNO\n"]}, {"input": "1\n1 98 468\n", "output": ["NO\n"]}, {"input": "1\n110110 100000 100100\n", "output": ["NO\n"]}, {"input": "1\n35510 2 1\n", "output": ["NO\n"]}, {"input": "3\n2 1 1\n2 1 2\n3 8 17\n", "output": ["YES\nNO\nNO\n"]}, {"input": "1\n110111 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n12451 3 1\n", "output": ["NO\n"]}, {"input": "3\n3 1 1\n2 1 2\n1 8 12\n", "output": ["NO\nNO\nNO\n"]}, {"input": "1\n100001 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n21851 2 2\n", "output": ["NO\n"]}, {"input": "1\n100010 101000 100100\n", "output": ["NO\n"]}, {"input": "1\n100011 100001 100000\n", "output": ["NO\n"]}, {"input": "1\n110011 001001 100010\n", "output": ["NO\n"]}, {"input": "1\n110011 000001 110000\n", "output": ["NO\n"]}, {"input": "1\n101011 001001 110000\n", "output": ["NO\n"]}, {"input": "1\n110011 001001 111000\n", "output": ["NO\n"]}, {"input": "1\n101011 001101 111000\n", "output": ["NO\n"]}, {"input": "1\n100011 011101 111001\n", "output": ["NO\n"]}, {"input": "1\n100001 001101 111011\n", "output": ["NO\n"]}, {"input": "1\n100011 001111 011011\n", "output": ["NO\n"]}, {"input": "1\n101011 001110 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 001110 110011\n", "output": ["YES\n"]}, {"input": "1\n110111 001010 111011\n", "output": ["NO\n"]}, {"input": "1\n010011 001011 111011\n", "output": ["NO\n"]}, {"input": "1\n110111 000011 111011\n", "output": ["NO\n"]}, {"input": "1\n110011 010011 011111\n", "output": ["NO\n"]}, {"input": "1\n010011 000011 011111\n", "output": ["NO\n"]}, {"input": "1\n110011 010011 011101\n", "output": ["NO\n"]}, {"input": "1\n110010 100011 011101\n", "output": ["NO\n"]}, {"input": "1\n110011 100011 011110\n", "output": ["NO\n"]}, {"input": "1\n111011 100011 011000\n", "output": ["YES\n"]}, {"input": "1\n110011 000011 001100\n", "output": ["NO\n"]}, {"input": "1\n010110 100011 001100\n", "output": ["NO\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    l1, l2, l3 = map(int, input().split())\n    \n    found = False\n    \n    # Check if we can break l1 into two pieces\n    if not found:\n        # Break l1 into two pieces that pair with l2 and l3\n        if l1 == l2 + l3:\n            found = True\n        # Break l1 into two equal pieces that both pair with either l2 or l3\n        elif l1 % 2 == 0:\n            half = l1 // 2\n            if half == l2 or half == l3:\n                # The remaining two sticks must be equal to form the other pair\n                if (half == l2 and l3 == l3) or (half == l3 and l2 == l2):  # Always true, need better check\n                # Actually, if half == l2, then we have half,half,l2,l3 = half,half,l2,l3\n                # We need {half, half, l2, l3} to form two pairs\n                # Either: half=l2 and half=l3 (so l2=l3) OR half=l2 and l2=l3 (impossible unless l2=l3) OR half=l3 and l2=l3\n                # Simplified: if half == l2, then we need l2 == l3 for pairing, or if half == l3, then we need l2 == l3\n                if (half == l2 and l2 == l3) or (half == l3 and l2 == l3):\n                    found = True\n    \n    # Check if we can break l2 into two pieces\n    if not found:\n        # Break l2 into two pieces that pair with l1 and l3\n        if l2 == l1 + l3:\n            found = True\n        # Break l2 into two equal pieces that both pair with either l1 or l3\n        elif l2 % 2 == 0:\n            half = l2 // 2\n            if (half == l1 and l1 == l3) or (half == l3 and l1 == l3):\n                found = True\n    \n    # Check if we can break l3 into two pieces\n    if not found:\n        # Break l3 into two pieces that pair with l1 and l2\n        if l3 == l1 + l2:\n            found = True\n        # Break l3 into two equal pieces that both pair with either l1 or l2\n        elif l3 % 2 == 0:\n            half = l3 // 2\n            if (half == l1 and l1 == l2) or (half == l2 and l1 == l2):\n                found = True\n    \n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "t = int(input())\nfor _ in range(t):\n    l = list(map(int, input().split()))\n    \n    found = False\n    \n    # Try breaking each stick\n    for i in range(3):\n        # Stick to break\n        to_break = l[i]\n        # Other two sticks\n        others = [l[j] for j in range(3) if j != i]\n        a, b = others[0], others[1]\n        \n        # Case 1: Break to_break into a and b (if a+b = to_break)\n        if a + b == to_break:\n            found = True\n            break\n            \n        # Case 2: Break to_break into two equal parts, and the other two sticks are equal\n        if to_break % 2 == 0 and a == b:\n            found = True\n            break\n    \n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    l1, l2, l3 = map(int, input().split())\n    \n    found = False\n    \n    # Check if we can break l1 into two pieces\n    if not found:\n        # Break l1 into two pieces that pair with l2 and l3\n        if l1 == l2 + l3:\n            found = True\n        # Break l1 into two equal pieces that both pair with either l2 or l3\n        elif l1 % 2 == 0:\n            half = l1 // 2\n            if half == l2 or half == l3:\n                # The remaining two sticks must be equal to form the other pair\n                if (half == l2 and l3 == l3) or (half == l3 and l2 == l2):  # Always true, need better check\n                # Actually, if half == l2, then we have half,half,l2,l3 = half,half,l2,l3\n                # We need {half, half, l2, l3} to form two pairs\n                # Either: half=l2 and half=l3 (so l2=l3) OR half=l2 and l2=l3 (impossible unless l2=l3) OR half=l3 and l2=l3\n                # Simplified: if half == l2, then we need l2 == l3 for pairing, or if half == l3, then we need l2 == l3\n                if (half == l2 and l2 == l3) or (half == l3 and l2 == l3):\n                    found = True\n    \n    # Check if we can break l2 into two pieces\n    if not found:\n        # Break l2 into two pieces that pair with l1 and l3\n        if l2 == l1 + l3:\n            found = True\n        # Break l2 into two equal pieces that both pair with either l1 or l3\n        elif l2 % 2 == 0:\n            half = l2 // 2\n            if (half == l1 and l1 == l3) or (half == l3 and l1 == l3):\n                found = True\n    \n    # Check if we can break l3 into two pieces\n    if not found:\n        # Break l3 into two pieces that pair with l1 and l2\n        if l3 == l1 + l2:\n            found = True\n        # Break l3 into two equal pieces that both pair with either l1 or l2\n        elif l3 % 2 == 0:\n            half = l3 // 2\n            if (half == l1 and l1 == l2) or (half == l2 and l1 == l2):\n                found = True\n    \n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\n", "\nt = int(input())\nfor _ in range(t):\n    l = list(map(int, input().split()))\n    \n    found = False\n    \n    # Try breaking each stick\n    for i in range(3):\n        # Stick to break\n        to_break = l[i]\n        # Other two sticks\n        others = [l[j] for j in range(3) if j != i]\n        a, b = others[0], others[1]\n        \n        # Case 1: Break to_break into a and b (if a+b = to_break)\n        if a + b == to_break:\n            found = True\n            break\n            \n        # Case 2: Break to_break into two equal parts, and the other two sticks are equal\n        if to_break % 2 == 0 and a == b:\n            found = True\n            break\n    \n    if found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\n"], "prompt_tokens": [13413, 13136], "completion_tokens": [6985, 7978], "no_of_try": 2, "api_calls": 20, "is_solved": true, "language": "Python3", "task_id": 1622}
{"name": "1623_A. Robot Cleaner", "description": "A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "tags": ["brute force", "implementation", "math"], "difficulty": 7, "id": 1623, "sample_io": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "test_list": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n8\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n3\n0\n"]}, {"input": "5\n10 10 2 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["0\n10\n8\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n9\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n6\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 3 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n6\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n3\n0\n"]}, {"input": "5\n10 10 6 2 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["6\n10\n9\n3\n1\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n10\n9\n3\n0\n"]}, {"input": "5\n25 10 5 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n2\n1\n"]}, {"input": "5\n14 10 5 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 4\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n2\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 6 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n7\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n26\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 1 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 15 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n1\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 2 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 2 8\n2 2 2 1 2 1\n", "output": ["7\n10\n9\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 2 1\n17 17 5 8 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n25\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n5\n1\n1\n"]}, {"input": "5\n25 10 2 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["0\n9\n15\n3\n1\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n3\n0\n"]}, {"input": "5\n14 10 1 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["3\n7\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 2 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n6\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 1 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n1\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n9\n27\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n1\n0\n"]}, {"input": "5\n7 10 2 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n15\n3\n1\n"]}, {"input": "5\n8 10 5 1 2 8\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n25\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 9 7 1 1\n6 9 2 2 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 7 5 4 1\n17 11 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n1\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["7\n9\n0\n3\n1\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n13 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n14\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 8 5 1 1 1\n6 9 2 2 5 3\n2 1 1 1 2 1\n", "output": ["1\n10\n0\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n3\n1\n"]}, {"input": "5\n14 16 6 1 2 8\n15 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 3 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n26\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n10\n5\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 6 2 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n9\n1\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 1\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["0\n9\n0\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 4 1\n17 17 5 5 2 1\n6 15 2 2 5 8\n3 2 1 2 2 1\n", "output": ["7\n7\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 6 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n4\n1\n"]}, {"input": "5\n18 8 6 2 2 8\n10 10 6 9 1 1\n25 8 5 6 2 2\n6 9 2 2 5 8\n2 1 0 1 2 1\n", "output": ["6\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n3\n0\n"]}, {"input": "5\n18 10 1 3 2 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n7\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n25 8 5 6 1 1\n6 9 2 2 3 9\n2 1 1 1 0 1\n", "output": ["7\n9\n9\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n26\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 1 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n1\n1\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 1 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 8 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n10\n0\n5\n0\n"]}, {"input": "5\n7 10 1 2 1 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n10\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n3\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 12 1 1\n6 9 4 1 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 32 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n29\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n14\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 3 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["4\n8\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 1 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n6\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n0\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 1 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n3\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n3\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 9 2 1\n11 13 5 6 2 1\n6 9 2 2 5 8\n3 1 1 1 2 1\n", "output": ["1\n9\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n9 10 9 9 1 1\n25 8 7 6 2 1\n12 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n8\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n24\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n26\n3\n1\n"]}, {"input": "5\n18 10 1 1 2 8\n11 19 9 9 1 1\n25 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n12\n9\n3\n0\n"]}, {"input": "5\n14 16 6 1 2 15\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["14\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 1 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n1\n1\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 1 2 1\n11 8 5 6 2 1\n6 9 2 3 5 8\n3 1 1 1 2 1\n", "output": ["1\n0\n9\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 0 2 8\n2 2 1 1 2 1\n", "output": ["6\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n9\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 6 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 7\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["6\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 5 1 2\n25 8 5 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 2 6 2 1\n6 9 2 2 5 0\n2 2 1 1 2 1\n", "output": ["7\n7\n0\n3\n0\n"]}, {"input": "5\n23 10 6 2 3 8\n10 10 9 9 1 1\n25 8 5 5 2 1\n6 9 2 2 5 8\n2 1 1 1 0 1\n", "output": ["6\n10\n10\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["2\n9\n9\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 1 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n30\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 13 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n13\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 2\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n9\n5\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n6\n14\n3\n1\n"]}, {"input": "5\n25 10 3 1 2 8\n10 10 9 9 2 2\n17 11 1 6 2 1\n6 9 2 2 5 6\n2 2 1 2 2 1\n", "output": ["7\n9\n1\n3\n1\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n22\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 4 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 7\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["6\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["0\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 2 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n26\n3\n0\n"]}, {"input": "5\n7 13 1 1 1 8\n14 10 9 4 1 1\n11 8 9 7 1 1\n6 26 2 2 5 8\n2 1 2 1 2 1\n", "output": ["0\n15\n8\n3\n0\n"]}, {"input": "5\n18 10 2 6 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["2\n10\n9\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 10 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 3\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n1\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 2\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n17\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n0\n0\n"]}, {"input": "5\n18 10 6 1 2 2\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 0 1 2 1\n", "output": ["1\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 6\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["5\n9\n21\n0\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 1 9 1 1\n25 8 3 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n0\n9\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 3\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 0 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n10\n9\n4\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 2 2 1\n17 12 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 2\n", "output": ["7\n9\n17\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["3\n10\n9\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 1 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n4\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 4\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n2\n0\n"]}, {"input": "5\n23 10 11 2 2 8\n17 10 2 9 1 1\n25 8 5 1 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["7\n9\n24\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 3 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n28\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 6\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["5\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 2\n17 17 3 6 2 1\n6 9 2 1 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 6 5 6 1 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n4\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 6 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 1\n", "output": ["4\n9\n9\n3\n1\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n7\n27\n2\n0\n"]}, {"input": "5\n7 10 1 1 2 8\n19 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 0 1 2 1\n", "output": ["1\n10\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 6\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 1 8\n2 2 2 1 2 1\n", "output": ["5\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 3 1 4 8\n10 9 9 9 4 1\n17 19 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["1\n7\n27\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n12 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n0\n0\n"]}, {"input": "5\n25 10 3 1 2 8\n10 15 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 4 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 14 8 6 2 2\n10 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n20\n3\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 1 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n10\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 10 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n9\n15\n0\n0\n"]}, {"input": "5\n14 17 11 1 4 10\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["9\n9\n29\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 10 5 6 1 1\n6 9 2 2 5 5\n2 1 1 1 2 1\n", "output": ["1\n10\n13\n3\n0\n"]}, {"input": "5\n8 10 5 1 2 7\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["6\n9\n25\n3\n0\n"]}, {"input": "5\n7 10 1 3 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 6\n2 1 0 1 2 1\n", "output": ["3\n9\n9\n4\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 11 2 1\n6 9 2 2 5 8\n2 1 1 1 1 1\n", "output": ["1\n10\n14\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 8 2 1\n6 9 3 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n2\n1\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n19 13 7 6 2 2\n6 9 2 2 4 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n2\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n19 10 9 9 1 1\n9 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 3 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n6\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n23\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 3 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n2\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 3 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 3 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n0\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 2\n5 12 1 6 2 1\n6 8 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n1\n1\n0\n"]}, {"input": "5\n15 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 3 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n2\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 3\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n16\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 6 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n4\n1\n"]}, {"input": "5\n10 10 6 1 1 8\n9 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n8\n7\n3\n1\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "source_codes": ["t = int(input())\nfor _ in range(t):\n    n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n    r, c = r_b, c_b\n    dr, dc = 1, 1\n    time = 0\n    \n    # Check if dirty cell is cleaned at initial position (time 0)\n    if r == r_d or c == c_d:\n        print(0)\n        continue\n            \n    while True:\n        # Check for wall collisions and update directions\n        if r + dr < 1 or r + dr > n:\n            dr = -dr\n        if c + dc < 1 or c + dc > m:\n            dc = -dc\n            \n        # Move robot\n        r += dr\n        c += dc\n        time += 1\n        \n        # Check if dirty cell is cleaned at current position\n        if r == r_d or c == c_d:\n            print(time)\n            break"], "responses": ["\nt = int(input())\nfor _ in range(t):\n    n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n    r, c = r_b, c_b\n    dr, dc = 1, 1\n    time = 0\n    \n    # Check if dirty cell is cleaned at initial position (time 0)\n    if r == r_d or c == c_d:\n        print(0)\n        continue\n            \n    while True:\n        # Check for wall collisions and update directions\n        if r + dr < 1 or r + dr > n:\n            dr = -dr\n        if c + dc < 1 or c + dc > m:\n            dc = -dc\n            \n        # Move robot\n        r += dr\n        c += dc\n        time += 1\n        \n        # Check if dirty cell is cleaned at current position\n        if r == r_d or c == c_d:\n            print(time)\n            break\n\n\n"], "prompt_tokens": [16569], "completion_tokens": [5677], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": 1623}
