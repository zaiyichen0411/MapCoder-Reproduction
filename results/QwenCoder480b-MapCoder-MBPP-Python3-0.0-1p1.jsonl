{"name": "mbpp_234_volume_cube", "language": "Python3", "prompt": "def volume_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the volume of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "volume_cube", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(2) == 8\n    assert candidate(5) == 125\n\ndef test_check():\n    check(volume_cube)\n\ntest_check()\n", "sample_io": ["assert volume_cube(3) == 27"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb3' in position 313: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_234_volume_cube"}
{"name": "mbpp_89_closest_num", "language": "Python3", "prompt": "def closest_num(N: int) -> int:\n    \"\"\"\n\tWrite a function to find the closest smaller number than n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "closest_num", "test": "def check(candidate):\n    assert candidate(11) == 10\n    assert candidate(7) == 6\n    assert candidate(12) == 11\n\ndef test_check():\n    check(closest_num)\n\ntest_check()\n", "sample_io": ["assert closest_num(11) == 10"], "source_codes": ["def closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n    \"\"\"\n    return N - 1"], "responses": ["\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n\n\n"], "prompt_tokens": [1404], "completion_tokens": [751], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_89_closest_num"}
{"name": "mbpp_245_max_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum", "test": "def check(candidate):\n    assert candidate([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert candidate([80, 60, 30, 40, 20, 10]) == 210\n    assert candidate([2, 3, 14, 16, 21, 23, 29, 30]) == 138\n\ndef test_check():\n    check(max_sum)\n\ntest_check()\n", "sample_io": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"], "source_codes": ["def max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    \n    n = len(arr)\n    \n    # inc[i] stores the maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + arr[i] > inc[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill dec[] array\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i] and dec[j] + arr[i] > dec[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find maximum bitonic sum\n    max_bitonic_sum = 0\n    for i in range(n):\n        bitonic_sum = inc[i] + dec[i] - arr[i]\n        if bitonic_sum > max_bitonic_sum:\n            max_bitonic_sum = bitonic_sum\n    \n    return max_bitonic_sum"], "responses": ["\nfrom typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    \n    n = len(arr)\n    \n    # inc[i] stores the maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + arr[i] > inc[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill dec[] array\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i] and dec[j] + arr[i] > dec[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find maximum bitonic sum\n    max_bitonic_sum = 0\n    for i in range(n):\n        bitonic_sum = inc[i] + dec[i] - arr[i]\n        if bitonic_sum > max_bitonic_sum:\n            max_bitonic_sum = bitonic_sum\n    \n    return max_bitonic_sum\n\n\n"], "prompt_tokens": [2367], "completion_tokens": [1528], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_245_max_sum"}
{"name": "mbpp_237_check_occurences", "language": "Python3", "prompt": "from typing import List, Tuple, Dict\n\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_occurences", "test": "def check(candidate):\n    assert candidate([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }\n    assert candidate([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]) == { (2, 4): 2, (3, 6): 2, (4, 7): 1 }\n    assert candidate([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]) == { (2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1 }\n\ndef test_check():\n    check(check_occurences)\n\ntest_check()\n", "sample_io": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }"], "source_codes": ["def check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        result[item] = result.get(item, 0) + 1\n    return result"], "responses": ["\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        result[item] = result.get(item, 0) + 1\n    return result\n\n\n"], "prompt_tokens": [6479], "completion_tokens": [3098], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_237_check_occurences"}
{"name": "mbpp_77_is_Diff", "language": "Python3", "prompt": "def is_Diff(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether a number is divisible by 11.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Diff", "test": "def check(candidate):\n    assert candidate(12345) == False\n    assert candidate(1212112) == True\n    assert candidate(1212) == False\n\ndef test_check():\n    check(is_Diff)\n\ntest_check()\n", "sample_io": ["assert is_Diff(12345) == False"], "source_codes": ["def is_Diff(n: int) -> bool:\n    # Handle edge case for zero\n    if n == 0:\n        return True\n    \n    # Work with absolute value for negative numbers\n    n = abs(n)\n    \n    # Convert number to string to access individual digits\n    str_n = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    # Note: Using 0-based indexing, so odd positions are 1,3,5... and even positions are 0,2,4...\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate through digits with their indices\n    for i, digit_char in enumerate(str_n):\n        digit = int(digit_char)\n        # If index is even (0-based), it's an odd position (1st, 3rd, 5th...)\n        if i % 2 == 0:\n            odd_sum += digit\n        # If index is odd (0-based), it's an even position (2nd, 4th, 6th...)\n        else:\n            even_sum += digit\n    \n    # Calculate the difference\n    diff = abs(odd_sum - even_sum)\n    \n    # Check if difference is divisible by 11\n    return diff % 11 == 0"], "responses": ["\ndef is_Diff(n: int) -> bool:\n    # Handle edge case for zero\n    if n == 0:\n        return True\n    \n    # Work with absolute value for negative numbers\n    n = abs(n)\n    \n    # Convert number to string to access individual digits\n    str_n = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    # Note: Using 0-based indexing, so odd positions are 1,3,5... and even positions are 0,2,4...\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate through digits with their indices\n    for i, digit_char in enumerate(str_n):\n        digit = int(digit_char)\n        # If index is even (0-based), it's an odd position (1st, 3rd, 5th...)\n        if i % 2 == 0:\n            odd_sum += digit\n        # If index is odd (0-based), it's an even position (2nd, 4th, 6th...)\n        else:\n            even_sum += digit\n    \n    # Calculate the difference\n    diff = abs(odd_sum - even_sum)\n    \n    # Check if difference is divisible by 11\n    return diff % 11 == 0\n\n\n"], "prompt_tokens": [1923], "completion_tokens": [1505], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_77_is_Diff"}
{"name": "mbpp_123_amicable_numbers_sum", "language": "Python3", "prompt": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n\tWrite a function to sum all amicable numbers from 1 to a specified number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "amicable_numbers_sum", "test": "def check(candidate):\n    assert candidate(999) == 504\n    assert candidate(9999) == 31626\n    assert candidate(99) == 0\n\ndef test_check():\n    check(amicable_numbers_sum)\n\ntest_check()\n", "sample_io": ["assert amicable_numbers_sum(999) == 504"], "source_codes": ["def amicable_numbers_sum(limit: int) -> int:\n    # Memoization dictionary to store sum of proper divisors\n    divisor_sums = {}\n    \n    def sum_of_divisors(n):\n        if n in divisor_sums:\n            return divisor_sums[n]\n        \n        divisors_sum = 1  # 1 is always a proper divisor\n        sqrt_n = int(n**0.5)\n        \n        # Check divisors up to sqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                # Add the corresponding divisor if it's different from i\n                if i != n // i:\n                    divisors_sum += n // i\n        \n        divisor_sums[n] = divisors_sum\n        return divisors_sum\n    \n    amicable_sum = 0\n    processed = set()  # To avoid counting the same pair twice\n    \n    for a in range(2, limit + 1):\n        if a in processed:\n            continue\n            \n        b = sum_of_divisors(a)\n        \n        # Check if b is within limit and forms an amicable pair with a\n        if b > a and b <= limit and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n            processed.add(a)\n            processed.add(b)\n        elif b == a and a != 1:  # Special case: perfect numbers (not amicable)\n            # Perfect numbers are not considered amicable with themselves\n            continue\n            \n    return amicable_sum"], "responses": ["\ndef amicable_numbers_sum(limit: int) -> int:\n    # Memoization dictionary to store sum of proper divisors\n    divisor_sums = {}\n    \n    def sum_of_divisors(n):\n        if n in divisor_sums:\n            return divisor_sums[n]\n        \n        divisors_sum = 1  # 1 is always a proper divisor\n        sqrt_n = int(n**0.5)\n        \n        # Check divisors up to sqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                # Add the corresponding divisor if it's different from i\n                if i != n // i:\n                    divisors_sum += n // i\n        \n        divisor_sums[n] = divisors_sum\n        return divisors_sum\n    \n    amicable_sum = 0\n    processed = set()  # To avoid counting the same pair twice\n    \n    for a in range(2, limit + 1):\n        if a in processed:\n            continue\n            \n        b = sum_of_divisors(a)\n        \n        # Check if b is within limit and forms an amicable pair with a\n        if b > a and b <= limit and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n            processed.add(a)\n            processed.add(b)\n        elif b == a and a != 1:  # Special case: perfect numbers (not amicable)\n            # Perfect numbers are not considered amicable with themselves\n            continue\n            \n    return amicable_sum\n\n\n"], "prompt_tokens": [2007], "completion_tokens": [1521], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_123_amicable_numbers_sum"}
{"name": "mbpp_420_cube_Sum", "language": "Python3", "prompt": "def cube_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the cube sum of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_Sum", "test": "def check(candidate):\n    assert candidate(2) == 72\n    assert candidate(3) == 288\n    assert candidate(4) == 800\n\ndef test_check():\n    check(cube_Sum)\n\ntest_check()\n", "sample_io": ["assert cube_Sum(2) == 72"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb3' in position 197: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_420_cube_Sum"}
{"name": "mbpp_585_expensive_items", "language": "Python3", "prompt": "from typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n\tWrite a function to find the n most expensive items in a given dataset.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "expensive_items", "test": "def check(candidate):\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }], 2) == [{ 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-1', 'price': 101.1 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }, { 'name': 'Item-4', 'price': 22.75 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n\ndef test_check():\n    check(expensive_items)\n\ntest_check()\n", "sample_io": ["assert expensive_items([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]"], "source_codes": ["def expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    # Handle edge cases\n    if not items or n <= 0:\n        return []\n    \n    # Limit n to the size of the list\n    n = min(n, len(items))\n    \n    # Define possible price keys\n    price_keys = ['price', 'cost']\n    \n    # Helper function to extract price from an item\n    def get_price(item):\n        for key in price_keys:\n            if key in item:\n                return item[key]\n        # If no price key found, return 0\n        return 0.0\n    \n    # Sort items by price in descending order\n    sorted_items = sorted(items, key=get_price, reverse=True)\n    \n    # Return the first n items\n    return sorted_items[:n]"], "responses": ["\nfrom typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    # Handle edge cases\n    if not items or n <= 0:\n        return []\n    \n    # Limit n to the size of the list\n    n = min(n, len(items))\n    \n    # Define possible price keys\n    price_keys = ['price', 'cost']\n    \n    # Helper function to extract price from an item\n    def get_price(item):\n        for key in price_keys:\n            if key in item:\n                return item[key]\n        # If no price key found, return 0\n        return 0.0\n    \n    # Sort items by price in descending order\n    sorted_items = sorted(items, key=get_price, reverse=True)\n    \n    # Return the first n items\n    return sorted_items[:n]\n\n\n"], "prompt_tokens": [2653], "completion_tokens": [1607], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_585_expensive_items"}
{"name": "mbpp_20_is_woodall", "language": "Python3", "prompt": "def is_woodall(x: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given number is woodball or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_woodall", "test": "def check(candidate):\n    assert candidate(383) == True\n    assert candidate(254) == False\n    assert candidate(200) == False\n\ndef test_check():\n    check(is_woodall)\n\ntest_check()\n", "sample_io": ["assert is_woodall(383) == True"], "source_codes": ["import math\n\ndef is_woodall(x: int) -> bool:\n    # Woodall numbers are positive integers\n    if x <= 0:\n        return False\n    \n    # Special case: 1 is the first Woodall number (1 * 2^1 - 1 = 1)\n    if x == 1:\n        return True\n    \n    # Estimate upper bound for n\n    # Since n * 2^n = x + 1, we can approximate n\n    # Start with a reasonable upper limit\n    n_upper = int(math.log2(x + 1)) + 1\n    \n    # Check for n from 1 to our estimated upper bound\n    for n in range(1, n_upper + 1):\n        woodall_candidate = n * (2 ** n) - 1\n        if woodall_candidate == x:\n            return True\n        elif woodall_candidate > x:\n            # Since the sequence is increasing, we can stop early\n            break\n    \n    return False"], "responses": ["\nimport math\n\ndef is_woodall(x: int) -> bool:\n    # Woodall numbers are positive integers\n    if x <= 0:\n        return False\n    \n    # Special case: 1 is the first Woodall number (1 * 2^1 - 1 = 1)\n    if x == 1:\n        return True\n    \n    # Estimate upper bound for n\n    # Since n * 2^n = x + 1, we can approximate n\n    # Start with a reasonable upper limit\n    n_upper = int(math.log2(x + 1)) + 1\n    \n    # Check for n from 1 to our estimated upper bound\n    for n in range(1, n_upper + 1):\n        woodall_candidate = n * (2 ** n) - 1\n        if woodall_candidate == x:\n            return True\n        elif woodall_candidate > x:\n            # Since the sequence is increasing, we can stop early\n            break\n    \n    return False\n\n\n"], "prompt_tokens": [2204], "completion_tokens": [1491], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_20_is_woodall"}
{"name": "mbpp_805_max_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that returns the list in a list of lists whose sum of elements is the highest.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_list", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]\n    assert candidate([[3, 2, 1], [6, 5, 4], [12, 11, 10]]) == [12, 11, 10]\n    assert candidate([[2, 3, 1]]) == [2, 3, 1]\n\ndef test_check():\n    check(max_sum_list)\n\ntest_check()\n", "sample_io": ["assert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"], "source_codes": ["def max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function that returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    # Handle edge case: empty input\n    if not lists:\n        return None\n    \n    # Initialize with first list\n    max_sum = sum(lists[0])\n    max_list = lists[0]\n    \n    # Iterate through remaining lists\n    for lst in lists[1:]:\n        current_sum = sum(lst)\n        # Update if current sum is greater (not equal to maintain first occurrence preference)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list"], "responses": ["\nfrom typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a function that returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    # Handle edge case: empty input\n    if not lists:\n        return None\n    \n    # Initialize with first list\n    max_sum = sum(lists[0])\n    max_list = lists[0]\n    \n    # Iterate through remaining lists\n    for lst in lists[1:]:\n        current_sum = sum(lst)\n        # Update if current sum is greater (not equal to maintain first occurrence preference)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n\n\n"], "prompt_tokens": [1944], "completion_tokens": [1179], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_805_max_sum_list"}
{"name": "mbpp_806_max_run_uppercase", "language": "Python3", "prompt": "def max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to find maximum run of uppercase characters in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_run_uppercase", "test": "def check(candidate):\n    assert candidate('GeMKSForGERksISBESt') == 5\n    assert candidate('PrECIOusMOVemENTSYT') == 6\n    assert candidate('GooGLEFluTTER') == 4\n\ndef test_check():\n    check(max_run_uppercase)\n\ntest_check()\n", "sample_io": ["assert max_run_uppercase('GeMKSForGERksISBESt') == 5"], "source_codes": ["def max_run_uppercase(test_str: str) -> int:\n    if not test_str:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run"], "responses": ["\ndef max_run_uppercase(test_str: str) -> int:\n    if not test_str:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run\n\n\n"], "prompt_tokens": [1740], "completion_tokens": [873], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_806_max_run_uppercase"}
{"name": "mbpp_455_check_monthnumb_number", "language": "Python3", "prompt": "def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 31 days or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumb_number", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(2) == False\n    assert candidate(6) == False\n\ndef test_check():\n    check(check_monthnumb_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumb_number(5) == True"], "source_codes": ["def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the month number is valid (between 1 and 12)\n    if monthnum2 < 1 or monthnum2 > 12:\n        return False\n    \n    # Check if the month has 31 days\n    return monthnum2 in months_with_31_days"], "responses": ["\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the month number is valid (between 1 and 12)\n    if monthnum2 < 1 or monthnum2 > 12:\n        return False\n    \n    # Check if the month has 31 days\n    return monthnum2 in months_with_31_days\n\n\n"], "prompt_tokens": [1866], "completion_tokens": [993], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_455_check_monthnumb_number"}
{"name": "mbpp_577_last_Digit_Factorial", "language": "Python3", "prompt": "def last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit in factorial of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit_Factorial", "test": "def check(candidate):\n    assert candidate(4) == 4\n    assert candidate(21) == 0\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit_Factorial)\n\ntest_check()\n", "sample_io": ["assert last_Digit_Factorial(4) == 4"], "source_codes": ["def last_Digit_Factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    if n >= 5:\n        return 0\n    \n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % 10\n    \n    return result"], "responses": ["\ndef last_Digit_Factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    if n >= 5:\n        return 0\n    \n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % 10\n    \n    return result\n\n\n"], "prompt_tokens": [1804], "completion_tokens": [1134], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_577_last_Digit_Factorial"}
{"name": "mbpp_555_difference", "language": "Python3", "prompt": "def difference(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "difference", "test": "def check(candidate):\n    assert candidate(3) == 30\n    assert candidate(5) == 210\n    assert candidate(2) == 6\n\ndef test_check():\n    check(difference)\n\ntest_check()\n", "sample_io": ["assert difference(3) == 30"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\u2081' in position 268: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_555_difference"}
{"name": "mbpp_456_reverse_string_list", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n\tWrite a function to reverse each string in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_string_list", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    assert candidate(['john', 'amal', 'joel', 'george']) == ['nhoj', 'lama', 'leoj', 'egroeg']\n    assert candidate(['jack', 'john', 'mary']) == ['kcaj', 'nhoj', 'yram']\n\ndef test_check():\n    check(reverse_string_list)\n\ntest_check()\n", "sample_io": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"], "source_codes": ["def reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]"], "responses": ["\nfrom typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n\n\n"], "prompt_tokens": [1760], "completion_tokens": [866], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_456_reverse_string_list"}
{"name": "mbpp_587_list_tuple", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n\tWrite a function to convert a list to a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_587_list_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_tuple", "test": "def check(candidate):\n    assert candidate([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    assert candidate([2, 4, 5, 6, 2, 3, 4, 4, 7]) == (2, 4, 5, 6, 2, 3, 4, 4, 7)\n    assert candidate([58, 44, 56]) == (58, 44, 56)\n\ndef test_check():\n    check(list_tuple)\n\ntest_check()\n", "sample_io": ["assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"], "source_codes": ["def list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)"], "responses": ["\nfrom typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n\n\n"], "prompt_tokens": [1646], "completion_tokens": [700], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_587_list_tuple"}
{"name": "mbpp_612_merge", "language": "Python3", "prompt": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]\n    assert candidate([['x', 'y', 'z'], ['a', 'b', 'c'], ['m', 'n', 'o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'], ['z', 'c', 'o']]\n\ndef test_check():\n    check(merge)\n\ntest_check()\n", "sample_io": ["assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"], "source_codes": ["def merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    # zip(*lst) will group the first elements together and second elements together\n    transposed = list(zip(*lst))\n    \n    # Convert tuples back to lists\n    return [list(transposed[0]), list(transposed[1])]"], "responses": ["\nfrom typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Use zip with unpacking to transpose the list of lists\n    # zip(*lst) will group the first elements together and second elements together\n    transposed = list(zip(*lst))\n    \n    # Convert tuples back to lists\n    return [list(transposed[0]), list(transposed[1])]\n\n\n"], "prompt_tokens": [1842], "completion_tokens": [1033], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_612_merge"}
{"name": "mbpp_12_sort_matrix", "language": "Python3", "prompt": "from typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_matrix", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    assert candidate([[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n    assert candidate([[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\n\ndef test_check():\n    check(sort_matrix)\n\ntest_check()\n", "sample_io": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"], "source_codes": ["def sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    # Handle edge case: empty matrix\n    if not M:\n        return []\n    \n    # Create list of (row_sum, original_index) pairs\n    row_sums_with_indices = [(sum(row), i) for i, row in enumerate(M)]\n    \n    # Sort by row sum (first element of tuple), maintaining stable sort for ties\n    row_sums_with_indices.sort(key=lambda x: x[0])\n    \n    # Reconstruct matrix using sorted indices\n    sorted_matrix = [M[index] for _, index in row_sums_with_indices]\n    \n    return sorted_matrix"], "responses": ["\nfrom typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    # Handle edge case: empty matrix\n    if not M:\n        return []\n    \n    # Create list of (row_sum, original_index) pairs\n    row_sums_with_indices = [(sum(row), i) for i, row in enumerate(M)]\n    \n    # Sort by row sum (first element of tuple), maintaining stable sort for ties\n    row_sums_with_indices.sort(key=lambda x: x[0])\n    \n    # Reconstruct matrix using sorted indices\n    sorted_matrix = [M[index] for _, index in row_sums_with_indices]\n    \n    return sorted_matrix\n\n\n"], "prompt_tokens": [2027], "completion_tokens": [1063], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_12_sort_matrix"}
{"name": "mbpp_584_find_adverbs", "language": "Python3", "prompt": "def find_adverbs(text: str) -> str:\n    \"\"\"\n\tWrite a function to find the first adverb ending with ly and its positions in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverbs", "test": "def check(candidate):\n    assert candidate('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'\n    assert candidate('Please handle the situation carefuly') == '28-36: carefuly'\n    assert candidate('Complete the task quickly') == '18-25: quickly'\n\ndef test_check():\n    check(find_adverbs)\n\ntest_check()\n", "sample_io": ["assert find_adverbs('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'"], "source_codes": ["import re\n\ndef find_adverbs(text: str) -> str:\n    # Pattern to match words ending with 'ly' (adverbs)\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first match\n    match = re.search(pattern, text)\n    \n    if match:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{start_pos}-{end_pos}: {adverb}\"\n    else:\n        return \"No adverb found\""], "responses": ["\nimport re\n\ndef find_adverbs(text: str) -> str:\n    # Pattern to match words ending with 'ly' (adverbs)\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first match\n    match = re.search(pattern, text)\n    \n    if match:\n        adverb = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{start_pos}-{end_pos}: {adverb}\"\n    else:\n        return \"No adverb found\"\n\n\n"], "prompt_tokens": [3728], "completion_tokens": [1463], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_584_find_adverbs"}
{"name": "mbpp_86_centered_hexagonal_number", "language": "Python3", "prompt": "def centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth centered hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "centered_hexagonal_number", "test": "def check(candidate):\n    assert candidate(10) == 271\n    assert candidate(2) == 7\n    assert candidate(9) == 217\n\ndef test_check():\n    check(centered_hexagonal_number)\n\ntest_check()\n", "sample_io": ["assert centered_hexagonal_number(10) == 271"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 258: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_86_centered_hexagonal_number"}
{"name": "mbpp_130_max_occurrences", "language": "Python3", "prompt": "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_occurrences", "test": "def check(candidate):\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]) == 8\n    assert candidate([10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]) == 20\n\ndef test_check():\n    check(max_occurrences)\n\ntest_check()\n", "sample_io": ["assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2"], "source_codes": ["def max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    freq_count = Counter(nums)\n    max_freq = max(freq_count.values())\n    \n    # Find the first element (in order of appearance) with maximum frequency\n    for num in nums:\n        if freq_count[num] == max_freq:\n            return num\n    \n    return 0"], "responses": ["\nfrom typing import List\nfrom collections import Counter\n\ndef max_occurrences(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    freq_count = Counter(nums)\n    max_freq = max(freq_count.values())\n    \n    # Find the first element (in order of appearance) with maximum frequency\n    for num in nums:\n        if freq_count[num] == max_freq:\n            return num\n    \n    return 0\n\n\n"], "prompt_tokens": [3302], "completion_tokens": [1489], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_130_max_occurrences"}
{"name": "mbpp_580_extract_even", "language": "Python3", "prompt": "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n\tWrite a function to remove uneven elements in the nested mixed tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_even", "test": "def check(candidate):\n    assert candidate((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    assert candidate((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))\n    assert candidate((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)\n\ndef test_check():\n    check(extract_even)\n\ntest_check()\n", "sample_io": ["assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"], "source_codes": ["def extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n    Write a function to remove uneven elements in the nested mixed tuple.\n    \"\"\"\n    if isinstance(test_tuple, int):\n        # Base case: if it's an integer, return it if even, otherwise return empty tuple\n        return test_tuple if test_tuple % 2 == 0 else ()\n    \n    # Recursive case: process each element in the tuple\n    result = []\n    for item in test_tuple:\n        processed_item = extract_even(item)\n        # Only add non-empty results\n        if processed_item != ():\n            result.append(processed_item)\n    \n    # If result is empty, return empty tuple\n    if not result:\n        return ()\n    \n    # Convert list back to tuple\n    return tuple(result)"], "responses": ["\nfrom typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n    Write a function to remove uneven elements in the nested mixed tuple.\n    \"\"\"\n    if isinstance(test_tuple, int):\n        # Base case: if it's an integer, return it if even, otherwise return empty tuple\n        return test_tuple if test_tuple % 2 == 0 else ()\n    \n    # Recursive case: process each element in the tuple\n    result = []\n    for item in test_tuple:\n        processed_item = extract_even(item)\n        # Only add non-empty results\n        if processed_item != ():\n            result.append(processed_item)\n    \n    # If result is empty, return empty tuple\n    if not result:\n        return ()\n    \n    # Convert list back to tuple\n    return tuple(result)\n\n\n"], "prompt_tokens": [2158], "completion_tokens": [1367], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_580_extract_even"}
{"name": "mbpp_742_area_tetrahedron", "language": "Python3", "prompt": "def area_tetrahedron(side: int) -> float:\n    \"\"\"\n\tWrite a function to caluclate the area of a tetrahedron.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "area_tetrahedron", "test": "def check(candidate):\n    assert candidate(3) == 15.588457268119894\n    assert candidate(20) == 692.8203230275509\n    assert candidate(10) == 173.20508075688772\n\ndef test_check():\n    check(area_tetrahedron)\n\ntest_check()\n", "sample_io": ["assert area_tetrahedron(3) == 15.588457268119894"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 723: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_742_area_tetrahedron"}
{"name": "mbpp_610_remove_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_kth_element", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], 4) == [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], 5) == [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10]\n\ndef test_check():\n    check(remove_kth_element)\n\ntest_check()\n", "sample_io": ["assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"], "source_codes": ["def remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    # Handle edge cases\n    if not list1 or L <= 0 or L > len(list1):\n        return list1[:]\n    \n    # Convert 1-indexed to 0-indexed and remove the element\n    return list1[:L-1] + list1[L:]"], "responses": ["\nfrom typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    # Handle edge cases\n    if not list1 or L <= 0 or L > len(list1):\n        return list1[:]\n    \n    # Convert 1-indexed to 0-indexed and remove the element\n    return list1[:L-1] + list1[L:]\n\n\n"], "prompt_tokens": [1550], "completion_tokens": [1146], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_610_remove_kth_element"}
{"name": "mbpp_394_check_distinct", "language": "Python3", "prompt": "from typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if given list contains no duplicates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_distinct", "test": "def check(candidate):\n    assert candidate([1, 4, 5, 6, 1, 4]) == False\n    assert candidate([1, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 6]) == True\n\ndef test_check():\n    check(check_distinct)\n\ntest_check()\n", "sample_io": ["assert check_distinct([1, 4, 5, 6, 1, 4]) == False"], "source_codes": ["def check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(test_tup)\n    \n    # Compare the length of the original list with the set\n    # If they're equal, there were no duplicates\n    return len(test_tup) == len(unique_elements)"], "responses": ["\nfrom typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(test_tup)\n    \n    # Compare the length of the original list with the set\n    # If they're equal, there were no duplicates\n    return len(test_tup) == len(unique_elements)\n\n\n"], "prompt_tokens": [1748], "completion_tokens": [858], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_394_check_distinct"}
{"name": "mbpp_793_last", "language": "Python3", "prompt": "from typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last position of an element in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 1) == 0\n    assert candidate([1, 1, 1, 2, 3, 4], 1) == 2\n    assert candidate([2, 3, 2, 3, 6, 8, 9], 3) == 3\n\ndef test_check():\n    check(last)\n\ntest_check()\n", "sample_io": ["assert last([1, 2, 3], 1) == 0"], "source_codes": ["def last(arr: List[int], x: int) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return -1\n    \n    left = 0\n    right = len(arr) - 1\n    result = -1\n    \n    # Modified binary search\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            # Found target, update result and search right half for later occurrences\n            result = mid\n            left = mid + 1\n        elif arr[mid] < x:\n            # Search right half\n            left = mid + 1\n        else:\n            # Search left half\n            right = mid - 1\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return -1\n    \n    left = 0\n    right = len(arr) - 1\n    result = -1\n    \n    # Modified binary search\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            # Found target, update result and search right half for later occurrences\n            result = mid\n            left = mid + 1\n        elif arr[mid] < x:\n            # Search right half\n            left = mid + 1\n        else:\n            # Search left half\n            right = mid - 1\n    \n    return result\n\n\n"], "prompt_tokens": [1971], "completion_tokens": [1051], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_793_last"}
{"name": "mbpp_728_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_list", "test": "def check(candidate):\n    assert candidate([10, 20, 30], [15, 25, 35]) == [25, 45, 65]\n    assert candidate([1, 2, 3], [5, 6, 7]) == [6, 8, 10]\n    assert candidate([15, 20, 30], [15, 45, 75]) == [30, 65, 105]\n\ndef test_check():\n    check(sum_list)\n\ntest_check()\n", "sample_io": ["assert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"], "source_codes": ["def sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]"], "responses": ["\nfrom typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n\n\n"], "prompt_tokens": [1987], "completion_tokens": [938], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_728_sum_list"}
{"name": "mbpp_566_sum_digits", "language": "Python3", "prompt": "def sum_digits(n: int) -> int:\n    \"\"\"\n\tWrite a function to get the sum of the digits of a non-negative integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_digits", "test": "def check(candidate):\n    assert candidate(345) == 12\n    assert candidate(12) == 3\n    assert candidate(97) == 16\n\ndef test_check():\n    check(sum_digits)\n\ntest_check()\n", "sample_io": ["assert sum_digits(345) == 12"], "source_codes": ["def sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total"], "responses": ["\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n\n\n"], "prompt_tokens": [1767], "completion_tokens": [1079], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_566_sum_digits"}
{"name": "mbpp_290_max_length", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list of maximum length in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1], [5, 7], [10, 12, 14, 15]]) == (4, [10, 12, 14, 15])\n    assert candidate([[5], [15, 20, 25]]) == (3, [15, 20, 25])\n\ndef test_check():\n    check(max_length)\n\ntest_check()\n", "sample_io": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["def max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not list1:\n        return (0, [])\n    \n    # Initialize variables to track maximum length and corresponding list\n    max_len = 0\n    max_list = []\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        current_len = len(sublist)\n        # Update if current sublist is longer than the tracked maximum\n        if current_len > max_len:\n            max_len = current_len\n            max_list = sublist\n    \n    return (max_len, max_list)"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not list1:\n        return (0, [])\n    \n    # Initialize variables to track maximum length and corresponding list\n    max_len = 0\n    max_list = []\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        current_len = len(sublist)\n        # Update if current sublist is longer than the tracked maximum\n        if current_len > max_len:\n            max_len = current_len\n            max_list = sublist\n    \n    return (max_len, max_list)\n\n\n"], "prompt_tokens": [2256], "completion_tokens": [1165], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_290_max_length"}
{"name": "mbpp_413_extract_nth_element", "language": "Python3", "prompt": "from typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract the nth element from a given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_nth_element", "test": "def check(candidate):\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2) == [99, 96, 94, 98]\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1) == [98, 97, 91, 94]\n\ndef test_check():\n    check(extract_nth_element)\n\ntest_check()\n", "sample_io": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"], "source_codes": ["def extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not list1:\n        return []\n    \n    # Extract the nth element from each tuple using list comprehension\n    # This will automatically raise IndexError if n is out of bounds\n    return [tuple_item[n] for tuple_item in list1]"], "responses": ["\nfrom typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    # Handle edge case of empty input list\n    if not list1:\n        return []\n    \n    # Extract the nth element from each tuple using list comprehension\n    # This will automatically raise IndexError if n is out of bounds\n    return [tuple_item[n] for tuple_item in list1]\n\n\n"], "prompt_tokens": [2026], "completion_tokens": [1301], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_413_extract_nth_element"}
{"name": "mbpp_628_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(string: str) -> str:\n    \"\"\"\n\tWrite a function to replace all spaces in the given string with '%20'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('My Name is Dawood') == 'My%20Name%20is%20Dawood'\n    assert candidate('I am a Programmer') == 'I%20am%20a%20Programmer'\n    assert candidate('I love Coding') == 'I%20love%20Coding'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('My Name is Dawood') == 'My%20Name%20is%20Dawood'"], "source_codes": ["def replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')"], "responses": ["\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n\n\n"], "prompt_tokens": [1755], "completion_tokens": [790], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_628_replace_spaces"}
{"name": "mbpp_417_group_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to find common first element in given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "group_tuples", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]\n    assert candidate([['a', 'b'], ['a', 'c'], ['d', 'e']]) == [['a', 'b', 'c'], ['d', 'e']]\n    assert candidate([['f', 'g'], ['f', 'g'], ['h', 'i']]) == [['f', 'g', 'g'], ['h', 'i']]\n\ndef test_check():\n    check(group_tuples)\n\ntest_check()\n", "sample_io": ["assert group_tuples([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]"], "source_codes": ["def group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    if not Input:\n        return []\n    \n    # Group lists by their first element\n    groups = {}\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].append(lst)\n    \n    # For each group, merge the lists\n    result = []\n    for group in groups.values():\n        if len(group) >= 1:  # Include all groups, even with single items\n            # Merge all lists in the group\n            merged = [group[0][0]]  # Start with the first element\n            for lst in group:\n                merged.extend(lst[1:])  # Add all elements except the first\n            result.append(merged)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    if not Input:\n        return []\n    \n    # Group lists by their first element\n    groups = {}\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].append(lst)\n    \n    # For each group, merge the lists\n    result = []\n    for group in groups.values():\n        if len(group) >= 1:  # Include all groups, even with single items\n            # Merge all lists in the group\n            merged = [group[0][0]]  # Start with the first element\n            for lst in group:\n                merged.extend(lst[1:])  # Add all elements except the first\n            result.append(merged)\n    \n    return result\n\n\n"], "prompt_tokens": [4197], "completion_tokens": [3049], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_417_group_tuples"}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum_repeated", "test": "def check(candidate):\n    assert candidate([10, 20, -30, -1], 4, 3) == 30\n    assert candidate([-1, 10, 20], 3, 2) == 59\n    assert candidate([-1, -2, -3], 3, 3) == -1\n\ndef test_check():\n    check(max_sub_array_sum_repeated)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"], "source_codes": ["def max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    if n == 0 or k == 0:\n        return 0\n    \n    # Kadane's algorithm for maximum subarray sum in single array\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate maximum prefix sum (from left to right)\n    max_prefix_sum = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_sum)\n    \n    # Calculate maximum suffix sum (from right to left)\n    max_suffix_sum = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_sum)\n    \n    # Total sum of array\n    total_sum = sum(a)\n    \n    # Maximum subarray sum in single array\n    max_kadane = kadane(a)\n    \n    # If k >= 2, we have three options:\n    # 1. Maximum subarray within one copy\n    # 2. Max prefix + max suffix (two copies)\n    # 3. If total_sum > 0: max prefix + (k-2)*total_sum + max suffix\n    \n    # Option 1: Maximum subarray in one copy\n    option1 = max_kadane\n    \n    # Option 2: Max prefix + max suffix\n    option2 = max_prefix_sum + max_suffix_sum\n    \n    # Option 3: If total sum is positive, we can include middle arrays\n    if total_sum > 0:\n        option3 = max_prefix_sum + (k - 2) * total_sum + max_suffix_sum\n        return max(option1, option2, option3)\n    else:\n        return max(option1, option2)"], "responses": ["\nfrom typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    if n == 0 or k == 0:\n        return 0\n    \n    # Kadane's algorithm for maximum subarray sum in single array\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, just apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate maximum prefix sum (from left to right)\n    max_prefix_sum = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, current_sum)\n    \n    # Calculate maximum suffix sum (from right to left)\n    max_suffix_sum = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix_sum = max(max_suffix_sum, current_sum)\n    \n    # Total sum of array\n    total_sum = sum(a)\n    \n    # Maximum subarray sum in single array\n    max_kadane = kadane(a)\n    \n    # If k >= 2, we have three options:\n    # 1. Maximum subarray within one copy\n    # 2. Max prefix + max suffix (two copies)\n    # 3. If total_sum > 0: max prefix + (k-2)*total_sum + max suffix\n    \n    # Option 1: Maximum subarray in one copy\n    option1 = max_kadane\n    \n    # Option 2: Max prefix + max suffix\n    option2 = max_prefix_sum + max_suffix_sum\n    \n    # Option 3: If total sum is positive, we can include middle arrays\n    if total_sum > 0:\n        option3 = max_prefix_sum + (k - 2) * total_sum + max_suffix_sum\n        return max(option1, option2, option3)\n    else:\n        return max(option1, option2)\n\n\n"], "prompt_tokens": [2298], "completion_tokens": [1792], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_286_max_sub_array_sum_repeated"}
{"name": "mbpp_66_pos_count", "language": "Python3", "prompt": "from typing import List\n\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of positive numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pos_count", "test": "def check(candidate):\n    assert candidate([1, -2, 3, -4]) == 2\n    assert candidate([3, 4, 5, -1]) == 3\n    assert candidate([1, 2, 3, 4]) == 4\n\ndef test_check():\n    check(pos_count)\n\ntest_check()\n", "sample_io": ["assert pos_count([1, -2, 3, -4]) == 2"], "source_codes": ["def pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count"], "responses": ["\nfrom typing import List\n\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1721], "completion_tokens": [811], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_66_pos_count"}
{"name": "mbpp_450_extract_string", "language": "Python3", "prompt": "from typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n\tWrite a function to extract specified size of strings from a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_string", "test": "def check(candidate):\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 6) == ['Python']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 9) == ['exercises']\n\ndef test_check():\n    check(extract_string)\n\ntest_check()\n", "sample_io": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"], "source_codes": ["def extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    # Handle edge cases\n    if not str or l < 0:\n        return []\n    \n    # Filter strings by exact length match\n    return [s for s in str if len(s) == l]"], "responses": ["\nfrom typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    # Handle edge cases\n    if not str or l < 0:\n        return []\n    \n    # Filter strings by exact length match\n    return [s for s in str if len(s) == l]\n\n\n"], "prompt_tokens": [1714], "completion_tokens": [798], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_450_extract_string"}
{"name": "mbpp_444_trim_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to trim each list by k in the given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "trim_tuple", "test": "def check(candidate):\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 1) == [[3, 2, 1], [4, 9, 2], [1, 2, 3], [8, 2, 1]]\n    assert candidate([[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]], 1) == [[8, 4], [8, 12], [1, 7], [6, 9]]\n\ndef test_check():\n    check(trim_tuple)\n\ntest_check()\n", "sample_io": ["assert trim_tuple([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]"], "source_codes": ["def trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    return [lst[K:-K] if len(lst) >= 2*K else [] for lst in test_list]"], "responses": ["\nfrom typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    return [lst[K:-K] if len(lst) >= 2*K else [] for lst in test_list]\n\n\n"], "prompt_tokens": [1129], "completion_tokens": [1292], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_444_trim_tuple"}
{"name": "mbpp_439_multiple_to_single", "language": "Python3", "prompt": "from typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n\tWrite a function to join a list of multiple integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiple_to_single", "test": "def check(candidate):\n    assert candidate([11, 33, 50]) == 113350\n    assert candidate([-1, 2, 3, 4, 5, 6]) == -123456\n    assert candidate([10, 15, 20, 25]) == 10152025\n\ndef test_check():\n    check(multiple_to_single)\n\ntest_check()\n", "sample_io": ["assert multiple_to_single([11, 33, 50]) == 113350"], "source_codes": ["def multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Write a function to join a list of multiple integers into a single integer.\n    \"\"\"\n    # Handle empty list\n    if not L:\n        return 0\n    \n    # Convert all integers to strings\n    str_list = [str(num) for num in L]\n    \n    # Join all strings\n    joined_str = ''.join(str_list)\n    \n    # Handle leading zeros\n    if joined_str.startswith('0') and len(joined_str) > 1:\n        # Remove leading zeros but keep at least one digit\n        joined_str = joined_str.lstrip('0') or '0'\n    \n    # Convert back to integer\n    return int(joined_str)"], "responses": ["\nfrom typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Write a function to join a list of multiple integers into a single integer.\n    \"\"\"\n    # Handle empty list\n    if not L:\n        return 0\n    \n    # Convert all integers to strings\n    str_list = [str(num) for num in L]\n    \n    # Join all strings\n    joined_str = ''.join(str_list)\n    \n    # Handle leading zeros\n    if joined_str.startswith('0') and len(joined_str) > 1:\n        # Remove leading zeros but keep at least one digit\n        joined_str = joined_str.lstrip('0') or '0'\n    \n    # Convert back to integer\n    return int(joined_str)\n\n\n"], "prompt_tokens": [1625], "completion_tokens": [1022], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_439_multiple_to_single"}
{"name": "mbpp_162_sum_series", "language": "Python3", "prompt": "def sum_series(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_series", "test": "def check(candidate):\n    assert candidate(6) == 12\n    assert candidate(10) == 30\n    assert candidate(9) == 25\n\ndef test_check():\n    check(sum_series)\n\ntest_check()\n", "sample_io": ["assert sum_series(6) == 12"], "source_codes": ["def sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4)... (until n-x <= 0).\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total = 0\n    for i in range(n // 2 + 1):\n        term = n - 2 * i\n        if term > 0:\n            total += term\n    \n    return total"], "responses": ["\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4)... (until n-x <= 0).\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total = 0\n    for i in range(n // 2 + 1):\n        term = n - 2 * i\n        if term > 0:\n            total += term\n    \n    return total\n\n\n"], "prompt_tokens": [1466], "completion_tokens": [978], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_162_sum_series"}
{"name": "mbpp_224_count_Set_Bits", "language": "Python3", "prompt": "def count_Set_Bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of set bits (binary digits with value 1) in a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Set_Bits", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(4) == 1\n    assert candidate(6) == 2\n\ndef test_check():\n    check(count_Set_Bits)\n\ntest_check()\n", "sample_io": ["assert count_Set_Bits(2) == 1"], "source_codes": ["def count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (binary digits with value 1) in a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The count of set bits in the binary representation of n\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    # For this problem, we'll assume we're counting bits in the absolute value\n    n = abs(n)\n    \n    # Initialize counter for set bits\n    count = 0\n    \n    # Use bit manipulation technique: n & (n-1) clears the least significant set bit\n    while n:\n        count += 1\n        n = n & (n - 1)\n    \n    return count"], "responses": ["\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (binary digits with value 1) in a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The count of set bits in the binary representation of n\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    # For this problem, we'll assume we're counting bits in the absolute value\n    n = abs(n)\n    \n    # Initialize counter for set bits\n    count = 0\n    \n    # Use bit manipulation technique: n & (n-1) clears the least significant set bit\n    while n:\n        count += 1\n        n = n & (n - 1)\n    \n    return count\n\n\n"], "prompt_tokens": [1844], "completion_tokens": [1233], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_224_count_Set_Bits"}
{"name": "mbpp_309_maximum", "language": "Python3", "prompt": "def maximum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximum", "test": "def check(candidate):\n    assert candidate(5, 10) == 10\n    assert candidate(-1, -2) == -1\n    assert candidate(9, 7) == 9\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n", "sample_io": ["assert maximum(5, 10) == 10"], "source_codes": ["def maximum(a: int, b: int) -> int:\n    \"\"\"\n    Find the maximum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The larger of the two numbers\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b"], "responses": ["\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Find the maximum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        \n    Returns:\n        int: The larger of the two numbers\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n\n\n"], "prompt_tokens": [1253], "completion_tokens": [798], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_309_maximum"}
{"name": "mbpp_632_move_zero", "language": "Python3", "prompt": "from typing import List\n\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to move all zeroes to the end of the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_zero", "test": "def check(candidate):\n    assert candidate([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]\n    assert candidate([2, 3, 2, 0, 0, 4, 0, 5, 0]) == [2, 3, 2, 4, 5, 0, 0, 0, 0]\n    assert candidate([0, 1, 0, 1, 1]) == [1, 1, 1, 0, 0]\n\ndef test_check():\n    check(move_zero)\n\ntest_check()\n", "sample_io": ["assert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"], "source_codes": ["def move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n    \n    Args:\n        num_list: A list of integers\n        \n    Returns:\n        The modified list with all zeros moved to the end\n    \"\"\"\n    # Handle empty list case\n    if not num_list:\n        return num_list\n    \n    # Initialize slow pointer for placing non-zero elements\n    slow = 0\n    \n    # Traverse the list with fast pointer\n    for fast in range(len(num_list)):\n        # If current element is non-zero, place it at slow pointer position\n        if num_list[fast] != 0:\n            num_list[slow] = num_list[fast]\n            slow += 1\n    \n    # Fill remaining positions with zeros\n    for i in range(slow, len(num_list)):\n        num_list[i] = 0\n    \n    return num_list"], "responses": ["\nfrom typing import List\n\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n    \n    Args:\n        num_list: A list of integers\n        \n    Returns:\n        The modified list with all zeros moved to the end\n    \"\"\"\n    # Handle empty list case\n    if not num_list:\n        return num_list\n    \n    # Initialize slow pointer for placing non-zero elements\n    slow = 0\n    \n    # Traverse the list with fast pointer\n    for fast in range(len(num_list)):\n        # If current element is non-zero, place it at slow pointer position\n        if num_list[fast] != 0:\n            num_list[slow] = num_list[fast]\n            slow += 1\n    \n    # Fill remaining positions with zeros\n    for i in range(slow, len(num_list)):\n        num_list[i] = 0\n    \n    return num_list\n\n\n"], "prompt_tokens": [1851], "completion_tokens": [990], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_632_move_zero"}
{"name": "mbpp_168_frequency", "language": "Python3", "prompt": "from typing import List\n\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurrences of a number in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 4) == 0\n    assert candidate([1, 2, 2, 3, 3, 3, 4], 3) == 3\n    assert candidate([0, 1, 2, 3, 1, 2], 1) == 2\n\ndef test_check():\n    check(frequency)\n\ntest_check()\n", "sample_io": ["assert frequency([1, 2, 3], 4) == 0"], "source_codes": ["def frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers to search through\n        x: Target integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Iterate through each element in the list\n    for element in a:\n        # If element matches target, increment counter\n        if element == x:\n            count += 1\n    \n    # Return final count\n    return count"], "responses": ["\nfrom typing import List\n\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers to search through\n        x: Target integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Iterate through each element in the list\n    for element in a:\n        # If element matches target, increment counter\n        if element == x:\n            count += 1\n    \n    # Return final count\n    return count\n\n\n"], "prompt_tokens": [1780], "completion_tokens": [922], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_168_frequency"}
{"name": "mbpp_749_sort_numeric_strings", "language": "Python3", "prompt": "from typing import List\n\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_numeric_strings", "test": "def check(candidate):\n    assert candidate(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    assert candidate(['2', '3', '8', '4', '7', '9', '8', '2', '6', '5', '1', '6', '1', '2', '3', '4', '6', '9', '1', '2']) == [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]\n    assert candidate(['1', '3', '5', '7', '1', '3', '13', '15', '17', '5', '7 ', '9', '1', '11']) == [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]\n\ndef test_check():\n    check(sort_numeric_strings)\n\ntest_check()\n", "sample_io": ["assert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"], "source_codes": ["def sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: A list of strings representing numbers\n        \n    Returns:\n        A list of integers sorted numerically\n    \"\"\"\n    # Handle empty list edge case\n    if not nums_str:\n        return []\n    \n    # Convert strings to integers and sort numerically\n    try:\n        nums_int = [int(s) for s in nums_str]\n        return sorted(nums_int)\n    except ValueError:\n        # Re-raise with more descriptive message if needed\n        raise ValueError(\"All elements in the list must be numeric strings\")"], "responses": ["\nfrom typing import List\n\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: A list of strings representing numbers\n        \n    Returns:\n        A list of integers sorted numerically\n    \"\"\"\n    # Handle empty list edge case\n    if not nums_str:\n        return []\n    \n    # Convert strings to integers and sort numerically\n    try:\n        nums_int = [int(s) for s in nums_str]\n        return sorted(nums_int)\n    except ValueError:\n        # Re-raise with more descriptive message if needed\n        raise ValueError(\"All elements in the list must be numeric strings\")\n\n\n"], "prompt_tokens": [1781], "completion_tokens": [1076], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_749_sort_numeric_strings"}
{"name": "mbpp_97_frequency_lists", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_97_frequency_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1 }\n    assert candidate([[20, 30, 40, 17], [18, 16, 14, 13], [10, 20, 30, 40]]) == { 20: 2, 30: 2, 40: 2, 17: 1, 18: 1, 16: 1, 14: 1, 13: 1, 10: 1 }\n\ndef test_check():\n    check(frequency_lists)\n\ntest_check()\n", "sample_io": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }"], "source_codes": ["def frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    # Handle edge case of empty input list\n    if not list1:\n        return {}\n    \n    # Flatten the nested list structure\n    flattened = []\n    for sublist in list1:\n        for element in sublist:\n            flattened.append(element)\n    \n    # Create a dictionary to store element frequencies\n    frequency_dict = {}\n    \n    # Count occurrences of each element\n    for element in flattened:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict"], "responses": ["\nfrom typing import List, Dict\n\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    # Handle edge case of empty input list\n    if not list1:\n        return {}\n    \n    # Flatten the nested list structure\n    flattened = []\n    for sublist in list1:\n        for element in sublist:\n            flattened.append(element)\n    \n    # Create a dictionary to store element frequencies\n    frequency_dict = {}\n    \n    # Count occurrences of each element\n    for element in flattened:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict\n\n\n"], "prompt_tokens": [1924], "completion_tokens": [1033], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_97_frequency_lists"}
{"name": "mbpp_429_and_tuples", "language": "Python3", "prompt": "from typing import Tuple\n\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to extract the elementwise and tuples from the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_429_and_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "and_tuples", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)\n    assert candidate((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)\n    assert candidate((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)\n\ndef test_check():\n    check(and_tuples)\n\ntest_check()\n", "sample_io": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"], "source_codes": ["def and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))"], "responses": ["\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "prompt_tokens": [2272], "completion_tokens": [1333], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_429_and_tuples"}
{"name": "mbpp_759_is_decimal", "language": "Python3", "prompt": "def is_decimal(num: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether a given string is a decimal number with a precision of 2.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_decimal", "test": "def check(candidate):\n    assert candidate('123.11') == True\n    assert candidate('e666.86') == False\n    assert candidate('3.124587') == False\n    assert candidate('1.11') == True\n    assert candidate('1.1.11') == False\n\ndef test_check():\n    check(is_decimal)\n\ntest_check()\n", "sample_io": ["assert is_decimal('123.11') == True"], "source_codes": ["def is_decimal(num: str) -> bool:\n    # Check if the input string is empty or None\n    if not num:\n        return False\n    \n    # Check for valid characters and structure\n    # Allow optional sign (+ or -) at the beginning, digits, and exactly one decimal point\n    if num.count('.') != 1:\n        return False\n    \n    # Split by decimal point\n    parts = num.split('.')\n    \n    # Should have exactly two parts\n    if len(parts) != 2:\n        return False\n    \n    integer_part, fractional_part = parts\n    \n    # Check fractional part has exactly 2 digits\n    if len(fractional_part) != 2 or not fractional_part.isdigit():\n        return False\n    \n    # Check integer part - can be empty (like in .12) or contain optional sign and digits\n    if integer_part == \"\":\n        return False\n    elif integer_part == \"+\" or integer_part == \"-\":\n        return False\n    else:\n        # If it starts with +/-, the rest must be digits\n        if integer_part[0] in \"+-\":\n            if len(integer_part) == 1 or not integer_part[1:].isdigit():\n                return False\n        else:\n            # No sign, must be all digits\n            if not integer_part.isdigit():\n                return False\n    \n    return True"], "responses": ["\ndef is_decimal(num: str) -> bool:\n    # Check if the input string is empty or None\n    if not num:\n        return False\n    \n    # Check for valid characters and structure\n    # Allow optional sign (+ or -) at the beginning, digits, and exactly one decimal point\n    if num.count('.') != 1:\n        return False\n    \n    # Split by decimal point\n    parts = num.split('.')\n    \n    # Should have exactly two parts\n    if len(parts) != 2:\n        return False\n    \n    integer_part, fractional_part = parts\n    \n    # Check fractional part has exactly 2 digits\n    if len(fractional_part) != 2 or not fractional_part.isdigit():\n        return False\n    \n    # Check integer part - can be empty (like in .12) or contain optional sign and digits\n    if integer_part == \"\":\n        return False\n    elif integer_part == \"+\" or integer_part == \"-\":\n        return False\n    else:\n        # If it starts with +/-, the rest must be digits\n        if integer_part[0] in \"+-\":\n            if len(integer_part) == 1 or not integer_part[1:].isdigit():\n                return False\n        else:\n            # No sign, must be all digits\n            if not integer_part.isdigit():\n                return False\n    \n    return True\n\n\n"], "prompt_tokens": [1728], "completion_tokens": [1054], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_759_is_decimal"}
{"name": "mbpp_599_sum_average", "language": "Python3", "prompt": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n\tWrite a function to find sum and average of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_599_sum_average.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_average", "test": "def check(candidate):\n    assert candidate(10) == (55, 5.5)\n    assert candidate(15) == (120, 8.0)\n    assert candidate(20) == (210, 10.5)\n\ndef test_check():\n    check(sum_average)\n\ntest_check()\n", "sample_io": ["assert sum_average(10) == (55, 5.5)"], "source_codes": ["def sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Write a function to find sum and average of first n natural numbers.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Number must be non-negative\")\n    \n    if number == 0:\n        return (0, 0.0)\n    \n    # Calculate sum using formula: n*(n+1)/2\n    total_sum = number * (number + 1) // 2\n    \n    # Calculate average\n    average = total_sum / number\n    \n    return (total_sum, average)"], "responses": ["\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Write a function to find sum and average of first n natural numbers.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Number must be non-negative\")\n    \n    if number == 0:\n        return (0, 0.0)\n    \n    # Calculate sum using formula: n*(n+1)/2\n    total_sum = number * (number + 1) // 2\n    \n    # Calculate average\n    average = total_sum / number\n    \n    return (total_sum, average)\n\n\n"], "prompt_tokens": [1670], "completion_tokens": [1055], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_599_sum_average"}
{"name": "mbpp_804_is_product_even", "language": "Python3", "prompt": "from typing import List\n\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether the product of numbers in a list is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_804_is_product_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_product_even", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 4]) == True\n    assert candidate([1, 1]) == False\n\ndef test_check():\n    check(is_product_even)\n\ntest_check()\n", "sample_io": ["assert is_product_even([1, 2, 3]) == True"], "source_codes": ["def is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether the product of numbers in a list is even or not.\n    \"\"\"\n    # Handle edge case: empty list\n    if not arr:\n        return False\n    \n    # Check if any number in the list is even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If no even number found, product is odd\n    return False"], "responses": ["\nfrom typing import List\n\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether the product of numbers in a list is even or not.\n    \"\"\"\n    # Handle edge case: empty list\n    if not arr:\n        return False\n    \n    # Check if any number in the list is even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If no even number found, product is odd\n    return False\n\n\n"], "prompt_tokens": [1779], "completion_tokens": [901], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_804_is_product_even"}
{"name": "mbpp_103_eulerian_num", "language": "Python3", "prompt": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a function to find the Eulerian number a(n, m).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "eulerian_num", "test": "def check(candidate):\n    assert candidate(3, 1) == 4\n    assert candidate(4, 1) == 11\n    assert candidate(5, 3) == 26\n\ndef test_check():\n    check(eulerian_num)\n\ntest_check()\n", "sample_io": ["assert eulerian_num(3, 1) == 4"], "source_codes": ["def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Find the Eulerian number A(n, m).\n    \n    The Eulerian number A(n, m) counts the number of permutations of the numbers 1 to n \n    in which exactly m elements are greater than the next element (m ascents).\n    \n    Args:\n        n: non-negative integer\n        m: non-negative integer where m < n\n        \n    Returns:\n        The Eulerian number A(n, m)\n    \"\"\"\n    # Base cases\n    if m >= n or m < 0:\n        return 0\n    if n == 0:\n        return 1\n    \n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Fill the base case\n    dp[0][0] = 1\n    \n    # Fill the rest of the table using the recurrence relation:\n    # A(n, m) = (n - m) * A(n-1, m-1) + (m + 1) * A(n-1, m)\n    for i in range(1, n + 1):\n        for j in range(0, min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]"], "responses": ["\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Find the Eulerian number A(n, m).\n    \n    The Eulerian number A(n, m) counts the number of permutations of the numbers 1 to n \n    in which exactly m elements are greater than the next element (m ascents).\n    \n    Args:\n        n: non-negative integer\n        m: non-negative integer where m < n\n        \n    Returns:\n        The Eulerian number A(n, m)\n    \"\"\"\n    # Base cases\n    if m >= n or m < 0:\n        return 0\n    if n == 0:\n        return 1\n    \n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Fill the base case\n    dp[0][0] = 1\n    \n    # Fill the rest of the table using the recurrence relation:\n    # A(n, m) = (n - m) * A(n-1, m-1) + (m + 1) * A(n-1, m)\n    for i in range(1, n + 1):\n        for j in range(0, min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]\n\n\n"], "prompt_tokens": [648], "completion_tokens": [1571], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_103_eulerian_num"}
{"name": "mbpp_391_convert_list_dictionary", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    \"\"\"\n\tWrite a function to convert more than one list to nested dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_391_convert_list_dictionary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert_list_dictionary", "test": "def check(candidate):\n    assert candidate(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }, { 'S002': { 'Leyton Marsh': 98 } }, { 'S003': { 'Duncan Boyle': 89 } }, { 'S004': { 'Saim Richards': 92 } }]\n    assert candidate(['abc', 'def', 'ghi', 'jkl'], ['python', 'program', 'language', 'programs'], [100, 200, 300, 400]) == [{ 'abc': { 'python': 100 } }, { 'def': { 'program': 200 } }, { 'ghi': { 'language': 300 } }, { 'jkl': { 'programs': 400 } }]\n    assert candidate(['A1', 'A2', 'A3', 'A4'], ['java', 'C', 'C++', 'DBMS'], [10, 20, 30, 40]) == [{ 'A1': { 'java': 10 } }, { 'A2': { 'C': 20 } }, { 'A3': { 'C++': 30 } }, { 'A4': { 'DBMS': 40 } }]\n\ndef test_check():\n    check(convert_list_dictionary)\n\ntest_check()\n", "sample_io": ["assert convert_list_dictionary(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }]"], "source_codes": ["def convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    result = []\n    for a, b, c in zip(l1, l2, l3):\n        result.append({a: {b: c}})\n    \n    return result"], "responses": ["\nfrom typing import List, Dict\n\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    result = []\n    for a, b, c in zip(l1, l2, l3):\n        result.append({a: {b: c}})\n    \n    return result\n\n\n"], "prompt_tokens": [7196], "completion_tokens": [3743], "no_of_try": 1, "api_calls": 10, "is_solved": true, "task_id": "mbpp_391_convert_list_dictionary"}
{"name": "mbpp_635_heap_sort", "language": "Python3", "prompt": "from typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_sort", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    assert candidate([7, 1, 9, 5]) == [1, 5, 7, 9]\n\ndef test_check():\n    check(heap_sort)\n\ntest_check()\n", "sample_io": ["assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "source_codes": ["def heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sorts the given list using heap sort algorithm.\n    \"\"\"\n    # Handle edge cases\n    if len(iterable) <= 1:\n        return iterable\n    \n    # Make a copy to avoid modifying the original list\n    arr = iterable.copy()\n    n = len(arr)\n    \n    # Helper function to maintain max heap property\n    def heapify(arr, n, i):\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1     # left child\n        right = 2 * i + 2    # right child\n        \n        # If left child exists and is greater than root\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n            \n        # If right child exists and is greater than current largest\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n            \n        # If largest is not root, swap and continue heapifying\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n    \n    # Build max heap by heapifying all non-leaf nodes\n    # Last non-leaf node is at index (n//2 - 1)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        \n        # Call heapify on reduced heap\n        heapify(arr, i, 0)\n    \n    return arr"], "responses": ["\nfrom typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sorts the given list using heap sort algorithm.\n    \"\"\"\n    # Handle edge cases\n    if len(iterable) <= 1:\n        return iterable\n    \n    # Make a copy to avoid modifying the original list\n    arr = iterable.copy()\n    n = len(arr)\n    \n    # Helper function to maintain max heap property\n    def heapify(arr, n, i):\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1     # left child\n        right = 2 * i + 2    # right child\n        \n        # If left child exists and is greater than root\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n            \n        # If right child exists and is greater than current largest\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n            \n        # If largest is not root, swap and continue heapifying\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n    \n    # Build max heap by heapifying all non-leaf nodes\n    # Last non-leaf node is at index (n//2 - 1)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        \n        # Call heapify on reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\n\n"], "prompt_tokens": [2050], "completion_tokens": [1404], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_635_heap_sort"}
{"name": "mbpp_270_sum_even_and_even_index", "language": "Python3", "prompt": "from typing import List\n\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even numbers at even positions of a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_even_and_even_index", "test": "def check(candidate):\n    assert candidate([5, 6, 12, 1, 18, 8]) == 30\n    assert candidate([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26\n    assert candidate([5, 6, 12, 1]) == 12\n\ndef test_check():\n    check(sum_even_and_even_index)\n\ntest_check()\n", "sample_io": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"], "source_codes": ["def sum_even_and_even_index(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            total += arr[i]\n    return total"], "responses": ["\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    total = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            total += arr[i]\n    return total\n\n\n"], "prompt_tokens": [2176], "completion_tokens": [1350], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_270_sum_even_and_even_index"}
{"name": "mbpp_787_text_match_three", "language": "Python3", "prompt": "def text_match_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by three 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('caacabbbba') == True\n\ndef test_check():\n    check(text_match_three)\n\ntest_check()\n", "sample_io": ["assert text_match_three('ac') == False"], "source_codes": ["import re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r\"abbb\"\n    return bool(re.search(pattern, text))"], "responses": ["\nimport re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r\"abbb\"\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1657], "completion_tokens": [976], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_787_text_match_three"}
{"name": "mbpp_765_is_polite", "language": "Python3", "prompt": "def is_polite(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_polite", "test": "def check(candidate):\n    assert candidate(7) == 11\n    assert candidate(4) == 7\n    assert candidate(9) == 13\n\ndef test_check():\n    check(is_polite)\n\ntest_check()\n", "sample_io": ["assert is_polite(7) == 11"], "source_codes": ["def is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    All positive integers except powers of 2 are polite numbers.\n    \"\"\"\n    def is_power_of_two(num):\n        \"\"\"Check if a number is a power of 2 using bitwise operation.\"\"\"\n        return num > 0 and (num & (num - 1)) == 0\n    \n    count = 0\n    num = 1\n    \n    while count < n:\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num"], "responses": ["\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    All positive integers except powers of 2 are polite numbers.\n    \"\"\"\n    def is_power_of_two(num):\n        \"\"\"Check if a number is a power of 2 using bitwise operation.\"\"\"\n        return num > 0 and (num & (num - 1)) == 0\n    \n    count = 0\n    num = 1\n    \n    while count < n:\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num\n\n\n"], "prompt_tokens": [1752], "completion_tokens": [1175], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_765_is_polite"}
{"name": "mbpp_459_remove_uppercase", "language": "Python3", "prompt": "def remove_uppercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove uppercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_uppercase", "test": "def check(candidate):\n    assert candidate('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\n    assert candidate('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'\n    assert candidate('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'\n\ndef test_check():\n    check(remove_uppercase)\n\ntest_check()\n", "sample_io": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"], "source_codes": ["def remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.isupper())"], "responses": ["\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.isupper())\n\n\n"], "prompt_tokens": [1695], "completion_tokens": [768], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_459_remove_uppercase"}
{"name": "mbpp_16_text_lowercase_underscore", "language": "Python3", "prompt": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n\tWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_lowercase_underscore", "test": "def check(candidate):\n    assert candidate('aab_cbbbc') == True\n    assert candidate('aab_Abbbc') == False\n    assert candidate('Aaab_abbbc') == False\n\ndef test_check():\n    check(text_lowercase_underscore)\n\ntest_check()\n", "sample_io": ["assert text_lowercase_underscore('aab_cbbbc') == True"], "source_codes": ["import re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    # Pattern to match sequences of lowercase letters joined by underscores\n    # This pattern looks for one or more lowercase letters, followed by an underscore,\n    # followed by one or more lowercase letters\n    pattern = r'[a-z]+_[a-z]+'\n    \n    # Search for the pattern anywhere in the text\n    return bool(re.search(pattern, text))"], "responses": ["\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    # Pattern to match sequences of lowercase letters joined by underscores\n    # This pattern looks for one or more lowercase letters, followed by an underscore,\n    # followed by one or more lowercase letters\n    pattern = r'[a-z]+_[a-z]+'\n    \n    # Search for the pattern anywhere in the text\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1644], "completion_tokens": [903], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_16_text_lowercase_underscore"}
{"name": "mbpp_731_lateralsurface_cone", "language": "Python3", "prompt": "def lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cone given radius r and the height h.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cone", "test": "def check(candidate):\n    assert candidate(5, 12) == 204.20352248333654\n    assert candidate(10, 15) == 566.3586699569488\n    assert candidate(19, 17) == 1521.8090132193388\n\ndef test_check():\n    check(lateralsurface_cone)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cone(5, 12) == 204.20352248333654"], "source_codes": ["import math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \"\"\"\n    # Validate inputs are non-negative\n    if r < 0 or h < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n    \n    # Handle edge case where radius is 0\n    if r == 0:\n        return 0.0\n    \n    # Calculate slant height l = sqrt(r^2 + h^2)\n    l = math.sqrt(r * r + h * h)\n    \n    # Calculate lateral surface area = \u03c0 * r * l\n    lateral_area = math.pi * r * l\n    \n    return float(lateral_area)"], "responses": ["\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \"\"\"\n    # Validate inputs are non-negative\n    if r < 0 or h < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n    \n    # Handle edge case where radius is 0\n    if r == 0:\n        return 0.0\n    \n    # Calculate slant height l = sqrt(r^2 + h^2)\n    l = math.sqrt(r * r + h * h)\n    \n    # Calculate lateral surface area = \u03c0 * r * l\n    lateral_area = math.pi * r * l\n    \n    return float(lateral_area)\n\n\n"], "prompt_tokens": [1877], "completion_tokens": [1170], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_731_lateralsurface_cone"}
{"name": "mbpp_802_count_rotation", "language": "Python3", "prompt": "from typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_rotation", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == 1\n    assert candidate([4, 5, 1, 2, 3]) == 2\n    assert candidate([7, 8, 9, 1, 2, 3]) == 3\n    assert candidate([1, 2, 3]) == 0\n    assert candidate([1, 3, 2]) == 2\n\ndef test_check():\n    check(count_rotation)\n\ntest_check()\n", "sample_io": ["assert count_rotation([3, 2, 1]) == 1"], "source_codes": ["def count_rotation(arr: List[int]) -> int:\n    # Handle edge cases\n    if len(arr) <= 1:\n        return 0\n    \n    # Find the rotation point where arr[i] > arr[i+1]\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return i + 1\n    \n    # If no rotation point found, array is already sorted\n    return 0"], "responses": ["\nfrom typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    # Handle edge cases\n    if len(arr) <= 1:\n        return 0\n    \n    # Find the rotation point where arr[i] > arr[i+1]\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return i + 1\n    \n    # If no rotation point found, array is already sorted\n    return 0\n\n\n"], "prompt_tokens": [2121], "completion_tokens": [1290], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_802_count_rotation"}
{"name": "mbpp_782_odd_length_sum", "language": "Python3", "prompt": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_length_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 4]) == 14\n    assert candidate([1, 2, 1, 2]) == 15\n    assert candidate([1, 7]) == 8\n\ndef test_check():\n    check(odd_length_sum)\n\ntest_check()\n", "sample_io": ["assert odd_length_sum([1, 2, 4]) == 14"], "source_codes": ["def odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    For each element at index i, it appears in ((i+1)*(n-i)+1)//2 odd-length subarrays.\n    We multiply each element by this count and sum all contributions.\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Number of odd-length subarrays containing arr[i]\n        count = ((i + 1) * (n - i) + 1) // 2\n        total_sum += arr[i] * count\n    \n    return total_sum"], "responses": ["\nfrom typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    For each element at index i, it appears in ((i+1)*(n-i)+1)//2 odd-length subarrays.\n    We multiply each element by this count and sum all contributions.\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Number of odd-length subarrays containing arr[i]\n        count = ((i + 1) * (n - i) + 1) // 2\n        total_sum += arr[i] * count\n    \n    return total_sum\n\n\n"], "prompt_tokens": [2033], "completion_tokens": [1142], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_782_odd_length_sum"}
{"name": "mbpp_470_add_pairwise", "language": "Python3", "prompt": "from typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the pairwise addition of the neighboring elements of the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_pairwise", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n    assert candidate((2, 6, 8, 9, 11)) == (8, 14, 17, 20)\n    assert candidate((3, 7, 9, 10, 12)) == (10, 16, 19, 22)\n\ndef test_check():\n    check(add_pairwise)\n\ntest_check()\n", "sample_io": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)"], "source_codes": ["def add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    return (test_tup[0] + test_tup[1], \n            test_tup[1] + test_tup[2], \n            test_tup[2] + test_tup[3], \n            test_tup[3] + test_tup[4])"], "responses": ["\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    return (test_tup[0] + test_tup[1], \n            test_tup[1] + test_tup[2], \n            test_tup[2] + test_tup[3], \n            test_tup[3] + test_tup[4])\n\n\n"], "prompt_tokens": [3651], "completion_tokens": [1792], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_470_add_pairwise"}
{"name": "mbpp_17_square_perimeter", "language": "Python3", "prompt": "def square_perimeter(a: int) -> int:\n    \"\"\"\n\tWrite a function that returns the perimeter of a square given its side length as input.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_perimeter", "test": "def check(candidate):\n    assert candidate(10) == 40\n    assert candidate(5) == 20\n    assert candidate(4) == 16\n\ndef test_check():\n    check(square_perimeter)\n\ntest_check()\n", "sample_io": ["assert square_perimeter(10) == 40"], "source_codes": ["def square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a"], "responses": ["\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n\n\n"], "prompt_tokens": [1383], "completion_tokens": [595], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_17_square_perimeter"}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "Python3", "prompt": "def all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the bits are unset in the given range or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Bits_Set_In_The_Given_Range", "test": "def check(candidate):\n    assert candidate(4, 1, 2) == True\n    assert candidate(17, 2, 4) == True\n    assert candidate(39, 4, 6) == False\n\ndef test_check():\n    check(all_Bits_Set_In_The_Given_Range)\n\ntest_check()\n", "sample_io": ["assert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"], "source_codes": ["def all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n    Check whether all the bits are unset in the given range [l, r] of number n.\n    \n    Args:\n        n: The number to check\n        l: Left boundary of the range (1-indexed from right)\n        r: Right boundary of the range (1-indexed from right)\n        \n    Returns:\n        bool: True if all bits in the range are unset (0), False otherwise\n    \"\"\"\n    # Handle invalid range\n    if l > r or l <= 0:\n        return True\n    \n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with r bits set: (1 << r) - 1\n    # Then remove the first (l-1) bits: shift right by (l-1) and shift back\n    mask = ((1 << r) - 1) & ~((1 << (l - 1)) - 1)\n    \n    # Alternative approach:\n    # mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if any bit in the range is set\n    # If (n & mask) == 0, then all bits in range are unset\n    return (n & mask) == 0"], "responses": ["\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n    Check whether all the bits are unset in the given range [l, r] of number n.\n    \n    Args:\n        n: The number to check\n        l: Left boundary of the range (1-indexed from right)\n        r: Right boundary of the range (1-indexed from right)\n        \n    Returns:\n        bool: True if all bits in the range are unset (0), False otherwise\n    \"\"\"\n    # Handle invalid range\n    if l > r or l <= 0:\n        return True\n    \n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with r bits set: (1 << r) - 1\n    # Then remove the first (l-1) bits: shift right by (l-1) and shift back\n    mask = ((1 << r) - 1) & ~((1 << (l - 1)) - 1)\n    \n    # Alternative approach:\n    # mask = ((1 << (r - l + 1)) - 1) << (l - 1)\n    \n    # Check if any bit in the range is set\n    # If (n & mask) == 0, then all bits in range are unset\n    return (n & mask) == 0\n\n\n"], "prompt_tokens": [1681], "completion_tokens": [1500], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_228_all_Bits_Set_In_The_Given_Range"}
{"name": "mbpp_240_replace_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_240_replace_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_list", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate(['red', 'blue', 'green'], ['yellow']) == ['red', 'blue', 'yellow']\n\ndef test_check():\n    check(replace_list)\n\ntest_check()\n", "sample_io": ["assert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"], "source_codes": ["def replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Handle the case where list1 is empty\n    if not list1:\n        return list2\n    \n    # Take all elements of list1 except the last one and concatenate with list2\n    return list1[:-1] + list2"], "responses": ["\nfrom typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Handle the case where list1 is empty\n    if not list1:\n        return list2\n    \n    # Take all elements of list1 except the last one and concatenate with list2\n    return list1[:-1] + list2\n\n\n"], "prompt_tokens": [1999], "completion_tokens": [962], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_240_replace_list"}
{"name": "mbpp_447_cube_nums", "language": "Python3", "prompt": "from typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find cubes of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    assert candidate([10, 20, 30]) == [1000, 8000, 27000]\n    assert candidate([12, 15]) == [1728, 3375]\n\ndef test_check():\n    check(cube_nums)\n\ntest_check()\n", "sample_io": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"], "source_codes": ["def cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]"], "responses": ["\nfrom typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n\n\n"], "prompt_tokens": [1807], "completion_tokens": [868], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_447_cube_nums"}
{"name": "mbpp_261_division_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "division_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)\n    assert candidate((12, 6, 8, 16), (6, 3, 4, 4)) == (2, 2, 2, 4)\n    assert candidate((20, 14, 36, 18), (5, 7, 6, 9)) == (4, 2, 6, 2)\n\ndef test_check():\n    check(division_elements)\n\ntest_check()\n", "sample_io": ["assert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)"], "source_codes": ["def division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    result = []\n    for i in range(4):\n        result.append(test_tup1[i] // test_tup2[i])\n    return tuple(result)"], "responses": ["\nfrom typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    result = []\n    for i in range(4):\n        result.append(test_tup1[i] // test_tup2[i])\n    return tuple(result)\n\n\n"], "prompt_tokens": [2493], "completion_tokens": [1510], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_261_division_elements"}
{"name": "mbpp_581_surface_Area", "language": "Python3", "prompt": "def surface_Area(b: int, s: int) -> int:\n    \"\"\"\n\tWrite a python function to find the surface area of a square pyramid with a given base edge and height.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surface_Area", "test": "def check(candidate):\n    assert candidate(3, 4) == 33\n    assert candidate(4, 5) == 56\n    assert candidate(1, 2) == 5\n\ndef test_check():\n    check(surface_Area)\n\ntest_check()\n", "sample_io": ["assert surface_Area(3, 4) == 33"], "source_codes": ["def surface_Area(b: int, s: int) -> int:\n    # Calculate base area\n    base_area = b * b\n    \n    # Calculate lateral surface area (4 triangular faces)\n    # s is already the slant height\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Calculate total surface area\n    total_area = base_area + lateral_area\n    \n    # Round to nearest integer and return\n    return round(total_area)"], "responses": ["\ndef surface_Area(b: int, s: int) -> int:\n    # Calculate base area\n    base_area = b * b\n    \n    # Calculate lateral surface area (4 triangular faces)\n    # s is already the slant height\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Calculate total surface area\n    total_area = base_area + lateral_area\n    \n    # Round to nearest integer and return\n    return round(total_area)\n\n\n"], "prompt_tokens": [4296], "completion_tokens": [3301], "no_of_try": 1, "api_calls": 8, "is_solved": true, "task_id": "mbpp_581_surface_Area"}
{"name": "mbpp_283_validate", "language": "Python3", "prompt": "def validate(n: int) -> bool:\n    \"\"\"\n\tWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "validate", "test": "def check(candidate):\n    assert candidate(1234) == True\n    assert candidate(51241) == False\n    assert candidate(321) == True\n\ndef test_check():\n    check(validate)\n\ntest_check()\n", "sample_io": ["assert validate(1234) == True"], "source_codes": ["def validate(n: int) -> bool:\n    # Convert to string and remove negative sign if present\n    s = str(abs(n))\n    \n    # Count frequency of each digit\n    freq_map = {}\n    for digit in s:\n        freq_map[digit] = freq_map.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= the digit itself\n    for digit, freq in freq_map.items():\n        # Convert digit character back to integer for comparison\n        digit_value = int(digit)\n        if freq > digit_value:\n            return False\n    \n    return True"], "responses": ["\ndef validate(n: int) -> bool:\n    # Convert to string and remove negative sign if present\n    s = str(abs(n))\n    \n    # Count frequency of each digit\n    freq_map = {}\n    for digit in s:\n        freq_map[digit] = freq_map.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= the digit itself\n    for digit, freq in freq_map.items():\n        # Convert digit character back to integer for comparison\n        digit_value = int(digit)\n        if freq > digit_value:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1730], "completion_tokens": [990], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_283_validate"}
