{"name": "mbpp_171_perimeter_pentagon", "language": "Python3", "prompt": "def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n\tWrite a function to find the perimeter of a regular pentagon from the length of its sides.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perimeter_pentagon", "test": "def check(candidate):\n    assert candidate(5) == 25\n    assert candidate(10) == 50\n    assert candidate(15) == 75\n\ndef test_check():\n    check(perimeter_pentagon)\n\ntest_check()\n", "sample_io": ["assert perimeter_pentagon(5) == 25"], "source_codes": ["def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Find the perimeter of a regular pentagon from the length of its sides.\n    \n    Args:\n        a (int): The length of one side of the pentagon\n        \n    Returns:\n        int: The perimeter of the pentagon\n    \"\"\"\n    return 5 * a"], "responses": ["\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Find the perimeter of a regular pentagon from the length of its sides.\n    \n    Args:\n        a (int): The length of one side of the pentagon\n        \n    Returns:\n        int: The perimeter of the pentagon\n    \"\"\"\n    return 5 * a\n\n\n"], "prompt_tokens": [1461], "completion_tokens": [827], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_171_perimeter_pentagon"}
{"name": "mbpp_222_check_type", "language": "Python3", "prompt": "from typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if all the elements in tuple have same data type or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_type", "test": "def check(candidate):\n    assert candidate((5, 6, 7, 3, 5, 6)) == True\n    assert candidate((1, 2, '4')) == False\n    assert candidate((3, 2, 1, 4, 5)) == True\n\ndef test_check():\n    check(check_type)\n\ntest_check()\n", "sample_io": ["assert check_type((5, 6, 7, 3, 5, 6)) == True"], "source_codes": ["def check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    # Handle edge cases\n    if len(test_tuple) <= 1:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Check if all elements have the same type as the first element\n    return all(type(element) == first_type for element in test_tuple)"], "responses": ["\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    # Handle edge cases\n    if len(test_tuple) <= 1:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Check if all elements have the same type as the first element\n    return all(type(element) == first_type for element in test_tuple)\n\n\n"], "prompt_tokens": [1831], "completion_tokens": [1131], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_222_check_type"}
{"name": "mbpp_164_are_equivalent", "language": "Python3", "prompt": "def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n\tWrite a function to determine if the sum of the divisors of two integers are the same.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "are_equivalent", "test": "def check(candidate):\n    assert candidate(36, 57) == False\n    assert candidate(2, 4) == False\n    assert candidate(23, 47) == True\n\ndef test_check():\n    check(are_equivalent)\n\ntest_check()\n", "sample_io": ["assert are_equivalent(36, 57) == False"], "source_codes": ["def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n            \n        divisor_sum = 0\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid adding the same divisor twice for perfect squares\n                    divisor_sum += n // i\n            i += 1\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)"], "responses": ["\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n            \n        divisor_sum = 0\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid adding the same divisor twice for perfect squares\n                    divisor_sum += n // i\n            i += 1\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n\n\n"], "prompt_tokens": [2112], "completion_tokens": [1450], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_164_are_equivalent"}
{"name": "mbpp_803_is_perfect_square", "language": "Python3", "prompt": "def is_perfect_square(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_perfect_square", "test": "def check(candidate):\n    assert candidate(10) == False\n    assert candidate(36) == True\n    assert candidate(14) == False\n    assert candidate(196) == True\n    assert candidate(125) == False\n    assert candidate(15625) == True\n\ndef test_check():\n    check(is_perfect_square)\n\ntest_check()\n", "sample_io": ["assert is_perfect_square(10) == False"], "source_codes": ["def is_perfect_square(n: int) -> bool:\n    # Handle negative numbers\n    if n < 0:\n        return False\n    \n    # Handle edge cases\n    if n == 0 or n == 1:\n        return True\n    \n    # Find the integer square root\n    sqrt_n = int(n ** 0.5)\n    \n    # Check if the square of the integer square root equals the original number\n    return sqrt_n * sqrt_n == n"], "responses": ["\ndef is_perfect_square(n: int) -> bool:\n    # Handle negative numbers\n    if n < 0:\n        return False\n    \n    # Handle edge cases\n    if n == 0 or n == 1:\n        return True\n    \n    # Find the integer square root\n    sqrt_n = int(n ** 0.5)\n    \n    # Check if the square of the integer square root equals the original number\n    return sqrt_n * sqrt_n == n\n\n\n"], "prompt_tokens": [1916], "completion_tokens": [1107], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_803_is_perfect_square"}
{"name": "mbpp_305_start_withp", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n\tWrite a function to return two words from a list of words starting with letter 'p'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "start_withp", "test": "def check(candidate):\n    assert candidate(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')\n    assert candidate(['Python Programming', 'Java Programming']) == ('Python', 'Programming')\n    assert candidate(['Pqrst Pqr', 'qrstuv']) == ('Pqrst', 'Pqr')\n\ndef test_check():\n    check(start_withp)\n\ntest_check()\n", "sample_io": ["assert start_withp(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')"], "source_codes": ["def start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    # Split each string into individual words\n    for phrase in words:\n        individual_words = phrase.split()\n        for word in individual_words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    \n    # Ensure we always return exactly 2 elements\n    while len(p_words) < 2:\n        p_words.append(\"\")\n    \n    return tuple(p_words[:2])"], "responses": ["\nfrom typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    p_words = []\n    # Split each string into individual words\n    for phrase in words:\n        individual_words = phrase.split()\n        for word in individual_words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                if len(p_words) == 2:\n                    break\n        if len(p_words) == 2:\n            break\n    \n    # Ensure we always return exactly 2 elements\n    while len(p_words) < 2:\n        p_words.append(\"\")\n    \n    return tuple(p_words[:2])\n\n\n"], "prompt_tokens": [3659], "completion_tokens": [1420], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_305_start_withp"}
{"name": "mbpp_617_min_Jumps", "language": "Python3", "prompt": "from typing import Tuple\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n\tWrite a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Jumps", "test": "def check(candidate):\n    assert candidate((3, 4), 11) == 3.5\n    assert candidate((3, 4), 0) == 0\n    assert candidate((11, 14), 11) == 1\n\ndef test_check():\n    check(min_Jumps)\n\ntest_check()\n", "sample_io": ["assert min_Jumps((3, 4), 11) == 3.5"], "source_codes": ["import math\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0\n    \n    a, b = steps\n    \n    if a == 0 and b == 0:\n        return float('inf')\n    \n    # If one step is 0, check if target is divisible by the other\n    if a == 0:\n        if d % b == 0:\n            return d / b\n        else:\n            return float('inf')\n    \n    if b == 0:\n        if d % a == 0:\n            return d / a\n        else:\n            return float('inf')\n    \n    # If d can be reached directly with one step\n    if d == a or d == b:\n        return 1\n    \n    # General case: find minimum n_a + n_b such that n_a*a + n_b*b = d\n    min_jumps = float('inf')\n    \n    # Try all possible values of n_a from 0 to d//a + reasonable buffer\n    for n_a in range(d // a + max(a, b) + 1):\n        remaining = d - n_a * a\n        if remaining >= 0 and remaining % b == 0:\n            n_b = remaining // b\n            jumps = n_a + n_b\n            min_jumps = min(min_jumps, jumps)\n        elif remaining < 0:\n            # Since we're increasing n_a, remaining will keep decreasing\n            break\n    \n    # Also try the other way around: fix n_b and solve for n_a\n    for n_b in range(d // b + max(a, b) + 1):\n        remaining = d - n_b * b\n        if remaining >= 0 and remaining % a == 0:\n            n_a = remaining // a\n            jumps = n_a + n_b\n            min_jumps = min(min_jumps, jumps)\n        elif remaining < 0:\n            break\n    \n    return min_jumps if min_jumps != float('inf') else float('inf')"], "responses": ["\nfrom typing import Tuple\nimport math\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0\n    \n    a, b = steps\n    \n    if a == 0 and b == 0:\n        return float('inf')\n    \n    # If one step is 0, check if target is divisible by the other\n    if a == 0:\n        if d % b == 0:\n            return d / b\n        else:\n            return float('inf')\n    \n    if b == 0:\n        if d % a == 0:\n            return d / a\n        else:\n            return float('inf')\n    \n    # If d can be reached directly with one step\n    if d == a or d == b:\n        return 1\n    \n    # General case: find minimum n_a + n_b such that n_a*a + n_b*b = d\n    min_jumps = float('inf')\n    \n    # Try all possible values of n_a from 0 to d//a + reasonable buffer\n    for n_a in range(d // a + max(a, b) + 1):\n        remaining = d - n_a * a\n        if remaining >= 0 and remaining % b == 0:\n            n_b = remaining // b\n            jumps = n_a + n_b\n            min_jumps = min(min_jumps, jumps)\n        elif remaining < 0:\n            # Since we're increasing n_a, remaining will keep decreasing\n            break\n    \n    # Also try the other way around: fix n_b and solve for n_a\n    for n_b in range(d // b + max(a, b) + 1):\n        remaining = d - n_b * b\n        if remaining >= 0 and remaining % a == 0:\n            n_a = remaining // a\n            jumps = n_a + n_b\n            min_jumps = min(min_jumps, jumps)\n        elif remaining < 0:\n            break\n    \n    return min_jumps if min_jumps != float('inf') else float('inf')\n\n\n"], "prompt_tokens": [6985], "completion_tokens": [5914], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_617_min_Jumps"}
{"name": "mbpp_117_list_to_float", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n\tWrite a function to convert all possible convertible elements in a list of lists to floats.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_to_float", "test": "def check(candidate):\n    assert candidate([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\n    assert candidate([('4', '4'), ('2', '27'), ('4.12', '9'), ('7', '11')]) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\n    assert candidate([('6', '78'), ('5', '26.45'), ('1.33', '4'), ('82', '13')]) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\n\ndef test_check():\n    check(list_to_float)\n\ntest_check()\n", "sample_io": ["assert list_to_float([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]"], "source_codes": ["def list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    \n    Args:\n        test_list: A list of tuples containing string elements\n        \n    Returns:\n        A list of tuples with float elements\n        \n    Raises:\n        ValueError: If any string cannot be converted to float\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    for tuple_item in test_list:\n        # Strip whitespace from strings before conversion\n        first_val = tuple_item[0].strip()\n        second_val = tuple_item[1].strip()\n        \n        # Convert to float\n        first_float = float(first_val)\n        second_float = float(second_val)\n        \n        # Append the converted tuple to result\n        result.append((first_float, second_float))\n        \n    return result"], "responses": ["\nfrom typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    \n    Args:\n        test_list: A list of tuples containing string elements\n        \n    Returns:\n        A list of tuples with float elements\n        \n    Raises:\n        ValueError: If any string cannot be converted to float\n    \"\"\"\n    if not test_list:\n        return []\n    \n    result = []\n    for tuple_item in test_list:\n        # Strip whitespace from strings before conversion\n        first_val = tuple_item[0].strip()\n        second_val = tuple_item[1].strip()\n        \n        # Convert to float\n        first_float = float(first_val)\n        second_float = float(second_val)\n        \n        # Append the converted tuple to result\n        result.append((first_float, second_float))\n        \n    return result\n\n\n"], "prompt_tokens": [1996], "completion_tokens": [1233], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_117_list_to_float"}
{"name": "mbpp_425_count_element_in_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n\tWrite a function to count the number of sublists containing a particular element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_425_count_element_in_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_element_in_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'A') == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'E') == 1\n\ndef test_check():\n    check(count_element_in_list)\n\ntest_check()\n", "sample_io": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"], "source_codes": ["def count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Write a function to count the number of sublists containing a particular element.\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Handle edge case of empty main list\n    if not list1:\n        return 0\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        # Check if element is present in the current sublist\n        if x in sublist:\n            # Increment counter if element is found\n            count += 1\n    \n    # Return the final count\n    return count"], "responses": ["\nfrom typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Write a function to count the number of sublists containing a particular element.\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Handle edge case of empty main list\n    if not list1:\n        return 0\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        # Check if element is present in the current sublist\n        if x in sublist:\n            # Increment counter if element is found\n            count += 1\n    \n    # Return the final count\n    return count\n\n\n"], "prompt_tokens": [2239], "completion_tokens": [1197], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_425_count_element_in_list"}
{"name": "mbpp_67_bell_number", "language": "Python3", "prompt": "def bell_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the number of ways to partition a set of Bell numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(10) == 115975\n    assert candidate(56) == 6775685320645824322581483068371419745979053216268760300\n\ndef test_check():\n    check(bell_number)\n\ntest_check()\n", "sample_io": ["assert bell_number(2) == 2"], "source_codes": ["def bell_number(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    # Initialize the first row of Bell triangle\n    prev_row = [1]\n    \n    # Construct Bell triangle row by row\n    for i in range(1, n + 1):\n        # Start new row with last element of previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill rest of the row using the recurrence relation\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update previous row for next iteration\n        prev_row = curr_row\n    \n    # Return the first element of the final row (which is B(n))\n    return prev_row[0]"], "responses": ["\ndef bell_number(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    # Initialize the first row of Bell triangle\n    prev_row = [1]\n    \n    # Construct Bell triangle row by row\n    for i in range(1, n + 1):\n        # Start new row with last element of previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill rest of the row using the recurrence relation\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update previous row for next iteration\n        prev_row = curr_row\n    \n    # Return the first element of the final row (which is B(n))\n    return prev_row[0]\n\n\n"], "prompt_tokens": [3137], "completion_tokens": [2007], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_67_bell_number"}
{"name": "mbpp_404_minimum", "language": "Python3", "prompt": "def minimum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "minimum", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(-5, -4) == -5\n    assert candidate(0, 0) == 0\n\ndef test_check():\n    check(minimum)\n\ntest_check()\n", "sample_io": ["assert minimum(1, 2) == 1"], "source_codes": ["def minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    return min(a, b)"], "responses": ["\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    return min(a, b)\n\n\n"], "prompt_tokens": [1103], "completion_tokens": [659], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_404_minimum"}
{"name": "mbpp_14_find_Volume", "language": "Python3", "prompt": "def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n\tWrite a python function to find the volume of a triangular prism.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Volume", "test": "def check(candidate):\n    assert candidate(10, 8, 6) == 240\n    assert candidate(3, 2, 2) == 6\n    assert candidate(1, 2, 1) == 1\n\ndef test_check():\n    check(find_Volume)\n\ntest_check()\n", "sample_io": ["assert find_Volume(10, 8, 6) == 240"], "source_codes": ["def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: length of the base triangle\n        b: breadth/base width of the base triangle  \n        h: height of the prism\n        \n    Returns:\n        Volume of the triangular prism as an integer\n    \"\"\"\n    # Formula: V = (1/2) * base_area * height\n    # For a right triangle base: base_area = (1/2) * l * b\n    # So: V = (1/2) * (1/2) * l * b * h = (1/4) * l * b * h\n    # But typically volume of triangular prism = base_area * height\n    # If we consider the base as a triangle with base=b and height=l:\n    # Base area = (1/2) * b * l\n    # Volume = (1/2) * b * l * h\n    \n    # Using integer division to ensure integer result\n    return (l * b * h) // 2"], "responses": ["\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: length of the base triangle\n        b: breadth/base width of the base triangle  \n        h: height of the prism\n        \n    Returns:\n        Volume of the triangular prism as an integer\n    \"\"\"\n    # Formula: V = (1/2) * base_area * height\n    # For a right triangle base: base_area = (1/2) * l * b\n    # So: V = (1/2) * (1/2) * l * b * h = (1/4) * l * b * h\n    # But typically volume of triangular prism = base_area * height\n    # If we consider the base as a triangle with base=b and height=l:\n    # Base area = (1/2) * b * l\n    # Volume = (1/2) * b * l * h\n    \n    # Using integer division to ensure integer result\n    return (l * b * h) // 2\n\n\n"], "prompt_tokens": [1875], "completion_tokens": [1448], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_14_find_Volume"}
{"name": "mbpp_8_square_nums", "language": "Python3", "prompt": "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find squares of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30]) == [100, 400, 900]\n    assert candidate([12, 15]) == [144, 225]\n\ndef test_check():\n    check(square_nums)\n\ntest_check()\n", "sample_io": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["def square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]"], "responses": ["\nfrom typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]\n\n\n"], "prompt_tokens": [1687], "completion_tokens": [796], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_8_square_nums"}
{"name": "mbpp_722_filter_data", "language": "Python3", "prompt": "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n\tThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_data", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.9, 67) == { 'Cierra Vega': (6.2, 70), 'Kierra Gentry': (6.0, 68) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.7, 64) == { 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }\n\ndef test_check():\n    check(filter_data)\n\ntest_check()\n", "sample_io": ["assert filter_data({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }"], "source_codes": ["def filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}"], "responses": ["\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height >= h and weight >= w}\n\n\n"], "prompt_tokens": [5064], "completion_tokens": [2005], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_722_filter_data"}
{"name": "mbpp_244_next_Perfect_Square", "language": "Python3", "prompt": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n\tWrite a python function to find the next perfect square greater than a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_Perfect_Square", "test": "def check(candidate):\n    assert candidate(35) == 36\n    assert candidate(6) == 9\n    assert candidate(9) == 16\n\ndef test_check():\n    check(next_Perfect_Square)\n\ntest_check()\n", "sample_io": ["assert next_Perfect_Square(35) == 36"], "source_codes": ["import math\n\ndef next_Perfect_Square(N: int) -> int:\n    # Calculate the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # Check if N is a perfect square by seeing if sqrt_N is an integer\n    if sqrt_N == int(sqrt_N):\n        # If it is a perfect square, increment the integer square root by 1\n        next_sqrt = int(sqrt_N) + 1\n    else:\n        # If it's not a perfect square, take the ceiling of the square root\n        next_sqrt = math.ceil(sqrt_N)\n    \n    # Return the square of the next integer\n    return next_sqrt ** 2"], "responses": ["\nimport math\n\ndef next_Perfect_Square(N: int) -> int:\n    # Calculate the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # Check if N is a perfect square by seeing if sqrt_N is an integer\n    if sqrt_N == int(sqrt_N):\n        # If it is a perfect square, increment the integer square root by 1\n        next_sqrt = int(sqrt_N) + 1\n    else:\n        # If it's not a perfect square, take the ceiling of the square root\n        next_sqrt = math.ceil(sqrt_N)\n    \n    # Return the square of the next integer\n    return next_sqrt ** 2\n\n\n"], "prompt_tokens": [2002], "completion_tokens": [1419], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_244_next_Perfect_Square"}
{"name": "mbpp_755_second_smallest", "language": "Python3", "prompt": "from typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find the second smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "second_smallest", "test": "def check(candidate):\n    assert candidate([1, 2, -8, -2, 0, -2]) == -2\n    assert candidate([1, 1, -0.5, 0, 2, -2, -2]) == -0.5\n    assert candidate([2, 2]) == None\n    assert candidate([2, 2, 2]) == None\n\ndef test_check():\n    check(second_smallest)\n\ntest_check()\n", "sample_io": ["assert second_smallest([1, 2, -8, -2, 0, -2]) == -2"], "source_codes": ["def second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    # Handle edge cases\n    if len(numbers) < 2:\n        return None\n    \n    # Initialize smallest and second smallest\n    smallest = float('inf')\n    second_smallest_val = float('inf')\n    \n    # Iterate through the list\n    for num in numbers:\n        if num < smallest:\n            second_smallest_val = smallest\n            smallest = num\n        elif num < second_smallest_val and num != smallest:\n            second_smallest_val = num\n    \n    # If second_smallest_val was never updated, it means all elements are the same\n    if second_smallest_val == float('inf'):\n        return None\n    \n    return second_smallest_val"], "responses": ["\nfrom typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    # Handle edge cases\n    if len(numbers) < 2:\n        return None\n    \n    # Initialize smallest and second smallest\n    smallest = float('inf')\n    second_smallest_val = float('inf')\n    \n    # Iterate through the list\n    for num in numbers:\n        if num < smallest:\n            second_smallest_val = smallest\n            smallest = num\n        elif num < second_smallest_val and num != smallest:\n            second_smallest_val = num\n    \n    # If second_smallest_val was never updated, it means all elements are the same\n    if second_smallest_val == float('inf'):\n        return None\n    \n    return second_smallest_val\n\n\n"], "prompt_tokens": [1983], "completion_tokens": [1081], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_755_second_smallest"}
{"name": "mbpp_405_check_tuplex", "language": "Python3", "prompt": "from typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n\tWrite a function to check whether an element exists within a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_405_check_tuplex.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_tuplex", "test": "def check(candidate):\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], '5') == False\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 3) == True\n\ndef test_check():\n    check(check_tuplex)\n\ntest_check()\n", "sample_io": ["assert check_tuplex(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True"], "source_codes": ["def check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex"], "responses": ["\nfrom typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex\n\n\n"], "prompt_tokens": [1910], "completion_tokens": [867], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_405_check_tuplex"}
{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["def find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n (int): The dividend\n        m (int): The divisor\n        \n    Returns:\n        int: The quotient rounded down to the nearest integer\n        \n    Raises:\n        ZeroDivisionError: If m is zero\n    \"\"\"\n    return n // m"], "responses": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n (int): The dividend\n        m (int): The divisor\n        \n    Returns:\n        int: The quotient rounded down to the nearest integer\n        \n    Raises:\n        ZeroDivisionError: If m is zero\n    \"\"\"\n    return n // m\n\n\n"], "prompt_tokens": [1724], "completion_tokens": [828], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": ["def get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Initialize candidate list with numbers from 1 to n\n    candidates = list(range(1, n + 1))\n    ludic_numbers = []\n    \n    while candidates:\n        # Take the first element as the next ludic number\n        ludic = candidates[0]\n        ludic_numbers.append(ludic)\n        \n        # If this is the last element, we're done\n        if len(candidates) == 1:\n            break\n            \n        # Remove every kth element where k is the ludic number just found\n        # We start counting from the second element (index 1)\n        new_candidates = []\n        for i in range(1, len(candidates)):  # Start from index 1\n            # Convert to 1-based position relative to the start of remaining elements\n            position = i  # This is already 1-based since we start from index 1\n            if position % ludic != 0:  # Keep elements whose position is not divisible by ludic\n                new_candidates.append(candidates[i])\n        \n        candidates = new_candidates\n    \n    return ludic_numbers"], "responses": ["\nfrom typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Initialize candidate list with numbers from 1 to n\n    candidates = list(range(1, n + 1))\n    ludic_numbers = []\n    \n    while candidates:\n        # Take the first element as the next ludic number\n        ludic = candidates[0]\n        ludic_numbers.append(ludic)\n        \n        # If this is the last element, we're done\n        if len(candidates) == 1:\n            break\n            \n        # Remove every kth element where k is the ludic number just found\n        # We start counting from the second element (index 1)\n        new_candidates = []\n        for i in range(1, len(candidates)):  # Start from index 1\n            # Convert to 1-based position relative to the start of remaining elements\n            position = i  # This is already 1-based since we start from index 1\n            if position % ludic != 0:  # Keep elements whose position is not divisible by ludic\n                new_candidates.append(candidates[i])\n        \n        candidates = new_candidates\n    \n    return ludic_numbers\n\n\n"], "prompt_tokens": [6449], "completion_tokens": [6809], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["def sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Contribution of arr[i] is arr[i] multiplied by the number of subarrays\n        # that include arr[i], which is (i+1) * (n-i)\n        contribution = arr[i] * (i + 1) * (n - i)\n        total_sum += contribution\n    \n    return total_sum"], "responses": ["\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        # Contribution of arr[i] is arr[i] multiplied by the number of subarrays\n        # that include arr[i], which is (i+1) * (n-i)\n        contribution = arr[i] * (i + 1) * (n - i)\n        total_sum += contribution\n    \n    return total_sum\n\n\n"], "prompt_tokens": [2223], "completion_tokens": [1728], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["import re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    # Find all substrings enclosed in double quotes\n    # This pattern handles escaped quotes within quoted strings\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*))\"'\n    matches = re.findall(pattern, text)\n    return matches"], "responses": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    # Find all substrings enclosed in double quotes\n    # This pattern handles escaped quotes within quoted strings\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*))\"'\n    matches = re.findall(pattern, text)\n    return matches\n\n\n"], "prompt_tokens": [5355], "completion_tokens": [2066], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": ["def issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(list1) <= 1:\n        return True\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(list1)):\n        # Compare current element with previous element\n        # If current element is smaller than previous, list is not sorted\n        if list1[i] < list1[i-1]:\n            return False\n    \n    # If we've gone through the entire list without finding violations, it's sorted\n    return True"], "responses": ["\nfrom typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(list1) <= 1:\n        return True\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(list1)):\n        # Compare current element with previous element\n        # If current element is smaller than previous, list is not sorted\n        if list1[i] < list1[i-1]:\n            return False\n    \n    # If we've gone through the entire list without finding violations, it's sorted\n    return True\n\n\n"], "prompt_tokens": [1837], "completion_tokens": [916], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["def sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)"], "responses": ["\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n\n"], "prompt_tokens": [3749], "completion_tokens": [1273], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["def recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    # Base case: empty list\n    if not data_list:\n        return 0\n    \n    # Initialize sum\n    total = 0\n    \n    # Iterate through each element\n    for element in data_list:\n        if isinstance(element, int):\n            # Base case: element is an integer\n            total += element\n        elif isinstance(element, list):\n            # Recursive case: element is a list\n            total += recursive_list_sum(element)\n    \n    return total"], "responses": ["\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Write a function to flatten a list and sum all of its elements.\n    \"\"\"\n    # Base case: empty list\n    if not data_list:\n        return 0\n    \n    # Initialize sum\n    total = 0\n    \n    # Iterate through each element\n    for element in data_list:\n        if isinstance(element, int):\n            # Base case: element is an integer\n            total += element\n        elif isinstance(element, list):\n            # Recursive case: element is a list\n            total += recursive_list_sum(element)\n    \n    return total\n\n\n"], "prompt_tokens": [1780], "completion_tokens": [944], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["def union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    # Convert lists to sets to eliminate duplicates within each list\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation to combine all unique elements\n    union_set = set1.union(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    result = sorted(list(union_set))\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    # Convert lists to sets to eliminate duplicates within each list\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation to combine all unique elements\n    union_set = set1.union(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "prompt_tokens": [2165], "completion_tokens": [1196], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["import re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Check if string is empty\n    if not string:\n        return False\n    \n    # Define regex pattern for vowels (both lowercase and uppercase)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.search to check if pattern matches at the beginning of the string\n    return bool(re.search(pattern, string))"], "responses": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Check if string is empty\n    if not string:\n        return False\n    \n    # Define regex pattern for vowels (both lowercase and uppercase)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.search to check if pattern matches at the beginning of the string\n    return bool(re.search(pattern, string))\n\n\n"], "prompt_tokens": [1656], "completion_tokens": [834], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": ["def triangle_area(r: int) -> Optional[int]:\n    if r <= 0:\n        return None\n    # The largest triangle inscribed in a semicircle has:\n    # - Base = diameter of the semicircle = 2 * r\n    # - Height = radius of the semicircle = r\n    # Area = (1/2) * base * height = (1/2) * (2 * r) * r = r^2\n    return r * r"], "responses": ["\ndef triangle_area(r: int) -> Optional[int]:\n    if r <= 0:\n        return None\n    # The largest triangle inscribed in a semicircle has:\n    # - Base = diameter of the semicircle = 2 * r\n    # - Height = radius of the semicircle = r\n    # Area = (1/2) * base * height = (1/2) * (2 * r) * r = r^2\n    return r * r\n\n\n"], "prompt_tokens": [1657], "completion_tokens": [851], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["def count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count"], "responses": ["\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1776], "completion_tokens": [1062], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["def max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    global_max = arr[0]\n    \n    for i in range(1, len(arr)):\n        # Store the current max_ending_here temporarily\n        temp_max = max(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        min_ending_here = min(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        max_ending_here = temp_max\n        \n        global_max = max(global_max, max_ending_here)\n    \n    return global_max"], "responses": ["\nfrom typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    global_max = arr[0]\n    \n    for i in range(1, len(arr)):\n        # Store the current max_ending_here temporarily\n        temp_max = max(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        min_ending_here = min(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        max_ending_here = temp_max\n        \n        global_max = max(global_max, max_ending_here)\n    \n    return global_max\n\n\n"], "prompt_tokens": [2502], "completion_tokens": [1618], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["def is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Handle edge case of empty array\n    if n == 0:\n        return False\n    \n    # Binary search for first occurrence of x\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        first_index = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_index = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return first_index\n    \n    # Binary search for last occurrence of x\n    def find_last_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        last_index = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_index = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return last_index\n    \n    # Find first and last occurrences\n    first_index = find_first_occurrence(arr, x)\n    \n    # If element is not found, it cannot be majority\n    if first_index == -1:\n        return False\n    \n    last_index = find_last_occurrence(arr, x)\n    \n    # Calculate count of x\n    count = last_index - first_index + 1\n    \n    # Check if count is greater than n/2\n    return count > n / 2"], "responses": ["\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Handle edge case of empty array\n    if n == 0:\n        return False\n    \n    # Binary search for first occurrence of x\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        first_index = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_index = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return first_index\n    \n    # Binary search for last occurrence of x\n    def find_last_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        last_index = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_index = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return last_index\n    \n    # Find first and last occurrences\n    first_index = find_first_occurrence(arr, x)\n    \n    # If element is not found, it cannot be majority\n    if first_index == -1:\n        return False\n    \n    last_index = find_last_occurrence(arr, x)\n    \n    # Calculate count of x\n    count = last_index - first_index + 1\n    \n    # Check if count is greater than n/2\n    return count > n / 2\n\n\n"], "prompt_tokens": [2586], "completion_tokens": [1645], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": ["import re\n\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Pattern: ^a.*b$\n    # ^ - start of string\n    # a - literal 'a'\n    # .* - zero or more of any character\n    # b - literal 'b'\n    # $ - end of string\n    pattern = r'^a.*b$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, text))"], "responses": ["\nimport re\n\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Pattern: ^a.*b$\n    # ^ - start of string\n    # a - literal 'a'\n    # .* - zero or more of any character\n    # b - literal 'b'\n    # $ - end of string\n    pattern = r'^a.*b$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, text))\n\n\n"], "prompt_tokens": [1774], "completion_tokens": [870], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["def word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1"], "responses": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "prompt_tokens": [1435], "completion_tokens": [630], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["def add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]"], "responses": ["\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n\n\n"], "prompt_tokens": [2026], "completion_tokens": [1184], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["def all_Characters_Same(s: str) -> bool:\n    # Handle edge cases\n    if len(s) <= 1:\n        return True\n    \n    # Select the first character as reference\n    reference_char = s[0]\n    \n    # Iterate through each character starting from index 1\n    for i in range(1, len(s)):\n        # If any character doesn't match the reference, return False\n        if s[i] != reference_char:\n            return False\n    \n    # If all characters match, return True\n    return True"], "responses": ["\ndef all_Characters_Same(s: str) -> bool:\n    # Handle edge cases\n    if len(s) <= 1:\n        return True\n    \n    # Select the first character as reference\n    reference_char = s[0]\n    \n    # Iterate through each character starting from index 1\n    for i in range(1, len(s)):\n        # If any character doesn't match the reference, return False\n        if s[i] != reference_char:\n            return False\n    \n    # If all characters match, return True\n    return True\n\n\n"], "prompt_tokens": [1587], "completion_tokens": [944], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": ["def odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    # Iterate through odd indices only\n    for i in range(1, len(nums), 2):\n        # If any number at an odd index is even, return False\n        if nums[i] % 2 == 0:\n            return False\n    \n    # If we've checked all odd indices and found no even numbers, return True\n    return True"], "responses": ["\nfrom typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    # Iterate through odd indices only\n    for i in range(1, len(nums), 2):\n        # If any number at an odd index is even, return False\n        if nums[i] % 2 == 0:\n            return False\n    \n    # If we've checked all odd indices and found no even numbers, return True\n    return True\n\n\n"], "prompt_tokens": [2089], "completion_tokens": [1104], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["def reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    # Handle edge cases\n    if not input or k == 0:\n        return input\n    \n    # Adjust k to not exceed array length\n    k = min(k, len(input))\n    \n    # Reverse the first k elements and concatenate with the rest\n    return input[:k][::-1] + input[k:]"], "responses": ["\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    # Handle edge cases\n    if not input or k == 0:\n        return input\n    \n    # Adjust k to not exceed array length\n    k = min(k, len(input))\n    \n    # Reverse the first k elements and concatenate with the rest\n    return input[:k][::-1] + input[k:]\n\n\n"], "prompt_tokens": [2052], "completion_tokens": [1051], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["def big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)"], "responses": ["\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)\n\n\n"], "prompt_tokens": [1716], "completion_tokens": [998], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["def flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    result = []\n    for item in list1:\n        if isinstance(item, int):\n            result.append(item)\n        else:\n            result.extend(flatten_list(item))\n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    result = []\n    for item in list1:\n        if isinstance(item, int):\n            result.append(item)\n        else:\n            result.extend(flatten_list(item))\n    return result\n\n\n"], "prompt_tokens": [5583], "completion_tokens": [2405], "no_of_try": 1, "api_calls": 10, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["def index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    # Get dimensions\n    rows = len(test_tup1)\n    cols = len(test_tup1[0])\n    \n    # Initialize result matrix\n    result = []\n    \n    # Perform element-wise multiplication\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row.append(product)\n        result.append(row)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    # Get dimensions\n    rows = len(test_tup1)\n    cols = len(test_tup1[0])\n    \n    # Initialize result matrix\n    result = []\n    \n    # Perform element-wise multiplication\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row.append(product)\n        result.append(row)\n    \n    return result\n\n\n"], "prompt_tokens": [2041], "completion_tokens": [1268], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as True. A value in prime[i] will\n    # finally be False if i is not a prime, else True.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count"], "responses": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as True. A value in prime[i] will\n    # finally be False if i is not a prime, else True.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1829], "completion_tokens": [1110], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["def sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n        \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle invalid range where m > n\n    if m > n:\n        return 0\n    \n    # Adjust negative indices\n    if m < 0:\n        m = max(0, len(list1) + m)\n    if n < 0:\n        n = len(list1) + n\n    \n    # Ensure indices are within valid range\n    m = max(0, m)\n    n = min(len(list1) - 1, n)\n    \n    # If m is now greater than n after adjustment, return 0\n    if m > n:\n        return 0\n    \n    # Calculate sum of the sublist\n    return sum(list1[m:n+1])"], "responses": ["\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n        \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    # Handle invalid range where m > n\n    if m > n:\n        return 0\n    \n    # Adjust negative indices\n    if m < 0:\n        m = max(0, len(list1) + m)\n    if n < 0:\n        n = len(list1) + n\n    \n    # Ensure indices are within valid range\n    m = max(0, m)\n    n = min(len(list1) - 1, n)\n    \n    # If m is now greater than n after adjustment, return 0\n    if m > n:\n        return 0\n    \n    # Calculate sum of the sublist\n    return sum(list1[m:n+1])\n\n\n"], "prompt_tokens": [1996], "completion_tokens": [1384], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": ["def comb_sort(nums: List[int]) -> List[int]:\n    if len(nums) <= 1:\n        return nums\n    \n    gap = len(nums)\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Update gap\n        gap = max(1, int(gap / shrink_factor))\n        \n        # Perform a single \"comb\" pass with the current gap\n        swapped = False\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n                \n        # If gap is 1 and no swaps occurred, we're done\n        if gap == 1 and not swapped:\n            break\n            \n    return nums"], "responses": ["\nfrom typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    if len(nums) <= 1:\n        return nums\n    \n    gap = len(nums)\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Update gap\n        gap = max(1, int(gap / shrink_factor))\n        \n        # Perform a single \"comb\" pass with the current gap\n        swapped = False\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n                \n        # If gap is 1 and no swaps occurred, we're done\n        if gap == 1 and not swapped:\n            break\n            \n    return nums\n\n\n"], "prompt_tokens": [2348], "completion_tokens": [1444], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())"], "responses": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return ''.join(text1.split())\n\n\n"], "prompt_tokens": [1620], "completion_tokens": [868], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    # Handle edge cases where any string is empty\n    if not X or not Y or not Z:\n        return 0\n    \n    # Get lengths of the three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Initialize a 3D DP table with zeros\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take the maximum of the three possible subsequences\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude character from X\n                        dp[i][j-1][k],    # Exclude character from Y\n                        dp[i][j][k-1]     # Exclude character from Z\n                    )\n    \n    # Return the length of the longest common subsequence\n    return dp[m][n][o]"], "responses": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    # Handle edge cases where any string is empty\n    if not X or not Y or not Z:\n        return 0\n    \n    # Get lengths of the three strings\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Initialize a 3D DP table with zeros\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                # If all three characters match\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    # Take the maximum of the three possible subsequences\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],    # Exclude character from X\n                        dp[i][j-1][k],    # Exclude character from Y\n                        dp[i][j][k-1]     # Exclude character from Z\n                    )\n    \n    # Return the length of the longest common subsequence\n    return dp[m][n][o]\n\n\n"], "prompt_tokens": [2269], "completion_tokens": [1360], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": ["def swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]"], "responses": ["\nfrom typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "prompt_tokens": [1748], "completion_tokens": [778], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["def subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])"], "responses": ["\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "prompt_tokens": [2246], "completion_tokens": [1099], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["def tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    # Convert each integer to string and concatenate them\n    concatenated_str = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated_str)"], "responses": ["\nfrom typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    # Convert each integer to string and concatenate them\n    concatenated_str = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated_str)\n\n\n"], "prompt_tokens": [1697], "completion_tokens": [788], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["def first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (positive or negative)\n        \n    Returns:\n        The first digit of the absolute value of n\n    \"\"\"\n    # Handle the edge case where input is 0\n    if n == 0:\n        return 0\n    \n    # Take absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Convert to string and get the first character\n    first_char = str(abs_n)[0]\n    \n    # Convert back to integer and return\n    return int(first_char)"], "responses": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (positive or negative)\n        \n    Returns:\n        The first digit of the absolute value of n\n    \"\"\"\n    # Handle the edge case where input is 0\n    if n == 0:\n        return 0\n    \n    # Take absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Convert to string and get the first character\n    first_char = str(abs_n)[0]\n    \n    # Convert back to integer and return\n    return int(first_char)\n\n\n"], "prompt_tokens": [1528], "completion_tokens": [814], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["def string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()"], "responses": ["\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()\n\n\n"], "prompt_tokens": [1600], "completion_tokens": [658], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": ["def find_min_diff(arr: List[int], n: int) -> int:\n    # Handle edge cases\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to bring closest elements together\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Compare adjacent elements to find minimum difference\n    for i in range(n - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff"], "responses": ["\nfrom typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    # Handle edge cases\n    if n < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to bring closest elements together\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Compare adjacent elements to find minimum difference\n    for i in range(n - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "prompt_tokens": [2272], "completion_tokens": [1335], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["import heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    # Handle edge cases\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Initialize heap with the smallest possible sum\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Keep track of visited indices to avoid duplicates\n    visited = set()\n    visited.add((0, 0))\n    \n    result = []\n    \n    while k > 0 and heap:\n        # Pop the smallest sum from heap\n        current_sum, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n            \n        k -= 1\n    \n    return result"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    # Handle edge cases\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Initialize heap with the smallest possible sum\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Keep track of visited indices to avoid duplicates\n    visited = set()\n    visited.add((0, 0))\n    \n    result = []\n    \n    while k > 0 and heap:\n        # Pop the smallest sum from heap\n        current_sum, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n            \n        k -= 1\n    \n    return result\n\n\n"], "prompt_tokens": [2522], "completion_tokens": [1505], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["def capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return \"\"\n    \n    result = str1[0]\n    \n    for i in range(1, len(str1)):\n        if str1[i].isupper():\n            result += \" \" + str1[i]\n        else:\n            result += str1[i]\n    \n    return result"], "responses": ["\ndef capital_words_spaces(str1: str) -> str:\n    if not str1:\n        return \"\"\n    \n    result = str1[0]\n    \n    for i in range(1, len(str1)):\n        if str1[i].isupper():\n            result += \" \" + str1[i]\n        else:\n            result += str1[i]\n    \n    return result\n\n\n"], "prompt_tokens": [1650], "completion_tokens": [955], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": ["import cmath\nfrom typing import Tuple\n\ndef convert(numbers: complex) -> Tuple[float, float]:\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    \n    Args:\n        numbers: A complex number\n        \n    Returns:\n        A tuple containing (modulus, phase) where:\n        - modulus is the distance from origin (r = |z|)\n        - phase is the angle in radians (\u03b8 = arg(z))\n    \"\"\"\n    # Calculate modulus (r) - distance from origin\n    modulus = abs(numbers)\n    \n    # Calculate phase (theta) - angle in radians\n    phase = cmath.phase(numbers)\n    \n    return (float(modulus), float(phase))"], "responses": ["\nimport cmath\nfrom typing import Tuple\n\ndef convert(numbers: complex) -> Tuple[float, float]:\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    \n    Args:\n        numbers: A complex number\n        \n    Returns:\n        A tuple containing (modulus, phase) where:\n        - modulus is the distance from origin (r = |z|)\n        - phase is the angle in radians (\u03b8 = arg(z))\n    \"\"\"\n    # Calculate modulus (r) - distance from origin\n    modulus = abs(numbers)\n    \n    # Calculate phase (theta) - angle in radians\n    phase = cmath.phase(numbers)\n    \n    return (float(modulus), float(phase))\n\n\n"], "prompt_tokens": [2364], "completion_tokens": [1421], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_252_convert"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["def neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]"], "responses": ["\nfrom typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n\n\n"], "prompt_tokens": [1627], "completion_tokens": [886], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n        \n    Returns:\n        float: The median value of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))"], "responses": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n        \n    Returns:\n        float: The median value of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))\n\n\n"], "prompt_tokens": [2067], "completion_tokens": [1080], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["def combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    if not list1:\n        return [[]]\n    \n    result = []\n    n = len(list1)\n    \n    # Generate all combinations using bit manipulation\n    for i in range(2**n):\n        combination = []\n        for j in range(n):\n            # Check if the j-th bit is set in i (from left to right)\n            if i & (1 << (n-1-j)):\n                combination.append(list1[n-1-j])\n        result.append(combination)\n    \n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    if not list1:\n        return [[]]\n    \n    result = []\n    n = len(list1)\n    \n    # Generate all combinations using bit manipulation\n    for i in range(2**n):\n        combination = []\n        for j in range(n):\n            # Check if the j-th bit is set in i (from left to right)\n            if i & (1 << (n-1-j)):\n                combination.append(list1[n-1-j])\n        result.append(combination)\n    \n    return result\n\n\n"], "prompt_tokens": [4216], "completion_tokens": [2061], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": ["def divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        \n        # Skip numbers containing '0'\n        if '0' in str_num:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in str_num:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n                \n        if valid:\n            result.append(num)\n            \n    return result"], "responses": ["\nfrom typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        str_num = str(num)\n        \n        # Skip numbers containing '0'\n        if '0' in str_num:\n            continue\n            \n        # Check if number is divisible by each of its digits\n        valid = True\n        for digit_char in str_num:\n            digit = int(digit_char)\n            if num % digit != 0:\n                valid = False\n                break\n                \n        if valid:\n            result.append(num)\n            \n    return result\n\n\n"], "prompt_tokens": [2414], "completion_tokens": [1535], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["def Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n    return [num for num in list if num % 2 != 0]"], "responses": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "prompt_tokens": [1690], "completion_tokens": [785], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["def long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Handle empty string case\n    if not str:\n        return []\n    \n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Handle empty string case\n    if not str:\n        return []\n    \n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result\n\n\n"], "prompt_tokens": [1700], "completion_tokens": [836], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["def is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge cases\n    if not s:  # Empty sublist is always contained\n        return True\n    if not l:  # Empty main list cannot contain non-empty sublist\n        return False\n    if len(s) > len(l):  # Sublist longer than main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if sublist matches at this position\n        if l[i:i+len(s)] == s:\n            return True\n    \n    # No match found\n    return False"], "responses": ["\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge cases\n    if not s:  # Empty sublist is always contained\n        return True\n    if not l:  # Empty main list cannot contain non-empty sublist\n        return False\n    if len(s) > len(l):  # Sublist longer than main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if sublist matches at this position\n        if l[i:i+len(s)] == s:\n            return True\n    \n    # No match found\n    return False\n\n\n"], "prompt_tokens": [2150], "completion_tokens": [1125], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": ["def common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    # Handle edge cases where either list is empty\n    if not list1 or not list2:\n        return None\n    \n    # Convert the smaller list to a set for O(1) lookups\n    if len(list1) <= len(list2):\n        smaller_set = set(list1)\n        larger_list = list2\n    else:\n        smaller_set = set(list2)\n        larger_list = list1\n    \n    # Check if any element in the larger list exists in the smaller set\n    for element in larger_list:\n        if element in smaller_set:\n            return True\n    \n    # No common elements found\n    return None"], "responses": ["\nfrom typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    # Handle edge cases where either list is empty\n    if not list1 or not list2:\n        return None\n    \n    # Convert the smaller list to a set for O(1) lookups\n    if len(list1) <= len(list2):\n        smaller_set = set(list1)\n        larger_list = list2\n    else:\n        smaller_set = set(list2)\n        larger_list = list1\n    \n    # Check if any element in the larger list exists in the smaller set\n    for element in larger_list:\n        if element in smaller_set:\n            return True\n    \n    # No common elements found\n    return None\n\n\n"], "prompt_tokens": [2107], "completion_tokens": [1091], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["import re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)"], "responses": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "prompt_tokens": [1525], "completion_tokens": [798], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": ["def pancake_sort(nums: List[int]) -> List[int]:\n    if len(nums) <= 1:\n        return nums[:]\n    \n    # Work with a copy to avoid modifying the original\n    arr = nums[:]\n    n = len(arr)\n    \n    for i in range(n-1, 0, -1):\n        # Find the index of the maximum element in arr[0:i+1]\n        max_idx = 0\n        for j in range(1, i+1):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        \n        # If max element is already in place, continue\n        if max_idx == i:\n            continue\n            \n        # If max element is not at the beginning, flip to bring it to the front\n        if max_idx != 0:\n            arr[:max_idx+1] = arr[:max_idx+1][::-1]\n        \n        # Flip to move the max element to its correct position\n        arr[:i+1] = arr[:i+1][::-1]\n    \n    return arr"], "responses": ["\nfrom typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    if len(nums) <= 1:\n        return nums[:]\n    \n    # Work with a copy to avoid modifying the original\n    arr = nums[:]\n    n = len(arr)\n    \n    for i in range(n-1, 0, -1):\n        # Find the index of the maximum element in arr[0:i+1]\n        max_idx = 0\n        for j in range(1, i+1):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        \n        # If max element is already in place, continue\n        if max_idx == i:\n            continue\n            \n        # If max element is not at the beginning, flip to bring it to the front\n        if max_idx != 0:\n            arr[:max_idx+1] = arr[:max_idx+1][::-1]\n        \n        # Flip to move the max element to its correct position\n        arr[:i+1] = arr[:i+1][::-1]\n    \n    return arr\n\n\n"], "prompt_tokens": [5197], "completion_tokens": [3251], "no_of_try": 1, "api_calls": 8, "is_solved": true, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["import heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # If N is greater than the number of products, adjust N\n    N = min(N, len(products))\n    \n    # Find the N largest products using heapq.nlargest for efficiency\n    return heapq.nlargest(N, products)"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # If N is greater than the number of products, adjust N\n    N = min(N, len(products))\n    \n    # Find the N largest products using heapq.nlargest for efficiency\n    return heapq.nlargest(N, products)\n\n\n"], "prompt_tokens": [2347], "completion_tokens": [1278], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 571: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["def add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    # Convert tuple to list and concatenate with the input list\n    combined = list(test_tup) + test_list\n    \n    # Pad with zeros if the result has fewer than 5 elements\n    while len(combined) < 5:\n        combined.append(0)\n    \n    # Truncate if the result has more than 5 elements\n    if len(combined) > 5:\n        combined = combined[:5]\n    \n    # Convert back to tuple and return\n    return tuple(combined)"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    # Convert tuple to list and concatenate with the input list\n    combined = list(test_tup) + test_list\n    \n    # Pad with zeros if the result has fewer than 5 elements\n    while len(combined) < 5:\n        combined.append(0)\n    \n    # Truncate if the result has more than 5 elements\n    if len(combined) > 5:\n        combined = combined[:5]\n    \n    # Convert back to tuple and return\n    return tuple(combined)\n\n\n"], "prompt_tokens": [2010], "completion_tokens": [1282], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["def add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)\n\n\n"], "prompt_tokens": [2135], "completion_tokens": [999], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
{"name": "mbpp_395_first_non_repeating_character", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first non-repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_non_repeating_character", "test": "def check(candidate):\n    assert candidate('abcabc') == None\n    assert candidate('abc') == 'a'\n    assert candidate('ababc') == 'c'\n\ndef test_check():\n    check(first_non_repeating_character)\n\ntest_check()\n", "sample_io": ["assert first_non_repeating_character('abcabc') == None"], "source_codes": ["def first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with frequency 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # No non-repeating character found\n    return None"], "responses": ["\nfrom typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with frequency 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # No non-repeating character found\n    return None\n\n\n"], "prompt_tokens": [1866], "completion_tokens": [1039], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_395_first_non_repeating_character"}
