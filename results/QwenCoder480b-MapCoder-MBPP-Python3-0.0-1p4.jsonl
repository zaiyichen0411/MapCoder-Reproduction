{"name": "mbpp_457_Find_Min", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min", "test": "def check(candidate):\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert candidate([[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1]\n    assert candidate([['x'], ['x', 'y'], ['x', 'y', 'z']]) == ['x']\n\ndef test_check():\n    check(Find_Min)\n\ntest_check()\n", "sample_io": ["assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"], "source_codes": ["def Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_length = len(lst[0])\n    min_sublist = lst[0]\n    \n    for sublist in lst[1:]:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist"], "responses": ["\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_length = len(lst[0])\n    min_sublist = lst[0]\n    \n    for sublist in lst[1:]:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n\n\n"], "prompt_tokens": [1850], "completion_tokens": [1070], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_457_Find_Min"}
{"name": "mbpp_725_extract_quotation", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks \" \" of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_quotation", "test": "def check(candidate):\n    assert candidate('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    assert candidate('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']\n    assert candidate('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']\n    assert candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == []\n\ndef test_check():\n    check(extract_quotation)\n\ntest_check()\n", "sample_io": ["assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"], "source_codes": ["import re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Pattern to match text between double quotes, including empty quotes\n    # This will match everything between the first \" and the next \"\n    pattern = r'\"([^\"]*)\"'\n    \n    # Find all matches and return the captured groups\n    matches = re.findall(pattern, text1)\n    \n    return matches"], "responses": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Pattern to match text between double quotes, including empty quotes\n    # This will match everything between the first \" and the next \"\n    pattern = r'\"([^\"]*)\"'\n    \n    # Find all matches and return the captured groups\n    matches = re.findall(pattern, text1)\n    \n    return matches\n\n\n"], "prompt_tokens": [1576], "completion_tokens": [973], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_725_extract_quotation"}
{"name": "mbpp_9_find_Rotations", "language": "Python3", "prompt": "def find_Rotations(str: str) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Rotations", "test": "def check(candidate):\n    assert candidate('aaaa') == 1\n    assert candidate('ab') == 2\n    assert candidate('abc') == 3\n\ndef test_check():\n    check(find_Rotations)\n\ntest_check()\n", "sample_io": ["assert find_Rotations('aaaa') == 1"], "source_codes": ["def find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Check for each possible rotation from 1 to n\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        \n        # If rotated string equals original string, return the rotation count\n        if rotated == str:\n            return i\n    \n    # If no rotation matches (shouldn't happen for valid input), return n\n    return n"], "responses": ["\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Check for each possible rotation from 1 to n\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        \n        # If rotated string equals original string, return the rotation count\n        if rotated == str:\n            return i\n    \n    # If no rotation matches (shouldn't happen for valid input), return n\n    return n\n\n\n"], "prompt_tokens": [1841], "completion_tokens": [1256], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_9_find_Rotations"}
{"name": "mbpp_792_count_list", "language": "Python3", "prompt": "from typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of lists in a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    assert candidate([[1, 2], [2, 3], [4, 5]]) == 3\n    assert candidate([[1, 0], [2, 0]]) == 2\n\ndef test_check():\n    check(count_list)\n\ntest_check()\n", "sample_io": ["assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"], "source_codes": ["def count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)"], "responses": ["\nfrom typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)\n\n\n"], "prompt_tokens": [1660], "completion_tokens": [759], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_792_count_list"}
{"name": "mbpp_477_is_lower", "language": "Python3", "prompt": "def is_lower(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert the given string to lower case.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_lower", "test": "def check(candidate):\n    assert candidate('InValid') == 'invalid'\n    assert candidate('TruE') == 'true'\n    assert candidate('SenTenCE') == 'sentence'\n\ndef test_check():\n    check(is_lower)\n\ntest_check()\n", "sample_io": ["assert is_lower('InValid') == 'invalid'"], "source_codes": ["def is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()"], "responses": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "prompt_tokens": [1544], "completion_tokens": [666], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_477_is_lower"}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "Python3", "prompt": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n\tWrite a python function to find the average of cubes of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Average_Of_Cube", "test": "def check(candidate):\n    assert candidate(2) == 4.5\n    assert candidate(3) == 12\n    assert candidate(1) == 1\n\ndef test_check():\n    check(find_Average_Of_Cube)\n\ntest_check()\n", "sample_io": ["assert find_Average_Of_Cube(2) == 4.5"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 193: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_422_find_Average_Of_Cube"}
{"name": "mbpp_637_noprofit_noloss", "language": "Python3", "prompt": "def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given amount has no profit and no loss\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "noprofit_noloss", "test": "def check(candidate):\n    assert candidate(1500, 1200) == False\n    assert candidate(100, 100) == True\n    assert candidate(2000, 5000) == False\n\ndef test_check():\n    check(noprofit_noloss)\n\ntest_check()\n", "sample_io": ["assert noprofit_noloss(1500, 1200) == False"], "source_codes": ["def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount"], "responses": ["\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n\n\n"], "prompt_tokens": [1428], "completion_tokens": [809], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_637_noprofit_noloss"}
{"name": "mbpp_557_toggle_string", "language": "Python3", "prompt": "def toggle_string(string: str) -> str:\n    \"\"\"\n\tWrite a function to toggle the case of all characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_string", "test": "def check(candidate):\n    assert candidate('Python') == 'pYTHON'\n    assert candidate('Pangram') == 'pANGRAM'\n    assert candidate('LIttLE') == 'liTTle'\n\ndef test_check():\n    check(toggle_string)\n\ntest_check()\n", "sample_io": ["assert toggle_string('Python') == 'pYTHON'"], "source_codes": ["def toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not string:\n        return \"\"\n    \n    # Initialize list to store toggled characters\n    result = []\n    \n    # Iterate through each character in the string\n    for char in string:\n        # If uppercase, convert to lowercase\n        if char.isupper():\n            result.append(char.lower())\n        # If lowercase, convert to uppercase\n        elif char.islower():\n            result.append(char.upper())\n        # If neither (numbers/symbols), keep unchanged\n        else:\n            result.append(char)\n    \n    # Join all characters into final string\n    return \"\".join(result)"], "responses": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not string:\n        return \"\"\n    \n    # Initialize list to store toggled characters\n    result = []\n    \n    # Iterate through each character in the string\n    for char in string:\n        # If uppercase, convert to lowercase\n        if char.isupper():\n            result.append(char.lower())\n        # If lowercase, convert to uppercase\n        elif char.islower():\n            result.append(char.upper())\n        # If neither (numbers/symbols), keep unchanged\n        else:\n            result.append(char)\n    \n    # Join all characters into final string\n    return \"\".join(result)\n\n\n"], "prompt_tokens": [1747], "completion_tokens": [979], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_557_toggle_string"}
{"name": "mbpp_786_right_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the right insertion point for a specified value in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "right_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(right_insertion)\n\ntest_check()\n", "sample_io": ["assert right_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["def right_insertion(a: List[int], x: int) -> int:\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"], "responses": ["\ndef right_insertion(a: List[int], x: int) -> int:\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "prompt_tokens": [1489], "completion_tokens": [906], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_786_right_insertion"}
{"name": "mbpp_807_first_odd", "language": "Python3", "prompt": "from typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the first odd number in a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5]) == 1\n    assert candidate([2, 4, 1, 3]) == 1\n    assert candidate([8, 9, 1]) == 9\n\ndef test_check():\n    check(first_odd)\n\ntest_check()\n", "sample_io": ["assert first_odd([1, 3, 5]) == 1"], "source_codes": ["def first_odd(nums: List[int]) -> Optional[int]:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list, or None if no odd number is found\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None"], "responses": ["\nfrom typing import List, Optional\n\ndef first_odd(nums: List[int]) -> Optional[int]:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list, or None if no odd number is found\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None\n\n\n"], "prompt_tokens": [1648], "completion_tokens": [926], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_807_first_odd"}
{"name": "mbpp_631_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace whitespaces with an underscore and vice versa in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert candidate('The_Avengers') == 'The Avengers'\n    assert candidate('Fast and Furious') == 'Fast_and_Furious'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"], "source_codes": ["def replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    # Count spaces and underscores\n    space_count = text.count(' ')\n    underscore_count = text.count('_')\n    \n    # If there are more spaces, replace spaces with underscores and vice versa\n    if space_count > underscore_count:\n        # Replace all whitespace characters (space, tab, newline, etc.) with underscores\n        result = text.replace(' ', '_')\n        return result\n    elif underscore_count > 0:\n        # Replace underscores with spaces\n        result = text.replace('_', ' ')\n        return result\n    else:\n        # If no spaces or underscores, return as is\n        return text"], "responses": ["\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    # Count spaces and underscores\n    space_count = text.count(' ')\n    underscore_count = text.count('_')\n    \n    # If there are more spaces, replace spaces with underscores and vice versa\n    if space_count > underscore_count:\n        # Replace all whitespace characters (space, tab, newline, etc.) with underscores\n        result = text.replace(' ', '_')\n        return result\n    elif underscore_count > 0:\n        # Replace underscores with spaces\n        result = text.replace('_', ' ')\n        return result\n    else:\n        # If no spaces or underscores, return as is\n        return text\n\n\n"], "prompt_tokens": [1631], "completion_tokens": [1007], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_631_replace_spaces"}
{"name": "mbpp_573_unique_product", "language": "Python3", "prompt": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to calculate the product of the unique numbers in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_product", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    assert candidate([1, 2, 3, 1]) == 6\n    assert candidate([7, 8, 9, 0, 1, 1]) == 0\n\ndef test_check():\n    check(unique_product)\n\ntest_check()\n", "sample_io": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"], "source_codes": ["def unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \n    Args:\n        list_data: A list of integers\n        \n    Returns:\n        The product of all unique numbers in the list\n    \"\"\"\n    # Handle edge case of empty list\n    if not list_data:\n        return 1\n    \n    # Convert to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product"], "responses": ["\nfrom typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \n    Args:\n        list_data: A list of integers\n        \n    Returns:\n        The product of all unique numbers in the list\n    \"\"\"\n    # Handle edge case of empty list\n    if not list_data:\n        return 1\n    \n    # Convert to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n\n\n"], "prompt_tokens": [1691], "completion_tokens": [902], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_573_unique_product"}
{"name": "mbpp_643_text_match_wordz_middle", "language": "Python3", "prompt": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks if a strings contains 'z', except at the start and end of the word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz_middle", "test": "def check(candidate):\n    assert candidate('pythonzabc.') == True\n    assert candidate('zxyabc.') == False\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz_middle)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz_middle('pythonzabc.') == True"], "source_codes": ["def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Handle edge cases: empty string or too short to have a middle\n    if len(text) < 3:\n        return False\n    \n    # Check characters from index 1 to len(text)-2 (excluding first and last)\n    for i in range(1, len(text) - 1):\n        if text[i] == 'z':\n            return True\n    \n    # No 'z' found in the middle portion\n    return False"], "responses": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Handle edge cases: empty string or too short to have a middle\n    if len(text) < 3:\n        return False\n    \n    # Check characters from index 1 to len(text)-2 (excluding first and last)\n    for i in range(1, len(text) - 1):\n        if text[i] == 'z':\n            return True\n    \n    # No 'z' found in the middle portion\n    return False\n\n\n"], "prompt_tokens": [1879], "completion_tokens": [919], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_643_text_match_wordz_middle"}
{"name": "mbpp_299_max_aggregate", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n\tWrite a function to calculate the maximum aggregate from the list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_aggregate", "test": "def check(candidate):\n    assert candidate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)\n    assert candidate([('Juan Whelan', 50), ('Sabah Colley', 48), ('Peter Nichols', 37), ('Juan Whelan', 22), ('Sabah Colley', 14)]) == ('Juan Whelan', 72)\n    assert candidate([('Juan Whelan', 10), ('Sabah Colley', 20), ('Peter Nichols', 30), ('Juan Whelan', 40), ('Sabah Colley', 50)]) == ('Sabah Colley', 70)\n\ndef test_check():\n    check(max_aggregate)\n\ntest_check()\n", "sample_io": ["assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"], "source_codes": ["def max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    if not stdata:\n        raise ValueError(\"Input list is empty\")\n    \n    # Create a dictionary to store aggregated sums\n    aggregates = {}\n    \n    # Calculate aggregates\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    # Find the key with maximum aggregate\n    max_key = max(aggregates, key=aggregates.get)\n    \n    return (max_key, aggregates[max_key])"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    if not stdata:\n        raise ValueError(\"Input list is empty\")\n    \n    # Create a dictionary to store aggregated sums\n    aggregates = {}\n    \n    # Calculate aggregates\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    # Find the key with maximum aggregate\n    max_key = max(aggregates, key=aggregates.get)\n    \n    return (max_key, aggregates[max_key])\n\n\n"], "prompt_tokens": [1864], "completion_tokens": [1119], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_299_max_aggregate"}
{"name": "mbpp_474_replace_char", "language": "Python3", "prompt": "def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n\tWrite a function to replace characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_char", "test": "def check(candidate):\n    assert candidate('polygon', 'y', 'l') == 'pollgon'\n    assert candidate('character', 'c', 'a') == 'aharaater'\n    assert candidate('python', 'l', 'a') == 'python'\n\ndef test_check():\n    check(replace_char)\n\ntest_check()\n", "sample_io": ["assert replace_char('polygon', 'y', 'l') == 'pollgon'"], "source_codes": ["def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return \"\"\n    \n    # Validate input parameters\n    if len(ch) != 1 or len(newch) != 1:\n        raise ValueError(\"ch and newch must be single characters\")\n    \n    # Build result string\n    result = \"\"\n    for char in str1:\n        if char == ch:\n            result += newch\n        else:\n            result += char\n    \n    return result"], "responses": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return \"\"\n    \n    # Validate input parameters\n    if len(ch) != 1 or len(newch) != 1:\n        raise ValueError(\"ch and newch must be single characters\")\n    \n    # Build result string\n    result = \"\"\n    for char in str1:\n        if char == ch:\n            result += newch\n        else:\n            result += char\n    \n    return result\n\n\n"], "prompt_tokens": [1712], "completion_tokens": [1005], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_474_replace_char"}
{"name": "mbpp_433_check_greater", "language": "Python3", "prompt": "from typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the entered number is greater than the elements of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_greater", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 4) == False\n    assert candidate([2, 3, 4, 5, 6], 8) == True\n    assert candidate([9, 7, 4, 8, 6, 1], 11) == True\n\ndef test_check():\n    check(check_greater)\n\ntest_check()\n", "sample_io": ["assert check_greater([1, 2, 3, 4, 5], 4) == False"], "source_codes": ["def check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: If array is empty, return True\n    if not arr:\n        return True\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the number is not greater than the current element, return False\n        if number <= element:\n            return False\n    \n    # If we've checked all elements and number was greater than all, return True\n    return True"], "responses": ["\nfrom typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: If array is empty, return True\n    if not arr:\n        return True\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the number is not greater than the current element, return False\n        if number <= element:\n            return False\n    \n    # If we've checked all elements and number was greater than all, return True\n    return True\n\n\n"], "prompt_tokens": [2037], "completion_tokens": [1070], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_433_check_greater"}
{"name": "mbpp_427_change_date_format", "language": "Python3", "prompt": "def change_date_format(dt: str) -> str:\n    \"\"\"\n\tWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "change_date_format", "test": "def check(candidate):\n    assert candidate('2026-01-02') == '02-01-2026'\n    assert candidate('2020-11-13') == '13-11-2020'\n    assert candidate('2021-04-26') == '26-04-2021'\n\ndef test_check():\n    check(change_date_format)\n\ntest_check()\n", "sample_io": ["assert change_date_format('2026-01-02') == '02-01-2026'"], "source_codes": ["import re\n\ndef change_date_format(dt: str) -> str:\n    # Validate input format using regex\n    if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', dt):\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    # Split the date string\n    parts = dt.split('-')\n    \n    # Ensure we have exactly 3 parts\n    if len(parts) != 3:\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    year, month, day = parts\n    \n    # Check lengths\n    if len(year) != 4 or len(month) != 2 or len(day) != 2:\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    # Reorder and join\n    return f\"{day}-{month}-{year}\""], "responses": ["\nimport re\n\ndef change_date_format(dt: str) -> str:\n    # Validate input format using regex\n    if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', dt):\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    # Split the date string\n    parts = dt.split('-')\n    \n    # Ensure we have exactly 3 parts\n    if len(parts) != 3:\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    year, month, day = parts\n    \n    # Check lengths\n    if len(year) != 4 or len(month) != 2 or len(day) != 2:\n        raise ValueError(\"Input must be in yyyy-mm-dd format\")\n    \n    # Reorder and join\n    return f\"{day}-{month}-{year}\"\n\n\n"], "prompt_tokens": [1852], "completion_tokens": [1208], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_427_change_date_format"}
{"name": "mbpp_442_positive_count", "language": "Python3", "prompt": "from typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n\tWrite a function to find the ration of positive numbers in an array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "positive_count", "test": "def check(candidate):\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54\n    assert candidate([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56\n\ndef test_check():\n    check(positive_count)\n\ntest_check()\n", "sample_io": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"], "source_codes": ["def positive_count(nums: List[int]) -> float:\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)"], "responses": ["\nfrom typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n\n\n"], "prompt_tokens": [5234], "completion_tokens": [2013], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_442_positive_count"}
{"name": "mbpp_453_sumofFactors", "language": "Python3", "prompt": "def sumofFactors(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even factors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sumofFactors", "test": "def check(candidate):\n    assert candidate(18) == 26\n    assert candidate(30) == 48\n    assert candidate(6) == 8\n\ndef test_check():\n    check(sumofFactors)\n\ntest_check()\n", "sample_io": ["assert sumofFactors(18) == 26"], "source_codes": ["def sumofFactors(n: int) -> int:\n    # Handle edge cases\n    if n <= 0 or n % 2 != 0:\n        return 0\n    \n    # Initialize sum of even factors\n    sum_even_factors = 0\n    \n    # Check all possible factors up to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            # If i is a factor\n            if i % 2 == 0:\n                sum_even_factors += i\n            \n            # Check the corresponding factor (n // i)\n            other_factor = n // i\n            if other_factor != i and other_factor % 2 == 0:\n                sum_even_factors += other_factor\n        \n        i += 1\n    \n    return sum_even_factors"], "responses": ["\ndef sumofFactors(n: int) -> int:\n    # Handle edge cases\n    if n <= 0 or n % 2 != 0:\n        return 0\n    \n    # Initialize sum of even factors\n    sum_even_factors = 0\n    \n    # Check all possible factors up to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            # If i is a factor\n            if i % 2 == 0:\n                sum_even_factors += i\n            \n            # Check the corresponding factor (n // i)\n            other_factor = n // i\n            if other_factor != i and other_factor % 2 == 0:\n                sum_even_factors += other_factor\n        \n        i += 1\n    \n    return sum_even_factors\n\n\n"], "prompt_tokens": [2005], "completion_tokens": [1424], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_453_sumofFactors"}
{"name": "mbpp_478_remove_lowercase", "language": "Python3", "prompt": "def remove_lowercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove lowercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_lowercase", "test": "def check(candidate):\n    assert candidate('PYTHon') == 'PYTH'\n    assert candidate('FInD') == 'FID'\n    assert candidate('STRinG') == 'STRG'\n\ndef test_check():\n    check(remove_lowercase)\n\ntest_check()\n", "sample_io": ["assert remove_lowercase('PYTHon') == 'PYTH'"], "source_codes": ["def remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())"], "responses": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())\n\n\n"], "prompt_tokens": [1628], "completion_tokens": [723], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_478_remove_lowercase"}
{"name": "mbpp_18_remove_dirty_chars", "language": "Python3", "prompt": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n\tWrite a function to remove characters from the first string which are present in the second string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_dirty_chars", "test": "def check(candidate):\n    assert candidate('probasscurve', 'pros') == 'bacuve'\n    assert candidate('digitalindia', 'talent') == 'digiidi'\n    assert candidate('exoticmiles', 'toxic') == 'emles'\n\ndef test_check():\n    check(remove_dirty_chars)\n\ntest_check()\n", "sample_io": ["assert remove_dirty_chars('probasscurve', 'pros') == 'bacuve'"], "source_codes": ["def remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Collect characters that are not in the removal set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    # Join the result list into a string and return\n    return ''.join(result)"], "responses": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Collect characters that are not in the removal set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    # Join the result list into a string and return\n    return ''.join(result)\n\n\n"], "prompt_tokens": [1783], "completion_tokens": [878], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_18_remove_dirty_chars"}
{"name": "mbpp_730_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function to remove consecutive duplicates of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd', 'a', 'a']) == ['a', 'b', 'c', 'd', 'a']\n\ndef test_check():\n    check(consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"], "source_codes": ["def consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    # Handle edge case: empty list\n    if not nums:\n        return []\n    \n    # Initialize result with first element\n    result = [nums[0]]\n    \n    # Iterate through remaining elements\n    for i in range(1, len(nums)):\n        # Add element to result if it's different from the last added element\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    # Handle edge case: empty list\n    if not nums:\n        return []\n    \n    # Initialize result with first element\n    result = [nums[0]]\n    \n    # Iterate through remaining elements\n    for i in range(1, len(nums)):\n        # Add element to result if it's different from the last added element\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    \n    return result\n\n\n"], "prompt_tokens": [1854], "completion_tokens": [1003], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_730_consecutive_duplicates"}
{"name": "mbpp_446_count_Occurrence", "language": "Python3", "prompt": "from typing import Any, List\n\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n\tWrite a python function to count the occurence of all elements of list in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Occurrence", "test": "def check(candidate):\n    assert candidate(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    assert candidate((1, 2, 3, 1, 4, 6, 7, 1, 4), [1, 4, 7]) == 6\n    assert candidate((1, 2, 3, 4, 5, 6), [1, 2]) == 2\n\ndef test_check():\n    check(count_Occurrence)\n\ntest_check()\n", "sample_io": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"], "source_codes": ["def count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n    \n    Args:\n        tup: A tuple to search in\n        lst: A list of elements to count in the tuple\n    \n    Returns:\n        int: Total count of all occurrences of list elements in the tuple\n    \"\"\"\n    # Initialize counter\n    total_count = 0\n    \n    # Handle edge case: empty tuple\n    if not tup:\n        return 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count occurrences of this element in the tuple and add to total\n        total_count += tup.count(element)\n    \n    return total_count"], "responses": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Count the occurrence of all elements of list in a tuple.\n    \n    Args:\n        tup: A tuple to search in\n        lst: A list of elements to count in the tuple\n    \n    Returns:\n        int: Total count of all occurrences of list elements in the tuple\n    \"\"\"\n    # Initialize counter\n    total_count = 0\n    \n    # Handle edge case: empty tuple\n    if not tup:\n        return 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count occurrences of this element in the tuple and add to total\n        total_count += tup.count(element)\n    \n    return total_count\n\n\n"], "prompt_tokens": [1925], "completion_tokens": [1043], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_446_count_Occurrence"}
{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["def remove_length(test_str: str, K: int) -> str:\n    # Handle edge case where input string is empty\n    if not test_str:\n        return \"\"\n    \n    # Split the input string into words\n    words = test_str.split()\n    \n    # Filter out words that have exactly K characters in length\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    result = \" \".join(filtered_words)\n    \n    return result"], "responses": ["\ndef remove_length(test_str: str, K: int) -> str:\n    # Handle edge case where input string is empty\n    if not test_str:\n        return \"\"\n    \n    # Split the input string into words\n    words = test_str.split()\n    \n    # Filter out words that have exactly K characters in length\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    result = \" \".join(filtered_words)\n    \n    return result\n\n\n"], "prompt_tokens": [1863], "completion_tokens": [1139], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"], "responses": ["\ndef jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "prompt_tokens": [2078], "completion_tokens": [1073], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["def max_Abs_Diff(arr: List[int]) -> int:\n    # Handle edge cases\n    if not arr or len(arr) <= 1:\n        return 0\n    \n    # Initialize min and max values with the first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # Update min_val if current element is smaller\n        if arr[i] < min_val:\n            min_val = arr[i]\n        # Update max_val if current element is larger\n        elif arr[i] > max_val:\n            max_val = arr[i]\n    \n    # Return the maximum absolute difference\n    return max_val - min_val"], "responses": ["\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    # Handle edge cases\n    if not arr or len(arr) <= 1:\n        return 0\n    \n    # Initialize min and max values with the first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # Update min_val if current element is smaller\n        if arr[i] < min_val:\n            min_val = arr[i]\n        # Update max_val if current element is larger\n        elif arr[i] > max_val:\n            max_val = arr[i]\n    \n    # Return the maximum absolute difference\n    return max_val - min_val\n\n\n"], "prompt_tokens": [1807], "completion_tokens": [980], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["def two_unique_nums(nums: List[int]) -> List[int]:\n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Return numbers that appear exactly once\n    return [num for num, freq in count.items() if freq == 1]"], "responses": ["\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Return numbers that appear exactly once\n    return [num for num, freq in count.items() if freq == 1]\n\n\n"], "prompt_tokens": [3689], "completion_tokens": [1445], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["def find_Odd_Pair(A: List[int], N: int) -> int:\n    # Handle edge cases\n    if N <= 1:\n        return 0\n    \n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with odd XOR is the product of even_count and odd_count\n    return even_count * odd_count"], "responses": ["\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    # Handle edge cases\n    if N <= 1:\n        return 0\n    \n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with odd XOR is the product of even_count and odd_count\n    return even_count * odd_count\n\n\n"], "prompt_tokens": [1997], "completion_tokens": [1087], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": ["def max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < 0 or k >= n or index >= k:\n        return 0\n    \n    # Initialize dp array to store maximum sum of increasing subsequence ending at each position\n    dp = [0] * (index + 1)\n    \n    # Fill the dp array\n    for i in range(index + 1):\n        # Only consider elements that can be part of a subsequence ending before k\n        if a[i] < a[k]:\n            dp[i] = a[i]\n            # Check all previous positions to extend the subsequence\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find the maximum sum among all valid subsequences\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    \n    # Add the kth element to the maximum sum\n    return max_sum + a[k]"], "responses": ["\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    if index < 0 or k >= n or index >= k:\n        return 0\n    \n    # Initialize dp array to store maximum sum of increasing subsequence ending at each position\n    dp = [0] * (index + 1)\n    \n    # Fill the dp array\n    for i in range(index + 1):\n        # Only consider elements that can be part of a subsequence ending before k\n        if a[i] < a[k]:\n            dp[i] = a[i]\n            # Check all previous positions to extend the subsequence\n            for j in range(i):\n                if a[j] < a[i]:\n                    dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find the maximum sum among all valid subsequences\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    \n    # Add the kth element to the maximum sum\n    return max_sum + a[k]\n\n\n"], "prompt_tokens": [3010], "completion_tokens": [2171], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    # Using bit manipulation approach\n    # Find the position of the most significant bit\n    result = 1\n    while result <= n:\n        result <<= 1  # Equivalent to result *= 2\n    \n    # Since we went one step too far, shift back\n    return result >> 1"], "responses": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    # Using bit manipulation approach\n    # Find the position of the most significant bit\n    result = 1\n    while result <= n:\n        result <<= 1  # Equivalent to result *= 2\n    \n    # Since we went one step too far, shift back\n    return result >> 1\n\n\n"], "prompt_tokens": [1853], "completion_tokens": [1115], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["def add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    # Validate input dimensions match\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Outer lists must have the same number of rows\")\n    \n    result = []\n    \n    # Iterate through corresponding rows\n    for i in range(len(test_tup1)):\n        row1 = test_tup1[i]\n        row2 = test_tup2[i]\n        \n        # Check that rows have matching lengths\n        if len(row1) != len(row2):\n            raise ValueError(\"Inner lists must have the same length\")\n        \n        # Add corresponding elements in the rows\n        new_row = []\n        for j in range(len(row1)):\n            new_row.append(row1[j] + row2[j])\n        \n        result.append(new_row)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    # Validate input dimensions match\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Outer lists must have the same number of rows\")\n    \n    result = []\n    \n    # Iterate through corresponding rows\n    for i in range(len(test_tup1)):\n        row1 = test_tup1[i]\n        row2 = test_tup2[i]\n        \n        # Check that rows have matching lengths\n        if len(row1) != len(row2):\n            raise ValueError(\"Inner lists must have the same length\")\n        \n        # Add corresponding elements in the rows\n        new_row = []\n        for j in range(len(row1)):\n            new_row.append(row1[j] + row2[j])\n        \n        result.append(new_row)\n    \n    return result\n\n\n"], "prompt_tokens": [2070], "completion_tokens": [1340], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_401_add_nested_tuples"}
{"name": "mbpp_435_last_Digit", "language": "Python3", "prompt": "def last_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit", "test": "def check(candidate):\n    assert candidate(123) == 3\n    assert candidate(25) == 5\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit)\n\ntest_check()\n", "sample_io": ["assert last_Digit(123) == 3"], "source_codes": ["def last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10"], "responses": ["\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10\n\n\n"], "prompt_tokens": [1476], "completion_tokens": [676], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_435_last_Digit"}
{"name": "mbpp_611_max_of_nth", "language": "Python3", "prompt": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n\tWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_of_nth", "test": "def check(candidate):\n    assert candidate([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    assert candidate([[6, 7, 8], [2, 4, 6], [9, 10, 20]], 1) == 10\n    assert candidate([[7, 8, 9], [3, 5, 7], [10, 11, 21]], 1) == 11\n\ndef test_check():\n    check(max_of_nth)\n\ntest_check()\n", "sample_io": ["assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"], "source_codes": ["def max_of_nth(test_list: List[List[int]], N: int) -> int:\n    # Collect all Nth column elements that exist\n    nth_column_elements = []\n    \n    # Iterate through each row\n    for row in test_list:\n        # Check if the row has enough elements to access index N\n        if len(row) > N:\n            nth_column_elements.append(row[N])\n    \n    # Return the maximum of the collected elements\n    return max(nth_column_elements)"], "responses": ["\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    # Collect all Nth column elements that exist\n    nth_column_elements = []\n    \n    # Iterate through each row\n    for row in test_list:\n        # Check if the row has enough elements to access index N\n        if len(row) > N:\n            nth_column_elements.append(row[N])\n    \n    # Return the maximum of the collected elements\n    return max(nth_column_elements)\n\n\n"], "prompt_tokens": [1982], "completion_tokens": [1193], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_611_max_of_nth"}
{"name": "mbpp_280_sequential_search", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n\tWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequential_search", "test": "def check(candidate):\n    assert candidate([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)\n    assert candidate([12, 32, 45, 62, 35, 47, 44, 61], 61) == (True, 7)\n    assert candidate([9, 10, 17, 19, 22, 39, 48, 56], 48) == (True, 6)\n\ndef test_check():\n    check(sequential_search)\n\ntest_check()\n", "sample_io": ["assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"], "source_codes": ["def sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    # Handle edge case of empty list\n    if not dlist:\n        return (False, -1)\n    \n    # Iterate through the list using enumerate to get both index and value\n    for index, value in enumerate(dlist):\n        # If a match is found, immediately return (True, current_index)\n        if value == item:\n            return (True, index)\n    \n    # If the loop completes without finding the item, return (False, -1)\n    return (False, -1)"], "responses": ["\nfrom typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    # Handle edge case of empty list\n    if not dlist:\n        return (False, -1)\n    \n    # Iterate through the list using enumerate to get both index and value\n    for index, value in enumerate(dlist):\n        # If a match is found, immediately return (True, current_index)\n        if value == item:\n            return (True, index)\n    \n    # If the loop completes without finding the item, return (False, -1)\n    return (False, -1)\n\n\n"], "prompt_tokens": [2348], "completion_tokens": [1234], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_280_sequential_search"}
{"name": "mbpp_576_is_Sub_Array", "language": "Python3", "prompt": "from typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list is sublist of another or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sub_Array", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 5], [1, 2]) == False\n    assert candidate([1, 2, 1], [1, 2, 1]) == True\n    assert candidate([1, 0, 2, 2], [2, 2, 0]) == False\n\ndef test_check():\n    check(is_Sub_Array)\n\ntest_check()\n", "sample_io": ["assert is_Sub_Array([1, 4, 3, 5], [1, 2]) == False"], "source_codes": ["def is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    # Handle edge cases\n    if not A:  # Empty list is a sublist of any list\n        return True\n    \n    if len(A) > len(B):  # A cannot be a sublist if it's longer than B\n        return False\n    \n    # Check for subarray match using sliding window\n    for i in range(len(B) - len(A) + 1):\n        # Extract a subarray of length len(A) starting at index i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False"], "responses": ["\nfrom typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    # Handle edge cases\n    if not A:  # Empty list is a sublist of any list\n        return True\n    \n    if len(A) > len(B):  # A cannot be a sublist if it's longer than B\n        return False\n    \n    # Check for subarray match using sliding window\n    for i in range(len(B) - len(A) + 1):\n        # Extract a subarray of length len(A) starting at index i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False\n\n\n"], "prompt_tokens": [2081], "completion_tokens": [1097], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_576_is_Sub_Array"}
{"name": "mbpp_131_reverse_vowels", "language": "Python3", "prompt": "def reverse_vowels(str1: str) -> str:\n    \"\"\"\n\tWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_vowels", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('USA') == 'ASU'\n    assert candidate('ab') == 'ab'\n\ndef test_check():\n    check(reverse_vowels)\n\ntest_check()\n", "sample_io": ["assert reverse_vowels('Python') == 'Python'"], "source_codes": ["def reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n            \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)"], "responses": ["\ndef reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n            \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)\n\n\n"], "prompt_tokens": [1785], "completion_tokens": [943], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_131_reverse_vowels"}
{"name": "mbpp_432_median_trapezium", "language": "Python3", "prompt": "def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n\tWrite a function to find the median length of a trapezium.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_trapezium", "test": "def check(candidate):\n    assert candidate(15, 25, 35) == 20\n    assert candidate(10, 20, 30) == 15\n    assert candidate(6, 9, 4) == 7.5\n\ndef test_check():\n    check(median_trapezium)\n\ntest_check()\n", "sample_io": ["assert median_trapezium(15, 25, 35) == 20"], "source_codes": ["def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides, and its length equals the average of the \n    lengths of the two parallel bases.\n    \n    Args:\n        base1 (int): Length of the first parallel base\n        base2 (int): Length of the second parallel base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The length of the median\n    \"\"\"\n    # Input validation\n    if base1 <= 0 or base2 <= 0 or height <= 0:\n        raise ValueError(\"All parameters must be positive numbers\")\n    \n    # Calculate median as the average of the two bases\n    median = (base1 + base2) / 2\n    \n    return float(median)"], "responses": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides, and its length equals the average of the \n    lengths of the two parallel bases.\n    \n    Args:\n        base1 (int): Length of the first parallel base\n        base2 (int): Length of the second parallel base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The length of the median\n    \"\"\"\n    # Input validation\n    if base1 <= 0 or base2 <= 0 or height <= 0:\n        raise ValueError(\"All parameters must be positive numbers\")\n    \n    # Calculate median as the average of the two bases\n    median = (base1 + base2) / 2\n    \n    return float(median)\n\n\n"], "prompt_tokens": [1909], "completion_tokens": [1261], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_432_median_trapezium"}
{"name": "mbpp_161_remove_elements", "language": "Python3", "prompt": "from typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to remove all elements from a given list present in another list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_elements", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]\n\ndef test_check():\n    check(remove_elements)\n\ntest_check()\n", "sample_io": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"], "source_codes": ["def remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Handle edge case where list1 is empty\n    if not list1:\n        return []\n    \n    # Handle edge case where list2 is empty\n    if not list2:\n        return list1\n    \n    # Convert list2 to a set for O(1) average time complexity lookup\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [element for element in list1 if element not in set2]"], "responses": ["\nfrom typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Handle edge case where list1 is empty\n    if not list1:\n        return []\n    \n    # Handle edge case where list2 is empty\n    if not list2:\n        return list1\n    \n    # Convert list2 to a set for O(1) average time complexity lookup\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [element for element in list1 if element not in set2]\n\n\n"], "prompt_tokens": [2030], "completion_tokens": [1085], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_161_remove_elements"}
{"name": "mbpp_597_find_kth", "language": "Python3", "prompt": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find kth element from the given two sorted arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_kth", "test": "def check(candidate):\n    assert candidate([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    assert candidate([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256\n    assert candidate([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8\n\ndef test_check():\n    check(find_kth)\n\ntest_check()\n", "sample_io": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"], "source_codes": ["def find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if not arr1:\n        return arr2[k-1]\n    if not arr2:\n        return arr1[k-1]\n    \n    # Binary search on arr1\n    low, high = max(0, k - len(arr2)), min(len(arr1), k)\n    \n    while low <= high:\n        # Partition arr1 and arr2\n        mid1 = (low + high) // 2\n        mid2 = k - mid1\n        \n        # Get boundary values\n        left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if left1 <= right2 and left2 <= right1:\n            return max(left1, left2)\n        elif left1 > right2:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    \n    # This should never be reached for valid inputs\n    raise ValueError(\"Invalid input\")"], "responses": ["\nfrom typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if not arr1:\n        return arr2[k-1]\n    if not arr2:\n        return arr1[k-1]\n    \n    # Binary search on arr1\n    low, high = max(0, k - len(arr2)), min(len(arr1), k)\n    \n    while low <= high:\n        # Partition arr1 and arr2\n        mid1 = (low + high) // 2\n        mid2 = k - mid1\n        \n        # Get boundary values\n        left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if left1 <= right2 and left2 <= right1:\n            return max(left1, left2)\n        elif left1 > right2:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    \n    # This should never be reached for valid inputs\n    raise ValueError(\"Invalid input\")\n\n\n"], "prompt_tokens": [2167], "completion_tokens": [1587], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_597_find_kth"}
{"name": "mbpp_226_odd_values_string", "language": "Python3", "prompt": "def odd_values_string(str: str) -> str:\n    \"\"\"\n\tWrite a python function to remove the characters which have odd index values of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_values_string", "test": "def check(candidate):\n    assert candidate('abcdef') == 'ace'\n    assert candidate('python') == 'pto'\n    assert candidate('data') == 'dt'\n    assert candidate('lambs') == 'lms'\n\ndef test_check():\n    check(odd_values_string)\n\ntest_check()\n", "sample_io": ["assert odd_values_string('abcdef') == 'ace'"], "source_codes": ["def odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]"], "responses": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]\n\n\n"], "prompt_tokens": [1581], "completion_tokens": [869], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_226_odd_values_string"}
{"name": "mbpp_278_count_first_elements", "language": "Python3", "prompt": "from typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n\tWrite a function to find the number of elements that occurs before the list element in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_first_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, (4, 6), 10]) == 3\n    assert candidate([2, 9, (5, 7), 11]) == 2\n    assert candidate([11, 15, 5, 8, (2, 3), 8]) == 4\n\ndef test_check():\n    check(count_first_elements)\n\ntest_check()\n", "sample_io": ["assert count_first_elements([1, 5, 7, (4, 6), 10]) == 3"], "source_codes": ["def count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_tup:\n        return 0\n    \n    # Iterate through each element in the input list\n    for i, element in enumerate(test_tup):\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # Return the count of elements before this tuple\n            return i\n    \n    # If no tuple is found, return the total count of elements\n    return len(test_tup)"], "responses": ["\nfrom typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_tup:\n        return 0\n    \n    # Iterate through each element in the input list\n    for i, element in enumerate(test_tup):\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # Return the count of elements before this tuple\n            return i\n    \n    # If no tuple is found, return the total count of elements\n    return len(test_tup)\n\n\n"], "prompt_tokens": [1804], "completion_tokens": [919], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_278_count_first_elements"}
{"name": "mbpp_269_ascii_value", "language": "Python3", "prompt": "def ascii_value(k: str) -> int:\n    \"\"\"\n\tWrite a function to find the ascii value of a character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "ascii_value", "test": "def check(candidate):\n    assert candidate('A') == 65\n    assert candidate('R') == 82\n    assert candidate('S') == 83\n\ndef test_check():\n    check(ascii_value)\n\ntest_check()\n", "sample_io": ["assert ascii_value('A') == 65"], "source_codes": ["def ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n    \n    return ord(k)"], "responses": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n    \n    return ord(k)\n\n\n"], "prompt_tokens": [1540], "completion_tokens": [1010], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_269_ascii_value"}
{"name": "mbpp_739_find_Index", "language": "Python3", "prompt": "def find_Index(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Index", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 14\n    assert candidate(4) == 45\n\ndef test_check():\n    check(find_Index)\n\ntest_check()\n", "sample_io": ["assert find_Index(2) == 4"], "source_codes": ["import math\n\ndef find_Index(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    # Calculate lower bound for k\n    lower_bound = int(math.sqrt(2 * (10 ** (n - 1))))\n    \n    # Binary search range\n    left = lower_bound\n    right = 2 * lower_bound\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Calculate triangular number T(mid) = mid * (mid + 1) / 2\n        triangular = mid * (mid + 1) // 2\n        \n        # Count number of digits\n        digits = len(str(triangular))\n        \n        if digits >= n:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result"], "responses": ["\nimport math\n\ndef find_Index(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    # Calculate lower bound for k\n    lower_bound = int(math.sqrt(2 * (10 ** (n - 1))))\n    \n    # Binary search range\n    left = lower_bound\n    right = 2 * lower_bound\n    \n    result = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Calculate triangular number T(mid) = mid * (mid + 1) / 2\n        triangular = mid * (mid + 1) // 2\n        \n        # Count number of digits\n        digits = len(str(triangular))\n        \n        if digits >= n:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n\n"], "prompt_tokens": [1895], "completion_tokens": [1356], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_739_find_Index"}
{"name": "mbpp_19_test_duplicate", "language": "Python3", "prompt": "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to find whether a given array of integers contains any duplicate element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_duplicate", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 4]) == True\n    assert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True\n\ndef test_check():\n    check(test_duplicate)\n\ntest_check()\n", "sample_io": ["assert test_duplicate([1, 2, 3, 4, 5]) == False"], "source_codes": ["def test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Handle edge case: if array is empty or has one element, return False\n    if len(arraynums) <= 1:\n        return False\n    \n    # Initialize an empty set to track seen elements\n    seen = set()\n    \n    # Iterate through each element in the input array\n    for num in arraynums:\n        # Check if element already exists in the set\n        if num in seen:\n            return True  # Duplicate found\n        # Add element to the set\n        seen.add(num)\n    \n    # No duplicates found\n    return False"], "responses": ["\nfrom typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Handle edge case: if array is empty or has one element, return False\n    if len(arraynums) <= 1:\n        return False\n    \n    # Initialize an empty set to track seen elements\n    seen = set()\n    \n    # Iterate through each element in the input array\n    for num in arraynums:\n        # Check if element already exists in the set\n        if num in seen:\n            return True  # Duplicate found\n        # Add element to the set\n        seen.add(num)\n    \n    # No duplicates found\n    return False\n\n\n"], "prompt_tokens": [1564], "completion_tokens": [965], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_19_test_duplicate"}
{"name": "mbpp_62_smallest_num", "language": "Python3", "prompt": "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "smallest_num", "test": "def check(candidate):\n    assert candidate([10, 20, 1, 45, 99]) == 1\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([45, 46, 50, 60]) == 45\n\ndef test_check():\n    check(smallest_num)\n\ntest_check()\n", "sample_io": ["assert smallest_num([10, 20, 1, 45, 99]) == 1"], "source_codes": ["def smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for i in range(1, len(xs)):\n        if xs[i] < min_val:\n            min_val = xs[i]\n    \n    return min_val"], "responses": ["\nfrom typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for i in range(1, len(xs)):\n        if xs[i] < min_val:\n            min_val = xs[i]\n    \n    return min_val\n\n\n"], "prompt_tokens": [1863], "completion_tokens": [1015], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_62_smallest_num"}
{"name": "mbpp_746_sector_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sector_area", "test": "def check(candidate):\n    assert candidate(4, 45) == 6.283185307179586\n    assert candidate(9, 45) == 31.808625617596654\n    assert candidate(9, 361) == None\n\ndef test_check():\n    check(sector_area)\n\ntest_check()\n", "sample_io": ["assert sector_area(4, 45) == 6.283185307179586"], "source_codes": ["import math\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    if a > 360:\n        return None\n    \n    area = (a / 360) * math.pi * r ** 2\n    return area"], "responses": ["\nimport math\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    if a > 360:\n        return None\n    \n    area = (a / 360) * math.pi * r ** 2\n    return area\n\n\n"], "prompt_tokens": [2025], "completion_tokens": [988], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_746_sector_area"}
{"name": "mbpp_142_count_samepair", "language": "Python3", "prompt": "from typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n\tWrite a function to count number items that are identical in the same position of three given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_samepair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 4\n    assert candidate([1, 2, 3, 4, 2, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 5\n\ndef test_check():\n    check(count_samepair)\n\ntest_check()\n", "sample_io": ["assert count_samepair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3"], "source_codes": ["def count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    # Handle edge case where any list is empty\n    if not list1 or not list2 or not list3:\n        return 0\n    \n    # Determine the minimum length among all three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter for identical elements at same positions\n    count = 0\n    \n    # Iterate through indices from 0 to minimum length - 1\n    for i in range(min_length):\n        # Compare elements from all three lists at current index\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count"], "responses": ["\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    # Handle edge case where any list is empty\n    if not list1 or not list2 or not list3:\n        return 0\n    \n    # Determine the minimum length among all three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter for identical elements at same positions\n    count = 0\n    \n    # Iterate through indices from 0 to minimum length - 1\n    for i in range(min_length):\n        # Compare elements from all three lists at current index\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [2224], "completion_tokens": [1219], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_142_count_samepair"}
{"name": "mbpp_400_extract_freq", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to extract the number of unique tuples in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_freq", "test": "def check(candidate):\n    assert candidate([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    assert candidate([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    assert candidate([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n\ndef test_check():\n    check(extract_freq)\n\ntest_check()\n", "sample_io": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"], "source_codes": ["def extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    # Convert each tuple to a frozenset to make them unordered\n    # For tuples like (a,b) and (b,a), they will become the same frozenset\n    unique_pairs = set()\n    for tup in test_list:\n        # Create a frozenset from the tuple elements to ignore order\n        pair = frozenset(tup)\n        unique_pairs.add(pair)\n    \n    return len(unique_pairs)"], "responses": ["\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    # Convert each tuple to a frozenset to make them unordered\n    # For tuples like (a,b) and (b,a), they will become the same frozenset\n    unique_pairs = set()\n    for tup in test_list:\n        # Create a frozenset from the tuple elements to ignore order\n        pair = frozenset(tup)\n        unique_pairs.add(pair)\n    \n    return len(unique_pairs)\n\n\n"], "prompt_tokens": [4676], "completion_tokens": [2671], "no_of_try": 1, "api_calls": 9, "is_solved": true, "task_id": "mbpp_400_extract_freq"}
{"name": "mbpp_595_min_Swaps", "language": "Python3", "prompt": "from typing import Any\n\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n\tWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Swaps", "test": "def check(candidate):\n    assert candidate('1101', '1110') == 1\n    assert candidate('111', '000') == 'Not Possible'\n    assert candidate('111', '110') == 'Not Possible'\n\ndef test_check():\n    check(min_Swaps)\n\ntest_check()\n", "sample_io": ["assert min_Swaps('1101', '1110') == 1"], "source_codes": ["def min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Check if both strings have the same number of 0s and 1s\n    if str1.count('0') != str2.count('0') or str1.count('1') != str2.count('1'):\n        return -1\n    \n    # Count mismatches\n    mismatches = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            mismatches += 1\n    \n    # If no mismatches, no swaps needed\n    if mismatches == 0:\n        return 0\n    \n    # If odd number of mismatches, impossible to resolve with swaps\n    if mismatches % 2 != 0:\n        return -1\n    \n    # Minimum swaps is half the number of mismatches\n    return mismatches // 2"], "responses": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Check if both strings have the same number of 0s and 1s\n    if str1.count('0') != str2.count('0') or str1.count('1') != str2.count('1'):\n        return -1\n    \n    # Count mismatches\n    mismatches = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            mismatches += 1\n    \n    # If no mismatches, no swaps needed\n    if mismatches == 0:\n        return 0\n    \n    # If odd number of mismatches, impossible to resolve with swaps\n    if mismatches % 2 != 0:\n        return -1\n    \n    # Minimum swaps is half the number of mismatches\n    return mismatches // 2\n\n\n"], "prompt_tokens": [1941], "completion_tokens": [1343], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_595_min_Swaps"}
{"name": "mbpp_135_hexagonal_num", "language": "Python3", "prompt": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "hexagonal_num", "test": "def check(candidate):\n    assert candidate(10) == 190\n    assert candidate(5) == 45\n    assert candidate(7) == 91\n\ndef test_check():\n    check(hexagonal_num)\n\ntest_check()\n", "sample_io": ["assert hexagonal_num(10) == 190"], "source_codes": ["def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth hexagonal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    \n    return n * (2 * n - 1)"], "responses": ["\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth hexagonal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    \n    return n * (2 * n - 1)\n\n\n"], "prompt_tokens": [1743], "completion_tokens": [1059], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_135_hexagonal_num"}
{"name": "mbpp_800_remove_all_spaces", "language": "Python3", "prompt": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_all_spaces", "test": "def check(candidate):\n    assert candidate('python  program') == 'pythonprogram'\n    assert candidate('python   programming    language') == 'pythonprogramminglanguage'\n    assert candidate('python                     program') == 'pythonprogram'\n    assert candidate('   python                     program') == 'pythonprogram'\n\ndef test_check():\n    check(remove_all_spaces)\n\ntest_check()\n", "sample_io": ["assert remove_all_spaces('python  program') == 'pythonprogram'"], "source_codes": ["def remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return ''.join(char for char in text if not char.isspace())"], "responses": ["\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return ''.join(char for char in text if not char.isspace())\n\n\n"], "prompt_tokens": [1616], "completion_tokens": [854], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_800_remove_all_spaces"}
{"name": "mbpp_127_multiply_int", "language": "Python3", "prompt": "def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n\tWrite a function to multiply two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_int", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(5, 10) == 50\n    assert candidate(4, 8) == 32\n\ndef test_check():\n    check(multiply_int)\n\ntest_check()\n", "sample_io": ["assert multiply_int(10, 20) == 200"], "source_codes": ["def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y"], "responses": ["\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n\n\n"], "prompt_tokens": [1683], "completion_tokens": [738], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_127_multiply_int"}
{"name": "mbpp_764_number_ctr", "language": "Python3", "prompt": "def number_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count number of digits in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_ctr", "test": "def check(candidate):\n    assert candidate('program2bedone') == 1\n    assert candidate('3wonders') == 1\n    assert candidate('123') == 3\n    assert candidate('3wond-1ers2') == 3\n\ndef test_check():\n    check(number_ctr)\n\ntest_check()\n", "sample_io": ["assert number_ctr('program2bedone') == 1"], "source_codes": ["def number_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    \"\"\"\n    # Initialize counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            count += 1\n    \n    # Return the final count\n    return count"], "responses": ["\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    \"\"\"\n    # Initialize counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            count += 1\n    \n    # Return the final count\n    return count\n\n\n"], "prompt_tokens": [1817], "completion_tokens": [991], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_764_number_ctr"}
{"name": "mbpp_767_get_pairs_count", "language": "Python3", "prompt": "from typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_pairs_count", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1], 2) == 6\n    assert candidate([1, 5, 7, -1, 5], 6) == 3\n    assert candidate([1, -2, 3], 1) == 1\n    assert candidate([-1, -2, 3], -3) == 1\n\ndef test_check():\n    check(get_pairs_count)\n\ntest_check()\n", "sample_io": ["assert get_pairs_count([1, 1, 1, 1], 2) == 6"], "source_codes": ["def get_pairs_count(arr: List[int], sum: int) -> int:\n    # Handle edge case: if array has less than 2 elements, no pairs possible\n    if len(arr) < 2:\n        return 0\n    \n    # Hash map to store frequency of elements\n    freq_map = {}\n    count = 0\n    \n    # Iterate through each element in array\n    for num in arr:\n        # Calculate complement needed to form the target sum\n        complement = sum - num\n        \n        # If complement exists in map, add its frequency to count\n        if complement in freq_map:\n            count += freq_map[complement]\n        \n        # Add/update frequency of current number in map\n        freq_map[num] = freq_map.get(num, 0) + 1\n    \n    return count"], "responses": ["\nfrom typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    # Handle edge case: if array has less than 2 elements, no pairs possible\n    if len(arr) < 2:\n        return 0\n    \n    # Hash map to store frequency of elements\n    freq_map = {}\n    count = 0\n    \n    # Iterate through each element in array\n    for num in arr:\n        # Calculate complement needed to form the target sum\n        complement = sum - num\n        \n        # If complement exists in map, add its frequency to count\n        if complement in freq_map:\n            count += freq_map[complement]\n        \n        # Add/update frequency of current number in map\n        freq_map[num] = freq_map.get(num, 0) + 1\n    \n    return count\n\n\n"], "prompt_tokens": [1887], "completion_tokens": [945], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_767_get_pairs_count"}
{"name": "mbpp_99_decimal_to_binary", "language": "Python3", "prompt": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n\tWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(8) == '1000'\n    assert candidate(18) == '10010'\n    assert candidate(7) == '111'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "sample_io": ["assert decimal_to_binary(8) == '1000'"], "source_codes": ["def decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return \"0\"\n    \n    binary_digits = []\n    while n > 0:\n        remainder = n % 2\n        binary_digits.append(str(remainder))\n        n = n // 2\n    \n    # Reverse the digits to get the correct binary representation\n    binary_digits.reverse()\n    \n    return ''.join(binary_digits)"], "responses": ["\ndef decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return \"0\"\n    \n    binary_digits = []\n    while n > 0:\n        remainder = n % 2\n        binary_digits.append(str(remainder))\n        n = n // 2\n    \n    # Reverse the digits to get the correct binary representation\n    binary_digits.reverse()\n    \n    return ''.join(binary_digits)\n\n\n"], "prompt_tokens": [1687], "completion_tokens": [1058], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_99_decimal_to_binary"}
{"name": "mbpp_119_search", "language": "Python3", "prompt": "from typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the element that appears only once in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "search", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8\n    assert candidate([1, 2, 2, 3, 3, 4, 4]) == 1\n\ndef test_check():\n    check(search)\n\ntest_check()\n", "sample_io": ["assert search([1, 1, 2, 2, 3]) == 3"], "source_codes": ["def search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers where every element appears exactly twice,\n             except for one element which appears exactly once.\n    \n    Returns:\n        The integer that appears only once.\n    \"\"\"\n    # Handle edge case of single element array\n    if len(arr) == 1:\n        return arr[0]\n    \n    # Initialize binary search pointers\n    left, right = 0, len(arr) - 1\n    \n    # Binary search\n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd and compare with neighbors\n        if (mid % 2 == 0 and arr[mid] == arr[mid + 1]) or \\\n           (mid % 2 == 1 and arr[mid] == arr[mid - 1]):\n            # Unique element is in the right half\n            left = mid + 1\n        else:\n            # Unique element is in the left half (including mid)\n            right = mid\n    \n    # Return the unique element\n    return arr[left]"], "responses": ["\nfrom typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers where every element appears exactly twice,\n             except for one element which appears exactly once.\n    \n    Returns:\n        The integer that appears only once.\n    \"\"\"\n    # Handle edge case of single element array\n    if len(arr) == 1:\n        return arr[0]\n    \n    # Initialize binary search pointers\n    left, right = 0, len(arr) - 1\n    \n    # Binary search\n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd and compare with neighbors\n        if (mid % 2 == 0 and arr[mid] == arr[mid + 1]) or \\\n           (mid % 2 == 1 and arr[mid] == arr[mid - 1]):\n            # Unique element is in the right half\n            left = mid + 1\n        else:\n            # Unique element is in the left half (including mid)\n            right = mid\n    \n    # Return the unique element\n    return arr[left]\n\n\n"], "prompt_tokens": [1901], "completion_tokens": [1233], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_119_search"}
{"name": "mbpp_92_is_undulating", "language": "Python3", "prompt": "def is_undulating(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is undulating or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_undulating", "test": "def check(candidate):\n    assert candidate(1212121) == True\n    assert candidate(1991) == False\n    assert candidate(121) == True\n\ndef test_check():\n    check(is_undulating)\n\ntest_check()\n", "sample_io": ["assert is_undulating(1212121) == True"], "source_codes": ["def is_undulating(n: int) -> bool:\n    # Convert the number to a string to work with individual digits\n    s = str(n)\n    \n    # A valid undulating number must have at least 2 digits\n    if len(s) < 2:\n        return False\n    \n    # Check if the number contains only two distinct digits\n    unique_digits = set(s)\n    if len(unique_digits) != 2:\n        return False\n    \n    # Get the two distinct digits\n    digits = list(unique_digits)\n    A, B = digits[0], digits[1]\n    \n    # Check both possible patterns: ABAB... or BAB...\n    pattern1_valid = True\n    pattern2_valid = True\n    \n    # Check pattern starting with A (ABAB...)\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even indices should be A\n            if s[i] != A:\n                pattern1_valid = False\n                break\n        else:  # Odd indices should be B\n            if s[i] != B:\n                pattern1_valid = False\n                break\n    \n    # Check pattern starting with B (BAB...)\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even indices should be B\n            if s[i] != B:\n                pattern2_valid = False\n                break\n        else:  # Odd indices should be A\n            if s[i] != A:\n                pattern2_valid = False\n                break\n    \n    # Return True if either pattern is valid\n    return pattern1_valid or pattern2_valid"], "responses": ["\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to work with individual digits\n    s = str(n)\n    \n    # A valid undulating number must have at least 2 digits\n    if len(s) < 2:\n        return False\n    \n    # Check if the number contains only two distinct digits\n    unique_digits = set(s)\n    if len(unique_digits) != 2:\n        return False\n    \n    # Get the two distinct digits\n    digits = list(unique_digits)\n    A, B = digits[0], digits[1]\n    \n    # Check both possible patterns: ABAB... or BAB...\n    pattern1_valid = True\n    pattern2_valid = True\n    \n    # Check pattern starting with A (ABAB...)\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even indices should be A\n            if s[i] != A:\n                pattern1_valid = False\n                break\n        else:  # Odd indices should be B\n            if s[i] != B:\n                pattern1_valid = False\n                break\n    \n    # Check pattern starting with B (BAB...)\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even indices should be B\n            if s[i] != B:\n                pattern2_valid = False\n                break\n        else:  # Odd indices should be A\n            if s[i] != A:\n                pattern2_valid = False\n                break\n    \n    # Return True if either pattern is valid\n    return pattern1_valid or pattern2_valid\n\n\n"], "prompt_tokens": [1768], "completion_tokens": [1112], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_92_is_undulating"}
{"name": "mbpp_105_count", "language": "Python3", "prompt": "from typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n\tWrite a python function to count true booleans in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count", "test": "def check(candidate):\n    assert candidate([True, False, True]) == 2\n    assert candidate([False, False]) == 0\n    assert candidate([True, True, True]) == 3\n\ndef test_check():\n    check(count)\n\ntest_check()\n", "sample_io": ["assert count([True, False, True]) == 2"], "source_codes": ["def count(lst: List[bool]) -> int:\n    \"\"\"\n    Count the number of True boolean values in the given list.\n    \n    Args:\n        lst: A list of boolean values\n        \n    Returns:\n        The count of True values in the list\n    \"\"\"\n    return sum(lst)"], "responses": ["\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Count the number of True boolean values in the given list.\n    \n    Args:\n        lst: A list of boolean values\n        \n    Returns:\n        The count of True values in the list\n    \"\"\"\n    return sum(lst)\n\n\n"], "prompt_tokens": [1551], "completion_tokens": [696], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_105_count"}
{"name": "mbpp_766_pair_wise", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to return a list of all pairs of consecutive items in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_wise", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    assert candidate([1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)]\n    assert candidate([5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n\ndef test_check():\n    check(pair_wise)\n\ntest_check()\n", "sample_io": ["assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"], "source_codes": ["def pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    # Handle edge cases: if list has fewer than 2 elements, return empty list\n    if len(l1) < 2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and create consecutive pairs\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    \n    return result"], "responses": ["\nfrom typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    # Handle edge cases: if list has fewer than 2 elements, return empty list\n    if len(l1) < 2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and create consecutive pairs\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    \n    return result\n\n\n"], "prompt_tokens": [1932], "completion_tokens": [987], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_766_pair_wise"}
{"name": "mbpp_464_check_value", "language": "Python3", "prompt": "from typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n\tWrite a function to check if all values are same in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_value", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 12) == True\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 5) == False\n\ndef test_check():\n    check(check_value)\n\ntest_check()\n", "sample_io": ["assert check_value({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False"], "source_codes": ["def check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Handle edge case: empty dictionary\n    if not dict:\n        return True\n    \n    # Check if all values are equal to n\n    for value in dict.values():\n        if value != n:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Handle edge case: empty dictionary\n    if not dict:\n        return True\n    \n    # Check if all values are equal to n\n    for value in dict.values():\n        if value != n:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1610], "completion_tokens": [979], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_464_check_value"}
{"name": "mbpp_443_largest_neg", "language": "Python3", "prompt": "from typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest negative number from the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "largest_neg", "test": "def check(candidate):\n    assert candidate([1, 2, 3, -4, -6]) == -6\n    assert candidate([1, 2, 3, -8, -9]) == -9\n    assert candidate([1, 2, 3, 4, -1]) == -1\n\ndef test_check():\n    check(largest_neg)\n\ntest_check()\n", "sample_io": ["assert largest_neg([1, 2, 3, -4, -6]) == -6"], "source_codes": ["def largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \n    Args:\n        list1: A list of integers\n        \n    Returns:\n        The largest negative number in the list\n    \"\"\"\n    largest_negative = None\n    \n    for num in list1:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n                \n    return largest_negative"], "responses": ["\nfrom typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \n    Args:\n        list1: A list of integers\n        \n    Returns:\n        The largest negative number in the list\n    \"\"\"\n    largest_negative = None\n    \n    for num in list1:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n                \n    return largest_negative\n\n\n"], "prompt_tokens": [5009], "completion_tokens": [4269], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_443_largest_neg"}
{"name": "mbpp_602_first_repeated_char", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_repeated_char", "test": "def check(candidate):\n    assert candidate('abcabc') == 'a'\n    assert candidate('abc') == None\n    assert candidate('123123') == '1'\n\ndef test_check():\n    check(first_repeated_char)\n\ntest_check()\n", "sample_io": ["assert first_repeated_char('abcabc') == 'a'"], "source_codes": ["def first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    if not str1:\n        return None\n    \n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None"], "responses": ["\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    if not str1:\n        return None\n    \n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n\n\n"], "prompt_tokens": [1684], "completion_tokens": [835], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_602_first_repeated_char"}
{"name": "mbpp_770_odd_num_sum", "language": "Python3", "prompt": "def odd_num_sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of fourth power of first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_num_sum", "test": "def check(candidate):\n    assert candidate(2) == 82\n    assert candidate(3) == 707\n    assert candidate(4) == 3108\n\ndef test_check():\n    check(odd_num_sum)\n\ntest_check()\n", "sample_io": ["assert odd_num_sum(2) == 82"], "source_codes": ["def odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total"], "responses": ["\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i ** 4\n    return total\n\n\n"], "prompt_tokens": [1094], "completion_tokens": [968], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_770_odd_num_sum"}
{"name": "mbpp_424_extract_rear", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n\tWrite a function to extract only the rear index element of each string in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_rear", "test": "def check(candidate):\n    assert candidate(('Mers', 'for', 'Vers')) == ['s', 'r', 's']\n    assert candidate(('Avenge', 'for', 'People')) == ['e', 'r', 'e']\n    assert candidate(('Gotta', 'get', 'go')) == ['a', 't', 'o']\n\ndef test_check():\n    check(extract_rear)\n\ntest_check()\n", "sample_io": ["assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"], "source_codes": ["def extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] if s else \"\" for s in test_tuple]"], "responses": ["\nfrom typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] if s else \"\" for s in test_tuple]\n\n\n"], "prompt_tokens": [1767], "completion_tokens": [1087], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_424_extract_rear"}
{"name": "mbpp_133_sum_negativenum", "language": "Python3", "prompt": "from typing import List\n\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of the negative numbers of a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_negativenum", "test": "def check(candidate):\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32\n    assert candidate([10, 15, -14, 13, -18, 12, -20]) == -52\n    assert candidate([19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894\n\ndef test_check():\n    check(sum_negativenum)\n\ntest_check()\n", "sample_io": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"], "source_codes": ["def sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total"], "responses": ["\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total\n\n\n"], "prompt_tokens": [1387], "completion_tokens": [773], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_133_sum_negativenum"}
{"name": "mbpp_760_unique_Element", "language": "Python3", "prompt": "from typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list of numbers contains only one distinct element or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_Element", "test": "def check(candidate):\n    assert candidate([1, 1, 1]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == False\n\ndef test_check():\n    check(unique_Element)\n\ntest_check()\n", "sample_io": ["assert unique_Element([1, 1, 1]) == True"], "source_codes": ["def unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise\n    \"\"\"\n    # Convert list to set to eliminate duplicates\n    unique_elements = set(arr)\n    \n    # Check if there is exactly one distinct element\n    return len(unique_elements) <= 1"], "responses": ["\nfrom typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise\n    \"\"\"\n    # Convert list to set to eliminate duplicates\n    unique_elements = set(arr)\n    \n    # Check if there is exactly one distinct element\n    return len(unique_elements) <= 1\n\n\n"], "prompt_tokens": [1584], "completion_tokens": [908], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_760_unique_Element"}
{"name": "mbpp_281_all_unique", "language": "Python3", "prompt": "from typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check if the elements of a given list are unique or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_unique", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == True\n\ndef test_check():\n    check(all_unique)\n\ntest_check()\n", "sample_io": ["assert all_unique([1, 2, 3]) == True"], "source_codes": ["def all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Check if the elements of a given list are unique or not.\n    \n    Args:\n        test_list: A list of integers\n        \n    Returns:\n        bool: True if all elements are unique, False otherwise\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_list:\n        return True\n    \n    # Use a set to track seen elements for O(1) lookup\n    seen = set()\n    \n    # Iterate through the list\n    for element in test_list:\n        # If we've seen this element before, it's not unique\n        if element in seen:\n            return False\n        # Add the element to our set of seen elements\n        seen.add(element)\n    \n    # If we get through the entire list without finding duplicates, all elements are unique\n    return True"], "responses": ["\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Check if the elements of a given list are unique or not.\n    \n    Args:\n        test_list: A list of integers\n        \n    Returns:\n        bool: True if all elements are unique, False otherwise\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_list:\n        return True\n    \n    # Use a set to track seen elements for O(1) lookup\n    seen = set()\n    \n    # Iterate through the list\n    for element in test_list:\n        # If we've seen this element before, it's not unique\n        if element in seen:\n            return False\n        # Add the element to our set of seen elements\n        seen.add(element)\n    \n    # If we get through the entire list without finding duplicates, all elements are unique\n    return True\n\n\n"], "prompt_tokens": [1777], "completion_tokens": [956], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_281_all_unique"}
