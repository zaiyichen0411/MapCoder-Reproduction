{"name": "mbpp_406_find_Parity", "language": "Python3", "prompt": "def find_Parity(x: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether the parity of a given number is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Parity", "test": "def check(candidate):\n    assert candidate(12) == False\n    assert candidate(7) == True\n    assert candidate(10) == False\n\ndef test_check():\n    check(find_Parity)\n\ntest_check()\n", "sample_io": ["assert find_Parity(12) == False"], "source_codes": ["def find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the number has odd parity (odd count of 1-bits), False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits using built-in method\n    count_of_ones = bin(x).count('1')\n    \n    # Return True if count is odd, False if even\n    return count_of_ones % 2 == 1"], "responses": ["\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        True if the number has odd parity (odd count of 1-bits), False otherwise\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits using built-in method\n    count_of_ones = bin(x).count('1')\n    \n    # Return True if count is odd, False if even\n    return count_of_ones % 2 == 1\n\n\n"], "prompt_tokens": [1758], "completion_tokens": [913], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_406_find_Parity"}
{"name": "mbpp_562_Find_Max_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 4], [5, 6, 7, 8]]) == 4\n    assert candidate([[0, 1], [2, 2], [3, 2, 1]]) == 3\n    assert candidate([[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5\n\ndef test_check():\n    check(Find_Max_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"], "source_codes": ["def Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Find the length of the longest sublists.\n    \n    Args:\n        lst: A list of lists containing integers\n        \n    Returns:\n        The length of the longest sublist\n    \"\"\"\n    # Handle edge case: empty main list\n    if not lst:\n        return 0\n    \n    # Initialize maximum length tracker\n    max_length = 0\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Get the length of current sublist\n        current_length = len(sublist)\n        # Update maximum if current is larger\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length"], "responses": ["\nfrom typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Find the length of the longest sublists.\n    \n    Args:\n        lst: A list of lists containing integers\n        \n    Returns:\n        The length of the longest sublist\n    \"\"\"\n    # Handle edge case: empty main list\n    if not lst:\n        return 0\n    \n    # Initialize maximum length tracker\n    max_length = 0\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Get the length of current sublist\n        current_length = len(sublist)\n        # Update maximum if current is larger\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\n\n"], "prompt_tokens": [1816], "completion_tokens": [1014], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_562_Find_Max_Length"}
{"name": "mbpp_87_merge_dictionaries_three", "language": "Python3", "prompt": "from typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to merge three dictionaries into a single dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_dictionaries_three", "test": "def check(candidate):\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'L': 'lavender', 'B': 'Blue' }) == { 'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'L': 'lavender', 'B': 'Blue' }, { 'G': 'Green', 'W': 'White' }) == { 'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White' }\n\ndef test_check():\n    check(merge_dictionaries_three)\n\ntest_check()\n", "sample_io": ["assert merge_dictionaries_three({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }"], "source_codes": ["def merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    return {**dict1, **dict2, **dict3}"], "responses": ["\nfrom typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    return {**dict1, **dict2, **dict3}\n\n\n"], "prompt_tokens": [2233], "completion_tokens": [1104], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_87_merge_dictionaries_three"}
{"name": "mbpp_11_remove_Occ", "language": "Python3", "prompt": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n\tWrite a python function to remove first and last occurrence of a given character from the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_Occ", "test": "def check(candidate):\n    assert candidate('hello', 'l') == 'heo'\n    assert candidate('abcda', 'a') == 'bcd'\n    assert candidate('PHP', 'P') == 'H'\n\ndef test_check():\n    check(remove_Occ)\n\ntest_check()\n", "sample_io": ["assert remove_Occ('hello', 'l') == 'heo'"], "source_codes": ["def remove_Occ(s: str, ch: str) -> str:\n    # Find the first and last occurrence of the character\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    # If character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # If there's only one occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrence\n    # Remove last occurrence first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first occurrence\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result"], "responses": ["\ndef remove_Occ(s: str, ch: str) -> str:\n    # Find the first and last occurrence of the character\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    # If character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # If there's only one occurrence\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrence\n    # Remove last occurrence first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first occurrence\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n\n\n"], "prompt_tokens": [1761], "completion_tokens": [972], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_11_remove_Occ"}
{"name": "mbpp_751_check_min_heap", "language": "Python3", "prompt": "from typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_min_heap", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 10, 15]) == True\n    assert candidate([2, 10, 4, 5, 3, 15]) == False\n\ndef test_check():\n    check(check_min_heap)\n\ntest_check()\n", "sample_io": ["assert check_min_heap([1, 2, 3, 4, 5, 6]) == True"], "source_codes": ["def check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if the given array represents min heap or not.\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return True\n    \n    # Calculate the index of the last internal node\n    last_internal_node = (len(arr) // 2) - 1\n    \n    # Iterate through all internal nodes\n    for i in range(last_internal_node + 1):\n        # Get indices of left and right children\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        \n        # Check if current node value is greater than left child value\n        if left_child < len(arr) and arr[i] > arr[left_child]:\n            return False\n            \n        # Check if current node value is greater than right child value\n        if right_child < len(arr) and arr[i] > arr[right_child]:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if the given array represents min heap or not.\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return True\n    \n    # Calculate the index of the last internal node\n    last_internal_node = (len(arr) // 2) - 1\n    \n    # Iterate through all internal nodes\n    for i in range(last_internal_node + 1):\n        # Get indices of left and right children\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        \n        # Check if current node value is greater than left child value\n        if left_child < len(arr) and arr[i] > arr[left_child]:\n            return False\n            \n        # Check if current node value is greater than right child value\n        if right_child < len(arr) and arr[i] > arr[right_child]:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [2010], "completion_tokens": [1100], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_751_check_min_heap"}
{"name": "mbpp_410_min_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 2\n    assert candidate(['Python', 15, 20, 25]) == 15\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 20\n\ndef test_check():\n    check(min_val)\n\ntest_check()\n", "sample_io": ["assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"], "source_codes": ["def min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Check if the list is empty\n    if not listval:\n        raise ValueError(\"List is empty\")\n    \n    # Filter out only the integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Check if there are any integers in the list\n    if not int_values:\n        raise ValueError(\"No integers found in the list\")\n    \n    # Find and return the minimum integer value\n    return min(int_values)"], "responses": ["\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    # Check if the list is empty\n    if not listval:\n        raise ValueError(\"List is empty\")\n    \n    # Filter out only the integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Check if there are any integers in the list\n    if not int_values:\n        raise ValueError(\"No integers found in the list\")\n    \n    # Find and return the minimum integer value\n    return min(int_values)\n\n\n"], "prompt_tokens": [1946], "completion_tokens": [1007], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_410_min_val"}
{"name": "mbpp_578_interleave_lists", "language": "Python3", "prompt": "from typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to interleave 3 lists of the same length into a single flat list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "interleave_lists", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    assert candidate([10, 20], [15, 2], [5, 10]) == [10, 15, 5, 20, 2, 10]\n    assert candidate([11, 44], [10, 15], [20, 5]) == [11, 10, 20, 44, 15, 5]\n\ndef test_check():\n    check(interleave_lists)\n\ntest_check()\n", "sample_io": ["assert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"], "source_codes": ["def interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n        list1: First list of integers\n        list2: Second list of integers\n        list3: Third list of integers\n        \n    Returns:\n        A single list with elements interleaved from the three input lists\n    \"\"\"\n    # Handle empty lists case\n    if not list1 and not list2 and not list3:\n        return []\n    \n    # Use zip to group corresponding elements and flatten them\n    result = []\n    for group in zip(list1, list2, list3):\n        result.extend(group)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n        list1: First list of integers\n        list2: Second list of integers\n        list3: Third list of integers\n        \n    Returns:\n        A single list with elements interleaved from the three input lists\n    \"\"\"\n    # Handle empty lists case\n    if not list1 and not list2 and not list3:\n        return []\n    \n    # Use zip to group corresponding elements and flatten them\n    result = []\n    for group in zip(list1, list2, list3):\n        result.extend(group)\n    \n    return result\n\n\n"], "prompt_tokens": [2217], "completion_tokens": [1238], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_578_interleave_lists"}
{"name": "mbpp_90_len_log", "language": "Python3", "prompt": "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "len_log", "test": "def check(candidate):\n    assert candidate(['python', 'PHP', 'bigdata']) == 7\n    assert candidate(['a', 'ab', 'abc']) == 3\n    assert candidate(['small', 'big', 'tall']) == 5\n\ndef test_check():\n    check(len_log)\n\ntest_check()\n", "sample_io": ["assert len_log(['python', 'PHP', 'bigdata']) == 7"], "source_codes": ["def len_log(list1: List[str]) -> int:\n    \"\"\"\n    Find the length of the longest word in a list of strings.\n    \n    Args:\n        list1: A list of strings\n        \n    Returns:\n        The length of the longest string in the list, or 0 if the list is empty\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        current_length = len(word)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length"], "responses": ["\nfrom typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Find the length of the longest word in a list of strings.\n    \n    Args:\n        list1: A list of strings\n        \n    Returns:\n        The length of the longest string in the list, or 0 if the list is empty\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        current_length = len(word)\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\n\n"], "prompt_tokens": [1509], "completion_tokens": [846], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_90_len_log"}
{"name": "mbpp_452_loss_amount", "language": "Python3", "prompt": "def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n\tWrite a function that gives loss amount on a sale if the given amount has loss else return 0.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "loss_amount", "test": "def check(candidate):\n    assert candidate(1500, 1200) == 0\n    assert candidate(100, 200) == 100\n    assert candidate(2000, 5000) == 3000\n\ndef test_check():\n    check(loss_amount)\n\ntest_check()\n", "sample_io": ["assert loss_amount(1500, 1200) == 0"], "source_codes": ["def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    if sale_amount >= actual_cost:\n        return 0\n    else:\n        return actual_cost - sale_amount"], "responses": ["\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    if sale_amount >= actual_cost:\n        return 0\n    else:\n        return actual_cost - sale_amount\n\n\n"], "prompt_tokens": [4004], "completion_tokens": [4029], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_452_loss_amount"}
{"name": "mbpp_798__sum", "language": "Python3", "prompt": "from typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([15, 12, 13, 10]) == 50\n    assert candidate([0, 1, 2]) == 3\n\ndef test_check():\n    check(_sum)\n\ntest_check()\n", "sample_io": ["assert _sum([1, 2, 3]) == 6"], "source_codes": ["def _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        The sum of all integers in the array\n        \n    Examples:\n        >>> _sum([1, 2, 3, 4, 5])\n        15\n        >>> _sum([])\n        0\n        >>> _sum([-1, -2, -3])\n        -6\n    \"\"\"\n    return sum(arr)"], "responses": ["\nfrom typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        The sum of all integers in the array\n        \n    Examples:\n        >>> _sum([1, 2, 3, 4, 5])\n        15\n        >>> _sum([])\n        0\n        >>> _sum([-1, -2, -3])\n        -6\n    \"\"\"\n    return sum(arr)\n\n\n"], "prompt_tokens": [1558], "completion_tokens": [784], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_798__sum"}
{"name": "mbpp_393_max_length_list", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list with maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length_list", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5])\n    assert candidate([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9])\n\ndef test_check():\n    check(max_length_list)\n\ntest_check()\n", "sample_io": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["def max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not input_list:\n        return (0, [])\n    \n    # Initialize with the first list\n    max_length = len(input_list[0])\n    max_list = input_list[0]\n    \n    # Iterate through the rest of the lists\n    for sublist in input_list[1:]:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_list = sublist\n    \n    return (max_length, max_list)"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not input_list:\n        return (0, [])\n    \n    # Initialize with the first list\n    max_length = len(input_list[0])\n    max_list = input_list[0]\n    \n    # Iterate through the rest of the lists\n    for sublist in input_list[1:]:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_list = sublist\n    \n    return (max_length, max_list)\n\n\n"], "prompt_tokens": [1902], "completion_tokens": [985], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_393_max_length_list"}
{"name": "mbpp_272_rear_extract", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rear_extract", "test": "def check(candidate):\n    assert candidate([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n    assert candidate([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\n    assert candidate([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\n\ndef test_check():\n    check(rear_extract)\n\ntest_check()\n", "sample_io": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"], "source_codes": ["def rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]"], "responses": ["\nfrom typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n\n\n"], "prompt_tokens": [1883], "completion_tokens": [1079], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_272_rear_extract"}
{"name": "mbpp_564_count_Pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Pairs", "test": "def check(candidate):\n    assert candidate([1, 2, 1], 3) == 2\n    assert candidate([1, 1, 1, 1], 4) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 10\n\ndef test_check():\n    check(count_Pairs)\n\ntest_check()\n", "sample_io": ["assert count_Pairs([1, 2, 1], 3) == 2"], "source_codes": ["def count_Pairs(arr: List[int], n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return 0\n    \n    # Count frequency of each element\n    freq_count = Counter(arr)\n    \n    # Calculate total possible pairs\n    total_pairs = n * (n - 1) // 2\n    \n    # Calculate pairs with equal elements\n    equal_pairs = 0\n    for freq in freq_count.values():\n        if freq > 1:\n            equal_pairs += freq * (freq - 1) // 2\n    \n    # Return unequal pairs\n    return total_pairs - equal_pairs"], "responses": ["\nfrom typing import List\nfrom collections import Counter\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return 0\n    \n    # Count frequency of each element\n    freq_count = Counter(arr)\n    \n    # Calculate total possible pairs\n    total_pairs = n * (n - 1) // 2\n    \n    # Calculate pairs with equal elements\n    equal_pairs = 0\n    for freq in freq_count.values():\n        if freq > 1:\n            equal_pairs += freq * (freq - 1) // 2\n    \n    # Return unequal pairs\n    return total_pairs - equal_pairs\n\n\n"], "prompt_tokens": [1868], "completion_tokens": [981], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_564_count_Pairs"}
{"name": "mbpp_438_count_bidirectional", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to count bidirectional tuple pairs.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_bidirectional", "test": "def check(candidate):\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3\n    assert candidate([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4\n\ndef test_check():\n    check(count_bidirectional)\n\ntest_check()\n", "sample_io": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3"], "source_codes": ["def count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    \n    # Count frequency of each tuple\n    freq = Counter(test_list)\n    counted = set()\n    total_pairs = 0\n    \n    for tup in freq:\n        if tup in counted:\n            continue\n            \n        reverse_tup = (tup[1], tup[0])\n        \n        if tup == reverse_tup:\n            # For tuples like (a, a), use combination formula n*(n-1)/2\n            n = freq[tup]\n            total_pairs += n * (n - 1) // 2\n        else:\n            # For regular tuples, multiply counts of tuple and its reverse\n            if reverse_tup in freq:\n                total_pairs += freq[tup] * freq[reverse_tup]\n                counted.add(reverse_tup)  # Avoid double counting\n        \n        counted.add(tup)\n    \n    return total_pairs"], "responses": ["\nfrom typing import List, Tuple\nfrom collections import Counter\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    \n    # Count frequency of each tuple\n    freq = Counter(test_list)\n    counted = set()\n    total_pairs = 0\n    \n    for tup in freq:\n        if tup in counted:\n            continue\n            \n        reverse_tup = (tup[1], tup[0])\n        \n        if tup == reverse_tup:\n            # For tuples like (a, a), use combination formula n*(n-1)/2\n            n = freq[tup]\n            total_pairs += n * (n - 1) // 2\n        else:\n            # For regular tuples, multiply counts of tuple and its reverse\n            if reverse_tup in freq:\n                total_pairs += freq[tup] * freq[reverse_tup]\n                counted.add(reverse_tup)  # Avoid double counting\n        \n        counted.add(tup)\n    \n    return total_pairs\n\n\n"], "prompt_tokens": [2112], "completion_tokens": [1211], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_438_count_bidirectional"}
{"name": "mbpp_640_remove_parenthesis", "language": "Python3", "prompt": "from typing import List\n\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n\tWrite a function to remove the parenthesis and what is inbetween them from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_parenthesis", "test": "def check(candidate):\n    assert candidate(['python (chrome)']) == 'python'\n    assert candidate(['string(.abc)']) == 'string'\n    assert candidate(['alpha(num)']) == 'alpha'\n\ndef test_check():\n    check(remove_parenthesis)\n\ntest_check()\n", "sample_io": ["assert remove_parenthesis(['python (chrome)']) == 'python'"], "source_codes": ["def remove_parenthesis(items: List[str]) -> str:\n    result = []\n    \n    for item in items:\n        stack = []\n        remove_ranges = []\n        \n        # Find all parenthesis ranges to remove\n        for i, char in enumerate(item):\n            if char == '(':\n                stack.append(i)\n            elif char == ')' and stack:\n                start = stack.pop()\n                remove_ranges.append((start, i))\n        \n        # Sort ranges by start position\n        remove_ranges.sort()\n        \n        # Merge overlapping ranges\n        merged_ranges = []\n        for start, end in remove_ranges:\n            if merged_ranges and start <= merged_ranges[-1][1]:\n                merged_ranges[-1] = (merged_ranges[-1][0], max(merged_ranges[-1][1], end))\n            else:\n                merged_ranges.append((start, end))\n        \n        # Build result string by skipping characters in removed ranges\n        new_chars = []\n        i = 0\n        range_index = 0\n        \n        while i < len(item):\n            if range_index < len(merged_ranges) and i >= merged_ranges[range_index][0]:\n                # Skip this range\n                i = merged_ranges[range_index][1] + 1\n                range_index += 1\n            else:\n                new_chars.append(item[i])\n                i += 1\n        \n        # Join and strip trailing/leading whitespace\n        processed_item = ''.join(new_chars).strip()\n        result.append(processed_item)\n    \n    return ' '.join(result)"], "responses": ["\ndef remove_parenthesis(items: List[str]) -> str:\n    result = []\n    \n    for item in items:\n        stack = []\n        remove_ranges = []\n        \n        # Find all parenthesis ranges to remove\n        for i, char in enumerate(item):\n            if char == '(':\n                stack.append(i)\n            elif char == ')' and stack:\n                start = stack.pop()\n                remove_ranges.append((start, i))\n        \n        # Sort ranges by start position\n        remove_ranges.sort()\n        \n        # Merge overlapping ranges\n        merged_ranges = []\n        for start, end in remove_ranges:\n            if merged_ranges and start <= merged_ranges[-1][1]:\n                merged_ranges[-1] = (merged_ranges[-1][0], max(merged_ranges[-1][1], end))\n            else:\n                merged_ranges.append((start, end))\n        \n        # Build result string by skipping characters in removed ranges\n        new_chars = []\n        i = 0\n        range_index = 0\n        \n        while i < len(item):\n            if range_index < len(merged_ranges) and i >= merged_ranges[range_index][0]:\n                # Skip this range\n                i = merged_ranges[range_index][1] + 1\n                range_index += 1\n            else:\n                new_chars.append(item[i])\n                i += 1\n        \n        # Join and strip trailing/leading whitespace\n        processed_item = ''.join(new_chars).strip()\n        result.append(processed_item)\n    \n    return ' '.join(result)\n\n\n"], "prompt_tokens": [3723], "completion_tokens": [2303], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_640_remove_parenthesis"}
{"name": "mbpp_72_dif_Square", "language": "Python3", "prompt": "def dif_Square(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dif_Square", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(10) == False\n    assert candidate(15) == True\n\ndef test_check():\n    check(dif_Square)\n\ntest_check()\n", "sample_io": ["assert dif_Square(5) == True"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 237: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_72_dif_Square"}
{"name": "mbpp_448_cal_sum", "language": "Python3", "prompt": "def cal_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of perrin numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cal_sum", "test": "def check(candidate):\n    assert candidate(9) == 49\n    assert candidate(10) == 66\n    assert candidate(11) == 88\n\ndef test_check():\n    check(cal_sum)\n\ntest_check()\n", "sample_io": ["assert cal_sum(9) == 49"], "source_codes": ["def cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Initialize the first three Perrin numbers\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    \n    # Calculate Perrin numbers and their sum\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2\n    \n    for i in range(3, n + 1):\n        pn = p0 + p1\n        total_sum += pn\n        p0, p1, p2 = p1, p2, pn\n    \n    return total_sum"], "responses": ["\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Initialize the first three Perrin numbers\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    \n    # Calculate Perrin numbers and their sum\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2\n    \n    for i in range(3, n + 1):\n        pn = p0 + p1\n        total_sum += pn\n        p0, p1, p2 = p1, p2, pn\n    \n    return total_sum\n\n\n"], "prompt_tokens": [1138], "completion_tokens": [1238], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_448_cal_sum"}
{"name": "mbpp_96_divisor", "language": "Python3", "prompt": "def divisor(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of divisors of a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisor", "test": "def check(candidate):\n    assert candidate(15) == 4\n    assert candidate(12) == 6\n    assert candidate(9) == 3\n\ndef test_check():\n    check(divisor)\n\ntest_check()\n", "sample_io": ["assert divisor(15) == 4"], "source_codes": ["def divisor(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    n = abs(n)\n    pair_count = 0\n    sqrt_n = int(n ** 0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            pair_count += 1\n    \n    if sqrt_n * sqrt_n == n:\n        return 2 * pair_count - 1\n    else:\n        return 2 * pair_count"], "responses": ["\ndef divisor(n: int) -> int:\n    if n == 1:\n        return 1\n    \n    n = abs(n)\n    pair_count = 0\n    sqrt_n = int(n ** 0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            pair_count += 1\n    \n    if sqrt_n * sqrt_n == n:\n        return 2 * pair_count - 1\n    else:\n        return 2 * pair_count\n\n\n"], "prompt_tokens": [2001], "completion_tokens": [1531], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_96_divisor"}
{"name": "mbpp_296_get_Inv_Count", "language": "Python3", "prompt": "from typing import List\n\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count inversions in an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Inv_Count", "test": "def check(candidate):\n    assert candidate([1, 20, 6, 4, 5]) == 5\n    assert candidate([1, 2, 1]) == 1\n    assert candidate([1, 2, 5, 6, 1]) == 3\n\ndef test_check():\n    check(get_Inv_Count)\n\ntest_check()\n", "sample_io": ["assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"], "source_codes": ["def get_Inv_Count(arr: List[int]) -> int:\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back the merged elements\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    # Create a temporary array for merging\n    temp_arr = [0] * len(arr)\n    # Make a copy of the original array to avoid modifying it\n    arr_copy = arr[:]\n    \n    return merge_sort_and_count(arr_copy, temp_arr, 0, len(arr) - 1)"], "responses": ["\ndef get_Inv_Count(arr: List[int]) -> int:\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back the merged elements\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    # Create a temporary array for merging\n    temp_arr = [0] * len(arr)\n    # Make a copy of the original array to avoid modifying it\n    arr_copy = arr[:]\n    \n    return merge_sort_and_count(arr_copy, temp_arr, 0, len(arr) - 1)\n\n\n"], "prompt_tokens": [1378], "completion_tokens": [1875], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_296_get_Inv_Count"}
{"name": "mbpp_57_find_Max_Num", "language": "Python3", "prompt": "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest number that can be formed with the given list of digits.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Max_Num", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 321\n    assert candidate([4, 5, 6, 1]) == 6541\n    assert candidate([1, 2, 3, 9]) == 9321\n\ndef test_check():\n    check(find_Max_Num)\n\ntest_check()\n", "sample_io": ["assert find_Max_Num([1, 2, 3]) == 321"], "source_codes": ["def find_Max_Num(arr: List[int]) -> int:\n    # Check if input array is empty\n    if not arr:\n        return 0\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Handle special case where all digits are 0\n    if arr[0] == 0:\n        return 0\n    \n    # Convert all digits to strings for concatenation\n    str_digits = [str(digit) for digit in arr]\n    \n    # Join all string digits to form the largest number string\n    max_num_str = ''.join(str_digits)\n    \n    # Convert the final string back to integer and return\n    return int(max_num_str)"], "responses": ["\nfrom typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    # Check if input array is empty\n    if not arr:\n        return 0\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Handle special case where all digits are 0\n    if arr[0] == 0:\n        return 0\n    \n    # Convert all digits to strings for concatenation\n    str_digits = [str(digit) for digit in arr]\n    \n    # Join all string digits to form the largest number string\n    max_num_str = ''.join(str_digits)\n    \n    # Convert the final string back to integer and return\n    return int(max_num_str)\n\n\n"], "prompt_tokens": [1663], "completion_tokens": [1074], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_57_find_Max_Num"}
{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["def cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Find the cumulative sum of all the values that are present in the given list of lists.\n    \n    Args:\n        test_list: A list of lists containing integers\n        \n    Returns:\n        The cumulative sum of all integers in the nested lists\n    \"\"\"\n    # Flatten the list of lists and sum all elements\n    return sum(element for sublist in test_list for element in sublist)"], "responses": ["\nfrom typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Find the cumulative sum of all the values that are present in the given list of lists.\n    \n    Args:\n        test_list: A list of lists containing integers\n        \n    Returns:\n        The cumulative sum of all integers in the nested lists\n    \"\"\"\n    # Flatten the list of lists and sum all elements\n    return sum(element for sublist in test_list for element in sublist)\n\n\n"], "prompt_tokens": [1756], "completion_tokens": [997], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["def nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function to compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]"], "responses": ["\nfrom typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function to compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n\n\n"], "prompt_tokens": [1795], "completion_tokens": [836], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["def left_rotate(n: int, d: int) -> int:\n    # Handle the case where d is greater than 32\n    d = d % 32\n    \n    # If d is 0, no rotation is needed\n    if d == 0:\n        return n\n    \n    # Extract the leftmost d bits that will overflow\n    overflow_bits = n >> (32 - d)\n    \n    # Shift the entire number left by d positions\n    shifted_number = (n << d) & 0xFFFFFFFF\n    \n    # Combine the shifted number with the wrapped-around bits\n    result = shifted_number | overflow_bits\n    \n    return result"], "responses": ["\ndef left_rotate(n: int, d: int) -> int:\n    # Handle the case where d is greater than 32\n    d = d % 32\n    \n    # If d is 0, no rotation is needed\n    if d == 0:\n        return n\n    \n    # Extract the leftmost d bits that will overflow\n    overflow_bits = n >> (32 - d)\n    \n    # Shift the entire number left by d positions\n    shifted_number = (n << d) & 0xFFFFFFFF\n    \n    # Combine the shifted number with the wrapped-around bits\n    result = shifted_number | overflow_bits\n    \n    return result\n\n\n"], "prompt_tokens": [1784], "completion_tokens": [1404], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": ["def lps(str: str) -> int:\n    n = len(str)\n    \n    # Handle edge case of empty string\n    if n == 0:\n        return 0\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length 2 to n\n    for cl in range(2, n + 1):  # cl is the chain length\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            \n            if str[i] == str[j]:\n                if cl == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"], "responses": ["\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Handle edge case of empty string\n    if n == 0:\n        return 0\n    \n    # Initialize DP table\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length 2 to n\n    for cl in range(2, n + 1):  # cl is the chain length\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            \n            if str[i] == str[j]:\n                if cl == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n\n\n"], "prompt_tokens": [1736], "completion_tokens": [1024], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_247_lps"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["def toggle_middle_bits(n: int) -> int:\n    # Handle edge cases where n is 0 or 1\n    if n <= 1:\n        return n\n    \n    # Find the position of the most significant bit (MSB)\n    bit_length = n.bit_length()\n    \n    # If the number has less than 3 bits, no middle bits to toggle\n    if bit_length < 3:\n        return n\n    \n    # Create a mask with all 1s for the middle bits\n    # This will be a sequence of (bit_length - 2) ones, positioned correctly\n    mask = ((1 << (bit_length - 2)) - 1) << 1\n    \n    # Toggle the middle bits using XOR\n    return n ^ mask"], "responses": ["\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases where n is 0 or 1\n    if n <= 1:\n        return n\n    \n    # Find the position of the most significant bit (MSB)\n    bit_length = n.bit_length()\n    \n    # If the number has less than 3 bits, no middle bits to toggle\n    if bit_length < 3:\n        return n\n    \n    # Create a mask with all 1s for the middle bits\n    # This will be a sequence of (bit_length - 2) ones, positioned correctly\n    mask = ((1 << (bit_length - 2)) - 1) << 1\n    \n    # Toggle the middle bits using XOR\n    return n ^ mask\n\n\n"], "prompt_tokens": [2171], "completion_tokens": [1241], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["def tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)"], "responses": ["\nfrom typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n\n\n"], "prompt_tokens": [1434], "completion_tokens": [596], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["def Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]"], "responses": ["\nfrom typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]\n\n\n"], "prompt_tokens": [1807], "completion_tokens": [847], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["import math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)"], "responses": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n\n"], "prompt_tokens": [1876], "completion_tokens": [1053], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
{"name": "mbpp_167_next_power_of_2", "language": "Python3", "prompt": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest power of 2 greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_power_of_2", "test": "def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 8\n    assert candidate(17) == 32\n\ndef test_check():\n    check(next_power_of_2)\n\ntest_check()\n", "sample_io": ["assert next_power_of_2(0) == 1"], "source_codes": ["def next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 1\n    \n    # Check if n is already a power of 2\n    if (n & (n - 1)) == 0:\n        return n\n    \n    # Find the next power of 2\n    # Using bit_length to find the position of the most significant bit\n    return 1 << (n.bit_length())"], "responses": ["\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 1\n    \n    # Check if n is already a power of 2\n    if (n & (n - 1)) == 0:\n        return n\n    \n    # Find the next power of 2\n    # Using bit_length to find the position of the most significant bit\n    return 1 << (n.bit_length())\n\n\n"], "prompt_tokens": [1387], "completion_tokens": [909], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_167_next_power_of_2"}
{"name": "mbpp_756_text_match_zero_one", "language": "Python3", "prompt": "def text_match_zero_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_zero_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('dsabbbba') == True\n    assert candidate('asbbbba') == False\n    assert candidate('abaaa') == True\n\ndef test_check():\n    check(text_match_zero_one)\n\ntest_check()\n", "sample_io": ["assert text_match_zero_one('ac') == False"], "source_codes": ["import re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return re.search(pattern, text) is not None"], "responses": ["\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return re.search(pattern, text) is not None\n\n\n"], "prompt_tokens": [1787], "completion_tokens": [810], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_756_text_match_zero_one"}
{"name": "mbpp_633_pair_xor_Sum", "language": "Python3", "prompt": "from typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of xor of all pairs of numbers in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_xor_Sum", "test": "def check(candidate):\n    assert candidate([5, 9, 7, 6], 4) == 47\n    assert candidate([7, 3, 5], 3) == 12\n    assert candidate([7, 3], 2) == 4\n\ndef test_check():\n    check(pair_xor_Sum)\n\ntest_check()\n", "sample_io": ["assert pair_xor_Sum([5, 9, 7, 6], 4) == 47"], "source_codes": ["def pair_xor_Sum(arr: List[int], n: int) -> int:\n    # Edge case: if less than 2 elements, no pairs exist\n    if n < 2:\n        return 0\n    \n    # Find the maximum element to determine number of bits needed\n    max_val = max(arr) if arr else 0\n    \n    # If all elements are zero, XOR sum will be zero\n    if max_val == 0:\n        return 0\n    \n    # Determine the number of bits required\n    max_bits = max_val.bit_length()\n    \n    result = 0\n    \n    # For each bit position\n    for i in range(max_bits):\n        # Count how many numbers have the ith bit set\n        count = 0\n        for num in arr:\n            if num & (1 << i):\n                count += 1\n        \n        # Number of pairs with different bits at position i\n        # count numbers have bit set, (n-count) don't\n        # So count * (n-count) pairs have different bits\n        # Each such pair contributes 2^i to the total XOR sum\n        result += count * (n - count) * (1 << i)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    # Edge case: if less than 2 elements, no pairs exist\n    if n < 2:\n        return 0\n    \n    # Find the maximum element to determine number of bits needed\n    max_val = max(arr) if arr else 0\n    \n    # If all elements are zero, XOR sum will be zero\n    if max_val == 0:\n        return 0\n    \n    # Determine the number of bits required\n    max_bits = max_val.bit_length()\n    \n    result = 0\n    \n    # For each bit position\n    for i in range(max_bits):\n        # Count how many numbers have the ith bit set\n        count = 0\n        for num in arr:\n            if num & (1 << i):\n                count += 1\n        \n        # Number of pairs with different bits at position i\n        # count numbers have bit set, (n-count) don't\n        # So count * (n-count) pairs have different bits\n        # Each such pair contributes 2^i to the total XOR sum\n        result += count * (n - count) * (1 << i)\n    \n    return result\n\n\n"], "prompt_tokens": [2195], "completion_tokens": [1504], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_633_pair_xor_Sum"}
{"name": "mbpp_458_rectangle_area", "language": "Python3", "prompt": "def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to find the area of a rectangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rectangle_area", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(10, 5) == 50\n    assert candidate(4, 2) == 8\n\ndef test_check():\n    check(rectangle_area)\n\ntest_check()\n", "sample_io": ["assert rectangle_area(10, 20) == 200"], "source_codes": ["def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b"], "responses": ["\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n\n\n"], "prompt_tokens": [1471], "completion_tokens": [705], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_458_rectangle_area"}
{"name": "mbpp_738_geometric_sum", "language": "Python3", "prompt": "def geometric_sum(n: int) -> float:\n    \"\"\"\n\tWrite a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "geometric_sum", "test": "def check(candidate):\n    assert candidate(7) == 1.9921875\n    assert candidate(4) == 1.9375\n    assert candidate(8) == 1.99609375\n\ndef test_check():\n    check(geometric_sum)\n\ntest_check()\n", "sample_io": ["assert geometric_sum(7) == 1.9921875"], "source_codes": ["def geometric_sum(n: int) -> float:\n    if n <= 0:\n        return 0.0\n    elif n == 1:\n        return 1.0\n    else:\n        return 1 / (2 ** (n - 1)) + geometric_sum(n - 1)"], "responses": ["\ndef geometric_sum(n: int) -> float:\n    if n <= 0:\n        return 0.0\n    elif n == 1:\n        return 1.0\n    else:\n        return 1 / (2 ** (n - 1)) + geometric_sum(n - 1)\n\n\n"], "prompt_tokens": [2489], "completion_tokens": [1291], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_738_geometric_sum"}
{"name": "mbpp_426_filter_oddnumbers", "language": "Python3", "prompt": "from typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to filter odd numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_oddnumbers", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 20, 45, 67, 84, 93]) == [45, 67, 93]\n    assert candidate([5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3]\n\ndef test_check():\n    check(filter_oddnumbers)\n\ntest_check()\n", "sample_io": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"], "source_codes": ["def filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]"], "responses": ["\nfrom typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\n\n"], "prompt_tokens": [1846], "completion_tokens": [911], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_426_filter_oddnumbers"}
{"name": "mbpp_437_remove_odd", "language": "Python3", "prompt": "def remove_odd(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove odd characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate('python') == 'yhn'\n    assert candidate('program') == 'rga'\n    assert candidate('language') == 'agae'\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd('python') == 'yhn'"], "source_codes": ["def remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join(str1[i] for i in range(1, len(str1), 2))"], "responses": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join(str1[i] for i in range(1, len(str1), 2))\n\n\n"], "prompt_tokens": [2789], "completion_tokens": [1245], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_437_remove_odd"}
{"name": "mbpp_227_min_of_three", "language": "Python3", "prompt": "def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find minimum of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_of_three", "test": "def check(candidate):\n    assert candidate(10, 20, 0) == 0\n    assert candidate(19, 15, 18) == 15\n    assert candidate(-10, -20, -30) == -30\n\ndef test_check():\n    check(min_of_three)\n\ntest_check()\n", "sample_io": ["assert min_of_three(10, 20, 0) == 0"], "source_codes": ["def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    # Compare the first two numbers\n    min_ab = a if a < b else b\n    \n    # Compare the result with the third number\n    minimum = min_ab if min_ab < c else c\n    \n    return minimum"], "responses": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    # Compare the first two numbers\n    min_ab = a if a < b else b\n    \n    # Compare the result with the third number\n    minimum = min_ab if min_ab < c else c\n    \n    return minimum\n\n\n"], "prompt_tokens": [1461], "completion_tokens": [1033], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_227_min_of_three"}
{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["def count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')"], "responses": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n\n\n"], "prompt_tokens": [1590], "completion_tokens": [679], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["import re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))"], "responses": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1711], "completion_tokens": [774], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["def count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 0:\n        return 0\n    if k == 1:\n        # With only one color, we can only have at most 2 posts\n        return 1 if n <= 2 else 0\n    \n    # For n >= 2, use dynamic programming\n    # same: number of ways where the last two posts have the same color\n    # diff: number of ways where the last two posts have different colors\n    same = k  # For n=2, all k ways of same color are valid\n    diff = k * (k - 1)  # For n=2, k*(k-1) ways of different colors\n    \n    # For each post from 3 to n\n    for i in range(3, n + 1):\n        # New same is previous diff (we can only add same color if previous was different)\n        new_same = diff\n        # New diff is (same + diff) * (k-1) (we can add any of the other k-1 colors)\n        new_diff = (same + diff) * (k - 1)\n        \n        same, diff = new_same, new_diff\n    \n    return same + diff"], "responses": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 0:\n        return 0\n    if k == 1:\n        # With only one color, we can only have at most 2 posts\n        return 1 if n <= 2 else 0\n    \n    # For n >= 2, use dynamic programming\n    # same: number of ways where the last two posts have the same color\n    # diff: number of ways where the last two posts have different colors\n    same = k  # For n=2, all k ways of same color are valid\n    diff = k * (k - 1)  # For n=2, k*(k-1) ways of different colors\n    \n    # For each post from 3 to n\n    for i in range(3, n + 1):\n        # New same is previous diff (we can only add same color if previous was different)\n        new_same = diff\n        # New diff is (same + diff) * (k-1) (we can add any of the other k-1 colors)\n        new_diff = (same + diff) * (k - 1)\n        \n        same, diff = new_same, new_diff\n    \n    return same + diff\n\n\n"], "prompt_tokens": [1623], "completion_tokens": [1433], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["def find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \"\"\"\n    # Handle edge case: if array is empty, return 1 % n\n    if not arr:\n        return 1 % n if n > 1 else 0\n    \n    result = 1\n    for num in arr:\n        # Take modulo at each step to prevent overflow and handle negative numbers\n        result = (result * (num % n)) % n\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \"\"\"\n    # Handle edge case: if array is empty, return 1 % n\n    if not arr:\n        return 1 % n if n > 1 else 0\n    \n    result = 1\n    for num in arr:\n        # Take modulo at each step to prevent overflow and handle negative numbers\n        result = (result * (num % n)) % n\n    \n    return result\n\n\n"], "prompt_tokens": [1736], "completion_tokens": [1029], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["def check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_tup:\n        return False\n    \n    # Check if K is in the list using the 'in' operator\n    return K in test_tup"], "responses": ["\nfrom typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    # Handle edge case of empty list\n    if not test_tup:\n        return False\n    \n    # Check if K is in the list using the 'in' operator\n    return K in test_tup\n\n\n"], "prompt_tokens": [1852], "completion_tokens": [891], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["def is_Monotonic(A: List[int]) -> bool:\n    # Handle edge cases\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is non-decreasing\n    def is_non_decreasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n    \n    # Check if array is non-increasing\n    def is_non_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                return False\n        return True\n    \n    # Determine monotonicity based on first and last elements\n    if A[0] <= A[-1]:\n        return is_non_decreasing(A)\n    else:\n        return is_non_increasing(A)"], "responses": ["\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    # Handle edge cases\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is non-decreasing\n    def is_non_decreasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n    \n    # Check if array is non-increasing\n    def is_non_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                return False\n        return True\n    \n    # Determine monotonicity based on first and last elements\n    if A[0] <= A[-1]:\n        return is_non_decreasing(A)\n    else:\n        return is_non_increasing(A)\n\n\n"], "prompt_tokens": [1519], "completion_tokens": [983], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": [""], "responses": ["'gbk' codec can't encode character '\\xb2' in position 156: illegal multibyte sequence"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": ["def div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    # Check if lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Handle empty lists\n    if len(nums1) == 0:\n        return []\n    \n    # Perform element-wise division\n    result = []\n    for i in range(len(nums1)):\n        if nums2[i] == 0:\n            if nums1[i] > 0:\n                result.append(float('inf'))\n            elif nums1[i] < 0:\n                result.append(float('-inf'))\n            else:\n                result.append(float('nan'))\n        else:\n            result.append(float(nums1[i] / nums2[i]))\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    # Check if lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Handle empty lists\n    if len(nums1) == 0:\n        return []\n    \n    # Perform element-wise division\n    result = []\n    for i in range(len(nums1)):\n        if nums2[i] == 0:\n            if nums1[i] > 0:\n                result.append(float('inf'))\n            elif nums1[i] < 0:\n                result.append(float('-inf'))\n            else:\n                result.append(float('nan'))\n        else:\n            result.append(float(nums1[i] / nums2[i]))\n    \n    return result\n\n\n"], "prompt_tokens": [1965], "completion_tokens": [1250], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_618_div_list"}
{"name": "mbpp_421_concatenate_tuple", "language": "Python3", "prompt": "from typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n\tWrite a function to concatenate each element of tuple by the delimiter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "concatenate_tuple", "test": "def check(candidate):\n    assert candidate(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'\n    assert candidate(('QWE', 'is', 4, 'RTY')) == 'QWE-is-4-RTY'\n    assert candidate(('ZEN', 'is', 4, 'OP')) == 'ZEN-is-4-OP'\n\ndef test_check():\n    check(concatenate_tuple)\n\ntest_check()\n", "sample_io": ["assert concatenate_tuple(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'"], "source_codes": ["def concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    delimiter = \"-\"\n    return delimiter.join(str(item) for item in test_tup)"], "responses": ["\nfrom typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    delimiter = \"-\"\n    return delimiter.join(str(item) for item in test_tup)\n\n\n"], "prompt_tokens": [3338], "completion_tokens": [1169], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_421_concatenate_tuple"}
{"name": "mbpp_750_add_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n\tWrite a function to add the given tuple to the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_tuple", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    assert candidate([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]\n    assert candidate([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]\n\ndef test_check():\n    check(add_tuple)\n\ntest_check()\n", "sample_io": ["assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"], "source_codes": ["def add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert tuple to list and concatenate with the original list\n    return test_list + list(test_tup)"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert tuple to list and concatenate with the original list\n    return test_list + list(test_tup)\n\n\n"], "prompt_tokens": [1766], "completion_tokens": [845], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_750_add_tuple"}
{"name": "mbpp_304_find_Element", "language": "Python3", "prompt": "from typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    \"\"\"\n\tWrite a python function to find element at a given index after number of rotations.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3\n    assert candidate([1, 2, 3, 4], [[0, 1], [0, 2]], 1, 2) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [[0, 1], [0, 2]], 1, 1) == 1\n\ndef test_check():\n    check(find_Element)\n\ntest_check()\n", "sample_io": ["assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3"], "source_codes": ["def find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Process each range\n    for start, end in ranges:\n        # Validate range bounds\n        if start < 0 or end >= len(result_arr) or start > end:\n            continue\n            \n        # Extract subarray\n        subarray = result_arr[start:end+1]\n        subarray_len = len(subarray)\n        \n        # Handle edge cases\n        if subarray_len <= 1 or rotations == 0:\n            continue\n            \n        # Calculate effective rotations using modulo\n        effective_rotations = rotations % subarray_len\n        \n        # Perform right rotation: last 'effective_rotations' elements move to front\n        rotated_subarray = subarray[-effective_rotations:] + subarray[:-effective_rotations]\n        \n        # Place rotated subarray back into result array\n        result_arr[start:end+1] = rotated_subarray\n    \n    # Return element at the specified index\n    return result_arr[index]"], "responses": ["\nfrom typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Process each range\n    for start, end in ranges:\n        # Validate range bounds\n        if start < 0 or end >= len(result_arr) or start > end:\n            continue\n            \n        # Extract subarray\n        subarray = result_arr[start:end+1]\n        subarray_len = len(subarray)\n        \n        # Handle edge cases\n        if subarray_len <= 1 or rotations == 0:\n            continue\n            \n        # Calculate effective rotations using modulo\n        effective_rotations = rotations % subarray_len\n        \n        # Perform right rotation: last 'effective_rotations' elements move to front\n        rotated_subarray = subarray[-effective_rotations:] + subarray[:-effective_rotations]\n        \n        # Place rotated subarray back into result array\n        result_arr[start:end+1] = rotated_subarray\n    \n    # Return element at the specified index\n    return result_arr[index]\n\n\n"], "prompt_tokens": [7489], "completion_tokens": [8944], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_304_find_Element"}
{"name": "mbpp_740_tuple_to_dict", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_dict", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }\n    assert candidate((1, 2, 3, 4, 5, 6)) == { 1: 2, 3: 4, 5: 6 }\n    assert candidate((7, 8, 9, 10, 11, 12)) == { 7: 8, 9: 10, 11: 12 }\n\ndef test_check():\n    check(tuple_to_dict)\n\ntest_check()\n", "sample_io": ["assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }"], "source_codes": ["def tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    result = {}\n    \n    # Process adjacent pairs with step size of 2\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    \n    return result"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    result = {}\n    \n    # Process adjacent pairs with step size of 2\n    for i in range(0, len(test_tup) - 1, 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    \n    return result\n\n\n"], "prompt_tokens": [2097], "completion_tokens": [1118], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_740_tuple_to_dict"}
{"name": "mbpp_627_find_First_Missing", "language": "Python3", "prompt": "from typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest missing number from a sorted list of natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_First_Missing", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3]) == 4\n    assert candidate([0, 1, 2, 6, 9]) == 3\n    assert candidate([2, 3, 5, 8, 9]) == 0\n\ndef test_check():\n    check(find_First_Missing)\n\ntest_check()\n", "sample_io": ["assert find_First_Missing([0, 1, 2, 3]) == 4"], "source_codes": ["def find_First_Missing(array: List[int]) -> int:\n    # Handle edge case of empty array\n    if not array:\n        return 0\n    \n    # Handle case where array doesn't start with 0\n    if array[0] != 0:\n        return 0\n    \n    # Binary search to find the first missing number\n    low, high = 0, len(array) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        \n        # If array[mid] equals mid, then the missing number is in the right half\n        if array[mid] == mid:\n            low = mid + 1\n        else:\n            # If array[mid] doesn't equal mid, the missing number is at mid or in the left half\n            high = mid\n    \n    # After the loop, low is the first index where array[low] != low\n    # So the missing number is low\n    # But we need to check if all numbers before low are present\n    if array[low] == low:\n        return low + 1\n    else:\n        return low"], "responses": ["\ndef find_First_Missing(array: List[int]) -> int:\n    # Handle edge case of empty array\n    if not array:\n        return 0\n    \n    # Handle case where array doesn't start with 0\n    if array[0] != 0:\n        return 0\n    \n    # Binary search to find the first missing number\n    low, high = 0, len(array) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        \n        # If array[mid] equals mid, then the missing number is in the right half\n        if array[mid] == mid:\n            low = mid + 1\n        else:\n            # If array[mid] doesn't equal mid, the missing number is at mid or in the left half\n            high = mid\n    \n    # After the loop, low is the first index where array[low] != low\n    # So the missing number is low\n    # But we need to check if all numbers before low are present\n    if array[low] == low:\n        return low + 1\n    else:\n        return low\n\n\n"], "prompt_tokens": [2090], "completion_tokens": [1418], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_627_find_First_Missing"}
{"name": "mbpp_294_max_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 5\n    assert candidate(['Python', 15, 20, 25]) == 25\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 50\n\ndef test_check():\n    check(max_val)\n\ntest_check()\n", "sample_io": ["assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"], "source_codes": ["def max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    # Initialize an empty list to store numeric values\n    numeric_values = []\n    \n    # Iterate through each element in the input list\n    for element in listval:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            numeric_values.append(element)\n    \n    # Check if no numeric values were found\n    if not numeric_values:\n        raise ValueError(\"No numeric values found in the list\")\n    \n    # Return the maximum value from the numeric values\n    return max(numeric_values)"], "responses": ["\nfrom typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    # Initialize an empty list to store numeric values\n    numeric_values = []\n    \n    # Iterate through each element in the input list\n    for element in listval:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            numeric_values.append(element)\n    \n    # Check if no numeric values were found\n    if not numeric_values:\n        raise ValueError(\"No numeric values found in the list\")\n    \n    # Return the maximum value from the numeric values\n    return max(numeric_values)\n\n\n"], "prompt_tokens": [1751], "completion_tokens": [891], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_294_max_val"}
{"name": "mbpp_165_count_char_position", "language": "Python3", "prompt": "def count_char_position(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_char_position", "test": "def check(candidate):\n    assert candidate('xbcefg') == 2\n    assert candidate('ABcED') == 3\n    assert candidate('AbgdeF') == 5\n\ndef test_check():\n    check(count_char_position)\n\ntest_check()\n", "sample_io": ["assert count_char_position('xbcefg') == 2"], "source_codes": ["def count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    for i, char in enumerate(str1):\n        if char.isalpha():\n            # Calculate the position of the character in the alphabet (a/A=1, b/B=2, etc.)\n            alphabet_position = ord(char.lower()) - ord('a') + 1\n            # Check if the zero-based string index matches the alphabet position minus 1\n            if i + 1 == alphabet_position:\n                count += 1\n    return count"], "responses": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    for i, char in enumerate(str1):\n        if char.isalpha():\n            # Calculate the position of the character in the alphabet (a/A=1, b/B=2, etc.)\n            alphabet_position = ord(char.lower()) - ord('a') + 1\n            # Check if the zero-based string index matches the alphabet position minus 1\n            if i + 1 == alphabet_position:\n                count += 1\n    return count\n\n\n"], "prompt_tokens": [2163], "completion_tokens": [1315], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_165_count_char_position"}
{"name": "mbpp_589_perfect_squares", "language": "Python3", "prompt": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find perfect squares between two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perfect_squares", "test": "def check(candidate):\n    assert candidate(1, 30) == [1, 4, 9, 16, 25]\n    assert candidate(50, 100) == [64, 81, 100]\n    assert candidate(100, 200) == [100, 121, 144, 169, 196]\n\ndef test_check():\n    check(perfect_squares)\n\ntest_check()\n", "sample_io": ["assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"], "source_codes": ["import math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    # Handle edge cases\n    if b < 0:\n        return []\n    \n    # Determine the starting and ending values of k\n    start_k = max(0, math.ceil(math.sqrt(max(0, a))))\n    end_k = math.floor(math.sqrt(b))\n    \n    # If start_k > end_k, there are no perfect squares in the range\n    if start_k > end_k:\n        return []\n    \n    # Collect all perfect squares in the range\n    result = []\n    for k in range(start_k, end_k + 1):\n        square = k * k\n        if a <= square <= b:\n            result.append(square)\n    \n    return result"], "responses": ["\nimport math\nfrom typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    # Handle edge cases\n    if b < 0:\n        return []\n    \n    # Determine the starting and ending values of k\n    start_k = max(0, math.ceil(math.sqrt(max(0, a))))\n    end_k = math.floor(math.sqrt(b))\n    \n    # If start_k > end_k, there are no perfect squares in the range\n    if start_k > end_k:\n        return []\n    \n    # Collect all perfect squares in the range\n    result = []\n    for k in range(start_k, end_k + 1):\n        square = k * k\n        if a <= square <= b:\n            result.append(square)\n    \n    return result\n\n\n"], "prompt_tokens": [2330], "completion_tokens": [1419], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_589_perfect_squares"}
{"name": "mbpp_744_check_none", "language": "Python3", "prompt": "from typing import Any\n\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuple has any none value or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_none", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6, None)) == True\n    assert candidate((7, 8, 9, 11, 14)) == False\n    assert candidate((1, 2, 3, 4, None)) == True\n\ndef test_check():\n    check(check_none)\n\ntest_check()\n", "sample_io": ["assert check_none((10, 4, 5, 6, None)) == True"], "source_codes": ["def check_none(test_tup: Any) -> bool:\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check each element in the tuple\n    for element in test_tup:\n        # If the element is None, return True immediately\n        if element is None:\n            return True\n        # If the element is a tuple, recursively check it\n        elif isinstance(element, tuple):\n            if check_none(element):\n                return True\n    \n    # If no None was found, return False\n    return False"], "responses": ["\ndef check_none(test_tup: Any) -> bool:\n    # Check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check each element in the tuple\n    for element in test_tup:\n        # If the element is None, return True immediately\n        if element is None:\n            return True\n        # If the element is a tuple, recursively check it\n        elif isinstance(element, tuple):\n            if check_none(element):\n                return True\n    \n    # If no None was found, return False\n    return False\n\n\n"], "prompt_tokens": [1886], "completion_tokens": [1122], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_744_check_none"}
{"name": "mbpp_726_multiply_elements", "language": "Python3", "prompt": "from typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, 8, 10]) == [5, 35, 56, 80]\n    assert candidate([2, 4, 5, 6, 7]) == [8, 20, 30, 42]\n    assert candidate([12, 13, 14, 9, 15]) == [156, 182, 126, 135]\n    assert candidate([12]) == []\n\ndef test_check():\n    check(multiply_elements)\n\ntest_check()\n", "sample_io": ["assert multiply_elements([1, 5, 7, 8, 10]) == [5, 35, 56, 80]"], "source_codes": ["def multiply_elements(test_tup: List[int]) -> List[Any]:\n    # Handle edge cases: empty list or single element\n    if len(test_tup) <= 1:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and multiply adjacent elements\n    for i in range(len(test_tup) - 1):\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    # Handle edge cases: empty list or single element\n    if len(test_tup) <= 1:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and multiply adjacent elements\n    for i in range(len(test_tup) - 1):\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    return result\n\n\n"], "prompt_tokens": [1896], "completion_tokens": [876], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_726_multiply_elements"}
{"name": "mbpp_736_left_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(left_insertion)\n\ntest_check()\n", "sample_io": ["assert left_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["def left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to insert\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"], "responses": ["\nfrom typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Args:\n        a: A sorted list of integers\n        x: The value to insert\n        \n    Returns:\n        The index where x should be inserted to maintain sorted order\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "prompt_tokens": [1639], "completion_tokens": [1004], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_736_left_insertion"}
{"name": "mbpp_63_max_difference", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between available pairs in the given tuple list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_difference", "test": "def check(candidate):\n    assert candidate([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    assert candidate([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    assert candidate([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n\ndef test_check():\n    check(max_difference)\n\ntest_check()\n", "sample_io": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"], "source_codes": ["def max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    \n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    \n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\n\n"], "prompt_tokens": [1934], "completion_tokens": [1068], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_63_max_difference"}
{"name": "mbpp_264_dog_age", "language": "Python3", "prompt": "def dog_age(h_age: int) -> int:\n    \"\"\"\n\tWrite a function to calculate a dog's age in dog's years.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dog_age", "test": "def check(candidate):\n    assert candidate(12) == 61\n    assert candidate(15) == 73\n    assert candidate(24) == 109\n\ndef test_check():\n    check(dog_age)\n\ntest_check()\n", "sample_io": ["assert dog_age(12) == 61"], "source_codes": ["def dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age < 0:\n        raise ValueError(\"Human age cannot be negative\")\n    \n    if h_age == 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + 4 * (h_age - 2)"], "responses": ["\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age < 0:\n        raise ValueError(\"Human age cannot be negative\")\n    \n    if h_age == 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + 4 * (h_age - 2)\n\n\n"], "prompt_tokens": [1641], "completion_tokens": [832], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_264_dog_age"}
{"name": "mbpp_273_substract_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "substract_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    assert candidate((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    assert candidate((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n\ndef test_check():\n    check(substract_elements)\n\ntest_check()\n", "sample_io": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"], "source_codes": ["def substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))"], "responses": ["\nfrom typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "prompt_tokens": [2062], "completion_tokens": [1024], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_273_substract_elements"}
{"name": "mbpp_83_get_Char", "language": "Python3", "prompt": "def get_Char(strr: str) -> str:\n    \"\"\"\n\tWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Char", "test": "def check(candidate):\n    assert candidate('abc') == 'f'\n    assert candidate('gfg') == 't'\n    assert candidate('ab') == 'c'\n\ndef test_check():\n    check(get_Char)\n\ntest_check()\n", "sample_io": ["assert get_Char('abc') == 'f'"], "source_codes": ["def get_Char(strr: str) -> str:\n    if not strr:\n        return 'a'\n    \n    # Sum the positions of each character in the alphabet (1-indexed)\n    position_sum = sum(ord(char) - ord('a') + 1 for char in strr)\n    mod_value = position_sum % 26\n    \n    # Convert back to character (if mod_value is 0, it means we want 'z')\n    if mod_value == 0:\n        return 'z'\n    else:\n        return chr(ord('a') + mod_value - 1)"], "responses": ["\ndef get_Char(strr: str) -> str:\n    if not strr:\n        return 'a'\n    \n    # Sum the positions of each character in the alphabet (1-indexed)\n    position_sum = sum(ord(char) - ord('a') + 1 for char in strr)\n    mod_value = position_sum % 26\n    \n    # Convert back to character (if mod_value is 0, it means we want 'z')\n    if mod_value == 0:\n        return 'z'\n    else:\n        return chr(ord('a') + mod_value - 1)\n\n\n"], "prompt_tokens": [4670], "completion_tokens": [4062], "no_of_try": 1, "api_calls": 8, "is_solved": true, "task_id": "mbpp_83_get_Char"}
{"name": "mbpp_91_find_substring", "language": "Python3", "prompt": "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string is present as a substring in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_substring", "test": "def check(candidate):\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ack') == True\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'abc') == False\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ange') == True\n\ndef test_check():\n    check(find_substring)\n\ntest_check()\n", "sample_io": ["assert find_substring(['red', 'black', 'white', 'green', 'orange'], 'ack') == True"], "source_codes": ["def find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Handle edge case: empty substring (empty string is substring of any string)\n    if sub_str == \"\":\n        return True\n    \n    # Iterate through each string in the list\n    for string in str1:\n        # Check if sub_str is a substring of the current string\n        if sub_str in string:\n            return True\n    \n    # If no match found after checking all strings\n    return False"], "responses": ["\nfrom typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Handle edge case: empty substring (empty string is substring of any string)\n    if sub_str == \"\":\n        return True\n    \n    # Iterate through each string in the list\n    for string in str1:\n        # Check if sub_str is a substring of the current string\n        if sub_str in string:\n            return True\n    \n    # If no match found after checking all strings\n    return False\n\n\n"], "prompt_tokens": [1960], "completion_tokens": [1002], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_91_find_substring"}
{"name": "mbpp_100_next_smallest_palindrome", "language": "Python3", "prompt": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_smallest_palindrome", "test": "def check(candidate):\n    assert candidate(99) == 101\n    assert candidate(1221) == 1331\n    assert candidate(120) == 121\n\ndef test_check():\n    check(next_smallest_palindrome)\n\ntest_check()\n", "sample_io": ["assert next_smallest_palindrome(99) == 101"], "source_codes": ["def next_smallest_palindrome(num: int) -> int:\n    num_str = str(num)\n    length = len(num_str)\n    \n    # Handle single digit numbers\n    if length == 1:\n        return num + 1\n    \n    # Handle case where all digits are 9\n    if all(digit == '9' for digit in num_str):\n        return num + 2\n    \n    # Split the number into left and right halves\n    mid = length // 2\n    if length % 2 == 0:\n        left_half = num_str[:mid]\n        right_half = num_str[mid:]\n        middle_digit = \"\"\n    else:\n        left_half = num_str[:mid]\n        middle_digit = num_str[mid]\n        right_half = num_str[mid+1:]\n    \n    # Create palindrome by mirroring left half\n    if length % 2 == 0:\n        palindrome = int(left_half + left_half[::-1])\n    else:\n        palindrome = int(left_half + middle_digit + left_half[::-1])\n    \n    # If the palindrome is greater than num, return it\n    if palindrome > num:\n        return palindrome\n    \n    # Otherwise, we need to increment the left half (and middle digit for odd lengths)\n    if length % 2 == 0:\n        left_half_incremented = str(int(left_half) + 1)\n        # Handle case where incrementing increases the number of digits\n        if len(left_half_incremented) > len(left_half):\n            return int('1' + '0' * (length - 1) + '1')\n        else:\n            # Pad with leading zeros if necessary\n            left_half_incremented = left_half_incremented.zfill(len(left_half))\n            return int(left_half_incremented + left_half_incremented[::-1])\n    else:\n        # For odd length, increment the combination of left half and middle digit\n        left_and_middle = left_half + middle_digit\n        left_and_middle_incremented = str(int(left_and_middle) + 1)\n        # Handle case where incrementing increases the number of digits\n        if len(left_and_middle_incremented) > len(left_and_middle):\n            return int('1' + '0' * (length - 1) + '1')\n        else:\n            # Extract new left half and middle digit\n            new_left_half = left_and_middle_incremented[:-1].zfill(len(left_half))\n            new_middle_digit = left_and_middle_incremented[-1]\n            return int(new_left_half + new_middle_digit + new_left_half[::-1])"], "responses": ["\ndef next_smallest_palindrome(num: int) -> int:\n    num_str = str(num)\n    length = len(num_str)\n    \n    # Handle single digit numbers\n    if length == 1:\n        return num + 1\n    \n    # Handle case where all digits are 9\n    if all(digit == '9' for digit in num_str):\n        return num + 2\n    \n    # Split the number into left and right halves\n    mid = length // 2\n    if length % 2 == 0:\n        left_half = num_str[:mid]\n        right_half = num_str[mid:]\n        middle_digit = \"\"\n    else:\n        left_half = num_str[:mid]\n        middle_digit = num_str[mid]\n        right_half = num_str[mid+1:]\n    \n    # Create palindrome by mirroring left half\n    if length % 2 == 0:\n        palindrome = int(left_half + left_half[::-1])\n    else:\n        palindrome = int(left_half + middle_digit + left_half[::-1])\n    \n    # If the palindrome is greater than num, return it\n    if palindrome > num:\n        return palindrome\n    \n    # Otherwise, we need to increment the left half (and middle digit for odd lengths)\n    if length % 2 == 0:\n        left_half_incremented = str(int(left_half) + 1)\n        # Handle case where incrementing increases the number of digits\n        if len(left_half_incremented) > len(left_half):\n            return int('1' + '0' * (length - 1) + '1')\n        else:\n            # Pad with leading zeros if necessary\n            left_half_incremented = left_half_incremented.zfill(len(left_half))\n            return int(left_half_incremented + left_half_incremented[::-1])\n    else:\n        # For odd length, increment the combination of left half and middle digit\n        left_and_middle = left_half + middle_digit\n        left_and_middle_incremented = str(int(left_and_middle) + 1)\n        # Handle case where incrementing increases the number of digits\n        if len(left_and_middle_incremented) > len(left_and_middle):\n            return int('1' + '0' * (length - 1) + '1')\n        else:\n            # Extract new left half and middle digit\n            new_left_half = left_and_middle_incremented[:-1].zfill(len(left_half))\n            new_middle_digit = left_and_middle_incremented[-1]\n            return int(new_left_half + new_middle_digit + new_left_half[::-1])\n\n\n"], "prompt_tokens": [1998], "completion_tokens": [1489], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_100_next_smallest_palindrome"}
{"name": "mbpp_282_sub_list", "language": "Python3", "prompt": "from typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to subtract two lists element-wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sub_list", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\n    assert candidate([1, 2], [3, 4]) == [-2, -2]\n    assert candidate([90, 120], [50, 70]) == [40, 50]\n\ndef test_check():\n    check(sub_list)\n\ntest_check()\n", "sample_io": ["assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"], "source_codes": ["def sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have equal length\")\n    \n    if not nums1:  # Handle empty lists\n        return []\n    \n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have equal length\")\n    \n    if not nums1:  # Handle empty lists\n        return []\n    \n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result\n\n\n"], "prompt_tokens": [2083], "completion_tokens": [1115], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_282_sub_list"}
{"name": "mbpp_790_even_position", "language": "Python3", "prompt": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every even index contains even numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_position", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == False\n    assert candidate([1, 2, 3]) == False\n    assert candidate([2, 1, 4]) == True\n\ndef test_check():\n    check(even_position)\n\ntest_check()\n", "sample_io": ["assert even_position([3, 2, 1]) == False"], "source_codes": ["def even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Check each even index position\n    for i in range(0, len(nums), 2):\n        # If the number at even index is odd, return False\n        if nums[i] % 2 != 0:\n            return False\n    return True"], "responses": ["\nfrom typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Check each even index position\n    for i in range(0, len(nums), 2):\n        # If the number at even index is odd, return False\n        if nums[i] % 2 != 0:\n            return False\n    return True\n\n\n"], "prompt_tokens": [1859], "completion_tokens": [911], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_790_even_position"}
{"name": "mbpp_411_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert the given snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('android_tv') == 'AndroidTv'\n    assert candidate('google_pixel') == 'GooglePixel'\n    assert candidate('apple_watch') == 'AppleWatch'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('android_tv') == 'AndroidTv'"], "source_codes": ["def snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    words = word.split('_')\n    result = []\n    \n    for w in words:\n        if w:\n            if result:  # If we already have words in result, capitalize\n                result.append(w.capitalize())\n            else:  # First non-empty word\n                result.append(w.capitalize())\n    \n    return ''.join(result)"], "responses": ["\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    words = word.split('_')\n    result = []\n    \n    for w in words:\n        if w:\n            if result:  # If we already have words in result, capitalize\n                result.append(w.capitalize())\n            else:  # First non-empty word\n                result.append(w.capitalize())\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [2919], "completion_tokens": [2270], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_411_snake_to_camel"}
{"name": "mbpp_754_extract_index_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n\tWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_index_list", "test": "def check(candidate):\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 6, 5], [0, 1, 2, 3, 4, 6, 7]) == [1, 6]\n    assert candidate([1, 1, 3, 4, 6, 5, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 5]\n    assert candidate([1, 2, 3, 4, 6, 6, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == []\n\ndef test_check():\n    check(extract_index_list)\n\ntest_check()\n", "sample_io": ["assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"], "source_codes": ["def extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    # Determine the minimum length to avoid index out of bounds\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through each index up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at the current index are equal\n        if l1[i] == l2[i] == l3[i]:\n            # Append the common element to the result list\n            result.append(l1[i])\n    \n    # Return the list of common elements\n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    # Determine the minimum length to avoid index out of bounds\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through each index up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at the current index are equal\n        if l1[i] == l2[i] == l3[i]:\n            # Append the common element to the result list\n            result.append(l1[i])\n    \n    # Return the list of common elements\n    return result\n\n\n"], "prompt_tokens": [2432], "completion_tokens": [1270], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_754_extract_index_list"}
{"name": "mbpp_56_checks", "language": "Python3", "prompt": "def checks(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check if a given number is one less than twice its reverse.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "checks", "test": "def check(candidate):\n    assert candidate(70) == False\n    assert candidate(23) == False\n    assert candidate(73) == True\n\ndef test_check():\n    check(checks)\n\ntest_check()\n", "sample_io": ["assert checks(70) == False"], "source_codes": ["def checks(n: int) -> bool:\n    # Convert the number to a string and reverse it\n    reversed_str = str(n)[::-1]\n    # Convert the reversed string back to an integer\n    reversed_num = int(reversed_str)\n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_num - 1"], "responses": ["\ndef checks(n: int) -> bool:\n    # Convert the number to a string and reverse it\n    reversed_str = str(n)[::-1]\n    # Convert the reversed string back to an integer\n    reversed_num = int(reversed_str)\n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_num - 1\n\n\n"], "prompt_tokens": [1792], "completion_tokens": [1060], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_56_checks"}
{"name": "mbpp_724_power_base_sum", "language": "Python3", "prompt": "def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n\tWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power_base_sum", "test": "def check(candidate):\n    assert candidate(2, 100) == 115\n    assert candidate(8, 10) == 37\n    assert candidate(8, 15) == 62\n    assert candidate(3, 3) == 9\n\ndef test_check():\n    check(power_base_sum)\n\ntest_check()\n", "sample_io": ["assert power_base_sum(2, 100) == 115"], "source_codes": ["def power_base_sum(base: int, power: int) -> int:\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Handle negative results by taking absolute value\n    result = abs(result)\n    \n    # Convert to string to process each digit\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = 0\n    for digit_char in result_str:\n        digit_sum += int(digit_char)\n    \n    return digit_sum"], "responses": ["\ndef power_base_sum(base: int, power: int) -> int:\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Handle negative results by taking absolute value\n    result = abs(result)\n    \n    # Convert to string to process each digit\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = 0\n    for digit_char in result_str:\n        digit_sum += int(digit_char)\n    \n    return digit_sum\n\n\n"], "prompt_tokens": [1870], "completion_tokens": [1164], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_724_power_base_sum"}
