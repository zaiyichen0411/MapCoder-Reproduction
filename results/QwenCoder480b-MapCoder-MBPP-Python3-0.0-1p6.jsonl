{"name": "mbpp_268_find_star_num", "language": "Python3", "prompt": "def find_star_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th star number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_star_num", "test": "def check(candidate):\n    assert candidate(3) == 37\n    assert candidate(4) == 73\n    assert candidate(5) == 121\n\ndef test_check():\n    check(find_star_num)\n\ntest_check()\n", "sample_io": ["assert find_star_num(3) == 37"], "source_codes": ["def find_star_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th star number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 6 * n * (n - 1) + 1"], "responses": ["\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th star number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 6 * n * (n - 1) + 1\n\n\n"], "prompt_tokens": [1851], "completion_tokens": [1155], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_268_find_star_num"}
{"name": "mbpp_251_insert_element", "language": "Python3", "prompt": "from typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n\tWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "insert_element", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    assert candidate(['python', 'java'], 'program') == ['program', 'python', 'program', 'java']\n    assert candidate(['happy', 'sad'], 'laugh') == ['laugh', 'happy', 'laugh', 'sad']\n\ndef test_check():\n    check(insert_element)\n\ntest_check()\n", "sample_io": ["assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"], "source_codes": ["def insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    # Handle the edge case of an empty input list\n    if not list:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through each element in the input list\n    for item in list:\n        # Append the insertion element first\n        result.append(element)\n        # Then append the current element\n        result.append(item)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    # Handle the edge case of an empty input list\n    if not list:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through each element in the input list\n    for item in list:\n        # Append the insertion element first\n        result.append(element)\n        # Then append the current element\n        result.append(item)\n    \n    return result\n\n\n"], "prompt_tokens": [1693], "completion_tokens": [1241], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_251_insert_element"}
{"name": "mbpp_428_shell_sort", "language": "Python3", "prompt": "from typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given array by using shell sort.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "shell_sort", "test": "def check(candidate):\n    assert candidate([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    assert candidate([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]\n    assert candidate([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]\n\ndef test_check():\n    check(shell_sort)\n\ntest_check()\n", "sample_io": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"], "source_codes": ["def shell_sort(my_list: List[int]) -> List[int]:\n    n = len(my_list)\n    \n    # Handle edge cases\n    if n <= 1:\n        return my_list\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Perform gapped insertion sort for this gap size\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save the current element\n            key = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > key:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put key in its correct location\n            my_list[j] = key\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return my_list"], "responses": ["\nfrom typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    n = len(my_list)\n    \n    # Handle edge cases\n    if n <= 1:\n        return my_list\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Perform gapped insertion sort for this gap size\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save the current element\n            key = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > key:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put key in its correct location\n            my_list[j] = key\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return my_list\n\n\n"], "prompt_tokens": [2624], "completion_tokens": [1676], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_428_shell_sort"}
{"name": "mbpp_476_big_sum", "language": "Python3", "prompt": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the largest and smallest value in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 4\n    assert candidate([-1, 2, 3, 4]) == 3\n    assert candidate([2, 3, 6]) == 8\n\ndef test_check():\n    check(big_sum)\n\ntest_check()\n", "sample_io": ["assert big_sum([1, 2, 3]) == 4"], "source_codes": ["def big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Array cannot be empty\")\n    \n    min_val = min(nums)\n    max_val = max(nums)\n    \n    return min_val + max_val"], "responses": ["\nfrom typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Array cannot be empty\")\n    \n    min_val = min(nums)\n    max_val = max(nums)\n    \n    return min_val + max_val\n\n\n"], "prompt_tokens": [1656], "completion_tokens": [919], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_476_big_sum"}
{"name": "mbpp_465_drop_empty", "language": "Python3", "prompt": "from typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to drop empty items from a given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "drop_empty", "test": "def check(candidate):\n    assert candidate({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }\n    assert candidate({ 'c1': 'Red', 'c2': None, 'c3': None }) == { 'c1': 'Red' }\n    assert candidate({ 'c1': None, 'c2': 'Green', 'c3': None }) == { 'c2': 'Green' }\n\ndef test_check():\n    check(drop_empty)\n\ntest_check()\n", "sample_io": ["assert drop_empty({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }"], "source_codes": ["def drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}"], "responses": ["\nfrom typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n\n\n"], "prompt_tokens": [2037], "completion_tokens": [972], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_465_drop_empty"}
{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Pattern to match any word containing 'z' (case insensitive)\n    # \\b represents word boundaries\n    # \\w* means zero or more word characters\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text (case insensitive)\n    return bool(re.search(pattern, text, re.IGNORECASE))"], "responses": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Pattern to match any word containing 'z' (case insensitive)\n    # \\b represents word boundaries\n    # \\w* means zero or more word characters\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text (case insensitive)\n    return bool(re.search(pattern, text, re.IGNORECASE))\n\n\n"], "prompt_tokens": [1557], "completion_tokens": [747], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["def prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if num < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if num == 2:\n        return True\n    \n    # All other even numbers are not prime\n    if num % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    \n    # If no divisors found, it's prime\n    return True"], "responses": ["\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if num < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if num == 2:\n        return True\n    \n    # All other even numbers are not prime\n    if num % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    \n    # If no divisors found, it's prime\n    return True\n\n\n"], "prompt_tokens": [1754], "completion_tokens": [1150], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["def merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Combine all elements from the three lists and sort them\n    result = []\n    result.extend(num1)\n    result.extend(num2)\n    result.extend(num3)\n    result.sort()\n    return result"], "responses": ["\nfrom typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Combine all elements from the three lists and sort them\n    result = []\n    result.extend(num1)\n    result.extend(num2)\n    result.extend(num3)\n    result.sort()\n    return result\n\n\n"], "prompt_tokens": [5405], "completion_tokens": [2434], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["def sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n    \"\"\"\n    # Filter names that start with an uppercase letter and sum their lengths\n    return sum(len(name) for name in sample_names if name and not name[0].islower())"], "responses": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n    \"\"\"\n    # Filter names that start with an uppercase letter and sum their lengths\n    return sum(len(name) for name in sample_names if name and not name[0].islower())\n\n\n"], "prompt_tokens": [1768], "completion_tokens": [867], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["def min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum product from the pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through the rest of the tuples\n    for a, b in list1[1:]:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum product from the pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through the rest of the tuples\n    for a, b in list1[1:]:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n\n\n"], "prompt_tokens": [1979], "completion_tokens": [1259], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["def remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    def flatten(tup):\n        result = []\n        for item in tup:\n            if not isinstance(item, tuple):\n                result.append(item)\n        return tuple(result)\n    \n    return flatten(test_tup)"], "responses": ["\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    def flatten(tup):\n        result = []\n        for item in tup:\n            if not isinstance(item, tuple):\n                result.append(item)\n        return tuple(result)\n    \n    return flatten(test_tup)\n\n\n"], "prompt_tokens": [3748], "completion_tokens": [2719], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["def swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "prompt_tokens": [1622], "completion_tokens": [772], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["def round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    rounded_numbers = [round(num) for num in list1]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(list1)\n    \n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    rounded_numbers = [round(num) for num in list1]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(list1)\n    \n    return result\n\n\n"], "prompt_tokens": [1997], "completion_tokens": [1016], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["def sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined by:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n-P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n        \n    Raises:\n        ValueError: If n <= 0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize array to store sequence values\n    # dp[i] will store P(i)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n using the recurrence relation\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i-1]] + dp[i - dp[i-1]]\n    \n    return dp[n]"], "responses": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined by:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n-P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n        \n    Raises:\n        ValueError: If n <= 0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize array to store sequence values\n    # dp[i] will store P(i)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Compute values from 3 to n using the recurrence relation\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i-1]] + dp[i - dp[i-1]]\n    \n    return dp[n]\n\n\n"], "prompt_tokens": [1976], "completion_tokens": [1324], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": ["def newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate the NSW sequence: S(0) = 1, S(1) = 1, S(n) = 2*S(n-1) + S(n-2)\n    s_prev2, s_prev1 = 1, 1\n    count = 0\n    \n    # Start checking from S(2) onwards since S(0)=S(1)=1 are not prime\n    i = 2\n    while count < n:\n        s_current = 2 * s_prev1 + s_prev2\n        if is_prime(s_current):\n            count += 1\n            if count == n:\n                return s_current\n        s_prev2, s_prev1 = s_prev1, s_current\n        i += 1"], "responses": ["\ndef newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate the NSW sequence: S(0) = 1, S(1) = 1, S(n) = 2*S(n-1) + S(n-2)\n    s_prev2, s_prev1 = 1, 1\n    count = 0\n    \n    # Start checking from S(2) onwards since S(0)=S(1)=1 are not prime\n    i = 2\n    while count < n:\n        s_current = 2 * s_prev1 + s_prev2\n        if is_prime(s_current):\n            count += 1\n            if count == n:\n                return s_current\n        s_prev2, s_prev1 = s_prev1, s_current\n        i += 1\n\n\n"], "prompt_tokens": [3270], "completion_tokens": [6521], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["def Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Find the element of a list having maximum length.\n    \n    Args:\n        lst: A list of lists\n        \n    Returns:\n        The sublist with maximum length. If multiple sublists have the same\n        maximum length, returns the first one. Returns None if input is empty.\n    \"\"\"\n    if not lst:\n        return None\n    \n    return max(lst, key=len)"], "responses": ["\nfrom typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Find the element of a list having maximum length.\n    \n    Args:\n        lst: A list of lists\n        \n    Returns:\n        The sublist with maximum length. If multiple sublists have the same\n        maximum length, returns the first one. Returns None if input is empty.\n    \"\"\"\n    if not lst:\n        return None\n    \n    return max(lst, key=len)\n\n\n"], "prompt_tokens": [1826], "completion_tokens": [1034], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["def split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)"], "responses": ["\nfrom typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n\n\n"], "prompt_tokens": [1493], "completion_tokens": [759], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["def pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not list1:\n        return []\n    \n    # Initialize result list and current group list with first element\n    result = []\n    current_group = [list1[0]]\n    \n    # Iterate through the list starting from second element\n    for i in range(1, len(list1)):\n        # If same as previous: add to current group list\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        # If different from previous: append current group to result, start new group\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    # After loop ends, append the final group to result list\n    result.append(current_group)\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not list1:\n        return []\n    \n    # Initialize result list and current group list with first element\n    result = []\n    current_group = [list1[0]]\n    \n    # Iterate through the list starting from second element\n    for i in range(1, len(list1)):\n        # If same as previous: add to current group list\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        # If different from previous: append current group to result, start new group\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    # After loop ends, append the final group to result list\n    result.append(current_group)\n    \n    return result\n\n\n"], "prompt_tokens": [2152], "completion_tokens": [1269], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["def min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort the list by the second element (integer) in ascending order\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first K elements (or all elements if K > length)\n    return sorted_list[:K]"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort the list by the second element (integer) in ascending order\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first K elements (or all elements if K > length)\n    return sorted_list[:K]\n\n\n"], "prompt_tokens": [2303], "completion_tokens": [1180], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["def check_integer(text: str) -> bool:\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Strip leading/trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check for optional sign\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, return False\n        if len(text) == 1:\n            return False\n    \n    # Check that there's at least one character after sign processing\n    if start_index >= len(text):\n        return False\n    \n    # Check that all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True"], "responses": ["\ndef check_integer(text: str) -> bool:\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Strip leading/trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check for optional sign\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, return False\n        if len(text) == 1:\n            return False\n    \n    # Check that there's at least one character after sign processing\n    if start_index >= len(text):\n        return False\n    \n    # Check that all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1641], "completion_tokens": [891], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["def rotate_right(lst: List[int], m: int) -> List[int]:\n    # Handle edge cases\n    if not lst or m == 0:\n        return lst\n    \n    # Calculate effective rotation using modulo\n    n = len(lst)\n    effective_rotation = m % n\n    \n    # If effective rotation is 0, no change needed\n    if effective_rotation == 0:\n        return lst\n    \n    # Determine split point\n    split_point = n - effective_rotation\n    \n    # Use list slicing and concatenate in reversed order\n    return lst[split_point:] + lst[:split_point]"], "responses": ["\nfrom typing import List\n\ndef rotate_right(lst: List[int], m: int) -> List[int]:\n    # Handle edge cases\n    if not lst or m == 0:\n        return lst\n    \n    # Calculate effective rotation using modulo\n    n = len(lst)\n    effective_rotation = m % n\n    \n    # If effective rotation is 0, no change needed\n    if effective_rotation == 0:\n        return lst\n    \n    # Determine split point\n    split_point = n - effective_rotation\n    \n    # Use list slicing and concatenate in reversed order\n    return lst[split_point:] + lst[:split_point]\n\n\n"], "prompt_tokens": [2112], "completion_tokens": [1182], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["def armstrong_number(number: int) -> bool:\n    # Negative numbers cannot be Armstrong numbers\n    if number < 0:\n        return False\n    \n    # Convert number to string to get individual digits\n    str_num = str(number)\n    n = len(str_num)\n    \n    # Calculate sum of each digit raised to the power n\n    total = sum(int(digit) ** n for digit in str_num)\n    \n    # Check if the total equals the original number\n    return total == number"], "responses": ["\ndef armstrong_number(number: int) -> bool:\n    # Negative numbers cannot be Armstrong numbers\n    if number < 0:\n        return False\n    \n    # Convert number to string to get individual digits\n    str_num = str(number)\n    n = len(str_num)\n    \n    # Calculate sum of each digit raised to the power n\n    total = sum(int(digit) ** n for digit in str_num)\n    \n    # Check if the total equals the original number\n    return total == number\n\n\n"], "prompt_tokens": [1816], "completion_tokens": [1147], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["def sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    \n    for num in nums:\n        # Check if the element is a number (int or float) and not None\n        if isinstance(num, (int, float)) and num is not None:\n            # Convert to string and extract only digit characters\n            digit_chars = [char for char in str(abs(num)) if char.isdigit()]\n            \n            # Convert each digit character back to int and sum them\n            for digit_char in digit_chars:\n                total_sum += int(digit_char)\n    \n    return total_sum"], "responses": ["\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    \n    for num in nums:\n        # Check if the element is a number (int or float) and not None\n        if isinstance(num, (int, float)) and num is not None:\n            # Convert to string and extract only digit characters\n            digit_chars = [char for char in str(abs(num)) if char.isdigit()]\n            \n            # Convert each digit character back to int and sum them\n            for digit_char in digit_chars:\n                total_sum += int(digit_char)\n    \n    return total_sum\n\n\n"], "prompt_tokens": [1917], "completion_tokens": [1070], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["def re_arrange_array(arr: List[int], n: int) -> List[int]:\n    if n <= 0:\n        return arr\n    \n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negatives and non-negatives while preserving order\n    negatives = [x for x in first_n if x < 0]\n    non_negatives = [x for x in first_n if x >= 0]\n    \n    # Concatenate the two lists\n    rearranged = negatives + non_negatives\n    \n    # Replace the first n elements in the original array\n    result = rearranged + arr[n:]\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    if n <= 0:\n        return arr\n    \n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negatives and non-negatives while preserving order\n    negatives = [x for x in first_n if x < 0]\n    non_negatives = [x for x in first_n if x >= 0]\n    \n    # Concatenate the two lists\n    rearranged = negatives + non_negatives\n    \n    # Replace the first n elements in the original array\n    result = rearranged + arr[n:]\n    \n    return result\n\n\n"], "prompt_tokens": [8146], "completion_tokens": [5625], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Handle special case when wind velocity is 0\n    if v == 0:\n        return t\n    \n    # Calculate V^0.16\n    v_pow = v ** 0.16\n    \n    # Implement the wind chill formula\n    # WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    wci = 13.12 + 0.6215 * t - 11.37 * v_pow + 0.3965 * t * v_pow\n    \n    # Round to the nearest integer\n    return round(wci)"], "responses": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Handle special case when wind velocity is 0\n    if v == 0:\n        return t\n    \n    # Calculate V^0.16\n    v_pow = v ** 0.16\n    \n    # Implement the wind chill formula\n    # WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    wci = 13.12 + 0.6215 * t - 11.37 * v_pow + 0.3965 * t * v_pow\n    \n    # Round to the nearest integer\n    return round(wci)\n\n\n"], "prompt_tokens": [2332], "completion_tokens": [1746], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["def bell_Number(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    # Initialize the first row of Bell's triangle\n    prev_row = [1]\n    \n    # Build the triangle up to the nth row\n    for i in range(1, n + 1):\n        # Start new row with the last element of previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill in the rest of the row\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update previous row for next iteration\n        prev_row = curr_row\n    \n    # The first element of the final row is B(n)\n    return prev_row[0]"], "responses": ["\ndef bell_Number(n: int) -> int:\n    if n == 0:\n        return 1\n    \n    # Initialize the first row of Bell's triangle\n    prev_row = [1]\n    \n    # Build the triangle up to the nth row\n    for i in range(1, n + 1):\n        # Start new row with the last element of previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill in the rest of the row\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update previous row for next iteration\n        prev_row = curr_row\n    \n    # The first element of the final row is B(n)\n    return prev_row[0]\n\n\n"], "prompt_tokens": [3082], "completion_tokens": [2617], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["def sum_div(number: int) -> int:\n    if number <= 0:\n        return 0\n    \n    total = 0\n    i = 1\n    while i * i <= number:\n        if number % i == 0:\n            total += i\n            if i != number // i:  # Avoid adding the same divisor twice for perfect squares\n                total += number // i\n        i += 1\n    \n    # Subtract the number itself to get sum of proper divisors\n    # But only if number > 1 (since 1's only divisor is itself)\n    if number > 1:\n        total -= number\n    \n    return total"], "responses": ["\ndef sum_div(number: int) -> int:\n    if number <= 0:\n        return 0\n    \n    total = 0\n    i = 1\n    while i * i <= number:\n        if number % i == 0:\n            total += i\n            if i != number // i:  # Avoid adding the same divisor twice for perfect squares\n                total += number // i\n        i += 1\n    \n    # Subtract the number itself to get sum of proper divisors\n    # But only if number > 1 (since 1's only divisor is itself)\n    if number > 1:\n        total -= number\n    \n    return total\n\n\n"], "prompt_tokens": [4402], "completion_tokens": [2770], "no_of_try": 1, "api_calls": 8, "is_solved": true, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["def get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 9 coordinates including the original and all adjacent ones\n    coords = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            coords.append([x + dx, y + dy])\n    \n    return coords"], "responses": ["\nfrom typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 9 coordinates including the original and all adjacent ones\n    coords = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            coords.append([x + dx, y + dy])\n    \n    return coords\n\n\n"], "prompt_tokens": [4673], "completion_tokens": [2017], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["def find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    # Convert tuples to sets to find unique elements\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    sym_diff = set1.symmetric_difference(set2)\n    \n    # Collect elements from both tuples that are in the symmetric difference\n    result = []\n    \n    # Preserve order from first tuple\n    for element in test_tup1:\n        if element in sym_diff:\n            result.append(element)\n    \n    # Preserve order from second tuple\n    for element in test_tup2:\n        if element in sym_diff:\n            result.append(element)\n    \n    return tuple(result)"], "responses": ["\nfrom typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    # Convert tuples to sets to find unique elements\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    sym_diff = set1.symmetric_difference(set2)\n    \n    # Collect elements from both tuples that are in the symmetric difference\n    result = []\n    \n    # Preserve order from first tuple\n    for element in test_tup1:\n        if element in sym_diff:\n            result.append(element)\n    \n    # Preserve order from second tuple\n    for element in test_tup2:\n        if element in sym_diff:\n            result.append(element)\n    \n    return tuple(result)\n\n\n"], "prompt_tokens": [2296], "completion_tokens": [1418], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["def find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    max_diff = 0  # Initialize to 0 to handle cases where all differences are negative\n    current_sum = 0\n    \n    for char in string:\n        # Transform '0' to +1 and '1' to -1\n        current_sum += 1 if char == '0' else -1\n        max_diff = max(max_diff, current_sum)\n        # Reset current_sum if it becomes negative (Kadane's algorithm)\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_diff"], "responses": ["\ndef find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    max_diff = 0  # Initialize to 0 to handle cases where all differences are negative\n    current_sum = 0\n    \n    for char in string:\n        # Transform '0' to +1 and '1' to -1\n        current_sum += 1 if char == '0' else -1\n        max_diff = max(max_diff, current_sum)\n        # Reset current_sum if it becomes negative (Kadane's algorithm)\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_diff\n\n\n"], "prompt_tokens": [3832], "completion_tokens": [1993], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["def split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    # Handle negative L by treating it as 0\n    if L < 0:\n        L = 0\n    \n    # Use list slicing to create the two parts\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return (first_part, second_part)"], "responses": ["\nfrom typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    # Handle negative L by treating it as 0\n    if L < 0:\n        L = 0\n    \n    # Use list slicing to create the two parts\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return (first_part, second_part)\n\n\n"], "prompt_tokens": [2103], "completion_tokens": [1032], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["def check_expression(exp: str) -> bool:\n    \"\"\"\n    Write a function to check if the given expression is balanced or not.\n    \"\"\"\n    # Initialize an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Create a mapping dictionary for matching opening and closing brackets\n    bracket_map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n    \n    # Iterate through each character in the expression string\n    for char in exp:\n        # If character is an opening bracket, push it onto the stack\n        if char in '({[':\n            stack.append(char)\n        # If character is a closing bracket\n        elif char in ')}]':\n            # Check if stack is empty or if the top element doesn't match\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # After processing all characters, return True if stack is empty, False otherwise\n    return len(stack) == 0"], "responses": ["\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Write a function to check if the given expression is balanced or not.\n    \"\"\"\n    # Initialize an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Create a mapping dictionary for matching opening and closing brackets\n    bracket_map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n    \n    # Iterate through each character in the expression string\n    for char in exp:\n        # If character is an opening bracket, push it onto the stack\n        if char in '({[':\n            stack.append(char)\n        # If character is a closing bracket\n        elif char in ')}]':\n            # Check if stack is empty or if the top element doesn't match\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the matching opening bracket\n            stack.pop()\n    \n    # After processing all characters, return True if stack is empty, False otherwise\n    return len(stack) == 0\n\n\n"], "prompt_tokens": [1726], "completion_tokens": [963], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Args:\n        x, y, z: Three integers to compare\n        \n    Returns:\n        int: 3 if all three are equal, 2 if exactly two are equal, 0 if all different\n    \"\"\"\n    # Check if all three numbers are equal\n    if x == y == z:\n        return 3\n    \n    # Check if exactly two numbers are equal\n    if x == y or y == z or x == z:\n        return 2\n    \n    # All numbers are different\n    return 0"], "responses": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Args:\n        x, y, z: Three integers to compare\n        \n    Returns:\n        int: 3 if all three are equal, 2 if exactly two are equal, 0 if all different\n    \"\"\"\n    # Check if all three numbers are equal\n    if x == y == z:\n        return 3\n    \n    # Check if exactly two numbers are equal\n    if x == y or y == z or x == z:\n        return 2\n    \n    # All numbers are different\n    return 0\n\n\n"], "prompt_tokens": [1806], "completion_tokens": [903], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["def find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    Lucas numbers follow the recurrence relation:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach for efficiency\n    prev_prev = 2  # L(0)\n    prev = 1       # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev + prev_prev\n        prev_prev = prev\n        prev = current\n        \n    return prev"], "responses": ["\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Find the n'th Lucas number.\n    \n    Lucas numbers follow the recurrence relation:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Args:\n        n: Non-negative integer representing the position in the Lucas sequence\n        \n    Returns:\n        The n'th Lucas number\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach for efficiency\n    prev_prev = 2  # L(0)\n    prev = 1       # L(1)\n    \n    for i in range(2, n + 1):\n        current = prev + prev_prev\n        prev_prev = prev\n        prev = current\n        \n    return prev\n\n\n"], "prompt_tokens": [1237], "completion_tokens": [1254], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["def snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    # If no valid words left, return empty string\n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of all words and join them\n    return ''.join(w.capitalize() for w in words)"], "responses": ["\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    # If no valid words left, return empty string\n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of all words and join them\n    return ''.join(w.capitalize() for w in words)\n\n\n"], "prompt_tokens": [3331], "completion_tokens": [1415], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words seperated by spaces in a given string.\n    \"\"\"\n    # Handle edge case of empty string\n    if not s:\n        return \"\"\n    \n    # Split the string by spaces and filter out empty strings\n    words = s.split()\n    \n    # If no words found (only whitespace), return empty string\n    if not words:\n        return \"\"\n    \n    # Reverse the words and join them back with single spaces\n    return \" \".join(reversed(words))"], "responses": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words seperated by spaces in a given string.\n    \"\"\"\n    # Handle edge case of empty string\n    if not s:\n        return \"\"\n    \n    # Split the string by spaces and filter out empty strings\n    words = s.split()\n    \n    # If no words found (only whitespace), return empty string\n    if not words:\n        return \"\"\n    \n    # Reverse the words and join them back with single spaces\n    return \" \".join(reversed(words))\n\n\n"], "prompt_tokens": [1527], "completion_tokens": [865], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["def is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()"], "responses": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "prompt_tokens": [1500], "completion_tokens": [827], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_length = max(len(str_n1), len(str_n2))\n    \n    # Pad the shorter number with leading zeros\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    \n    # Calculate the sum of digit differences\n    total_difference = 0\n    for i in range(max_length):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_difference += digit_diff\n    \n    return total_difference"], "responses": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_length = max(len(str_n1), len(str_n2))\n    \n    # Pad the shorter number with leading zeros\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    \n    # Calculate the sum of digit differences\n    total_difference = 0\n    for i in range(max_length):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_difference += digit_diff\n    \n    return total_difference\n\n\n"], "prompt_tokens": [1672], "completion_tokens": [1008], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["def find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1  # Count the current list\n            count += find_lists(element)  # Recursively count nested lists\n    \n    return count"], "responses": ["\nfrom typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1  # Count the current list\n            count += find_lists(element)  # Recursively count nested lists\n    \n    return count\n\n\n"], "prompt_tokens": [1668], "completion_tokens": [979], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_143_find_lists"}
{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["def average_tuple(nums: List[List[int]]) -> List[float]:\n    result = []\n    for sublist in nums:\n        if len(sublist) == 0:\n            result.append(0.0)\n        else:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n    return result"], "responses": ["\nfrom typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    result = []\n    for sublist in nums:\n        if len(sublist) == 0:\n            result.append(0.0)\n        else:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n    return result\n\n\n"], "prompt_tokens": [6269], "completion_tokens": [5932], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["def find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Two numbers XOR to an even number when:\n    - Both numbers are even, or\n    - Both numbers are odd\n    \n    So we count pairs of even numbers and pairs of odd numbers.\n    \"\"\"\n    # Count even and odd numbers\n    count_even = 0\n    count_odd = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    # Calculate pairs: n*(n-1)/2 for combinations\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    \n    return even_pairs + odd_pairs"], "responses": ["\nfrom typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Two numbers XOR to an even number when:\n    - Both numbers are even, or\n    - Both numbers are odd\n    \n    So we count pairs of even numbers and pairs of odd numbers.\n    \"\"\"\n    # Count even and odd numbers\n    count_even = 0\n    count_odd = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    # Calculate pairs: n*(n-1)/2 for combinations\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n\n"], "prompt_tokens": [1865], "completion_tokens": [1032], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \n    Args:\n        x: First integer\n        y: Second integer\n    \n    Returns:\n        bool: True if x and y have opposite signs, False otherwise\n    \"\"\"\n    # Two numbers have opposite signs if their product is negative\n    # This also correctly handles the case where one or both numbers are zero\n    return (x * y) < 0"], "responses": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \n    Args:\n        x: First integer\n        y: Second integer\n    \n    Returns:\n        bool: True if x and y have opposite signs, False otherwise\n    \"\"\"\n    # Two numbers have opposite signs if their product is negative\n    # This also correctly handles the case where one or both numbers are zero\n    return (x * y) < 0\n\n\n"], "prompt_tokens": [1821], "completion_tokens": [918], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["def sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    # Handle edge case of empty main list\n    if not list1:\n        return []\n    \n    # Sort each sublist individually\n    sorted_sublists = [sorted(sublist) for sublist in list1]\n    \n    return sorted_sublists"], "responses": ["\nfrom typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    # Handle edge case of empty main list\n    if not list1:\n        return []\n    \n    # Sort each sublist individually\n    sorted_sublists = [sorted(sublist) for sublist in list1]\n    \n    return sorted_sublists\n\n\n"], "prompt_tokens": [1813], "completion_tokens": [838], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["def combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    # Generate all combinations with replacement\n    combinations = combinations_with_replacement(l, n)\n    \n    # Convert each combination tuple to a list\n    result = [list(combo) for combo in combinations]\n    \n    return result"], "responses": ["\nfrom typing import List\nfrom itertools import combinations_with_replacement\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    \n    if not l:\n        return []\n    \n    # Generate all combinations with replacement\n    combinations = combinations_with_replacement(l, n)\n    \n    # Convert each combination tuple to a list\n    result = [list(combo) for combo in combinations]\n    \n    return result\n\n\n"], "prompt_tokens": [1980], "completion_tokens": [1223], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["def move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    return ''.join(non_digits + digits)"], "responses": ["\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    return ''.join(non_digits + digits)\n\n\n"], "prompt_tokens": [1648], "completion_tokens": [792], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["def intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    # Handle edge cases\n    if not array_nums1 or not array_nums2:\n        return []\n    \n    # Convert the second array to a set for O(1) lookup\n    set_nums2 = set(array_nums2)\n    result_set = set()\n    result = []\n    \n    # Find intersections while preserving order from first array\n    for num in array_nums1:\n        if num in set_nums2 and num not in result_set:\n            result.append(num)\n            result_set.add(num)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    # Handle edge cases\n    if not array_nums1 or not array_nums2:\n        return []\n    \n    # Convert the second array to a set for O(1) lookup\n    set_nums2 = set(array_nums2)\n    result_set = set()\n    result = []\n    \n    # Find intersections while preserving order from first array\n    for num in array_nums1:\n        if num in set_nums2 and num not in result_set:\n            result.append(num)\n            result_set.add(num)\n    \n    return result\n\n\n"], "prompt_tokens": [3979], "completion_tokens": [2123], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["def count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count"], "responses": ["\nfrom typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1720], "completion_tokens": [795], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["def get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    if n == 0:\n        return 0.0\n    \n    # Ensure arr1 is the smaller array\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    low, high = 0, n\n    \n    while low <= high:\n        partition1 = (low + high) // 2\n        partition2 = n - partition1\n        \n        # Handle edge cases for boundaries\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we have found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            # Calculate median\n            if (n * 2) % 2 == 0:  # Total elements is 2*n\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2\n            else:\n                return float(max(max_left1, max_left2))\n        elif max_left1 > min_right2:\n            # Move partition to the left in arr1\n            high = partition1 - 1\n        else:\n            # Move partition to the right in arr1\n            low = partition1 + 1\n    \n    raise ValueError(\"Input arrays are not sorted or of equal size\")"], "responses": ["\nfrom typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    if n == 0:\n        return 0.0\n    \n    # Ensure arr1 is the smaller array\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    low, high = 0, n\n    \n    while low <= high:\n        partition1 = (low + high) // 2\n        partition2 = n - partition1\n        \n        # Handle edge cases for boundaries\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we have found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            # Calculate median\n            if (n * 2) % 2 == 0:  # Total elements is 2*n\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2\n            else:\n                return float(max(max_left1, max_left2))\n        elif max_left1 > min_right2:\n            # Move partition to the left in arr1\n            high = partition1 - 1\n        else:\n            # Move partition to the right in arr1\n            low = partition1 + 1\n    \n    raise ValueError(\"Input arrays are not sorted or of equal size\")\n\n\n"], "prompt_tokens": [4742], "completion_tokens": [3176], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["def tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number using the formula T(n) = n(n+1)(n+2)/6.\n    \n    Args:\n        n: A non-negative integer representing the position in the tetrahedral number sequence.\n        \n    Returns:\n        The nth tetrahedral number, or 0 if n is negative.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    return n * (n + 1) * (n + 2) // 6"], "responses": ["\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number using the formula T(n) = n(n+1)(n+2)/6.\n    \n    Args:\n        n: A non-negative integer representing the position in the tetrahedral number sequence.\n        \n    Returns:\n        The nth tetrahedral number, or 0 if n is negative.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "prompt_tokens": [2153], "completion_tokens": [1311], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": ["def find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    # Handle edge cases\n    if len(test_list) < 2:\n        return []\n    \n    # Generate all unique pairs of tuples and calculate their element-wise sums\n    result = []\n    for pair in combinations(test_list, 2):\n        sum_tuple = (pair[0][0] + pair[1][0], pair[0][1] + pair[1][1])\n        result.append(sum_tuple)\n    \n    return result"], "responses": ["\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find the combinations of sums with tuples in the given tuple list.\n    \"\"\"\n    # Handle edge cases\n    if len(test_list) < 2:\n        return []\n    \n    # Generate all unique pairs of tuples and calculate their element-wise sums\n    result = []\n    for pair in combinations(test_list, 2):\n        sum_tuple = (pair[0][0] + pair[1][0], pair[0][1] + pair[1][1])\n        result.append(sum_tuple)\n    \n    return result\n\n\n"], "prompt_tokens": [2022], "completion_tokens": [1039], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["def find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    \n    Args:\n        A: A sorted list of integers\n        x: The target number to find\n        \n    Returns:\n        The index of the first occurrence of x in A, or -1 if x is not found\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return result"], "responses": ["\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    \n    Args:\n        A: A sorted list of integers\n        x: The target number to find\n        \n    Returns:\n        The index of the first occurrence of x in A, or -1 if x is not found\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return result\n\n\n"], "prompt_tokens": [1019], "completion_tokens": [1165], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to get 1s in positions where bits differ\n    xor_result = a ^ b\n    \n    # If XOR result is 0, numbers are identical (no differing bits)\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has exactly one bit set)\n    # A number is power of 2 if n & (n-1) == 0\n    return (xor_result & (xor_result - 1)) == 0"], "responses": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to get 1s in positions where bits differ\n    xor_result = a ^ b\n    \n    # If XOR result is 0, numbers are identical (no differing bits)\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has exactly one bit set)\n    # A number is power of 2 if n & (n-1) == 0\n    return (xor_result & (xor_result - 1)) == 0\n\n\n"], "prompt_tokens": [2337], "completion_tokens": [1546], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Check if month number is valid (between 1 and 12)\n    if monthnum3 < 1 or monthnum3 > 12:\n        return False\n    \n    # Months with exactly 30 days: April (4), June (6), September (9), November (11)\n    thirty_day_months = {4, 6, 9, 11}\n    \n    # Check if the month is in the set of 30-day months\n    return monthnum3 in thirty_day_months"], "responses": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Check if month number is valid (between 1 and 12)\n    if monthnum3 < 1 or monthnum3 > 12:\n        return False\n    \n    # Months with exactly 30 days: April (4), June (6), September (9), November (11)\n    thirty_day_months = {4, 6, 9, 11}\n    \n    # Check if the month is in the set of 30-day months\n    return monthnum3 in thirty_day_months\n\n\n"], "prompt_tokens": [2132], "completion_tokens": [1092], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["def swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "prompt_tokens": [1663], "completion_tokens": [807], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["def rearrange_bigger(n: int) -> Any:\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Step 1: Find the pivot - the first digit from the right that is smaller than its successor\n    pivot = -1\n    for i in range(length - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            pivot = i\n            break\n    \n    # If no pivot is found, the digits are in descending order, so no next permutation exists\n    if pivot == -1:\n        return None\n    \n    # Step 2: Find the smallest digit on the right of the pivot that is larger than the pivot\n    successor = -1\n    for i in range(length - 1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            successor = i\n            break\n    \n    # Step 3: Swap the pivot with the successor\n    digits[pivot], digits[successor] = digits[successor], digits[pivot]\n    \n    # Step 4: Reverse the suffix (everything after the pivot's original position)\n    digits[pivot + 1:] = reversed(digits[pivot + 1:])\n    \n    # Convert back to integer and return\n    return int(''.join(digits))"], "responses": ["\ndef rearrange_bigger(n: int) -> Any:\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Step 1: Find the pivot - the first digit from the right that is smaller than its successor\n    pivot = -1\n    for i in range(length - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            pivot = i\n            break\n    \n    # If no pivot is found, the digits are in descending order, so no next permutation exists\n    if pivot == -1:\n        return None\n    \n    # Step 2: Find the smallest digit on the right of the pivot that is larger than the pivot\n    successor = -1\n    for i in range(length - 1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            successor = i\n            break\n    \n    # Step 3: Swap the pivot with the successor\n    digits[pivot], digits[successor] = digits[successor], digits[pivot]\n    \n    # Step 4: Reverse the suffix (everything after the pivot's original position)\n    digits[pivot + 1:] = reversed(digits[pivot + 1:])\n    \n    # Convert back to integer and return\n    return int(''.join(digits))\n\n\n"], "prompt_tokens": [2120], "completion_tokens": [1357], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["def get_max_sum(n: int) -> int:\n    # Memoization dictionary to store computed results\n    memo = {}\n    \n    def helper(num):\n        # Base cases\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n            \n        # Check if result is already computed\n        if num in memo:\n            return memo[num]\n        \n        # Calculate the sum using integer division\n        sum_breakdown = helper(num // 2) + helper(num // 3) + helper(num // 4) + helper(num // 5)\n        \n        # Store result in memo and return maximum\n        memo[num] = max(sum_breakdown, num)\n        return memo[num]\n    \n    return helper(n)"], "responses": ["\ndef get_max_sum(n: int) -> int:\n    # Memoization dictionary to store computed results\n    memo = {}\n    \n    def helper(num):\n        # Base cases\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n            \n        # Check if result is already computed\n        if num in memo:\n            return memo[num]\n        \n        # Calculate the sum using integer division\n        sum_breakdown = helper(num // 2) + helper(num // 3) + helper(num // 4) + helper(num // 5)\n        \n        # Store result in memo and return maximum\n        memo[num] = max(sum_breakdown, num)\n        return memo[num]\n    \n    return helper(n)\n\n\n"], "prompt_tokens": [2015], "completion_tokens": [1180], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["def mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \n    Args:\n        list1: A list of integers\n        \n    Returns:\n        The product of the first even and first odd number, or 0 if either is not found\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even and odd numbers\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n        # If we found both, we can exit early\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If both first even and odd numbers are found, return their product\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        # If either even or odd number is not found, return 0\n        return 0"], "responses": ["\nfrom typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \n    Args:\n        list1: A list of integers\n        \n    Returns:\n        The product of the first even and first odd number, or 0 if either is not found\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even and odd numbers\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n        # If we found both, we can exit early\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If both first even and odd numbers are found, return their product\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        # If either even or odd number is not found, return 0\n        return 0\n\n\n"], "prompt_tokens": [1932], "completion_tokens": [1281], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["def odd_Equivalent(s: str, n: int) -> int:\n    if not s or n == 0:\n        return 0\n    \n    # Normalize rotations to avoid redundant work\n    n = min(n, len(s))\n    \n    # Use a set to store unique odd binary strings\n    odd_numbers = set()\n    \n    # Check each rotation\n    for i in range(n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        # Check if the number is odd (last digit is '1')\n        if rotated[-1] == '1':\n            odd_numbers.add(rotated)\n            \n    return len(odd_numbers)"], "responses": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    if not s or n == 0:\n        return 0\n    \n    # Normalize rotations to avoid redundant work\n    n = min(n, len(s))\n    \n    # Use a set to store unique odd binary strings\n    odd_numbers = set()\n    \n    # Check each rotation\n    for i in range(n + 1):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        # Check if the number is odd (last digit is '1')\n        if rotated[-1] == '1':\n            odd_numbers.add(rotated)\n            \n    return len(odd_numbers)\n\n\n"], "prompt_tokens": [2461], "completion_tokens": [1343], "no_of_try": 1, "api_calls": 5, "is_solved": false, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["def Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n    if not lst:\n        return 0\n    \n    return min(len(sublist) for sublist in lst)"], "responses": ["\nfrom typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n    if not lst:\n        return 0\n    \n    return min(len(sublist) for sublist in lst)\n\n\n"], "prompt_tokens": [1911], "completion_tokens": [1067], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["def bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Perform the mathematical bitwise xor operation across the given tuples.\n    \n    Args:\n        test_tup1: A tuple of 4 integers\n        test_tup2: A tuple of 4 integers\n        \n    Returns:\n        A tuple containing the element-wise XOR results\n    \"\"\"\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))"], "responses": ["\nfrom typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Perform the mathematical bitwise xor operation across the given tuples.\n    \n    Args:\n        test_tup1: A tuple of 4 integers\n        test_tup2: A tuple of 4 integers\n        \n    Returns:\n        A tuple containing the element-wise XOR results\n    \"\"\"\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "prompt_tokens": [2740], "completion_tokens": [1846], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["def is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2"], "responses": ["\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: n(7n - 5)/2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2\n\n\n"], "prompt_tokens": [1174], "completion_tokens": [1229], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": ["def is_octagonal(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth octagonal number.\n    \"\"\"\n    return n * (3 * n - 2)"], "responses": ["\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth octagonal number.\n    \"\"\"\n    return n * (3 * n - 2)\n\n\n"], "prompt_tokens": [1666], "completion_tokens": [1086], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_59_is_octagonal"}
