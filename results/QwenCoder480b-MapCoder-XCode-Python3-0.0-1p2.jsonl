{"description": "Welcome to Codeforces Stock Exchange! We're pretty limited now as we currently allow trading on one stock, Codeforces Ltd. We hope you'll still be able to make profit from the market!In the morning, there are $$$n$$$ opportunities to buy shares. The $$$i$$$-th of them allows to buy as many shares as you want, each at the price of $$$s_i$$$ bourles.In the evening, there are $$$m$$$ opportunities to sell shares. The $$$i$$$-th of them allows to sell as many shares as you want, each at the price of $$$b_i$$$ bourles. You can't sell more shares than you have.It's morning now and you possess $$$r$$$ bourles and no shares.What is the maximum number of bourles you can hold after the evening?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains three integers $$$n, m, r$$$ ($$$1 \\leq n \\leq 30$$$, $$$1 \\leq m \\leq 30$$$, $$$1 \\leq r \\leq 1000$$$) \u2014 the number of ways to buy the shares on the market, the number of ways to sell the shares on the market, and the number of bourles you hold now. The next line contains $$$n$$$ integers $$$s_1, s_2, \\dots, s_n$$$ ($$$1 \\leq s_i \\leq 1000$$$); $$$s_i$$$ indicates the opportunity to buy shares at the price of $$$s_i$$$ bourles. The following line contains $$$m$$$ integers $$$b_1, b_2, \\dots, b_m$$$ ($$$1 \\leq b_i \\leq 1000$$$); $$$b_i$$$ indicates the opportunity to sell shares at the price of $$$b_i$$$ bourles.", "output_spec": "Output a single integer \u2014 the maximum number of bourles you can hold after the evening.", "notes": "NoteIn the first example test, you have $$$11$$$ bourles in the morning. It's optimal to buy $$$5$$$ shares of a stock at the price of $$$2$$$ bourles in the morning, and then to sell all of them at the price of $$$5$$$ bourles in the evening. It's easy to verify that you'll have $$$26$$$ bourles after the evening.In the second example test, it's optimal not to take any action.", "sample_inputs": ["3 4 11\n4 2 5\n4 4 5 4", "2 2 50\n5 7\n4 2"], "sample_outputs": ["26", "50"], "tags": ["greedy", "implementation"], "src_uid": "42f25d492bddc12d3d89d39315d63cb9", "difficulty": 800, "source_codes": ["n, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nmin_buy = min(s)\nmax_sell = max(b)\n\nif min_buy < max_sell:\n    shares_bought = r // min_buy\n    money_spent = shares_bought * min_buy\n    money_earned = shares_bought * max_sell\n    remaining_money = r - money_spent\n    result = remaining_money + money_earned\nelse:\n    result = r\n\nprint(result)"], "responses": ["\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nmin_buy = min(s)\nmax_sell = max(b)\n\nif min_buy < max_sell:\n    shares_bought = r // min_buy\n    money_spent = shares_bought * min_buy\n    money_earned = shares_bought * max_sell\n    remaining_money = r - money_spent\n    result = remaining_money + money_earned\nelse:\n    result = r\n\nprint(result)\n\n\n"], "prompt_tokens": [12141], "completion_tokens": [2973], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "42f25d492bddc12d3d89d39315d63cb9"}
{"description": "Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows.You are given a segment with length $$$l$$$. We randomly choose $$$n$$$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $$$n$$$, and another integer $$$k$$$. The $$$2n$$$ endpoints of the chosen segments split the segment into $$$(2n+1)$$$ intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $$$k$$$ segments of the $$$n$$$ random segments.You should find the answer modulo $$$998244353$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "First line contains three space-separated positive integers $$$n$$$, $$$k$$$ and $$$l$$$ ($$$1\\leq k \\leq n \\leq 2000$$$, $$$1\\leq l\\leq 10^9$$$).", "output_spec": "Output one integer\u00a0\u2014 the expected total length of all the intervals covered by at least $$$k$$$ segments of the $$$n$$$ random segments modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.", "notes": "NoteIn the first example, the expected total length is $$$\\int_0^1 \\int_0^1 |x-y| \\,\\mathrm{d}x\\,\\mathrm{d}y = {1\\over 3}$$$, and $$$3^{-1}$$$ modulo $$$998244353$$$ is $$$332748118$$$.", "sample_inputs": ["1 1 1", "6 2 1", "7 5 3", "97 31 9984524"], "sample_outputs": ["332748118", "760234711", "223383352", "267137618"], "tags": ["math", "probabilities", "combinatorics", "dp"], "src_uid": "c9e79e83928d5d034123ebc3b2f5e064", "difficulty": 2600, "source_codes": ["def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    \n    # Read input\n    n, k, l = map(int, input().split())\n    \n    # Precompute factorials and inverse factorials\n    max_n = 2 * n + 1\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    ifact = [1] * (max_n + 1)\n    ifact[max_n] = mod_inverse(fact[max_n], MOD)\n    for i in range(max_n - 1, -1, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % MOD\n    \n    # Calculate C(2n, n)\n    cn = fact[2 * n] * ifact[n] % MOD * ifact[n] % MOD\n    \n    # Calculate sum for i from k to n of C(n,i)^2 * (2*i + 1)\n    numerator_sum = 0\n    for i in range(k, n + 1):\n        # Calculate C(n, i)\n        cni = fact[n] * ifact[i] % MOD * ifact[n - i] % MOD\n        # Add C(n, i)^2 * (2*i + 1) to sum\n        term = cni * cni % MOD * (2 * i + 1) % MOD\n        numerator_sum = (numerator_sum + term) % MOD\n    \n    # Final result is l * numerator_sum / (C(2n, n) * (2n + 1))\n    denominator = cn * (2 * n + 1) % MOD\n    result = l * numerator_sum % MOD\n    result = result * mod_inverse(denominator, MOD) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    \n    # Read input\n    n, k, l = map(int, input().split())\n    \n    # Precompute factorials and inverse factorials\n    max_n = 2 * n + 1\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    ifact = [1] * (max_n + 1)\n    ifact[max_n] = mod_inverse(fact[max_n], MOD)\n    for i in range(max_n - 1, -1, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % MOD\n    \n    # Calculate C(2n, n)\n    cn = fact[2 * n] * ifact[n] % MOD * ifact[n] % MOD\n    \n    # Calculate sum for i from k to n of C(n,i)^2 * (2*i + 1)\n    numerator_sum = 0\n    for i in range(k, n + 1):\n        # Calculate C(n, i)\n        cni = fact[n] * ifact[i] % MOD * ifact[n - i] % MOD\n        # Add C(n, i)^2 * (2*i + 1) to sum\n        term = cni * cni % MOD * (2 * i + 1) % MOD\n        numerator_sum = (numerator_sum + term) % MOD\n    \n    # Final result is l * numerator_sum / (C(2n, n) * (2n + 1))\n    denominator = cn * (2 * n + 1) % MOD\n    result = l * numerator_sum % MOD\n    result = result * mod_inverse(denominator, MOD) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [15980], "completion_tokens": [8450], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "c9e79e83928d5d034123ebc3b2f5e064"}
{"description": "Young Teodor enjoys drawing. His favourite hobby is drawing segments with integer borders inside his huge [1;m] segment. One day Teodor noticed that picture he just drawn has one interesting feature: there doesn't exist an integer point, that belongs each of segments in the picture. Having discovered this fact, Teodor decided to share it with Sasha.Sasha knows that Teodor likes to show off so he never trusts him. Teodor wants to prove that he can be trusted sometimes, so he decided to convince Sasha that there is no such integer point in his picture, which belongs to each segment. However Teodor is lazy person and neither wills to tell Sasha all coordinates of segments' ends nor wills to tell him their amount, so he suggested Sasha to ask him series of questions 'Given the integer point xi, how many segments in Fedya's picture contain that point?', promising to tell correct answers for this questions.Both boys are very busy studying and don't have much time, so they ask you to find out how many questions can Sasha ask Teodor, that having only answers on his questions, Sasha can't be sure that Teodor isn't lying to him. Note that Sasha doesn't know amount of segments in Teodor's picture. Sure, Sasha is smart person and never asks about same point twice.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "First line of input contains two integer numbers: n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100\u2009000)\u00a0\u2014 amount of segments of Teodor's picture and maximal coordinate of point that Sasha can ask about. ith of next n lines contains two integer numbers li and ri (1\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u2009m)\u00a0\u2014 left and right ends of ith segment in the picture. Note that that left and right ends of segment can be the same point. It is guaranteed that there is no integer point, that belongs to all segments.", "output_spec": "Single line of output should contain one integer number k \u2013 size of largest set (xi,\u2009cnt(xi)) where all xi are different, 1\u2009\u2264\u2009xi\u2009\u2264\u2009m, and cnt(xi) is amount of segments, containing point with coordinate xi, such that one can't be sure that there doesn't exist point, belonging to all of segments in initial picture, if he knows only this set(and doesn't know n).", "notes": "NoteFirst example shows situation where Sasha can never be sure that Teodor isn't lying to him, because even if one knows cnt(xi) for each point in segment [1;4], he can't distinguish this case from situation Teodor has drawn whole [1;4] segment.In second example Sasha can ask about 5 points e.g. 1,\u20092,\u20093,\u20095,\u20096, still not being sure if Teodor haven't lied to him. But once he knows information about all points in [1;6] segment, Sasha can be sure that Teodor haven't lied to him.", "sample_inputs": ["2 4\n1 2\n3 4", "4 6\n1 3\n2 3\n4 6\n5 6"], "sample_outputs": ["4", "5"], "tags": ["data structures", "dp", "binary search"], "src_uid": "ce8350be138ce2061349d7f9224a5aaf", "difficulty": 1900, "source_codes": ["import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    segments = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        segments.append((l, r))\n        idx += 2\n    \n    # Count coverage for each point\n    count = [0] * (m + 2)  # 1-indexed, extra space to avoid boundary checks\n    \n    for l, r in segments:\n        count[l] += 1\n        count[r + 1] -= 1\n        \n    # Convert to actual counts\n    for i in range(1, m + 1):\n        count[i] += count[i - 1]\n    \n    # Find minimum coverage\n    min_coverage = min(count[1:m+1])\n    \n    # Find all points with minimum coverage\n    min_points = [i for i in range(1, m + 1) if count[i] == min_coverage]\n    \n    # The answer is the number of points with minimal coverage\n    # Because querying all but these points would still leave ambiguity\n    result = len(min_points)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    segments = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        segments.append((l, r))\n        idx += 2\n    \n    # Count coverage for each point\n    count = [0] * (m + 2)  # 1-indexed, extra space to avoid boundary checks\n    \n    for l, r in segments:\n        count[l] += 1\n        count[r + 1] -= 1\n        \n    # Convert to actual counts\n    for i in range(1, m + 1):\n        count[i] += count[i - 1]\n    \n    # Find minimum coverage\n    min_coverage = min(count[1:m+1])\n    \n    # Find all points with minimum coverage\n    min_points = [i for i in range(1, m + 1) if count[i] == min_coverage]\n    \n    # The answer is the number of points with minimal coverage\n    # Because querying all but these points would still leave ambiguity\n    result = len(min_points)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [8311], "completion_tokens": [2665], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "ce8350be138ce2061349d7f9224a5aaf"}
{"description": "You are given an integer N. Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and N, inclusive; there will be  of them.You want to draw these segments in several layers so that in each layer the segments don't overlap (they might touch at the endpoints though). You can not move the segments to a different location on the coordinate axis. Find the minimal number of layers you have to use for the given N.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only input line contains a single integer N (1\u2009\u2264\u2009N\u2009\u2264\u2009100).", "output_spec": "Output a single integer - the minimal number of layers required to draw the segments for the given N.", "notes": "NoteAs an example, here are the segments and their optimal arrangement into layers for N\u2009=\u20094.  ", "sample_inputs": ["2", "3", "4"], "sample_outputs": ["2", "4", "6"], "tags": ["math", "constructive algorithms"], "src_uid": "f8af5dfcf841a7f105ac4c144eb51319", "difficulty": 1300, "source_codes": ["n = int(input())\n\nif n % 2 == 0:\n    # For even N: (N/2) * (N/2 + 1)\n    half_n = n // 2\n    result = half_n * (half_n + 1)\nelse:\n    # For odd N: ((N+1)/2)^2\n    half_n_plus_one = (n + 1) // 2\n    result = half_n_plus_one * half_n_plus_one\n    \nprint(result)"], "responses": ["\nn = int(input())\n\nif n % 2 == 0:\n    # For even N: (N/2) * (N/2 + 1)\n    half_n = n // 2\n    result = half_n * (half_n + 1)\nelse:\n    # For odd N: ((N+1)/2)^2\n    half_n_plus_one = (n + 1) // 2\n    result = half_n_plus_one * half_n_plus_one\n    \nprint(result)\n\n\n"], "prompt_tokens": [8208], "completion_tokens": [5734], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "f8af5dfcf841a7f105ac4c144eb51319"}
{"description": "Given an integer $$$x$$$. Your task is to find out how many positive integers $$$n$$$ ($$$1 \\leq n \\leq x$$$) satisfy $$$$$$n \\cdot a^n \\equiv b \\quad (\\textrm{mod}\\;p),$$$$$$ where $$$a, b, p$$$ are all known constants.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains four integers $$$a,b,p,x$$$ ($$$2 \\leq p \\leq 10^6+3$$$, $$$1 \\leq a,b &lt; p$$$, $$$1 \\leq x \\leq 10^{12}$$$). It is guaranteed that $$$p$$$ is a prime.", "output_spec": "Print a single integer: the number of possible answers $$$n$$$.", "notes": "NoteIn the first sample, we can see that $$$n=2$$$ and $$$n=8$$$ are possible answers.", "sample_inputs": ["2 3 5 8", "4 6 7 13", "233 233 10007 1"], "sample_outputs": ["2", "1", "1"], "tags": ["math", "chinese remainder theorem", "number theory"], "src_uid": "4b9f470e5889da29affae6376f6c9f6a", "difficulty": 2100, "source_codes": ["def mod_inverse(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(a, b, p, x):\n    # Precompute powers of a modulo p\n    # By Fermat's little theorem, a^(p-1) \u2261 1 (mod p)\n    powers = [1] * p\n    for i in range(1, p):\n        powers[i] = (powers[i-1] * a) % p\n    \n    count = 0\n    \n    # For each possible remainder r when n is divided by (p-1)\n    # n = k*(p-1) + r where 0 \u2264 r < p-1\n    for r in range(p - 1):\n        # We want n * a^n \u2261 b (mod p)\n        # Since n \u2261 r (mod p-1), we have a^n \u2261 a^r (mod p)\n        # So we need n * a^r \u2261 b (mod p)\n        # Which gives us n \u2261 b / a^r (mod p) if a^r \u2260 0\n        \n        a_power = powers[r]\n        \n        if a_power == 0:\n            continue\n            \n        # Calculate n \u2261 b * inverse(a^r) (mod p)\n        n_mod_p = (b * mod_inverse(a_power, p)) % p\n        if n_mod_p == 0:\n            n_mod_p = p\n            \n        # Now we need to solve the system:\n        # n \u2261 r (mod p-1)\n        # n \u2261 n_mod_p (mod p)\n        \n        # Using Chinese Remainder Theorem\n        # We want to find n such that:\n        # n = r + t*(p-1) for some integer t\n        # and n \u2261 n_mod_p (mod p)\n        # So: r + t*(p-1) \u2261 n_mod_p (mod p)\n        # Since (p-1) \u2261 -1 (mod p):\n        # r - t \u2261 n_mod_p (mod p)\n        # t \u2261 r - n_mod_p (mod p)\n        \n        t = (r - n_mod_p) % p\n        first_solution = r + t * (p - 1)\n        \n        # Handle the case when first_solution is 0\n        if first_solution == 0:\n            first_solution = (p - 1) * p\n            \n        # The solutions form an arithmetic sequence with difference (p-1)*p\n        # Count how many such solutions exist in [1, x]\n        if first_solution <= x:\n            count += 1 + (x - first_solution) // ((p - 1) * p)\n    \n    return count\n\n# Read input\nline = input().strip()\na, b, p, x = map(int, line.split())\n\n# Solve and print result\nresult = solve(a, b, p, x)\nprint(result)"], "responses": ["\ndef mod_inverse(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(a, b, p, x):\n    # Precompute powers of a modulo p\n    # By Fermat's little theorem, a^(p-1) \u2261 1 (mod p)\n    powers = [1] * p\n    for i in range(1, p):\n        powers[i] = (powers[i-1] * a) % p\n    \n    count = 0\n    \n    # For each possible remainder r when n is divided by (p-1)\n    # n = k*(p-1) + r where 0 \u2264 r < p-1\n    for r in range(p - 1):\n        # We want n * a^n \u2261 b (mod p)\n        # Since n \u2261 r (mod p-1), we have a^n \u2261 a^r (mod p)\n        # So we need n * a^r \u2261 b (mod p)\n        # Which gives us n \u2261 b / a^r (mod p) if a^r \u2260 0\n        \n        a_power = powers[r]\n        \n        if a_power == 0:\n            continue\n            \n        # Calculate n \u2261 b * inverse(a^r) (mod p)\n        n_mod_p = (b * mod_inverse(a_power, p)) % p\n        if n_mod_p == 0:\n            n_mod_p = p\n            \n        # Now we need to solve the system:\n        # n \u2261 r (mod p-1)\n        # n \u2261 n_mod_p (mod p)\n        \n        # Using Chinese Remainder Theorem\n        # We want to find n such that:\n        # n = r + t*(p-1) for some integer t\n        # and n \u2261 n_mod_p (mod p)\n        # So: r + t*(p-1) \u2261 n_mod_p (mod p)\n        # Since (p-1) \u2261 -1 (mod p):\n        # r - t \u2261 n_mod_p (mod p)\n        # t \u2261 r - n_mod_p (mod p)\n        \n        t = (r - n_mod_p) % p\n        first_solution = r + t * (p - 1)\n        \n        # Handle the case when first_solution is 0\n        if first_solution == 0:\n            first_solution = (p - 1) * p\n            \n        # The solutions form an arithmetic sequence with difference (p-1)*p\n        # Count how many such solutions exist in [1, x]\n        if first_solution <= x:\n            count += 1 + (x - first_solution) // ((p - 1) * p)\n    \n    return count\n\n# Read input\nline = input().strip()\na, b, p, x = map(int, line.split())\n\n# Solve and print result\nresult = solve(a, b, p, x)\nprint(result)\n\n\n"], "prompt_tokens": [9912], "completion_tokens": [7780], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "4b9f470e5889da29affae6376f6c9f6a"}
{"description": "Imp is in a magic forest, where xorangles grow (wut?)  A xorangle of order n is such a non-degenerate triangle, that lengths of its sides are integers not exceeding n, and the xor-sum of the lengths is equal to zero. Imp has to count the number of distinct xorangles of order n to get out of the forest. Formally, for a given integer n you have to find the number of such triples (a,\u2009b,\u2009c), that:  1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009c\u2009\u2264\u2009n;  , where  denotes the bitwise xor of integers x and y.  (a,\u2009b,\u2009c) form a non-degenerate (with strictly positive area) triangle. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092500).", "output_spec": "Print the number of xorangles of order n.", "notes": "NoteThe only xorangle in the first sample is (3,\u20095,\u20096).", "sample_inputs": ["6", "10"], "sample_outputs": ["1", "2"], "tags": ["brute force"], "src_uid": "838f2e75fdff0f13f002c0dfff0b2e8d", "difficulty": 1300, "source_codes": ["n = int(input())\n\ncount = 0\nfor a in range(1, n + 1):\n    for b in range(a, n + 1):\n        c = a ^ b\n        if c >= 1 and c <= n and b <= c and a + b > c:\n            count += 1\n\nprint(count)"], "responses": ["\nn = int(input())\n\ncount = 0\nfor a in range(1, n + 1):\n    for b in range(a, n + 1):\n        c = a ^ b\n        if c >= 1 and c <= n and b <= c and a + b > c:\n            count += 1\n\nprint(count)\n\n\n"], "prompt_tokens": [9465], "completion_tokens": [2367], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "838f2e75fdff0f13f002c0dfff0b2e8d"}
{"description": "Mahmoud and Ehab play a game called the even-odd game. Ehab chooses his favorite integer n and then they take turns, starting from Mahmoud. In each player's turn, he has to choose an integer a and subtract it from n such that:  1\u2009\u2264\u2009a\u2009\u2264\u2009n.  If it's Mahmoud's turn, a has to be even, but if it's Ehab's turn, a has to be odd. If the current player can't choose any number satisfying the conditions, he loses. Can you determine the winner if they both play optimally?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109), the number at the beginning of the game.", "output_spec": "Output \"Mahmoud\" (without quotes) if Mahmoud wins and \"Ehab\" (without quotes) otherwise.", "notes": "NoteIn the first sample, Mahmoud can't choose any integer a initially because there is no positive even integer less than or equal to 1 so Ehab wins.In the second sample, Mahmoud has to choose a\u2009=\u20092 and subtract it from n. It's Ehab's turn and n\u2009=\u20090. There is no positive odd integer less than or equal to 0 so Mahmoud wins.", "sample_inputs": ["1", "2"], "sample_outputs": ["Ehab", "Mahmoud"], "tags": ["games", "math"], "src_uid": "5e74750f44142624e6da41d4b35beb9a", "difficulty": 800, "source_codes": ["n = int(input())\nif n % 2 == 0:\n    print(\"Mahmoud\")\nelse:\n    print(\"Ehab\")"], "responses": ["\nn = int(input())\nif n % 2 == 0:\n    print(\"Mahmoud\")\nelse:\n    print(\"Ehab\")\n\n\n"], "prompt_tokens": [7941], "completion_tokens": [1792], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "5e74750f44142624e6da41d4b35beb9a"}
{"description": "Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.She has ordered a very big round pizza, in order to serve her many friends. Exactly $$$n$$$ of Shiro's friends are here. That's why she has to divide the pizza into $$$n + 1$$$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "128 megabytes", "input_spec": "A single line contains one non-negative integer $$$n$$$ ($$$0 \\le n \\leq 10^{18}$$$)\u00a0\u2014 the number of Shiro's friends. The circular pizza has to be sliced into $$$n + 1$$$ pieces.", "output_spec": "A single integer\u00a0\u2014 the number of straight cuts Shiro needs.", "notes": "NoteTo cut the round pizza into quarters one has to make two cuts through the center with angle $$$90^{\\circ}$$$ between them.To cut the round pizza into five equal parts one has to make five cuts.", "sample_inputs": ["3", "4"], "sample_outputs": ["2", "5"], "tags": ["math"], "src_uid": "236177ff30dafe68295b5d33dc501828", "difficulty": 1000, "source_codes": ["n = int(input())\nslices = n + 1\n\nif slices == 1:\n    print(0)\nelif slices % 2 == 0:\n    print(slices // 2)\nelse:\n    print(slices)"], "responses": ["\nn = int(input())\nslices = n + 1\n\nif slices == 1:\n    print(0)\nelif slices % 2 == 0:\n    print(slices // 2)\nelse:\n    print(slices)\n\n\n"], "prompt_tokens": [9388], "completion_tokens": [2466], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "236177ff30dafe68295b5d33dc501828"}
{"description": "Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,\u2009b) good, if GCD(a,\u2009b)\u2009=\u2009x and LCM(a,\u2009b)\u2009=\u2009y, where GCD(a,\u2009b) denotes the greatest common divisor of a and b, and LCM(a,\u2009b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,\u2009b) such that l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r. Note that pairs (a,\u2009b) and (b,\u2009a) are considered different if a\u2009\u2260\u2009b.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line contains four integers l,\u2009r,\u2009x,\u2009y (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009109).", "output_spec": "In the only line print the only integer\u00a0\u2014 the answer for the problem.", "notes": "NoteIn the first example there are two suitable good pairs of integers (a,\u2009b): (1,\u20092) and (2,\u20091).In the second example there are four suitable good pairs of integers (a,\u2009b): (1,\u200912), (12,\u20091), (3,\u20094) and (4,\u20093).In the third example there are good pairs of integers, for example, (3,\u200930), but none of them fits the condition l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r.", "sample_inputs": ["1 2 1 2", "1 12 1 12", "50 100 3 30"], "sample_outputs": ["2", "4", "0"], "tags": ["math", "number theory"], "src_uid": "d37dde5841116352c9b37538631d0b15", "difficulty": 1600, "source_codes": ["import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_good_pairs(l, r, x, y):\n    # If x > y or y is not divisible by x, no solutions exist\n    if x > y or y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    # Iterate through all possible values of the first normalized number\n    # We only need to check up to sqrt(k) to avoid double counting\n    sqrt_k = int(math.sqrt(k))\n    \n    for i in range(1, sqrt_k + 1):\n        if k % i == 0:  # i is a divisor of k\n            j = k // i  # corresponding divisor\n            \n            # Check if i and j are coprime\n            if gcd(i, j) == 1:\n                # Calculate actual values\n                a1, b1 = x * i, x * j\n                \n                # Check if they are within range\n                if l <= a1 <= r and l <= b1 <= r:\n                    if i == j:\n                        # When i = j, only one pair (a1, b1)\n                        count += 1\n                    else:\n                        # When i != j, we have two pairs: (a1, b1) and (b1, a1)\n                        count += 2\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Solve and print result\nprint(count_good_pairs(l, r, x, y))"], "responses": ["\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_good_pairs(l, r, x, y):\n    # If x > y or y is not divisible by x, no solutions exist\n    if x > y or y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    # Iterate through all possible values of the first normalized number\n    # We only need to check up to sqrt(k) to avoid double counting\n    sqrt_k = int(math.sqrt(k))\n    \n    for i in range(1, sqrt_k + 1):\n        if k % i == 0:  # i is a divisor of k\n            j = k // i  # corresponding divisor\n            \n            # Check if i and j are coprime\n            if gcd(i, j) == 1:\n                # Calculate actual values\n                a1, b1 = x * i, x * j\n                \n                # Check if they are within range\n                if l <= a1 <= r and l <= b1 <= r:\n                    if i == j:\n                        # When i = j, only one pair (a1, b1)\n                        count += 1\n                    else:\n                        # When i != j, we have two pairs: (a1, b1) and (b1, a1)\n                        count += 2\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Solve and print result\nprint(count_good_pairs(l, r, x, y))\n\n\n"], "prompt_tokens": [12616], "completion_tokens": [5042], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "d37dde5841116352c9b37538631d0b15"}
{"description": "Vasya has got a tree consisting of $$$n$$$ vertices. He wants to delete some (possibly zero) edges in this tree such that the maximum matching in the resulting graph is unique. He asks you to calculate the number of ways to choose a set of edges to remove.A matching in the graph is a subset of its edges such that there is no vertex incident to two (or more) edges from the subset. A maximum matching is a matching such that the number of edges in the subset is maximum possible among all matchings in this graph.Since the answer may be large, output it modulo $$$998244353$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$) \u2014 the number of vertices in the tree. Each of the next $$$n \u2212 1$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n, u \\neq v$$$) denoting an edge between vertex $$$u$$$ and vertex $$$v$$$. It is guaranteed that these edges form a tree.", "output_spec": "Print one integer \u2014 the number of ways to delete some (possibly empty) subset of edges so that the maximum matching in the resulting graph is unique. Print the answer modulo $$$998244353$$$.", "notes": "NotePossible ways to delete edges in the first example:   delete $$$(1, 2)$$$ and $$$(1, 3)$$$.  delete $$$(1, 2)$$$ and $$$(1, 4)$$$.  delete $$$(1, 3)$$$ and $$$(1, 4)$$$.  delete all edges. Possible ways to delete edges in the second example:   delete no edges.  delete $$$(1, 2)$$$ and $$$(2, 3)$$$.  delete $$$(1, 2)$$$ and $$$(3, 4)$$$.  delete $$$(2, 3)$$$ and $$$(3, 4)$$$.  delete $$$(2, 3)$$$.  delete all edges. ", "sample_inputs": ["4\n1 2\n1 3\n1 4", "4\n1 2\n2 3\n3 4", "1"], "sample_outputs": ["4", "6", "1"], "tags": ["dp", "trees"], "src_uid": "a40e78a7144ac2fae1890ac7598990bf", "difficulty": 2400, "source_codes": ["import sys\nsys.setrecursionlimit(1 << 25)\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    if n == 1:\n        print(1)\n        return\n        \n    adj = [[] for _ in range(n + 1)]\n    idx = 1\n    for _ in range(n - 1):\n        u = int(data[idx])\n        v = int(data[idx + 1])\n        idx += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # For each node, return:\n    # (max_match_size_if_unmatched, is_unique_if_unmatched, ways_if_unmatched,\n    #  max_match_size_if_matched, is_unique_if_matched, ways_if_matched)\n    \n    def dfs(u, parent):\n        children = [v for v in adj[u] if v != parent]\n        \n        if not children:\n            # Leaf node\n            return (0, True, 1, 0, False, 0)\n        \n        child_results = []\n        for v in children:\n            res = dfs(v, u)\n            child_results.append(res)\n        \n        # Case 1: u is unmatched - take optimal from each child\n        total_m0 = 0\n        total_unique0 = True\n        total_count0 = 1\n        \n        for m0_c, uniq0_c, cnt0_c, m1_c, uniq1_c, cnt1_c in child_results:\n            if m0_c > m1_c:\n                total_m0 += m0_c\n                if not uniq0_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * cnt0_c) % MOD\n            elif m1_c > m0_c:\n                total_m0 += m1_c\n                if not uniq1_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * cnt1_c) % MOD\n            else:  # m0_c == m1_c\n                total_m0 += m0_c\n                # If both options give same matching size but either is not unique, result is not unique\n                if not uniq0_c or not uniq1_c:\n                    total_unique0 = False\n                # If both are unique, we can choose either, so not unique overall\n                elif uniq0_c and uniq1_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * (cnt0_c + cnt1_c)) % MOD\n        \n        # Case 2: u is matched with one of its children\n        best_m1 = -1\n        best_unique1 = False\n        best_count1 = 0\n        \n        # Try matching u with each child\n        for i in range(len(children)):\n            v = children[i]\n            m0_v, uniq0_v, cnt0_v, m1_v, uniq1_v, cnt1_v = child_results[i]\n            \n            # Match u with child v: we get 1 edge + max matching in v's subtree where v is unmatched\n            current_m1 = 1 + m0_v\n            \n            # For other children, take their optimal matching\n            others_m = 0\n            others_unique = True\n            others_count = 1\n            \n            for j in range(len(children)):\n                if j == i:\n                    continue\n                m0_c, uniq0_c, cnt0_c, m1_c, uniq1_c, cnt1_c = child_results[j]\n                if m0_c > m1_c:\n                    others_m += m0_c\n                    if not uniq0_c:\n                        others_unique = False\n                    others_count = (others_count * cnt0_c) % MOD\n                elif m1_c > m0_c:\n                    others_m += m1_c\n                    if not uniq1_c:\n                        others_unique = False\n                    others_count = (others_count * cnt1_c) % MOD\n                else:  # m0_c == m1_c\n                    others_m += m0_c\n                    if not uniq0_c or not uniq1_c:\n                        others_unique = False\n                    elif uniq0_c and uniq1_c:\n                        # Both options are unique but different -> not unique overall\n                        others_unique = False\n                    others_count = (others_count * (cnt0_c + cnt1_c)) % MOD\n            \n            current_m1 += others_m\n            current_unique = others_unique and uniq0_v\n            current_count = (others_count * cnt0_v) % MOD\n            \n            if current_m1 > best_m1:\n                best_m1 = current_m1\n                best_unique1 = current_unique\n                best_count1 = current_count\n            elif current_m1 == best_m1:\n                if best_unique1 and current_unique:\n                    best_unique1 = False\n                    best_count1 = (best_count1 + current_count) % MOD\n                elif current_unique and not best_unique1:\n                    best_unique1 = True\n                    best_count1 = current_count\n                elif not best_unique1:\n                    best_count1 = (best_count1 + current_count) % MOD\n        \n        if best_m1 == -1:\n            best_m1 = 0\n            best_unique1 = False\n            best_count1 = 0\n                    \n        return (total_m0, total_unique0, total_count0, best_m1, best_unique1, best_count1)\n    \n    res = dfs(1, -1)\n    m0, uniq0, cnt0, m1, uniq1, cnt1 = res\n    \n    if m0 > m1:\n        print(cnt0 if uniq0 else 0)\n    elif m1 > m0:\n        print(cnt1 if uniq1 else 0)\n    else:  # m0 == m1\n        ans = 0\n        if uniq0:\n            ans = (ans + cnt0) % MOD\n        if uniq1:\n            ans = (ans + cnt1) % MOD\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nsys.setrecursionlimit(1 << 25)\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    if n == 1:\n        print(1)\n        return\n        \n    adj = [[] for _ in range(n + 1)]\n    idx = 1\n    for _ in range(n - 1):\n        u = int(data[idx])\n        v = int(data[idx + 1])\n        idx += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # For each node, return:\n    # (max_match_size_if_unmatched, is_unique_if_unmatched, ways_if_unmatched,\n    #  max_match_size_if_matched, is_unique_if_matched, ways_if_matched)\n    \n    def dfs(u, parent):\n        children = [v for v in adj[u] if v != parent]\n        \n        if not children:\n            # Leaf node\n            return (0, True, 1, 0, False, 0)\n        \n        child_results = []\n        for v in children:\n            res = dfs(v, u)\n            child_results.append(res)\n        \n        # Case 1: u is unmatched - take optimal from each child\n        total_m0 = 0\n        total_unique0 = True\n        total_count0 = 1\n        \n        for m0_c, uniq0_c, cnt0_c, m1_c, uniq1_c, cnt1_c in child_results:\n            if m0_c > m1_c:\n                total_m0 += m0_c\n                if not uniq0_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * cnt0_c) % MOD\n            elif m1_c > m0_c:\n                total_m0 += m1_c\n                if not uniq1_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * cnt1_c) % MOD\n            else:  # m0_c == m1_c\n                total_m0 += m0_c\n                # If both options give same matching size but either is not unique, result is not unique\n                if not uniq0_c or not uniq1_c:\n                    total_unique0 = False\n                # If both are unique, we can choose either, so not unique overall\n                elif uniq0_c and uniq1_c:\n                    total_unique0 = False\n                total_count0 = (total_count0 * (cnt0_c + cnt1_c)) % MOD\n        \n        # Case 2: u is matched with one of its children\n        best_m1 = -1\n        best_unique1 = False\n        best_count1 = 0\n        \n        # Try matching u with each child\n        for i in range(len(children)):\n            v = children[i]\n            m0_v, uniq0_v, cnt0_v, m1_v, uniq1_v, cnt1_v = child_results[i]\n            \n            # Match u with child v: we get 1 edge + max matching in v's subtree where v is unmatched\n            current_m1 = 1 + m0_v\n            \n            # For other children, take their optimal matching\n            others_m = 0\n            others_unique = True\n            others_count = 1\n            \n            for j in range(len(children)):\n                if j == i:\n                    continue\n                m0_c, uniq0_c, cnt0_c, m1_c, uniq1_c, cnt1_c = child_results[j]\n                if m0_c > m1_c:\n                    others_m += m0_c\n                    if not uniq0_c:\n                        others_unique = False\n                    others_count = (others_count * cnt0_c) % MOD\n                elif m1_c > m0_c:\n                    others_m += m1_c\n                    if not uniq1_c:\n                        others_unique = False\n                    others_count = (others_count * cnt1_c) % MOD\n                else:  # m0_c == m1_c\n                    others_m += m0_c\n                    if not uniq0_c or not uniq1_c:\n                        others_unique = False\n                    elif uniq0_c and uniq1_c:\n                        # Both options are unique but different -> not unique overall\n                        others_unique = False\n                    others_count = (others_count * (cnt0_c + cnt1_c)) % MOD\n            \n            current_m1 += others_m\n            current_unique = others_unique and uniq0_v\n            current_count = (others_count * cnt0_v) % MOD\n            \n            if current_m1 > best_m1:\n                best_m1 = current_m1\n                best_unique1 = current_unique\n                best_count1 = current_count\n            elif current_m1 == best_m1:\n                if best_unique1 and current_unique:\n                    best_unique1 = False\n                    best_count1 = (best_count1 + current_count) % MOD\n                elif current_unique and not best_unique1:\n                    best_unique1 = True\n                    best_count1 = current_count\n                elif not best_unique1:\n                    best_count1 = (best_count1 + current_count) % MOD\n        \n        if best_m1 == -1:\n            best_m1 = 0\n            best_unique1 = False\n            best_count1 = 0\n                    \n        return (total_m0, total_unique0, total_count0, best_m1, best_unique1, best_count1)\n    \n    res = dfs(1, -1)\n    m0, uniq0, cnt0, m1, uniq1, cnt1 = res\n    \n    if m0 > m1:\n        print(cnt0 if uniq0 else 0)\n    elif m1 > m0:\n        print(cnt1 if uniq1 else 0)\n    else:  # m0 == m1\n        ans = 0\n        if uniq0:\n            ans = (ans + cnt0) % MOD\n        if uniq1:\n            ans = (ans + cnt1) % MOD\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [17512], "completion_tokens": [10739], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "a40e78a7144ac2fae1890ac7598990bf"}
{"description": "You are given a binary string $$$s$$$.Find the number of distinct cyclical binary strings of length $$$n$$$ which contain $$$s$$$ as a substring.The cyclical string $$$t$$$ contains $$$s$$$ as a substring if there is some cyclical shift of string $$$t$$$, such that $$$s$$$ is a substring of this cyclical shift of $$$t$$$.For example, the cyclical string \"000111\" contains substrings \"001\", \"01110\" and \"10\", but doesn't contain \"0110\" and \"10110\".Two cyclical strings are called different if they differ from each other as strings. For example, two different strings, which differ from each other by a cyclical shift, are still considered different cyclical strings.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 40$$$)\u00a0\u2014 the length of the target string $$$t$$$. The next line contains the string $$$s$$$ ($$$1 \\le |s| \\le n$$$)\u00a0\u2014 the string which must be a substring of cyclical string $$$t$$$. String $$$s$$$ contains only characters '0' and '1'.", "output_spec": "Print the only integer\u00a0\u2014 the number of distinct cyclical binary strings $$$t$$$, which contain $$$s$$$ as a substring.", "notes": "NoteIn the first example, there are three cyclical strings, which contain \"0\"\u00a0\u2014 \"00\", \"01\" and \"10\".In the second example, there are only two such strings\u00a0\u2014 \"1010\", \"0101\".", "sample_inputs": ["2\n0", "4\n1010", "20\n10101010101010"], "sample_outputs": ["3", "2", "962"], "tags": ["dp", "strings"], "src_uid": "0034806908c9794086736a2d07fc654c", "difficulty": 2900, "source_codes": ["def solve():\n    n = int(input())\n    s = input().strip()\n    \n    if len(s) > n:\n        print(0)\n        return\n    \n    count = 0\n    \n    # Generate all possible binary strings of length n\n    for i in range(1 << n):\n        # Convert number to binary string of length n\n        t = format(i, f'0{n}b')\n        \n        # Create doubled string to check all cyclic shifts\n        doubled_t = t + t\n        \n        # Check if s appears in any cyclic shift\n        # We need to check positions 0 to n-1 in the doubled string\n        found = False\n        for j in range(n):\n            if doubled_t[j:j+len(s)] == s:\n                found = True\n                break\n        \n        if found:\n            count += 1\n    \n    print(count)\n\nsolve()"], "responses": ["\ndef solve():\n    n = int(input())\n    s = input().strip()\n    \n    if len(s) > n:\n        print(0)\n        return\n    \n    count = 0\n    \n    # Generate all possible binary strings of length n\n    for i in range(1 << n):\n        # Convert number to binary string of length n\n        t = format(i, f'0{n}b')\n        \n        # Create doubled string to check all cyclic shifts\n        doubled_t = t + t\n        \n        # Check if s appears in any cyclic shift\n        # We need to check positions 0 to n-1 in the doubled string\n        found = False\n        for j in range(n):\n            if doubled_t[j:j+len(s)] == s:\n                found = True\n                break\n        \n        if found:\n            count += 1\n    \n    print(count)\n\nsolve()\n\n\n"], "prompt_tokens": [10188], "completion_tokens": [6186], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "0034806908c9794086736a2d07fc654c"}
{"description": "Masha has three sticks of length $$$a$$$, $$$b$$$ and $$$c$$$ centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allowed to break sticks.What is the minimum number of minutes she needs to spend increasing the stick's length in order to be able to assemble a triangle of positive area. Sticks should be used as triangle's sides (one stick for one side) and their endpoints should be located at triangle's vertices.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains tree integers $$$a$$$, $$$b$$$ and $$$c$$$ ($$$1 \\leq a, b, c \\leq 100$$$)\u00a0\u2014 the lengths of sticks Masha possesses.", "output_spec": "Print a single integer\u00a0\u2014 the minimum number of minutes that Masha needs to spend in order to be able to make the triangle of positive area from her sticks.", "notes": "NoteIn the first example, Masha can make a triangle from the sticks without increasing the length of any of them.In the second example, Masha can't make a triangle of positive area from the sticks she has at the beginning, but she can spend one minute to increase the length $$$2$$$ centimeter stick by one and after that form a triangle with sides $$$3$$$, $$$3$$$ and $$$5$$$ centimeters.In the third example, Masha can take $$$33$$$ minutes to increase one of the $$$10$$$ centimeters sticks by $$$33$$$ centimeters, and after that take $$$48$$$ minutes to increase another $$$10$$$ centimeters stick by $$$48$$$ centimeters. This way she can form a triangle with lengths $$$43$$$, $$$58$$$ and $$$100$$$ centimeters in $$$81$$$ minutes. One can show that it is impossible to get a valid triangle faster.", "sample_inputs": ["3 4 5", "2 5 3", "100 10 10"], "sample_outputs": ["0", "1", "81"], "tags": ["geometry", "brute force", "math"], "src_uid": "3dc56bc08606a39dd9ca40a43c452f09", "difficulty": 800, "source_codes": ["a, b, c = map(int, input().split())\nsides = sorted([a, b, c])\nx, y, z = sides[0], sides[1], sides[2]\n\nif x + y > z:\n    print(0)\nelse:\n    print(z - (x + y) + 1)"], "responses": ["\na, b, c = map(int, input().split())\nsides = sorted([a, b, c])\nx, y, z = sides[0], sides[1], sides[2]\n\nif x + y > z:\n    print(0)\nelse:\n    print(z - (x + y) + 1)\n\n\n"], "prompt_tokens": [8787], "completion_tokens": [1646], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "3dc56bc08606a39dd9ca40a43c452f09"}
{"description": "Hasan loves playing games and has recently discovered a game called TopScore. In this soccer-like game there are $$$p$$$ players doing penalty shoot-outs. Winner is the one who scores the most. In case of ties, one of the top-scorers will be declared as the winner randomly with equal probability.They have just finished the game and now are waiting for the result. But there's a tiny problem! The judges have lost the paper of scores! Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored. However, the information about the bounds is private, so Hasan only got to know his bound.According to the available data, he knows that his score is at least $$$r$$$ and sum of the scores is $$$s$$$.Thus the final state of the game can be represented in form of sequence of $$$p$$$ integers $$$a_1, a_2, \\dots, a_p$$$ ($$$0 \\le a_i$$$) \u2014 player's scores. Hasan is player number $$$1$$$, so $$$a_1 \\ge r$$$. Also $$$a_1 + a_2 + \\dots + a_p = s$$$. Two states are considered different if there exists some position $$$i$$$ such that the value of $$$a_i$$$ differs in these states. Once again, Hasan doesn't know the exact scores (he doesn't know his exact score as well). So he considers each of the final states to be equally probable to achieve.Help Hasan find the probability of him winning.It can be shown that it is in the form of $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \\ne 0$$$, $$$P \\le Q$$$. Report the value of $$$P \\cdot Q^{-1} \\pmod {998244353}$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains three integers $$$p$$$, $$$s$$$ and $$$r$$$ ($$$1 \\le p \\le 100$$$, $$$0 \\le r \\le s \\le 5000$$$) \u2014 the number of players, the sum of scores of all players and Hasan's score, respectively.", "output_spec": "Print a single integer \u2014 the probability of Hasan winning. It can be shown that it is in the form of $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \\ne 0$$$, $$$P \\le Q$$$. Report the value of $$$P \\cdot Q^{-1} \\pmod {998244353}$$$.", "notes": "NoteIn the first example Hasan can score $$$3$$$, $$$4$$$, $$$5$$$ or $$$6$$$ goals. If he scores $$$4$$$ goals or more than he scores strictly more than his only opponent. If he scores $$$3$$$ then his opponent also scores $$$3$$$ and Hasan has a probability of $$$\\frac 1 2$$$ to win the game. Thus, overall he has the probability of $$$\\frac 7 8$$$ to win.In the second example even Hasan's lower bound on goal implies him scoring more than any of his opponents. Thus, the resulting probability is $$$1$$$.", "sample_inputs": ["2 6 3", "5 20 11", "10 30 10"], "sample_outputs": ["124780545", "1", "85932500"], "tags": ["math", "probabilities", "combinatorics", "dp"], "src_uid": "609195ef4a970c62a8210dafe118580e", "difficulty": 2500, "source_codes": ["def solve():\n    MOD = 998244353\n    \n    def modinv(a):\n        return pow(a, MOD - 2, MOD)\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    p, s, r = map(int, input().split())\n    \n    if s < r:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials\n    max_val = s + p\n    fact = [1] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_val + 1)\n    inv_fact[max_val] = modinv(fact[max_val])\n    for i in range(max_val - 1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Total number of valid distributions\n    # Distribute (s-r) additional points among p players, first player already has r points\n    total_ways = comb(s - r + p - 1, p - 1)\n    \n    if total_ways == 0:\n        print(0)\n        return\n    \n    # Calculate winning probability using the correct approach\n    numerator = 0\n    \n    # For each possible score of Hasan from r to s\n    for hasan_score in range(r, s + 1):\n        remaining = s - hasan_score  # Points for other (p-1) players\n        \n        if p == 1:\n            # Only Hasan, he always wins\n            numerator = (numerator + 1) % MOD\n        else:\n            # Count cases where Hasan wins with score hasan_score\n            \n            # Method: Use inclusion-exclusion to count favorable cases\n            # We want to count distributions where Hasan's score >= all others\n            # and when tied, Hasan is chosen as winner with equal probability\n            \n            # Case 1: Hasan's score is strictly greater than everyone else\n            # Other players must score <= hasan_score - 1\n            # This is equivalent to distributing remaining points among (p-1) players \n            # where each gets at most (hasan_score - 1) points\n            \n            if hasan_score == 0:\n                # Everyone must score 0\n                if remaining == 0:\n                    # All score 0, Hasan wins with probability 1/p\n                    numerator = (numerator + 1) % MOD\n            else:\n                # Use inclusion-exclusion principle\n                # Total ways to distribute remaining points among (p-1) players\n                # minus ways where at least one player gets >= hasan_score points\n                \n                ways_total = comb(remaining + p - 2, p - 2)\n                ways_at_least_one_geq = 0\n                \n                # Inclusion-exclusion\n                for i in range(1, p):  # i is number of players getting at least hasan_score\n                    if i * hasan_score <= remaining:\n                        # Give hasan_score points to i players, distribute rest\n                        rest = remaining - i * hasan_score\n                        term = comb(p - 1, i) * comb(rest + p - 2, p - 2) % MOD\n                        if i % 2 == 1:\n                            ways_at_least_one_geq = (ways_at_least_one_geq + term) % MOD\n                        else:\n                            ways_at_least_one_geq = (ways_at_least_one_geq - term) % MOD\n                            if ways_at_least_one_geq < 0:\n                                ways_at_least_one_geq += MOD\n                    else:\n                        break\n                \n                ways_all_less = (ways_total - ways_at_least_one_geq) % MOD\n                numerator = (numerator + ways_all_less) % MOD\n            \n            # Case 2: Hasan ties for maximum score\n            # Count cases where exactly k players (including Hasan) have score hasan_score\n            # and others have score < hasan_score\n            # Hasan wins with probability 1/k in such cases\n            \n            for k in range(2, min(p + 1, remaining + 2)):  # k is number of players tied for maximum\n                # This needs to be more careful\n                # Actually, let's reconsider the approach\n                \n                # When Hasan scores exactly hasan_score and ties with (k-1) others,\n                # we choose (k-1) players from (p-1) others to also score hasan_score\n                # remaining - (k-1)*hasan_score points go to remaining (p-k) players\n                # each getting < hasan_score\n                \n                if (k - 1) * hasan_score > remaining:\n                    continue\n                    \n                remaining_others = remaining - (k - 1) * hasan_score\n                if remaining_others < 0:\n                    continue\n                \n                # Choose (k-1) players from (p-1)  \n                choose_ways = comb(p - 1, k - 1)\n                \n                # Distribute remaining_others among (p-k) players, each < hasan_score\n                if p - k == 0:\n                    distribute_ways = 1 if remaining_others == 0 else 0\n                elif remaining_others == 0:\n                    distribute_ways = 1\n                else:\n                    # Use inclusion-exclusion\n                    distribute_ways = 0\n                    for i in range(p - k + 1):\n                        if i * hasan_score <= remaining_others:\n                            stars = remaining_others - i * hasan_score\n                            term = comb(p - k, i) * comb(stars + (p - k) - 1, (p - k) - 1) % MOD\n                            if i % 2 == 0:\n                                distribute_ways = (distribute_ways + term) % MOD\n                            else:\n                                distribute_ways = (distribute_ways - term) % MOD\n                                if distribute_ways < 0:\n                                    distribute_ways += MOD\n                        else:\n                            break\n                \n                # Hasan wins with probability 1/k\n                prob_wins = modinv(k)\n                contribution = (choose_ways * distribute_ways) % MOD\n                numerator = (numerator + contribution * prob_wins) % MOD\n    \n    result = numerator * modinv(total_ways) % MOD\n    print(result)\n\nsolve()"], "responses": ["\ndef solve():\n    MOD = 998244353\n    \n    def modinv(a):\n        return pow(a, MOD - 2, MOD)\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    p, s, r = map(int, input().split())\n    \n    if s < r:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials\n    max_val = s + p\n    fact = [1] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_val + 1)\n    inv_fact[max_val] = modinv(fact[max_val])\n    for i in range(max_val - 1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # Total number of valid distributions\n    # Distribute (s-r) additional points among p players, first player already has r points\n    total_ways = comb(s - r + p - 1, p - 1)\n    \n    if total_ways == 0:\n        print(0)\n        return\n    \n    # Calculate winning probability using the correct approach\n    numerator = 0\n    \n    # For each possible score of Hasan from r to s\n    for hasan_score in range(r, s + 1):\n        remaining = s - hasan_score  # Points for other (p-1) players\n        \n        if p == 1:\n            # Only Hasan, he always wins\n            numerator = (numerator + 1) % MOD\n        else:\n            # Count cases where Hasan wins with score hasan_score\n            \n            # Method: Use inclusion-exclusion to count favorable cases\n            # We want to count distributions where Hasan's score >= all others\n            # and when tied, Hasan is chosen as winner with equal probability\n            \n            # Case 1: Hasan's score is strictly greater than everyone else\n            # Other players must score <= hasan_score - 1\n            # This is equivalent to distributing remaining points among (p-1) players \n            # where each gets at most (hasan_score - 1) points\n            \n            if hasan_score == 0:\n                # Everyone must score 0\n                if remaining == 0:\n                    # All score 0, Hasan wins with probability 1/p\n                    numerator = (numerator + 1) % MOD\n            else:\n                # Use inclusion-exclusion principle\n                # Total ways to distribute remaining points among (p-1) players\n                # minus ways where at least one player gets >= hasan_score points\n                \n                ways_total = comb(remaining + p - 2, p - 2)\n                ways_at_least_one_geq = 0\n                \n                # Inclusion-exclusion\n                for i in range(1, p):  # i is number of players getting at least hasan_score\n                    if i * hasan_score <= remaining:\n                        # Give hasan_score points to i players, distribute rest\n                        rest = remaining - i * hasan_score\n                        term = comb(p - 1, i) * comb(rest + p - 2, p - 2) % MOD\n                        if i % 2 == 1:\n                            ways_at_least_one_geq = (ways_at_least_one_geq + term) % MOD\n                        else:\n                            ways_at_least_one_geq = (ways_at_least_one_geq - term) % MOD\n                            if ways_at_least_one_geq < 0:\n                                ways_at_least_one_geq += MOD\n                    else:\n                        break\n                \n                ways_all_less = (ways_total - ways_at_least_one_geq) % MOD\n                numerator = (numerator + ways_all_less) % MOD\n            \n            # Case 2: Hasan ties for maximum score\n            # Count cases where exactly k players (including Hasan) have score hasan_score\n            # and others have score < hasan_score\n            # Hasan wins with probability 1/k in such cases\n            \n            for k in range(2, min(p + 1, remaining + 2)):  # k is number of players tied for maximum\n                # This needs to be more careful\n                # Actually, let's reconsider the approach\n                \n                # When Hasan scores exactly hasan_score and ties with (k-1) others,\n                # we choose (k-1) players from (p-1) others to also score hasan_score\n                # remaining - (k-1)*hasan_score points go to remaining (p-k) players\n                # each getting < hasan_score\n                \n                if (k - 1) * hasan_score > remaining:\n                    continue\n                    \n                remaining_others = remaining - (k - 1) * hasan_score\n                if remaining_others < 0:\n                    continue\n                \n                # Choose (k-1) players from (p-1)  \n                choose_ways = comb(p - 1, k - 1)\n                \n                # Distribute remaining_others among (p-k) players, each < hasan_score\n                if p - k == 0:\n                    distribute_ways = 1 if remaining_others == 0 else 0\n                elif remaining_others == 0:\n                    distribute_ways = 1\n                else:\n                    # Use inclusion-exclusion\n                    distribute_ways = 0\n                    for i in range(p - k + 1):\n                        if i * hasan_score <= remaining_others:\n                            stars = remaining_others - i * hasan_score\n                            term = comb(p - k, i) * comb(stars + (p - k) - 1, (p - k) - 1) % MOD\n                            if i % 2 == 0:\n                                distribute_ways = (distribute_ways + term) % MOD\n                            else:\n                                distribute_ways = (distribute_ways - term) % MOD\n                                if distribute_ways < 0:\n                                    distribute_ways += MOD\n                        else:\n                            break\n                \n                # Hasan wins with probability 1/k\n                prob_wins = modinv(k)\n                contribution = (choose_ways * distribute_ways) % MOD\n                numerator = (numerator + contribution * prob_wins) % MOD\n    \n    result = numerator * modinv(total_ways) % MOD\n    print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [14153], "completion_tokens": [10698], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "609195ef4a970c62a8210dafe118580e"}
{"description": "Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word \"abracadabra\" Hongcow will get words \"aabracadabr\", \"raabracadab\" and so on.Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of input will be a single string s (1\u2009\u2264\u2009|s|\u2009\u2264\u200950), the word Hongcow initially learns how to spell. The string s consists only of lowercase English letters ('a'\u2013'z').", "output_spec": "Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.", "notes": "NoteFor the first sample, the strings Hongcow can generate are \"abcd\", \"dabc\", \"cdab\", and \"bcda\".For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate \"bbb\".For the third sample, the two strings Hongcow can generate are \"yzyz\" and \"zyzy\".", "sample_inputs": ["abcd", "bbb", "yzyz"], "sample_outputs": ["4", "1", "2"], "tags": ["strings", "implementation"], "src_uid": "8909ac99ed4ab2ee4d681ec864c7831e", "difficulty": 900, "source_codes": ["def count_distinct_cyclic_shifts(s):\n    distinct_strings = set()\n    current = s\n    while True:\n        distinct_strings.add(current)\n        # Perform cyclic shift: move last character to front\n        current = current[-1] + current[:-1]\n        if current == s:\n            break\n    return len(distinct_strings)\n\n# Read input and solve\ns = input().strip()\nprint(count_distinct_cyclic_shifts(s))"], "responses": ["\ndef count_distinct_cyclic_shifts(s):\n    distinct_strings = set()\n    current = s\n    while True:\n        distinct_strings.add(current)\n        # Perform cyclic shift: move last character to front\n        current = current[-1] + current[:-1]\n        if current == s:\n            break\n    return len(distinct_strings)\n\n# Read input and solve\ns = input().strip()\nprint(count_distinct_cyclic_shifts(s))\n\n\n"], "prompt_tokens": [7868], "completion_tokens": [2177], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "8909ac99ed4ab2ee4d681ec864c7831e"}
