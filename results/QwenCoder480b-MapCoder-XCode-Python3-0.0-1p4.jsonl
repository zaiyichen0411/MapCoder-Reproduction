{"description": "One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of n positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter k, so now his function contains the following code:int fast_max(int n, int a[]) {     int ans = 0;    int offset = 0;    for (int i = 0; i &lt; n; ++i)        if (ans &lt; a[i]) {            ans = a[i];            offset = 0;        } else {            offset = offset + 1;            if (offset == k)                return ans;        }    return ans;}That way the function iteratively checks array elements, storing the intermediate maximum, and if after k consecutive iterations that maximum has not changed, it is returned as the answer.Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from 1 to n such that the return value of his function on those permutations is not equal to n. Since this number could be very big, output the answer modulo 109\u2009+\u20097.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009106), separated by a space\u00a0\u2014 the length of the permutations and the parameter k.", "output_spec": "Output the answer to the problem modulo 109\u2009+\u20097.", "notes": "NotePermutations from second example: [4,\u20091,\u20092,\u20093,\u20095], [4,\u20091,\u20093,\u20092,\u20095], [4,\u20092,\u20091,\u20093,\u20095], [4,\u20092,\u20093,\u20091,\u20095], [4,\u20093,\u20091,\u20092,\u20095], [4,\u20093,\u20092,\u20091,\u20095].", "sample_inputs": ["5 2", "5 3", "6 3"], "sample_outputs": ["22", "6", "84"], "tags": ["dp", "combinatorics", "math"], "src_uid": "0644605611a2cd10ab3a9f12f18d7ae4", "difficulty": 2400, "source_codes": [""], "responses": [""], "prompt_tokens": [3096], "completion_tokens": [1286], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "0644605611a2cd10ab3a9f12f18d7ae4"}
{"description": "Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0,\u20090). The robot can process commands. There are four types of commands it can perform:  U \u2014 move from the cell (x,\u2009y) to (x,\u2009y\u2009+\u20091);  D \u2014 move from (x,\u2009y) to (x,\u2009y\u2009-\u20091);  L \u2014 move from (x,\u2009y) to (x\u2009-\u20091,\u2009y);  R \u2014 move from (x,\u2009y) to (x\u2009+\u20091,\u2009y). Ivan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0,\u20090), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains one number n \u2014 the length of sequence of commands entered by Ivan (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains the sequence itself \u2014 a string consisting of n characters. Each character can be U, D, L or R.", "output_spec": "Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.", "notes": null, "sample_inputs": ["4\nLDUR", "5\nRRRUU", "6\nLLRRRR"], "sample_outputs": ["4", "0", "4"], "tags": ["greedy"], "src_uid": "b9fa2bb8001bd064ede531a5281cfd8a", "difficulty": 1000, "source_codes": ["n = int(input())\nif n == 0:\n    print(0)\nelse:\n    commands = input().strip()\n    \n    # Count each type of command\n    count_U = commands.count('U')\n    count_D = commands.count('D')\n    count_L = commands.count('L')\n    count_R = commands.count('R')\n    \n    # Calculate the number of valid vertical and horizontal pairs\n    vertical_pairs = min(count_U, count_D)\n    horizontal_pairs = min(count_L, count_R)\n    \n    # Total commands executed correctly is twice the sum of pairs\n    total_commands = 2 * (vertical_pairs + horizontal_pairs)\n    \n    print(total_commands)"], "responses": ["\nn = int(input())\nif n == 0:\n    print(0)\nelse:\n    commands = input().strip()\n    \n    # Count each type of command\n    count_U = commands.count('U')\n    count_D = commands.count('D')\n    count_L = commands.count('L')\n    count_R = commands.count('R')\n    \n    # Calculate the number of valid vertical and horizontal pairs\n    vertical_pairs = min(count_U, count_D)\n    horizontal_pairs = min(count_L, count_R)\n    \n    # Total commands executed correctly is twice the sum of pairs\n    total_commands = 2 * (vertical_pairs + horizontal_pairs)\n    \n    print(total_commands)\n\n\n"], "prompt_tokens": [9166], "completion_tokens": [2901], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "b9fa2bb8001bd064ede531a5281cfd8a"}
{"description": "You are given an array a consisting of n integers, and additionally an integer m. You have to choose some sequence of indices b1,\u2009b2,\u2009...,\u2009bk (1\u2009\u2264\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bk\u2009\u2264\u2009n) in such a way that the value of  is maximized. Chosen sequence can be empty.Print the maximum possible value of .", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200935, 1\u2009\u2264\u2009m\u2009\u2264\u2009109). The second line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109).", "output_spec": "Print the maximum possible value of .", "notes": "NoteIn the first example you can choose a sequence b\u2009=\u2009{1,\u20092}, so the sum  is equal to 7 (and that's 3 after taking it modulo 4).In the second example you can choose a sequence b\u2009=\u2009{3}.", "sample_inputs": ["4 4\n5 2 4 1", "3 20\n199 41 299"], "sample_outputs": ["3", "19"], "tags": ["bitmasks", "meet-in-the-middle", "divide and conquer"], "src_uid": "d3a8a3e69a55936ee33aedd66e5b7f4a", "difficulty": 1800, "source_codes": ["import bisect\n\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Split array into two halves\n    mid = n // 2\n    left = a[:mid]\n    right = a[mid:]\n    \n    # Generate all possible subset sums for an array\n    def generate_sums(arr):\n        sums = set()\n        for i in range(1 << len(arr)):\n            s = 0\n            for j in range(len(arr)):\n                if i & (1 << j):\n                    s += arr[j]\n            sums.add(s % m)\n        return sorted(list(sums))\n    \n    left_sums = generate_sums(left)\n    right_sums = generate_sums(right)\n    \n    max_val = 0\n    \n    # Consider all combinations\n    # Case 1: Maximum within each half separately\n    if left_sums:\n        max_val = max(max_val, left_sums[-1])\n    if right_sums:\n        max_val = max(max_val, right_sums[-1])\n    \n    # Case 2: Combination of both halves\n    for ls in left_sums:\n        # Find the best rs to maximize (ls + rs) % m\n        \n        # Subcase 1: ls + rs < m, so result is ls + rs\n        # We want maximum rs such that ls + rs < m, i.e., rs < m - ls\n        idx = bisect.bisect_left(right_sums, m - ls)\n        if idx > 0:\n            max_val = max(max_val, ls + right_sums[idx - 1])\n        \n        # Subcase 2: ls + rs >= m, so result is (ls + rs) % m = ls + rs - m\n        # We want maximum such value, so we take maximum rs\n        if right_sums:\n            max_val = max(max_val, (ls + right_sums[-1]) % m)\n    \n    print(max_val)\n\nsolve()"], "responses": ["\nimport bisect\n\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Split array into two halves\n    mid = n // 2\n    left = a[:mid]\n    right = a[mid:]\n    \n    # Generate all possible subset sums for an array\n    def generate_sums(arr):\n        sums = set()\n        for i in range(1 << len(arr)):\n            s = 0\n            for j in range(len(arr)):\n                if i & (1 << j):\n                    s += arr[j]\n            sums.add(s % m)\n        return sorted(list(sums))\n    \n    left_sums = generate_sums(left)\n    right_sums = generate_sums(right)\n    \n    max_val = 0\n    \n    # Consider all combinations\n    # Case 1: Maximum within each half separately\n    if left_sums:\n        max_val = max(max_val, left_sums[-1])\n    if right_sums:\n        max_val = max(max_val, right_sums[-1])\n    \n    # Case 2: Combination of both halves\n    for ls in left_sums:\n        # Find the best rs to maximize (ls + rs) % m\n        \n        # Subcase 1: ls + rs < m, so result is ls + rs\n        # We want maximum rs such that ls + rs < m, i.e., rs < m - ls\n        idx = bisect.bisect_left(right_sums, m - ls)\n        if idx > 0:\n            max_val = max(max_val, ls + right_sums[idx - 1])\n        \n        # Subcase 2: ls + rs >= m, so result is (ls + rs) % m = ls + rs - m\n        # We want maximum such value, so we take maximum rs\n        if right_sums:\n            max_val = max(max_val, (ls + right_sums[-1]) % m)\n    \n    print(max_val)\n\nsolve()\n\n\n"], "prompt_tokens": [10130], "completion_tokens": [5149], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "d3a8a3e69a55936ee33aedd66e5b7f4a"}
{"description": "Amr loves Geometry. One day he came up with a very interesting problem.Amr has a circle of radius r and center in point (x,\u2009y). He wants the circle center to be in new position (x',\u2009y').In one step Amr can put a pin to the border of the circle in a certain point, then rotate the circle around that pin by any angle and finally remove the pin.Help Amr to achieve his goal in minimum number of steps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "Input consists of 5 space-separated integers r, x, y, x' y' (1\u2009\u2264\u2009r\u2009\u2264\u2009105, \u2009-\u2009105\u2009\u2264\u2009x,\u2009y,\u2009x',\u2009y'\u2009\u2264\u2009105), circle radius, coordinates of original center of the circle and coordinates of destination center of the circle respectively.", "output_spec": "Output a single integer \u2014 minimum number of steps required to move the center of the circle to the destination point.", "notes": "NoteIn the first sample test the optimal way is to put a pin at point (0,\u20092) and rotate the circle by 180 degrees counter-clockwise (or clockwise, no matter).", "sample_inputs": ["2 0 0 0 4", "1 1 1 4 4", "4 5 6 5 6"], "sample_outputs": ["1", "3", "0"], "tags": ["geometry", "math"], "src_uid": "698da80c7d24252b57cca4e4f0ca7031", "difficulty": 1400, "source_codes": ["import math\n\ndef min_steps_to_move_circle(r, x, y, x_dest, y_dest):\n    # Calculate the squared distance between current and destination centers\n    dx = x_dest - x\n    dy = y_dest - y\n    distance_squared = dx * dx + dy * dy\n    \n    # If already at destination\n    if distance_squared == 0:\n        return 0\n    \n    # Calculate actual distance\n    distance = math.sqrt(distance_squared)\n    \n    # Each step can move the center by at most 2*r (diameter)\n    # So we need ceil(distance / (2*r)) steps\n    steps = math.ceil(distance / (2 * r))\n    return steps\n\n# Read input\nline = input().strip()\nr, x, y, x_dest, y_dest = map(int, line.split())\n\n# Calculate and print result\nresult = min_steps_to_move_circle(r, x, y, x_dest, y_dest)\nprint(result)"], "responses": ["\nimport math\n\ndef min_steps_to_move_circle(r, x, y, x_dest, y_dest):\n    # Calculate the squared distance between current and destination centers\n    dx = x_dest - x\n    dy = y_dest - y\n    distance_squared = dx * dx + dy * dy\n    \n    # If already at destination\n    if distance_squared == 0:\n        return 0\n    \n    # Calculate actual distance\n    distance = math.sqrt(distance_squared)\n    \n    # Each step can move the center by at most 2*r (diameter)\n    # So we need ceil(distance / (2*r)) steps\n    steps = math.ceil(distance / (2 * r))\n    return steps\n\n# Read input\nline = input().strip()\nr, x, y, x_dest, y_dest = map(int, line.split())\n\n# Calculate and print result\nresult = min_steps_to_move_circle(r, x, y, x_dest, y_dest)\nprint(result)\n\n\n"], "prompt_tokens": [9352], "completion_tokens": [3870], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "698da80c7d24252b57cca4e4f0ca7031"}
{"description": "Drazil is playing a math game with Varda.Let's define  for positive integer x as a product of factorials of its digits. For example, .First, they choose a decimal number a consisting of n digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number x satisfying following two conditions:1. x doesn't contain neither digit 0 nor digit 1.2.  = .Help friends find such number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200915) \u2014 the number of digits in a. The second line contains n digits of a. There is at least one digit in a that is larger than 1. Number a may possibly contain leading zeroes.", "output_spec": "Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.", "notes": "NoteIn the first case, ", "sample_inputs": ["4\n1234", "3\n555"], "sample_outputs": ["33222", "555"], "tags": ["greedy", "math", "sortings", "dp", "implementation"], "src_uid": "60dbfc7a65702ae8bd4a587db1e06398", "difficulty": 1400, "source_codes": ["def solve():\n    n = int(input())\n    a = input().strip()\n    \n    # Count prime factors in F(a)\n    count_2 = 0\n    count_3 = 0\n    count_5 = 0\n    count_7 = 0\n    \n    # For each digit, add its prime factorization to our counts\n    for digit_char in a:\n        digit = int(digit_char)\n        if digit == 2:\n            count_2 += 1\n        elif digit == 3:\n            count_3 += 1\n        elif digit == 4:\n            count_2 += 3\n        elif digit == 5:\n            count_5 += 1\n        elif digit == 6:\n            count_2 += 1\n            count_3 += 1\n        elif digit == 7:\n            count_7 += 1\n        elif digit == 8:\n            count_2 += 7\n        elif digit == 9:\n            count_2 += 3\n            count_3 += 2\n    \n    # Construct maximum number by using largest digits first\n    result = []\n    \n    # Use 9s (2^3 * 3^2)\n    while count_2 >= 3 and count_3 >= 2:\n        result.append('9')\n        count_2 -= 3\n        count_3 -= 2\n    \n    # Use 8s (2^7)\n    while count_2 >= 7:\n        result.append('8')\n        count_2 -= 7\n    \n    # Use 7s\n    while count_7 > 0:\n        result.append('7')\n        count_7 -= 1\n    \n    # Use 6s (2^1 * 3^1)\n    while count_2 >= 1 and count_3 >= 1:\n        result.append('6')\n        count_2 -= 1\n        count_3 -= 1\n    \n    # Use 5s\n    while count_5 > 0:\n        result.append('5')\n        count_5 -= 1\n    \n    # Use 4s (2^3)\n    while count_2 >= 3:\n        result.append('4')\n        count_2 -= 3\n    \n    # Use 3s\n    while count_3 > 0:\n        result.append('3')\n        count_3 -= 1\n    \n    # Use 2s\n    while count_2 > 0:\n        result.append('2')\n        count_2 -= 1\n    \n    return ''.join(result)\n\nprint(solve())"], "responses": ["\ndef solve():\n    n = int(input())\n    a = input().strip()\n    \n    # Count prime factors in F(a)\n    count_2 = 0\n    count_3 = 0\n    count_5 = 0\n    count_7 = 0\n    \n    # For each digit, add its prime factorization to our counts\n    for digit_char in a:\n        digit = int(digit_char)\n        if digit == 2:\n            count_2 += 1\n        elif digit == 3:\n            count_3 += 1\n        elif digit == 4:\n            count_2 += 3\n        elif digit == 5:\n            count_5 += 1\n        elif digit == 6:\n            count_2 += 1\n            count_3 += 1\n        elif digit == 7:\n            count_7 += 1\n        elif digit == 8:\n            count_2 += 7\n        elif digit == 9:\n            count_2 += 3\n            count_3 += 2\n    \n    # Construct maximum number by using largest digits first\n    result = []\n    \n    # Use 9s (2^3 * 3^2)\n    while count_2 >= 3 and count_3 >= 2:\n        result.append('9')\n        count_2 -= 3\n        count_3 -= 2\n    \n    # Use 8s (2^7)\n    while count_2 >= 7:\n        result.append('8')\n        count_2 -= 7\n    \n    # Use 7s\n    while count_7 > 0:\n        result.append('7')\n        count_7 -= 1\n    \n    # Use 6s (2^1 * 3^1)\n    while count_2 >= 1 and count_3 >= 1:\n        result.append('6')\n        count_2 -= 1\n        count_3 -= 1\n    \n    # Use 5s\n    while count_5 > 0:\n        result.append('5')\n        count_5 -= 1\n    \n    # Use 4s (2^3)\n    while count_2 >= 3:\n        result.append('4')\n        count_2 -= 3\n    \n    # Use 3s\n    while count_3 > 0:\n        result.append('3')\n        count_3 -= 1\n    \n    # Use 2s\n    while count_2 > 0:\n        result.append('2')\n        count_2 -= 1\n    \n    return ''.join(result)\n\nprint(solve())\n\n\n"], "prompt_tokens": [5716], "completion_tokens": [3748], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "60dbfc7a65702ae8bd4a587db1e06398"}
{"description": "Let's define the permutation of length n as an array p\u2009=\u2009[p1,\u2009p2,\u2009...,\u2009pn] consisting of n distinct integers from range from 1 to n. We say that this permutation maps value 1 into the value p1, value 2 into the value p2 and so on.Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of p as a collection of cycles forming p. For example, permutation p\u2009=\u2009[4,\u20091,\u20096,\u20092,\u20095,\u20093] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,\u20091,\u20096,\u20092,\u20095,\u20093] is (421)(5)(63).Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,\u20091,\u20096,\u20092,\u20095,\u20093] will become [4,\u20092,\u20091,\u20095,\u20096,\u20093].Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length n that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers n and k, print the permutation that was k-th on Kyoya's list.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line will contain two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950, 1\u2009\u2264\u2009k\u2009\u2264\u2009min{1018,\u2009l} where l is the length of the Kyoya's list).", "output_spec": "Print n space-separated integers, representing the permutation that is the answer for the question. ", "notes": "NoteThe standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1,\u20092,\u20093,\u20094], while the second permutation would be [1,\u20092,\u20094,\u20093].", "sample_inputs": ["4 3", "10 1"], "sample_outputs": ["1 3 2 4", "1 2 3 4 5 6 7 8 9 10"], "tags": ["greedy", "combinatorics", "binary search", "constructive algorithms", "math", "implementation"], "src_uid": "e03c6d3bb8cf9119530668765691a346", "difficulty": 1900, "source_codes": ["def main():\n    n, k = map(int, input().split())\n    \n    # Precompute Fibonacci-like numbers\n    # f[i] = number of valid permutations of length i\n    f = [0] * (n + 2)\n    f[0] = 1\n    f[1] = 1\n    for i in range(2, n + 2):\n        f[i] = f[i-1] + f[i-2]\n    \n    def solve(length, remaining_k):\n        # Find the k-th valid permutation of length 'length'\n        if length <= 0:\n            return []\n        \n        # Number of valid permutations if we fix the last element\n        count_fix = f[length - 1]\n        \n        if remaining_k <= count_fix:\n            # Fix the last element\n            result = solve(length - 1, remaining_k)\n            result.append(length)\n            return result\n        else:\n            # Pair (length-1, length) - transposition\n            result = solve(length - 2, remaining_k - count_fix)\n            result.extend([length, length - 1])\n            return result\n    \n    result = solve(n, k)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef main():\n    n, k = map(int, input().split())\n    \n    # Precompute Fibonacci-like numbers\n    # f[i] = number of valid permutations of length i\n    f = [0] * (n + 2)\n    f[0] = 1\n    f[1] = 1\n    for i in range(2, n + 2):\n        f[i] = f[i-1] + f[i-2]\n    \n    def solve(length, remaining_k):\n        # Find the k-th valid permutation of length 'length'\n        if length <= 0:\n            return []\n        \n        # Number of valid permutations if we fix the last element\n        count_fix = f[length - 1]\n        \n        if remaining_k <= count_fix:\n            # Fix the last element\n            result = solve(length - 1, remaining_k)\n            result.append(length)\n            return result\n        else:\n            # Pair (length-1, length) - transposition\n            result = solve(length - 2, remaining_k - count_fix)\n            result.extend([length, length - 1])\n            return result\n    \n    result = solve(n, k)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [14545], "completion_tokens": [4438], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "e03c6d3bb8cf9119530668765691a346"}
{"description": "You are given three sticks with positive integer lengths of a,\u2009b, and c centimeters. You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters. In particular, it is allowed not to increase the length of any stick.Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of centimeters in them.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains 4 integers a,\u2009b,\u2009c,\u2009l (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20093\u00b7105, 0\u2009\u2264\u2009l\u2009\u2264\u20093\u00b7105).", "output_spec": "Print a single integer \u2014 the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.", "notes": "NoteIn the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.", "sample_inputs": ["1 1 1 2", "1 2 3 1", "10 2 1 7"], "sample_outputs": ["4", "2", "0"], "tags": ["math", "combinatorics", "brute force", "dp", "implementation"], "src_uid": "185ff90a8b0ae0e2b75605f772589410", "difficulty": 2100, "source_codes": ["import sys\n\ndef main():\n    a, b, c, l = map(int, sys.stdin.readline().split())\n    \n    # Total number of ways to distribute up to l centimeters\n    # This is C(l+3, 3) = (l+3)(l+2)(l+1)/6\n    total = (l + 3) * (l + 2) * (l + 1) // 6\n    \n    # Count invalid triangles using inclusion-exclusion\n    bad = 0\n    \n    # Count cases where triangle inequality is violated\n    # We count cases where one side >= sum of other two\n    \n    def count_bad_cases(x, y, z, gap):\n        # Count cases where (z + dz) >= (x + dx) + (y + dy) + gap\n        # i.e., dz >= dx + dy + gap - z + x + y\n        # Let diff = gap - z + x + y\n        # So dz >= dx + dy + diff\n        # And dx + dy + dz <= l\n        # Therefore dx + dy + (dx + dy + diff) <= l\n        # So 2*(dx + dy) <= l - diff\n        # So dx + dy <= (l - diff) // 2\n        \n        diff = gap - z + x + y\n        if diff > l:\n            return 0\n            \n        max_sum = min(l - diff, l)\n        if max_sum < 0:\n            return 0\n            \n        count = 0\n        for s in range(max_sum + 1):\n            # s = dx + dy\n            # dz >= s + diff\n            # dz <= l - s\n            # So we need s + diff <= l - s, i.e., 2*s <= l - diff\n            if 2 * s > l - diff:\n                break\n                \n            # Number of ways to write s = dx + dy with dx,dy >= 0 is s + 1\n            # For each such way, dz can be s + diff, s + diff + 1, ..., l - s\n            # That's (l - s) - (s + diff) + 1 = l - 2*s - diff + 1 choices\n            valid_dz_count = l - 2 * s - diff + 1\n            if valid_dz_count > 0:\n                count += (s + 1) * valid_dz_count\n                \n        return count\n    \n    # Count cases where each side is too long\n    bad += count_bad_cases(a, b, c, 1)  # c >= a + b + 1\n    bad += count_bad_cases(a, c, b, 1)  # b >= a + c + 1\n    bad += count_bad_cases(b, c, a, 1)  # a >= b + c + 1\n    \n    result = total - bad\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef main():\n    a, b, c, l = map(int, sys.stdin.readline().split())\n    \n    # Total number of ways to distribute up to l centimeters\n    # This is C(l+3, 3) = (l+3)(l+2)(l+1)/6\n    total = (l + 3) * (l + 2) * (l + 1) // 6\n    \n    # Count invalid triangles using inclusion-exclusion\n    bad = 0\n    \n    # Count cases where triangle inequality is violated\n    # We count cases where one side >= sum of other two\n    \n    def count_bad_cases(x, y, z, gap):\n        # Count cases where (z + dz) >= (x + dx) + (y + dy) + gap\n        # i.e., dz >= dx + dy + gap - z + x + y\n        # Let diff = gap - z + x + y\n        # So dz >= dx + dy + diff\n        # And dx + dy + dz <= l\n        # Therefore dx + dy + (dx + dy + diff) <= l\n        # So 2*(dx + dy) <= l - diff\n        # So dx + dy <= (l - diff) // 2\n        \n        diff = gap - z + x + y\n        if diff > l:\n            return 0\n            \n        max_sum = min(l - diff, l)\n        if max_sum < 0:\n            return 0\n            \n        count = 0\n        for s in range(max_sum + 1):\n            # s = dx + dy\n            # dz >= s + diff\n            # dz <= l - s\n            # So we need s + diff <= l - s, i.e., 2*s <= l - diff\n            if 2 * s > l - diff:\n                break\n                \n            # Number of ways to write s = dx + dy with dx,dy >= 0 is s + 1\n            # For each such way, dz can be s + diff, s + diff + 1, ..., l - s\n            # That's (l - s) - (s + diff) + 1 = l - 2*s - diff + 1 choices\n            valid_dz_count = l - 2 * s - diff + 1\n            if valid_dz_count > 0:\n                count += (s + 1) * valid_dz_count\n                \n        return count\n    \n    # Count cases where each side is too long\n    bad += count_bad_cases(a, b, c, 1)  # c >= a + b + 1\n    bad += count_bad_cases(a, c, b, 1)  # b >= a + c + 1\n    bad += count_bad_cases(b, c, a, 1)  # a >= b + c + 1\n    \n    result = total - bad\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [12876], "completion_tokens": [9070], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "185ff90a8b0ae0e2b75605f772589410"}
{"description": "One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.", "output_spec": "Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.", "notes": "NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.", "sample_inputs": ["3 1", "2 3", "7 3"], "sample_outputs": ["1 1", "2 0", "3 2"], "tags": ["math", "implementation"], "src_uid": "775766790e91e539c1cfaa5030e5b955", "difficulty": 800, "source_codes": ["a, b = map(int, input().split())\n\n# Maximum days wearing different socks\ndifferent_days = min(a, b)\n\n# Remaining socks after wearing different socks\nremaining = abs(a - b)\n\n# Days wearing same socks from remaining socks\nsame_days = remaining // 2\n\nprint(different_days, same_days)"], "responses": ["\na, b = map(int, input().split())\n\n# Maximum days wearing different socks\ndifferent_days = min(a, b)\n\n# Remaining socks after wearing different socks\nremaining = abs(a - b)\n\n# Days wearing same socks from remaining socks\nsame_days = remaining // 2\n\nprint(different_days, same_days)\n\n\n"], "prompt_tokens": [8522], "completion_tokens": [2311], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "775766790e91e539c1cfaa5030e5b955"}
{"description": "A monster is attacking the Cyberland!Master Yang, a braver, is going to beat the monster. Yang and the monster each have 3 attributes: hitpoints (HP), offensive power (ATK) and defensive power (DEF).During the battle, every second the monster's HP decrease by max(0,\u2009ATKY\u2009-\u2009DEFM), while Yang's HP decreases by max(0,\u2009ATKM\u2009-\u2009DEFY), where index Y denotes Master Yang and index M denotes monster. Both decreases happen simultaneously Once monster's HP\u2009\u2264\u20090 and the same time Master Yang's HP\u2009&gt;\u20090, Master Yang wins.Master Yang can buy attributes from the magic shop of Cyberland: h bitcoins per HP, a bitcoins per ATK, and d bitcoins per DEF.Now Master Yang wants to know the minimum number of bitcoins he can spend in order to win.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains three integers HPY,\u2009ATKY,\u2009DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang. The second line contains three integers HPM,\u2009ATKM,\u2009DEFM, separated by a space, denoting the HP, ATK and DEF of the monster. The third line contains three integers h,\u2009a,\u2009d, separated by a space, denoting the price of 1\u00a0HP, 1\u00a0ATK and 1\u00a0DEF. All numbers in input are integer and lie between 1 and 100 inclusively.", "output_spec": "The only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.", "notes": "NoteFor the first sample, prices for ATK and DEF are extremely high. Master Yang can buy 99 HP, then he can beat the monster with 1 HP left.For the second sample, Master Yang is strong enough to beat the monster, so he doesn't need to buy anything.", "sample_inputs": ["1 2 1\n1 100 1\n1 100 100", "100 100 100\n1 1 1\n1 1 1"], "sample_outputs": ["99", "0"], "tags": ["brute force", "binary search", "implementation"], "src_uid": "bf8a133154745e64a547de6f31ddc884", "difficulty": 1800, "source_codes": ["import math\n\ndef main():\n    # Read input\n    hp_y, atk_y, def_y = map(int, input().split())\n    hp_m, atk_m, def_m = map(int, input().split())\n    h, a, d = map(int, input().split())\n\n    min_cost = float('inf')\n\n    # Try different combinations of additional ATK and DEF\n    # Upper bounds chosen to be sufficiently large\n    for add_atk in range(200):\n        for add_def in range(200):\n            # Yang's stats after improvement\n            new_atk_y = atk_y + add_atk\n            new_def_y = def_y + add_def\n            \n            # Damage per second\n            dmg_to_monster = max(0, new_atk_y - def_m)\n            dmg_to_yang = max(0, atk_m - new_def_y)\n            \n            # If Yang can't deal damage, this combination is invalid\n            if dmg_to_monster == 0:\n                continue\n            \n            # Calculate rounds needed to kill monster\n            rounds_to_kill_monster = math.ceil(hp_m / dmg_to_monster)\n            \n            # Calculate HP needed to survive all rounds\n            # Yang needs to survive (rounds_to_kill_monster - 1) full rounds of damage\n            # He can die on the final round (HP can be <= 0 after killing monster)\n            hp_needed = (rounds_to_kill_monster - 1) * dmg_to_yang + 1\n            \n            # Additional HP needed\n            add_hp = max(0, hp_needed - hp_y)\n            \n            # Total cost\n            cost = h * add_hp + a * add_atk + d * add_def\n            \n            # Update minimum cost\n            min_cost = min(min_cost, cost)\n    \n    # Also check if Yang already wins without spending anything\n    # This happens when Yang can kill monster before monster kills Yang\n    dmg_to_monster_initial = max(0, atk_y - def_m)\n    dmg_to_yang_initial = max(0, atk_m - def_y)\n    \n    if dmg_to_monster_initial > 0:\n        rounds_to_kill_monster_initial = math.ceil(hp_m / dmg_to_monster_initial)\n        if dmg_to_yang_initial == 0:\n            # Monster can't hurt Yang, so Yang wins\n            min_cost = min(min_cost, 0)\n        else:\n            hp_needed_initial = (rounds_to_kill_monster_initial - 1) * dmg_to_yang_initial + 1\n            if hp_y >= hp_needed_initial:\n                min_cost = min(min_cost, 0)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport math\n\ndef main():\n    # Read input\n    hp_y, atk_y, def_y = map(int, input().split())\n    hp_m, atk_m, def_m = map(int, input().split())\n    h, a, d = map(int, input().split())\n\n    min_cost = float('inf')\n\n    # Try different combinations of additional ATK and DEF\n    # Upper bounds chosen to be sufficiently large\n    for add_atk in range(200):\n        for add_def in range(200):\n            # Yang's stats after improvement\n            new_atk_y = atk_y + add_atk\n            new_def_y = def_y + add_def\n            \n            # Damage per second\n            dmg_to_monster = max(0, new_atk_y - def_m)\n            dmg_to_yang = max(0, atk_m - new_def_y)\n            \n            # If Yang can't deal damage, this combination is invalid\n            if dmg_to_monster == 0:\n                continue\n            \n            # Calculate rounds needed to kill monster\n            rounds_to_kill_monster = math.ceil(hp_m / dmg_to_monster)\n            \n            # Calculate HP needed to survive all rounds\n            # Yang needs to survive (rounds_to_kill_monster - 1) full rounds of damage\n            # He can die on the final round (HP can be <= 0 after killing monster)\n            hp_needed = (rounds_to_kill_monster - 1) * dmg_to_yang + 1\n            \n            # Additional HP needed\n            add_hp = max(0, hp_needed - hp_y)\n            \n            # Total cost\n            cost = h * add_hp + a * add_atk + d * add_def\n            \n            # Update minimum cost\n            min_cost = min(min_cost, cost)\n    \n    # Also check if Yang already wins without spending anything\n    # This happens when Yang can kill monster before monster kills Yang\n    dmg_to_monster_initial = max(0, atk_y - def_m)\n    dmg_to_yang_initial = max(0, atk_m - def_y)\n    \n    if dmg_to_monster_initial > 0:\n        rounds_to_kill_monster_initial = math.ceil(hp_m / dmg_to_monster_initial)\n        if dmg_to_yang_initial == 0:\n            # Monster can't hurt Yang, so Yang wins\n            min_cost = min(min_cost, 0)\n        else:\n            hp_needed_initial = (rounds_to_kill_monster_initial - 1) * dmg_to_yang_initial + 1\n            if hp_y >= hp_needed_initial:\n                min_cost = min(min_cost, 0)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [12845], "completion_tokens": [5491], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "bf8a133154745e64a547de6f31ddc884"}
{"description": "Vasya decided to learn to play chess. Classic chess doesn't seem interesting to him, so he plays his own sort of chess.The queen is the piece that captures all squares on its vertical, horizontal and diagonal lines. If the cell is located on the same vertical, horizontal or diagonal line with queen, and the cell contains a piece of the enemy color, the queen is able to move to this square. After that the enemy's piece is removed from the board. The queen cannot move to a cell containing an enemy piece if there is some other piece between it and the queen. There is an n\u2009\u00d7\u2009n chessboard. We'll denote a cell on the intersection of the r-th row and c-th column as (r,\u2009c). The square (1,\u20091) contains the white queen and the square (1,\u2009n) contains the black queen. All other squares contain green pawns that don't belong to anyone.The players move in turns. The player that moves first plays for the white queen, his opponent plays for the black queen.On each move the player has to capture some piece with his queen (that is, move to a square that contains either a green pawn or the enemy queen). The player loses if either he cannot capture any piece during his move or the opponent took his queen during the previous move. Help Vasya determine who wins if both players play with an optimal strategy on the board n\u2009\u00d7\u2009n.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The input contains a single number n (2\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 the size of the board.", "output_spec": "On the first line print the answer to problem \u2014 string \"white\" or string \"black\", depending on who wins if the both players play optimally.  If the answer is \"white\", then you should also print two integers r and c representing the cell (r,\u2009c), where the first player should make his first move to win. If there are multiple such cells, print the one with the minimum r. If there are still multiple squares, print the one with the minimum c.", "notes": "NoteIn the first sample test the white queen can capture the black queen at the first move, so the white player wins.In the second test from the statement if the white queen captures the green pawn located on the central vertical line, then it will be captured by the black queen during the next move. So the only move for the white player is to capture the green pawn located at (2,\u20091). Similarly, the black queen doesn't have any other options but to capture the green pawn located at (2,\u20093), otherwise if it goes to the middle vertical line, it will be captured by the white queen.During the next move the same thing happens \u2014 neither the white, nor the black queen has other options rather than to capture green pawns situated above them. Thus, the white queen ends up on square (3,\u20091), and the black queen ends up on square (3,\u20093). In this situation the white queen has to capture any of the green pawns located on the middle vertical line, after that it will be captured by the black queen. Thus, the player who plays for the black queen wins.", "sample_inputs": ["2", "3"], "sample_outputs": ["white\n1 2", "black"], "tags": ["games", "math", "constructive algorithms"], "src_uid": "52e07d176aa1d370788f94ee2e61df93", "difficulty": 1700, "source_codes": ["n = int(input())\n\nif n % 2 == 0:\n    print(\"white\")\n    print(1, n // 2 + 1)\nelse:\n    print(\"black\")"], "responses": ["\nn = int(input())\n\nif n % 2 == 0:\n    print(\"white\")\n    print(1, n // 2 + 1)\nelse:\n    print(\"black\")\n\n\n"], "prompt_tokens": [11913], "completion_tokens": [1233], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "52e07d176aa1d370788f94ee2e61df93"}
{"description": "It's tough to be a superhero. And it's twice as tough to resist the supervillain who is cool at math. Suppose that you're an ordinary Batman in an ordinary city of Gotham. Your enemy Joker mined the building of the city administration and you only have several minutes to neutralize the charge. To do that you should enter the cancel code on the bomb control panel.However, that mad man decided to give you a hint. This morning the mayor found a playing card under his pillow. There was a line written on the card:The bomb has a note saying \"J(x)\u2009=\u2009A\", where A is some positive integer. You suspect that the cancel code is some integer x that meets the equation J(x)\u2009=\u2009A. Now in order to decide whether you should neutralize the bomb or run for your life, you've got to count how many distinct positive integers x meet this equation.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains a single integer A (1\u2009\u2264\u2009A\u2009\u2264\u20091012).", "output_spec": "Print the number of solutions of the equation J(x)\u2009=\u2009A.", "notes": "NoteRecord x|n means that number n divides number x. is defined as the largest positive integer that divides both a and b.In the first sample test the only suitable value of x is 2. Then J(2)\u2009=\u20091\u2009+\u20092.In the second sample test the following values of x match:  x\u2009=\u200914, J(14)\u2009=\u20091\u2009+\u20092\u2009+\u20097\u2009+\u200914\u2009=\u200924  x\u2009=\u200915, J(15)\u2009=\u20091\u2009+\u20093\u2009+\u20095\u2009+\u200915\u2009=\u200924  x\u2009=\u200923, J(23)\u2009=\u20091\u2009+\u200923\u2009=\u200924 ", "sample_inputs": ["3", "24"], "sample_outputs": ["1", "3"], "tags": ["math", "number theory", "hashing", "dp", "dfs and similar"], "src_uid": "1f68bd6f8b40e45a5bd360b03a264ef4", "difficulty": 2600, "source_codes": ["import math\n\ndef sum_of_divisors(n):\n    \"\"\"Calculate sum of divisors of n\"\"\"\n    if n == 1:\n        return 1\n    \n    result = 1 + n  # 1 and n are always divisors\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:  # Avoid counting the same divisor twice for perfect squares\n                result += n // i\n    \n    return result\n\ndef solve(A):\n    if A == 1:\n        return 0\n    \n    count = 0\n    \n    # Key insight: J(x) >= x + 1 for all x > 1\n    # So if J(x) = A, then x <= A - 1\n    # We should check all possible x from 1 to A-1\n    # But that might be too slow for large A\n    \n    # Let's optimize: we only need to check up to a reasonable limit\n    # In practice, solutions tend to be much smaller than A\n    \n    # Check if A-1 works (this covers the case where A-1 is prime)\n    if sum_of_divisors(A - 1) == A:\n        count += 1\n    \n    # For other cases, we search but with a reasonable upper bound\n    # Most solutions will be found within a reasonable range\n    \n    upper_limit = min(A - 1, 1000000) if A > 1 else 0\n    \n    # Check all values from 1 to upper_limit, except A-1 which we already checked\n    for x in range(1, upper_limit + 1):\n        if x == A - 1:  # Skip already checked case\n            continue\n        if sum_of_divisors(x) == A:\n            count += 1\n            \n    return count\n\nif __name__ == \"__main__\":\n    A = int(input())\n    result = solve(A)\n    print(result)"], "responses": ["\nimport math\n\ndef sum_of_divisors(n):\n    \"\"\"Calculate sum of divisors of n\"\"\"\n    if n == 1:\n        return 1\n    \n    result = 1 + n  # 1 and n are always divisors\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:  # Avoid counting the same divisor twice for perfect squares\n                result += n // i\n    \n    return result\n\ndef solve(A):\n    if A == 1:\n        return 0\n    \n    count = 0\n    \n    # Key insight: J(x) >= x + 1 for all x > 1\n    # So if J(x) = A, then x <= A - 1\n    # We should check all possible x from 1 to A-1\n    # But that might be too slow for large A\n    \n    # Let's optimize: we only need to check up to a reasonable limit\n    # In practice, solutions tend to be much smaller than A\n    \n    # Check if A-1 works (this covers the case where A-1 is prime)\n    if sum_of_divisors(A - 1) == A:\n        count += 1\n    \n    # For other cases, we search but with a reasonable upper bound\n    # Most solutions will be found within a reasonable range\n    \n    upper_limit = min(A - 1, 1000000) if A > 1 else 0\n    \n    # Check all values from 1 to upper_limit, except A-1 which we already checked\n    for x in range(1, upper_limit + 1):\n        if x == A - 1:  # Skip already checked case\n            continue\n        if sum_of_divisors(x) == A:\n            count += 1\n            \n    return count\n\nif __name__ == \"__main__\":\n    A = int(input())\n    result = solve(A)\n    print(result)\n\n\n"], "prompt_tokens": [17456], "completion_tokens": [7876], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "1f68bd6f8b40e45a5bd360b03a264ef4"}
{"description": "Limak is a little polar bear. He has n balls, the i-th ball has size ti.Limak wants to give one ball to each of his three friends. Giving gifts isn't easy\u00a0\u2014 there are two rules Limak must obey to make friends happy:  No two friends can get balls of the same size.  No two friends can get balls of sizes that differ by more than 2. For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).Your task is to check whether Limak can choose three balls that satisfy conditions above.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains one integer n (3\u2009\u2264\u2009n\u2009\u2264\u200950)\u00a0\u2014 the number of balls Limak has. The second line contains n integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20091000) where ti denotes the size of the i-th ball.", "output_spec": "Print \"YES\" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print \"NO\" (without quotes).", "notes": "NoteIn the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.In the second sample, there is no way to give gifts to three friends without breaking the rules.In the third sample, there is even more than one way to choose balls:  Choose balls with sizes 3, 4 and 5.  Choose balls with sizes 972, 970, 971. ", "sample_inputs": ["4\n18 55 16 17", "6\n40 41 43 44 44 44", "8\n5 972 3 4 1 4 970 971"], "sample_outputs": ["YES", "NO", "YES"], "tags": ["brute force", "implementation", "sortings"], "src_uid": "d6c876a84c7b92141710be5d76536eab", "difficulty": 900, "source_codes": ["n = int(input())\nballs = list(map(int, input().split()))\n\nballs.sort()\n\nfound = False\nfor i in range(n - 2):\n    a, b, c = balls[i], balls[i + 1], balls[i + 2]\n    if a < b < c and c - a <= 2:\n        found = True\n        break\n\nif found:\n    print(\"YES\")\nelse:\n    print(\"NO\")"], "responses": ["\nn = int(input())\nballs = list(map(int, input().split()))\n\nballs.sort()\n\nfound = False\nfor i in range(n - 2):\n    a, b, c = balls[i], balls[i + 1], balls[i + 2]\n    if a < b < c and c - a <= 2:\n        found = True\n        break\n\nif found:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n"], "prompt_tokens": [11526], "completion_tokens": [1943], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "d6c876a84c7b92141710be5d76536eab"}
{"description": "Buses run between the cities A and B, the first one is at 05:00 AM and the last one departs not later than at 11:59 PM. A bus from the city A departs every a minutes and arrives to the city B in a ta minutes, and a bus from the city B departs every b minutes and arrives to the city A in a tb minutes.The driver Simion wants to make his job diverse, so he counts the buses going towards him. Simion doesn't count the buses he meet at the start and finish.You know the time when Simion departed from the city A to the city B. Calculate the number of buses Simion will meet to be sure in his counting.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers a,\u2009ta (1\u2009\u2264\u2009a,\u2009ta\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city A to the city B and the travel time. Both values are given in minutes. The second line contains two integers b,\u2009tb (1\u2009\u2264\u2009b,\u2009tb\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city B to the city A and the travel time. Both values are given in minutes. The last line contains the departure time of Simion from the city A in the format hh:mm. It is guaranteed that there are a bus from the city A at that time. Note that the hours and the minutes are given with exactly two digits.", "output_spec": "Print the only integer z \u2014 the number of buses Simion will meet on the way. Note that you should not count the encounters in cities A and B.", "notes": "NoteIn the first example Simion departs form the city A at 05:20 AM and arrives to the city B at 05:50 AM. He will meet the first 5 buses from the city B that departed in the period [05:00 AM - 05:40 AM]. Also Simion will meet a bus in the city B at 05:50 AM, but he will not count it.Also note that the first encounter will be between 05:26 AM and 05:27 AM (if we suggest that the buses are go with the sustained speed).", "sample_inputs": ["10 30\n10 35\n05:20", "60 120\n24 100\n13:00"], "sample_outputs": ["5", "9"], "tags": ["implementation"], "src_uid": "1c4cf1c3cb464a483511a8a61f8685a7", "difficulty": 1600, "source_codes": ["def count_buses(a, ta, b, tb, departure_time):\n    # Convert departure time to minutes since 00:00\n    hours, minutes = map(int, departure_time.split(':'))\n    simion_departure = hours * 60 + minutes\n    simion_arrival = simion_departure + ta\n    \n    count = 0\n    \n    # First bus from B departs at 05:00 (300 minutes)\n    # Last bus from B should be such that it can possibly meet Simion\n    start_time_B = 5 * 60  # 05:00\n    end_time = 23 * 60 + 59  # 23:59\n    \n    # We only care about buses from B that could meet Simion\n    # A bus from B departing at time t will meet Simion if:\n    # max(simion_departure, t) < min(simion_arrival, t + tb)\n    # This means: t < simion_arrival and t + tb > simion_departure\n    # Which means: t < simion_arrival and t > simion_departure - tb\n    # So: max(start_time_B, simion_departure - tb) <= t < simion_arrival\n    \n    # But we also need to ensure t <= end_time and t is a valid bus departure time\n    # Buses from B depart at: start_time_B, start_time_B + b, start_time_B + 2*b, ...\n    \n    # Find the first bus departure time >= max(start_time_B, simion_departure - tb)\n    earliest_possible_departure = max(start_time_B, simion_departure - tb)\n    \n    # Find the bus number (starting from 0) whose departure time >= earliest_possible_departure\n    if earliest_possible_departure <= start_time_B:\n        first_bus_index = 0\n    else:\n        first_bus_index = max(0, ((earliest_possible_departure - start_time_B) + b - 1) // b)\n    \n    current_departure = start_time_B + first_bus_index * b\n    \n    while current_departure < simion_arrival and current_departure <= end_time:\n        bus_arrival_at_A = current_departure + tb\n        \n        # Check if intervals overlap: [simion_departure, simion_arrival] and [current_departure, bus_arrival_at_A]\n        overlap_start = max(simion_departure, current_departure)\n        overlap_end = min(simion_arrival, bus_arrival_at_A)\n        \n        # Count if there's a real overlap (not just touching at endpoints)\n        if overlap_start < overlap_end:\n            count += 1\n            \n        current_departure += b\n        \n    return count\n\n# Read inputs\nline1 = input().strip()\nline2 = input().strip()\ndeparture_time = input().strip()\n\na, ta = map(int, line1.split())\nb, tb = map(int, line2.split())\n\nresult = count_buses(a, ta, b, tb, departure_time)\nprint(result)"], "responses": ["\ndef count_buses(a, ta, b, tb, departure_time):\n    # Convert departure time to minutes since 00:00\n    hours, minutes = map(int, departure_time.split(':'))\n    simion_departure = hours * 60 + minutes\n    simion_arrival = simion_departure + ta\n    \n    count = 0\n    \n    # First bus from B departs at 05:00 (300 minutes)\n    # Last bus from B should be such that it can possibly meet Simion\n    start_time_B = 5 * 60  # 05:00\n    end_time = 23 * 60 + 59  # 23:59\n    \n    # We only care about buses from B that could meet Simion\n    # A bus from B departing at time t will meet Simion if:\n    # max(simion_departure, t) < min(simion_arrival, t + tb)\n    # This means: t < simion_arrival and t + tb > simion_departure\n    # Which means: t < simion_arrival and t > simion_departure - tb\n    # So: max(start_time_B, simion_departure - tb) <= t < simion_arrival\n    \n    # But we also need to ensure t <= end_time and t is a valid bus departure time\n    # Buses from B depart at: start_time_B, start_time_B + b, start_time_B + 2*b, ...\n    \n    # Find the first bus departure time >= max(start_time_B, simion_departure - tb)\n    earliest_possible_departure = max(start_time_B, simion_departure - tb)\n    \n    # Find the bus number (starting from 0) whose departure time >= earliest_possible_departure\n    if earliest_possible_departure <= start_time_B:\n        first_bus_index = 0\n    else:\n        first_bus_index = max(0, ((earliest_possible_departure - start_time_B) + b - 1) // b)\n    \n    current_departure = start_time_B + first_bus_index * b\n    \n    while current_departure < simion_arrival and current_departure <= end_time:\n        bus_arrival_at_A = current_departure + tb\n        \n        # Check if intervals overlap: [simion_departure, simion_arrival] and [current_departure, bus_arrival_at_A]\n        overlap_start = max(simion_departure, current_departure)\n        overlap_end = min(simion_arrival, bus_arrival_at_A)\n        \n        # Count if there's a real overlap (not just touching at endpoints)\n        if overlap_start < overlap_end:\n            count += 1\n            \n        current_departure += b\n        \n    return count\n\n# Read inputs\nline1 = input().strip()\nline2 = input().strip()\ndeparture_time = input().strip()\n\na, ta = map(int, line1.split())\nb, tb = map(int, line2.split())\n\nresult = count_buses(a, ta, b, tb, departure_time)\nprint(result)\n\n\n"], "prompt_tokens": [12093], "completion_tokens": [5689], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "1c4cf1c3cb464a483511a8a61f8685a7"}
{"description": "There are three friend living on the straight line Ox in Lineland. The first friend lives at the point x1, the second friend lives at the point x2, and the third friend lives at the point x3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?It's guaranteed that the optimal answer is always integer.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains three distinct integers x1, x2 and x3 (1\u2009\u2264\u2009x1,\u2009x2,\u2009x3\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the houses of the first, the second and the third friends respectively. ", "output_spec": "Print one integer\u00a0\u2014 the minimum total distance the friends need to travel in order to meet together.", "notes": "NoteIn the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.", "sample_inputs": ["7 1 4", "30 20 10"], "sample_outputs": ["6", "20"], "tags": ["math", "implementation", "sortings"], "src_uid": "7bffa6e8d2d21bbb3b7f4aec109b3319", "difficulty": 800, "source_codes": ["# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort to find the median\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The optimal meeting point is the median (middle value)\nmedian = coordinates[1]\n\n# Calculate total distance: sum of absolute differences from median\ntotal_distance = abs(x1 - median) + abs(x2 - median) + abs(x3 - median)\n\n# Print the result\nprint(total_distance)"], "responses": ["\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort to find the median\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The optimal meeting point is the median (middle value)\nmedian = coordinates[1]\n\n# Calculate total distance: sum of absolute differences from median\ntotal_distance = abs(x1 - median) + abs(x2 - median) + abs(x3 - median)\n\n# Print the result\nprint(total_distance)\n\n\n"], "prompt_tokens": [8014], "completion_tokens": [1561], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "7bffa6e8d2d21bbb3b7f4aec109b3319"}
