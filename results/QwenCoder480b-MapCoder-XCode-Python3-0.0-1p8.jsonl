{"description": "One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "64 megabytes", "input_spec": "The first (and the only) input line contains integer number w (1\u2009\u2264\u2009w\u2009\u2264\u2009100) \u2014 the weight of the watermelon bought by the boys.", "output_spec": "Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.", "notes": "NoteFor example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).", "sample_inputs": ["8"], "sample_outputs": ["YES"], "tags": ["brute force", "math"], "src_uid": "230a3c4d7090401e5fa3c6b9d994cdf2", "difficulty": 800, "source_codes": ["w = int(input())\nif w >= 4 and w % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"], "responses": ["\nw = int(input())\nif w >= 4 and w % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n"], "prompt_tokens": [7696], "completion_tokens": [869], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "230a3c4d7090401e5fa3c6b9d994cdf2"}
{"description": "Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,\u2009y1), (x2,\u2009y2), ..., (xn,\u2009yn). The first vertex has a coordinate x1\u2009=\u20091, the second \u2014 x2\u2009=\u20092, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&lt;\u2009yj\u2009&gt;\u2009yj\u2009+\u20091,  there should be precisely t\u2009-\u20091 such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&gt;\u2009yj\u2009&lt;\u2009yj\u2009+\u20091,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "64 megabytes", "input_spec": "The first line contains a pair of integers n and t (3\u2009\u2264\u2009n\u2009\u2264\u200920, 1\u2009\u2264\u2009t\u2009\u2264\u200910).", "output_spec": "Output the required amount of camels with t humps.", "notes": "NoteIn the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).", "sample_inputs": ["6 1", "4 2"], "sample_outputs": ["6", "0"], "tags": ["dp"], "src_uid": "6d67559744583229455c5eafe68f7952", "difficulty": 1900, "source_codes": ["def count_camel_polylines(n, t):\n    count = 0\n    \n    # Generate all possible y-coordinate sequences\n    for y_seq in product(range(1, 5), repeat=n):\n        # Check for horizontal segments\n        valid = True\n        for i in range(n - 1):\n            if y_seq[i] == y_seq[i + 1]:\n                valid = False\n                break\n        \n        if not valid:\n            continue\n            \n        # Count humps (local maxima) and valleys (local minima)\n        humps = 0\n        valleys = 0\n        \n        for j in range(1, n - 1):\n            prev_y, curr_y, next_y = y_seq[j-1], y_seq[j], y_seq[j+1]\n            if prev_y < curr_y > next_y:\n                humps += 1\n            elif prev_y > curr_y < next_y:\n                valleys += 1\n                \n        # Check if the sequence represents a camel with exactly t humps and t-1 valleys\n        if humps == t and valleys == t - 1:\n            count += 1\n            \n    return count\n\n# Read input\nn, t = map(int, input().split())\n\n# Calculate and print result\nresult = count_camel_polylines(n, t)\nprint(result)"], "responses": ["\nfrom itertools import product\n\ndef count_camel_polylines(n, t):\n    count = 0\n    \n    # Generate all possible y-coordinate sequences\n    for y_seq in product(range(1, 5), repeat=n):\n        # Check for horizontal segments\n        valid = True\n        for i in range(n - 1):\n            if y_seq[i] == y_seq[i + 1]:\n                valid = False\n                break\n        \n        if not valid:\n            continue\n            \n        # Count humps (local maxima) and valleys (local minima)\n        humps = 0\n        valleys = 0\n        \n        for j in range(1, n - 1):\n            prev_y, curr_y, next_y = y_seq[j-1], y_seq[j], y_seq[j+1]\n            if prev_y < curr_y > next_y:\n                humps += 1\n            elif prev_y > curr_y < next_y:\n                valleys += 1\n                \n        # Check if the sequence represents a camel with exactly t humps and t-1 valleys\n        if humps == t and valleys == t - 1:\n            count += 1\n            \n    return count\n\n# Read input\nn, t = map(int, input().split())\n\n# Calculate and print result\nresult = count_camel_polylines(n, t)\nprint(result)\n\n\n"], "prompt_tokens": [10359], "completion_tokens": [4834], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "6d67559744583229455c5eafe68f7952"}
{"description": "A car moves from point A to point B at speed v meters per second. The action takes place on the X-axis. At the distance d meters from A there are traffic lights. Starting from time 0, for the first g seconds the green light is on, then for the following r seconds the red light is on, then again the green light is on for the g seconds, and so on.The car can be instantly accelerated from 0 to v and vice versa, can instantly slow down from the v to 0. Consider that it passes the traffic lights at the green light instantly. If the car approaches the traffic lights at the moment when the red light has just turned on, it doesn't have time to pass it. But if it approaches the traffic lights at the moment when the green light has just turned on, it can move. The car leaves point A at the time 0.What is the minimum time for the car to get from point A to point B without breaking the traffic rules?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains integers l, d, v, g, r (1\u2009\u2264\u2009l,\u2009d,\u2009v,\u2009g,\u2009r\u2009\u2264\u20091000,\u2009d\u2009&lt;\u2009l) \u2014 the distance between A and B (in meters), the distance from A to the traffic lights, car's speed, the duration of green light and the duration of red light.", "output_spec": "Output a single number \u2014 the minimum time that the car needs to get from point A to point B. Your output must have relative or absolute error less than 10\u2009-\u20096.", "notes": null, "sample_inputs": ["2 1 3 4 5", "5 4 3 1 1"], "sample_outputs": ["0.66666667", "2.33333333"], "tags": ["implementation"], "src_uid": "e4a4affb439365c843c9f9828d81b42c", "difficulty": 1500, "source_codes": ["import sys\n\ndef min_car_time(l, d, v, g, r):\n    # Time to reach traffic lights\n    t_reach = d / v\n    \n    # Cycle duration\n    cycle = g + r\n    \n    # Phase within the cycle\n    phase = t_reach % cycle\n    \n    # Waiting time\n    wait = 0\n    if phase > g:\n        # Currently in red phase, wait for next green\n        wait = cycle - phase\n    elif phase == g:\n        # Arrived exactly when red starts, must wait full cycle\n        wait = cycle\n    # If phase < g, we're in green phase, no waiting needed\n    \n    # Time from traffic lights to destination\n    t_remaining = (l - d) / v\n    \n    return t_reach + wait + t_remaining\n\n# Read input\nline = input().strip()\nl, d, v, g, r = map(int, line.split())\n\n# Calculate and print result\nresult = min_car_time(l, d, v, g, r)\nprint(f\"{result:.10f}\")"], "responses": ["\nimport sys\n\ndef min_car_time(l, d, v, g, r):\n    # Time to reach traffic lights\n    t_reach = d / v\n    \n    # Cycle duration\n    cycle = g + r\n    \n    # Phase within the cycle\n    phase = t_reach % cycle\n    \n    # Waiting time\n    wait = 0\n    if phase > g:\n        # Currently in red phase, wait for next green\n        wait = cycle - phase\n    elif phase == g:\n        # Arrived exactly when red starts, must wait full cycle\n        wait = cycle\n    # If phase < g, we're in green phase, no waiting needed\n    \n    # Time from traffic lights to destination\n    t_remaining = (l - d) / v\n    \n    return t_reach + wait + t_remaining\n\n# Read input\nline = input().strip()\nl, d, v, g, r = map(int, line.split())\n\n# Calculate and print result\nresult = min_car_time(l, d, v, g, r)\nprint(f\"{result:.10f}\")\n\n\n"], "prompt_tokens": [13868], "completion_tokens": [5753], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "e4a4affb439365c843c9f9828d81b42c"}
{"description": "Volodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges.", "input_from": "standard input", "output_to": "standard output", "time_limit": "4 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains the number of cases t (1\u2009\u2264\u2009t\u2009\u2264\u200910). Each of the next t lines contains two natural numbers li and ri (1\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u20099\u2009\u00b71018). Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).", "output_spec": "Output should contain t numbers \u2014 answers to the queries, one number per line \u2014 quantities of beautiful numbers in given intervals (from li to ri, inclusively).", "notes": null, "sample_inputs": ["1\n1 9", "1\n12 15"], "sample_outputs": ["9", "2"], "tags": ["dp", "number theory"], "src_uid": "37feadce373f728ba2a560b198ca4bc9", "difficulty": 2500, "source_codes": ["import sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef get_lcm_of_digits(digits):\n    if not digits:\n        return 1\n    result = digits[0]\n    for i in range(1, len(digits)):\n        result = lcm(result, digits[i])\n    return result\n\n# Precompute all valid digit combinations and their LCMs\nvalid_combinations = {}\n\n# For each subset of digits {1,2,3,4,5,6,7,8,9}, compute LCM\nfor mask in range(1 << 9):\n    digit_set = []\n    for i in range(9):\n        if mask & (1 << i):\n            digit_set.append(i + 1)  # digits 1-9\n    \n    if not digit_set:\n        continue\n    \n    current_lcm = get_lcm_of_digits(digit_set)\n    valid_combinations[mask] = current_lcm\n\ndef subtract_one(s):\n    # Convert string to list for easier manipulation\n    digits = list(s)\n    i = len(digits) - 1\n    \n    # Handle borrowing\n    while i >= 0 and digits[i] == '0':\n        digits[i] = '9'\n        i -= 1\n    \n    if i >= 0:\n        digits[i] = str(int(digits[i]) - 1)\n    \n    # Remove leading zeros\n    result = ''.join(digits).lstrip('0')\n    return result if result else '0'\n\ndef count_beautiful_numbers(num_str):\n    if not num_str or num_str == '0':\n        return 0\n        \n    n = len(num_str)\n    memo = {}\n    \n    def dp(pos, tight, started, mask, remainder, lcm_val):\n        if pos == n:\n            # A number is beautiful if it's divisible by its LCM\n            # But we need to make sure the LCM corresponds to the actual digits used\n            if started and remainder == 0:\n                return 1\n            return 0\n            \n        state = (pos, tight, started, mask, remainder, lcm_val)\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                new_remainder = remainder\n                result += dp(pos + 1, tight and (digit == limit), False, mask, new_remainder, lcm_val)\n                continue\n            \n            # For actual digits, we need to check divisibility\n            if digit == 0:\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1))\n            \n            # Get LCM for current digit set\n            new_lcm = valid_combinations.get(new_mask, 0)\n            if new_lcm == 0:\n                continue  # Invalid combination\n                \n            # Update remainder\n            new_remainder = (remainder * 10 + digit) % new_lcm\n            \n            result += dp(pos + 1, tight and (digit == limit), True, new_mask, new_remainder, new_lcm)\n        \n        memo[state] = result\n        return result\n    \n    # This approach is too complex. Let me simplify.\n    \n    # Better approach: for each possible LCM value, count numbers divisible by that LCM\n    total = 0\n    memo.clear()\n    \n    def dp_simple(pos, tight, started, mask, num_value, max_len):\n        if pos == n:\n            if started:\n                # Check if this number is beautiful\n                lcm_digits = valid_combinations.get(mask, 1)\n                if num_value % lcm_digits == 0:\n                    return 1\n            return 0\n            \n        state = (pos, tight, started, mask, num_value % 1000000 if pos > 10 else num_value)  # Hack to reduce state space\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                result += dp_simple(pos + 1, tight and (digit == limit), False, mask, num_value * 10 + digit, max_len)\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1)) if digit > 0 else mask\n            \n            result += dp_simple(pos + 1, tight and (digit == limit), True, new_mask, num_value * 10 + digit, max_len)\n        \n        memo[state] = result\n        return result\n    \n    # Even simpler approach - track remainder properly\n    memo.clear()\n    \n    def dp_final(pos, tight, started, mask, remainder):\n        if pos == n:\n            return 1 if (started and remainder == 0) else 0\n            \n        # Reduce state space by taking mod of remainder with LCM\n        effective_remainder = remainder\n        if mask in valid_combinations:\n            effective_remainder = remainder % valid_combinations[mask]\n            \n        state = (pos, tight, started, mask, effective_remainder)\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                result += dp_final(pos + 1, tight and (digit == limit), False, mask, remainder)\n                continue\n            \n            # Skip zero digits for divisibility check\n            if digit == 0:\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1))\n            \n            # Calculate new remainder\n            if new_mask in valid_combinations:\n                new_lcm = valid_combinations[new_mask]\n                new_remainder = (remainder * 10 + digit) % new_lcm\n                result += dp_final(pos + 1, tight and (digit == limit), True, new_mask, new_remainder)\n        \n        memo[state] = result\n        return result\n    \n    return dp_final(0, True, False, 0, 0)\n\ndef solve(l, r):\n    count_r = count_beautiful_numbers(str(r))\n    if l == 1:\n        count_l_minus_1 = 0\n    else:\n        count_l_minus_1 = count_beautiful_numbers(subtract_one(str(l)))\n    return count_r - count_l_minus_1\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    \n    t = int(input_lines[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        l, r = map(int, input_lines[i].split())\n        results.append(str(solve(l, r)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef get_lcm_of_digits(digits):\n    if not digits:\n        return 1\n    result = digits[0]\n    for i in range(1, len(digits)):\n        result = lcm(result, digits[i])\n    return result\n\n# Precompute all valid digit combinations and their LCMs\nvalid_combinations = {}\n\n# For each subset of digits {1,2,3,4,5,6,7,8,9}, compute LCM\nfor mask in range(1 << 9):\n    digit_set = []\n    for i in range(9):\n        if mask & (1 << i):\n            digit_set.append(i + 1)  # digits 1-9\n    \n    if not digit_set:\n        continue\n    \n    current_lcm = get_lcm_of_digits(digit_set)\n    valid_combinations[mask] = current_lcm\n\ndef subtract_one(s):\n    # Convert string to list for easier manipulation\n    digits = list(s)\n    i = len(digits) - 1\n    \n    # Handle borrowing\n    while i >= 0 and digits[i] == '0':\n        digits[i] = '9'\n        i -= 1\n    \n    if i >= 0:\n        digits[i] = str(int(digits[i]) - 1)\n    \n    # Remove leading zeros\n    result = ''.join(digits).lstrip('0')\n    return result if result else '0'\n\ndef count_beautiful_numbers(num_str):\n    if not num_str or num_str == '0':\n        return 0\n        \n    n = len(num_str)\n    memo = {}\n    \n    def dp(pos, tight, started, mask, remainder, lcm_val):\n        if pos == n:\n            # A number is beautiful if it's divisible by its LCM\n            # But we need to make sure the LCM corresponds to the actual digits used\n            if started and remainder == 0:\n                return 1\n            return 0\n            \n        state = (pos, tight, started, mask, remainder, lcm_val)\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                new_remainder = remainder\n                result += dp(pos + 1, tight and (digit == limit), False, mask, new_remainder, lcm_val)\n                continue\n            \n            # For actual digits, we need to check divisibility\n            if digit == 0:\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1))\n            \n            # Get LCM for current digit set\n            new_lcm = valid_combinations.get(new_mask, 0)\n            if new_lcm == 0:\n                continue  # Invalid combination\n                \n            # Update remainder\n            new_remainder = (remainder * 10 + digit) % new_lcm\n            \n            result += dp(pos + 1, tight and (digit == limit), True, new_mask, new_remainder, new_lcm)\n        \n        memo[state] = result\n        return result\n    \n    # This approach is too complex. Let me simplify.\n    \n    # Better approach: for each possible LCM value, count numbers divisible by that LCM\n    total = 0\n    memo.clear()\n    \n    def dp_simple(pos, tight, started, mask, num_value, max_len):\n        if pos == n:\n            if started:\n                # Check if this number is beautiful\n                lcm_digits = valid_combinations.get(mask, 1)\n                if num_value % lcm_digits == 0:\n                    return 1\n            return 0\n            \n        state = (pos, tight, started, mask, num_value % 1000000 if pos > 10 else num_value)  # Hack to reduce state space\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                result += dp_simple(pos + 1, tight and (digit == limit), False, mask, num_value * 10 + digit, max_len)\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1)) if digit > 0 else mask\n            \n            result += dp_simple(pos + 1, tight and (digit == limit), True, new_mask, num_value * 10 + digit, max_len)\n        \n        memo[state] = result\n        return result\n    \n    # Even simpler approach - track remainder properly\n    memo.clear()\n    \n    def dp_final(pos, tight, started, mask, remainder):\n        if pos == n:\n            return 1 if (started and remainder == 0) else 0\n            \n        # Reduce state space by taking mod of remainder with LCM\n        effective_remainder = remainder\n        if mask in valid_combinations:\n            effective_remainder = remainder % valid_combinations[mask]\n            \n        state = (pos, tight, started, mask, effective_remainder)\n        if state in memo:\n            return memo[state]\n            \n        limit = int(num_str[pos]) if tight else 9\n        result = 0\n        \n        for digit in range(0, limit + 1):\n            # Handle leading zeros\n            if not started and digit == 0:\n                result += dp_final(pos + 1, tight and (digit == limit), False, mask, remainder)\n                continue\n            \n            # Skip zero digits for divisibility check\n            if digit == 0:\n                continue\n                \n            # Add this digit to our mask\n            new_mask = mask | (1 << (digit - 1))\n            \n            # Calculate new remainder\n            if new_mask in valid_combinations:\n                new_lcm = valid_combinations[new_mask]\n                new_remainder = (remainder * 10 + digit) % new_lcm\n                result += dp_final(pos + 1, tight and (digit == limit), True, new_mask, new_remainder)\n        \n        memo[state] = result\n        return result\n    \n    return dp_final(0, True, False, 0, 0)\n\ndef solve(l, r):\n    count_r = count_beautiful_numbers(str(r))\n    if l == 1:\n        count_l_minus_1 = 0\n    else:\n        count_l_minus_1 = count_beautiful_numbers(subtract_one(str(l)))\n    return count_r - count_l_minus_1\n\ndef main():\n    input_lines = sys.stdin.read().strip().split('\\n')\n    \n    t = int(input_lines[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        l, r = map(int, input_lines[i].split())\n        results.append(str(solve(l, r)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13768], "completion_tokens": [9770], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "37feadce373f728ba2a560b198ca4bc9"}
{"description": "Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word s. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word \"hello\". For example, if Vasya types the word \"ahhellllloou\", it will be considered that he said hello, and if he types \"hlelo\", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word s.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first and only line contains the word s, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.", "output_spec": "If Vasya managed to say hello, print \"YES\", otherwise print \"NO\".", "notes": null, "sample_inputs": ["ahhellllloou", "hlelo"], "sample_outputs": ["YES", "NO"], "tags": ["strings", "greedy"], "src_uid": "c5d19dc8f2478ee8d9cba8cc2e4cd838", "difficulty": 1000, "source_codes": ["s = input().strip()\ntarget = \"hello\"\nindex = 0\n\nfor char in s:\n    if index < len(target) and char == target[index]:\n        index += 1\n\nif index == len(target):\n    print(\"YES\")\nelse:\n    print(\"NO\")"], "responses": ["\ns = input().strip()\ntarget = \"hello\"\nindex = 0\n\nfor char in s:\n    if index < len(target) and char == target[index]:\n        index += 1\n\nif index == len(target):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n"], "prompt_tokens": [8006], "completion_tokens": [1596], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "c5d19dc8f2478ee8d9cba8cc2e4cd838"}
{"description": "Sometimes one has to spell email addresses over the phone. Then one usually pronounces a dot as dot, an at sign as at. As a result, we get something like vasyaatgmaildotcom. Your task is to transform it into a proper email address (vasya@gmail.com). It is known that a proper email address contains only such symbols as . @ and lower-case Latin letters, doesn't start with and doesn't end with a dot. Also, a proper email address doesn't start with and doesn't end with an at sign. Moreover, an email address contains exactly one such symbol as @, yet may contain any number (possible, zero) of dots. You have to carry out a series of replacements so that the length of the result was as short as possible and it was a proper email address. If the lengths are equal, you should print the lexicographically minimal result. Overall, two variants of replacement are possible: dot can be replaced by a dot, at can be replaced by an at. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains the email address description. It is guaranteed that that is a proper email address with all the dots replaced by dot an the at signs replaced by at. The line is not empty and its length does not exceed 100 symbols.", "output_spec": "Print the shortest email address, from which the given line could be made by the described above replacements. If there are several solutions to that problem, print the lexicographically minimal one (the lexicographical comparison of the lines are implemented with an operator &lt; in modern programming languages). In the ASCII table the symbols go in this order: . @ ab...z", "notes": null, "sample_inputs": ["vasyaatgmaildotcom", "dotdotdotatdotdotat", "aatt"], "sample_outputs": ["vasya@gmail.com", "dot..@..at", "a@t"], "tags": ["expression parsing", "implementation"], "src_uid": "a11c9679d8e2dca51be17d466202df6e", "difficulty": 1300, "source_codes": ["def is_valid_email(email):\n    # Check if it's a valid email address\n    if email.count('@') != 1:\n        return False\n    if email.startswith('.') or email.endswith('.'):\n        return False\n    if email.startswith('@') or email.endswith('@'):\n        return False\n    # Check that email only contains valid characters\n    for c in email:\n        if c not in '.@' and not ('a' <= c <= 'z'):\n            return False\n    return True\n\ndef generate_possibilities(s, pos, current, results):\n    # Generate all possible ways to parse the string\n    if pos == len(s):\n        if is_valid_email(current):\n            results.append(current)\n        return\n    \n    # Pruning: if we already have too many @ symbols, stop\n    if current.count('@') > 1:\n        return\n        \n    # Try taking single character (if it's a valid character)\n    if s[pos] in '.@abcdefghijklmnopqrstuvwxyz':\n        generate_possibilities(s, pos + 1, current + s[pos], results)\n    \n    # Try matching \"dot\"\n    if pos + 2 < len(s) and s[pos:pos+3] == \"dot\":\n        generate_possibilities(s, pos + 3, current + \".\", results)\n    \n    # Try matching \"at\"\n    if pos + 1 < len(s) and s[pos:pos+2] == \"at\":\n        generate_possibilities(s, pos + 2, current + \"@\", results)\n\ndef solve(s):\n    results = []\n    generate_possibilities(s, 0, \"\", results)\n    \n    if not results:\n        return \"\"\n    \n    # Find the shortest, and among those, the lexicographically smallest\n    min_length = min(len(result) for result in results)\n    candidates = [result for result in results if len(result) == min_length]\n    return min(candidates)\n\ninput_str = input().strip()\nprint(solve(input_str))"], "responses": ["\ndef is_valid_email(email):\n    # Check if it's a valid email address\n    if email.count('@') != 1:\n        return False\n    if email.startswith('.') or email.endswith('.'):\n        return False\n    if email.startswith('@') or email.endswith('@'):\n        return False\n    # Check that email only contains valid characters\n    for c in email:\n        if c not in '.@' and not ('a' <= c <= 'z'):\n            return False\n    return True\n\ndef generate_possibilities(s, pos, current, results):\n    # Generate all possible ways to parse the string\n    if pos == len(s):\n        if is_valid_email(current):\n            results.append(current)\n        return\n    \n    # Pruning: if we already have too many @ symbols, stop\n    if current.count('@') > 1:\n        return\n        \n    # Try taking single character (if it's a valid character)\n    if s[pos] in '.@abcdefghijklmnopqrstuvwxyz':\n        generate_possibilities(s, pos + 1, current + s[pos], results)\n    \n    # Try matching \"dot\"\n    if pos + 2 < len(s) and s[pos:pos+3] == \"dot\":\n        generate_possibilities(s, pos + 3, current + \".\", results)\n    \n    # Try matching \"at\"\n    if pos + 1 < len(s) and s[pos:pos+2] == \"at\":\n        generate_possibilities(s, pos + 2, current + \"@\", results)\n\ndef solve(s):\n    results = []\n    generate_possibilities(s, 0, \"\", results)\n    \n    if not results:\n        return \"\"\n    \n    # Find the shortest, and among those, the lexicographically smallest\n    min_length = min(len(result) for result in results)\n    candidates = [result for result in results if len(result) == min_length]\n    return min(candidates)\n\ninput_str = input().strip()\nprint(solve(input_str))\n\n\n"], "prompt_tokens": [10041], "completion_tokens": [6061], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "a11c9679d8e2dca51be17d466202df6e"}
{"description": "Fangy collects cookies. Once he decided to take a box and put cookies into it in some way. If we take a square k\u2009\u00d7\u2009k in size, divided into blocks 1\u2009\u00d7\u20091 in size and paint there the main diagonal together with cells, which lie above it, then the painted area will be equal to the area occupied by one cookie k in size. Fangy also has a box with a square base 2n\u2009\u00d7\u20092n, divided into blocks 1\u2009\u00d7\u20091 in size. In a box the cookies should not overlap, and they should not be turned over or rotated. See cookies of sizes 2 and 4 respectively on the figure:    To stack the cookies the little walrus uses the following algorithm. He takes out of the repository the largest cookie which can fit in some place in the box and puts it there. Everything could be perfect but alas, in the repository the little walrus has infinitely many cookies of size 2 and larger, and there are no cookies of size 1, therefore, empty cells will remain in the box. Fangy wants to know how many empty cells will be left in the end.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091000).", "output_spec": "Print the single number, equal to the number of empty cells in the box. The answer should be printed modulo 106\u2009+\u20093.", "notes": "NoteIf the box possesses the base of 23\u2009\u00d7\u200923 (as in the example), then the cookies will be put there in the following manner: ", "sample_inputs": ["3"], "sample_outputs": ["9"], "tags": ["math"], "src_uid": "1a335a9638523ca0315282a67e18eec7", "difficulty": 1300, "source_codes": ["def solve():\n    n = int(input())\n    MOD = 1000003\n    \n    if n == 0:\n        print(1)\n        return\n    \n    # Calculate 3^(n-1) mod MOD\n    result = pow(3, n - 1, MOD)\n    print(result)\n\nsolve()"], "responses": ["\ndef solve():\n    n = int(input())\n    MOD = 1000003\n    \n    if n == 0:\n        print(1)\n        return\n    \n    # Calculate 3^(n-1) mod MOD\n    result = pow(3, n - 1, MOD)\n    print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [8764], "completion_tokens": [3540], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "1a335a9638523ca0315282a67e18eec7"}
{"description": "For each positive integer n consider the integer \u03c8(n) which is obtained from n by replacing every digit a in the decimal notation of n with the digit (9\u2009\u2009-\u2009\u2009a). We say that \u03c8(n) is the reflection of n. For example, reflection of 192 equals 807. Note that leading zeros (if any) should be omitted. So reflection of 9 equals 0, reflection of 91 equals 8.Let us call the weight of the number the product of the number and its reflection. Thus, the weight of the number 10 is equal to 10\u00b789\u2009=\u2009890.Your task is to find the maximum weight of the numbers in the given range [l,\u2009r] (boundaries are included).", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "Input contains two space-separated integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109) \u2014 bounds of the range.", "output_spec": "Output should contain single integer number: maximum value of the product n\u00b7\u03c8(n), where l\u2009\u2264\u2009n\u2009\u2264\u2009r. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).", "notes": "NoteIn the third sample weight of 8 equals 8\u00b71\u2009=\u20098, weight of 9 equals 9\u00b70\u2009=\u20090, weight of 10 equals 890.Thus, maximum value of the product is equal to 890.", "sample_inputs": ["3 7", "1 1", "8 10"], "sample_outputs": ["20", "8", "890"], "tags": ["math"], "src_uid": "2c4b2a162563242cb2f43f6209b59d5e", "difficulty": 1600, "source_codes": ["def reflect(n):\n    s = str(n)\n    reflected = ''.join(str(9 - int(d)) for d in s)\n    return int(reflected)\n\ndef weight(n):\n    return n * reflect(n)\n\ndef get_all_nines(length):\n    \"\"\"Generate a number with all 9s of given length\"\"\"\n    if length == 0:\n        return 0\n    return int('9' * length)\n\ndef get_all_zeros(length):\n    \"\"\"Generate a number with all 0s of given length (returns 0)\"\"\"\n    return 0\n\ndef generate_candidates(l, r):\n    candidates = set()\n    \n    # Always include boundaries\n    candidates.add(l)\n    candidates.add(r)\n    \n    # Generate candidates around significant points\n    str_l, str_r = str(l), str(r)\n    min_len, max_len = len(str_l), len(str_r)\n    \n    # Check all 9s numbers of relevant lengths\n    for length in range(min_len, max_len + 2):\n        all_nines = get_all_nines(length)\n        if l <= all_nines <= r:\n            candidates.add(all_nines)\n        # Also check one less than all 9s\n        if length > 0:\n            almost_all_nines = all_nines - 1\n            if l <= almost_all_nines <= r:\n                candidates.add(almost_all_nines)\n    \n    # Check powers of 10 and nearby numbers\n    for length in range(min_len, max_len + 2):\n        if length == 0:\n            pow_10 = 1\n        else:\n            pow_10 = 10 ** (length - 1)\n        \n        # Check power of 10 and nearby values\n        for offset in range(-10, 11):\n            candidate = pow_10 + offset\n            if l <= candidate <= r:\n                candidates.add(candidate)\n                \n        # Check one less than next power of 10\n        if length > 0:\n            next_pow = 10 ** length\n            for offset in range(-10, 1):\n                candidate = next_pow + offset\n                if l <= candidate <= r:\n                    candidates.add(candidate)\n    \n    # For small ranges, check all numbers\n    if r - l <= 1000:\n        for i in range(l, r + 1):\n            candidates.add(i)\n    else:\n        # For larger ranges, sample strategically\n        # Check around boundaries more thoroughly\n        for base in [l, r]:\n            for offset in range(-50, 51):\n                candidate = base + offset\n                if l <= candidate <= r:\n                    candidates.add(candidate)\n        \n        # Sample the range\n        step = max(1, (r - l) // 1000)\n        for i in range(l, r + 1, step):\n            candidates.add(i)\n            \n        # Add some intermediate points\n        mid = (l + r) // 2\n        for offset in range(-100, 101):\n            candidate = mid + offset\n            if l <= candidate <= r:\n                candidates.add(candidate)\n    \n    return list(candidates)\n\ndef solve(l, r):\n    candidates = generate_candidates(l, r)\n    \n    max_weight = 0\n    for n in candidates:\n        if l <= n <= r:\n            w = weight(n)\n            max_weight = max(max_weight, w)\n    \n    return max_weight\n\nl, r = map(int, input().split())\nprint(solve(l, r))"], "responses": ["\ndef reflect(n):\n    s = str(n)\n    reflected = ''.join(str(9 - int(d)) for d in s)\n    return int(reflected)\n\ndef weight(n):\n    return n * reflect(n)\n\ndef get_all_nines(length):\n    \"\"\"Generate a number with all 9s of given length\"\"\"\n    if length == 0:\n        return 0\n    return int('9' * length)\n\ndef get_all_zeros(length):\n    \"\"\"Generate a number with all 0s of given length (returns 0)\"\"\"\n    return 0\n\ndef generate_candidates(l, r):\n    candidates = set()\n    \n    # Always include boundaries\n    candidates.add(l)\n    candidates.add(r)\n    \n    # Generate candidates around significant points\n    str_l, str_r = str(l), str(r)\n    min_len, max_len = len(str_l), len(str_r)\n    \n    # Check all 9s numbers of relevant lengths\n    for length in range(min_len, max_len + 2):\n        all_nines = get_all_nines(length)\n        if l <= all_nines <= r:\n            candidates.add(all_nines)\n        # Also check one less than all 9s\n        if length > 0:\n            almost_all_nines = all_nines - 1\n            if l <= almost_all_nines <= r:\n                candidates.add(almost_all_nines)\n    \n    # Check powers of 10 and nearby numbers\n    for length in range(min_len, max_len + 2):\n        if length == 0:\n            pow_10 = 1\n        else:\n            pow_10 = 10 ** (length - 1)\n        \n        # Check power of 10 and nearby values\n        for offset in range(-10, 11):\n            candidate = pow_10 + offset\n            if l <= candidate <= r:\n                candidates.add(candidate)\n                \n        # Check one less than next power of 10\n        if length > 0:\n            next_pow = 10 ** length\n            for offset in range(-10, 1):\n                candidate = next_pow + offset\n                if l <= candidate <= r:\n                    candidates.add(candidate)\n    \n    # For small ranges, check all numbers\n    if r - l <= 1000:\n        for i in range(l, r + 1):\n            candidates.add(i)\n    else:\n        # For larger ranges, sample strategically\n        # Check around boundaries more thoroughly\n        for base in [l, r]:\n            for offset in range(-50, 51):\n                candidate = base + offset\n                if l <= candidate <= r:\n                    candidates.add(candidate)\n        \n        # Sample the range\n        step = max(1, (r - l) // 1000)\n        for i in range(l, r + 1, step):\n            candidates.add(i)\n            \n        # Add some intermediate points\n        mid = (l + r) // 2\n        for offset in range(-100, 101):\n            candidate = mid + offset\n            if l <= candidate <= r:\n                candidates.add(candidate)\n    \n    return list(candidates)\n\ndef solve(l, r):\n    candidates = generate_candidates(l, r)\n    \n    max_weight = 0\n    for n in candidates:\n        if l <= n <= r:\n            w = weight(n)\n            max_weight = max(max_weight, w)\n    \n    return max_weight\n\nl, r = map(int, input().split())\nprint(solve(l, r))\n\n\n"], "prompt_tokens": [11802], "completion_tokens": [5366], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "2c4b2a162563242cb2f43f6209b59d5e"}
