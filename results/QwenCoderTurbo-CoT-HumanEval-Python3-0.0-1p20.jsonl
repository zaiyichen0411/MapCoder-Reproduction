{"task_id": "HumanEval/76", "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n", "entry_point": "is_simple_power", "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert is_simple_power(1, 4) == True", "assert is_simple_power(2, 2) == True", "assert is_simple_power(8, 2) == True", "assert is_simple_power(3, 2) == False", "assert is_simple_power(3, 1) == False", "assert is_simple_power(5, 3) == False"], "source_codes": ["\ndef is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n (i.e., n**k = x for some integer k), False otherwise.\n    \"\"\"\n    # Handle special cases\n    if n == 0:\n        return x == 0\n    if n == 1:\n        return x == 1\n    if x == 1:\n        return True\n    \n    # For negative bases, we need to check both positive and negative powers\n    if n < 0:\n        # For negative n, x must be either positive or negative depending on the power\n        # This gets complex, so let's handle specific cases\n        if x == 0:\n            return False\n        # We'll check a reasonable range of powers\n        for k in range(-100, 101):\n            if k == 0:\n                continue\n            try:\n                if n ** k == x:\n                    return True\n            except:\n                # Overflow or other computational issues\n                continue\n        return False\n    \n    # For positive n > 1\n    if n > 1:\n        # Check positive powers\n        power = 1\n        k = 0\n        while power < x:\n            power *= n\n            k += 1\n        return power == x\n    \n    # For 0 < n < 1 (fractional base)\n    # This would require checking fractional powers which is complex\n    # Let's simplify by checking a reasonable range\n    for k in range(0, 100):\n        if n ** k == x:\n            return True\n    return False\n\n\n"], "responses": ["```python\ndef is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n (i.e., n**k = x for some integer k), False otherwise.\n    \"\"\"\n    # Handle special cases\n    if n == 0:\n        return x == 0\n    if n == 1:\n        return x == 1\n    if x == 1:\n        return True\n    \n    # For negative bases, we need to check both positive and negative powers\n    if n < 0:\n        # For negative n, x must be either positive or negative depending on the power\n        # This gets complex, so let's handle specific cases\n        if x == 0:\n            return False\n        # We'll check a reasonable range of powers\n        for k in range(-100, 101):\n            if k == 0:\n                continue\n            try:\n                if n ** k == x:\n                    return True\n            except:\n                # Overflow or other computational issues\n                continue\n        return False\n    \n    # For positive n > 1\n    if n > 1:\n        # Check positive powers\n        power = 1\n        k = 0\n        while power < x:\n            power *= n\n            k += 1\n        return power == x\n    \n    # For 0 < n < 1 (fractional base)\n    # This would require checking fractional powers which is complex\n    # Let's simplify by checking a reasonable range\n    for k in range(0, 100):\n        if n ** k == x:\n            return True\n    return False\n```"], "prompt_tokens": [1837], "completion_tokens": [348], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/77", "prompt": "\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "sample_io": ["assert iscube(1) == True", "assert iscube(2) == False", "assert iscube(-1) == True", "assert iscube(64) == True", "assert iscube(0) == True", "assert iscube(180) == False"], "source_codes": ["\ndef iscube(a):\n    if a >= 0:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    else:\n        cube_root = round((-a) ** (1/3))\n        return (-cube_root) ** 3 == a\n\n\n"], "responses": ["```python\ndef iscube(a):\n    if a >= 0:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    else:\n        cube_root = round((-a) ** (1/3))\n        return (-cube_root) ** 3 == a\n```"], "prompt_tokens": [1808], "completion_tokens": [67], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/78", "prompt": "\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n", "entry_point": "hex_key", "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "sample_io": ["assert hex_key(\"AB\") == 1", "assert hex_key(\"1077E\") == 2", "assert hex_key(\"ABED1A33\") == 4", "assert hex_key(\"123456789ABCDEF0\") == 6", "assert hex_key(\"2020\") == 2"], "source_codes": ["\ndef hex_key(num):\n    # Define the set of hexadecimal digits that represent prime numbers\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime hexadecimal digits\n    count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime hexadecimal digit\n        if char in prime_hex_digits:\n            count += 1\n    \n    # Return the total count of prime hexadecimal digits\n    return count\n\n\n"], "responses": ["```python\ndef hex_key(num):\n    # Define the set of hexadecimal digits that represent prime numbers\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime hexadecimal digits\n    count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime hexadecimal digit\n        if char in prime_hex_digits:\n            count += 1\n    \n    # Return the total count of prime hexadecimal digits\n    return count\n```"], "prompt_tokens": [2010], "completion_tokens": [120], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/79", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert decimal_to_binary(15) == \"db1111db\"", "assert decimal_to_binary(32) == \"db100000db\""], "source_codes": ["\ndef decimal_to_binary(decimal):\n    # Convert the decimal number to binary (remove the '0b' prefix)\n    binary_str = bin(decimal)[2:]\n    \n    # Add 'db' at the beginning and end of the binary string\n    result = 'db' + binary_str + 'db'\n    \n    return result\n\n\n"], "responses": ["```python\ndef decimal_to_binary(decimal):\n    # Convert the decimal number to binary (remove the '0b' prefix)\n    binary_str = bin(decimal)[2:]\n    \n    # Add 'db' at the beginning and end of the binary string\n    result = 'db' + binary_str + 'db'\n    \n    return result\n```"], "prompt_tokens": [1842], "completion_tokens": [71], "no_of_try": 1, "is_solved": true, "language": "Python3"}
