{"task_id": "HumanEval/88", "prompt": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "sample_io": ["assert sort_array([]) == []", "assert sort_array([5]) == [5]", "assert sort_array([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]", "assert sort_array([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]"], "source_codes": ["\ndef sort_array(array):\n    # Handle edge cases: empty array or single element\n    if len(array) <= 1:\n        return array[:]\n    \n    # Calculate the sum of first and last elements\n    sum_first_last = array[0] + array[-1]\n    \n    # Create a copy of the array to avoid modifying the original\n    sorted_array = array[:]\n    \n    # Sort in ascending order if sum is odd, else descending\n    if sum_first_last % 2 == 1:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n    \n    return sorted_array\n\n\n"], "responses": ["```python\ndef sort_array(array):\n    # Handle edge cases: empty array or single element\n    if len(array) <= 1:\n        return array[:]\n    \n    # Calculate the sum of first and last elements\n    sum_first_last = array[0] + array[-1]\n    \n    # Create a copy of the array to avoid modifying the original\n    sorted_array = array[:]\n    \n    # Sort in ascending order if sum is odd, else descending\n    if sum_first_last % 2 == 1:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n    \n    return sorted_array\n```"], "prompt_tokens": [1898], "completion_tokens": [130], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/89", "prompt": "\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n", "entry_point": "encrypt", "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert encrypt('hi') == 'lm'", "assert encrypt('asdfghjkl') == 'ewhjklnop'", "assert encrypt('gf') == 'kj'", "assert encrypt('et') == 'ix'"], "source_codes": ["\ndef encrypt(s):\n    # Define the alphabet as a string\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Initialize an empty string to store the encrypted result\n    out = ''\n    \n    # Iterate through each character in the input string\n    for c in s:\n        # Check if the character is a letter in the alphabet\n        if c in d:\n            # Find the index of the current letter in the alphabet\n            index = d.index(c)\n            \n            # Rotate the alphabet by two multiplied to two places (2*2=4)\n            # Use modulo 26 to handle wrapping around the alphabet\n            rotated_index = (index + 4) % 26\n            \n            # Append the encrypted letter to the result string\n            out += d[rotated_index]\n        else:\n            # If the character is not a letter, append it unchanged to the result string\n            out += c\n    \n    # Return the final encrypted string\n    return out\n\n\n"], "responses": ["```python\ndef encrypt(s):\n    # Define the alphabet as a string\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Initialize an empty string to store the encrypted result\n    out = ''\n    \n    # Iterate through each character in the input string\n    for c in s:\n        # Check if the character is a letter in the alphabet\n        if c in d:\n            # Find the index of the current letter in the alphabet\n            index = d.index(c)\n            \n            # Rotate the alphabet by two multiplied to two places (2*2=4)\n            # Use modulo 26 to handle wrapping around the alphabet\n            rotated_index = (index + 4) % 26\n            \n            # Append the encrypted letter to the result string\n            out += d[rotated_index]\n        else:\n            # If the character is not a letter, append it unchanged to the result string\n            out += c\n    \n    # Return the final encrypted string\n    return out\n```"], "prompt_tokens": [1805], "completion_tokens": [203], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/90", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "sample_io": ["assert next_smallest([1, 2, 3, 4, 5]) == 2", "assert next_smallest([5, 1, 4, 3, 2]) == 2", "assert next_smallest([]) == None", "assert next_smallest([1, 1]) == None"], "source_codes": ["\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to set, then back to list\n    unique_elements = list(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements\n    unique_elements.sort()\n    \n    # Return the second smallest element\n    return unique_elements[1]\n\n\n"], "responses": ["```python\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to set, then back to list\n    unique_elements = list(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements\n    unique_elements.sort()\n    \n    # Return the second smallest element\n    return unique_elements[1]\n```"], "prompt_tokens": [1819], "completion_tokens": [202], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/91", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert is_bored(\"Hello world\") == 0", "assert is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1"], "source_codes": ["\ndef is_bored(S):\n    # Split the string into sentences using the delimiters '.', '?', and '!'\n    sentences = []\n    current_sentence = \"\"\n    for char in S:\n        if char in '.?!':\n            if current_sentence.strip():  # Only add non-empty sentences\n                sentences.append(current_sentence.strip())\n            current_sentence = \"\"\n        else:\n            current_sentence += char\n    # Handle any remaining sentence that doesn't end with a delimiter\n    if current_sentence.strip():\n        sentences.append(current_sentence.strip())\n    \n    # Count how many sentences start with \"I\"\n    count = 0\n    for sentence in sentences:\n        # Split the sentence into words and check if the first word is \"I\"\n        words = sentence.split()\n        if words and words[0] == \"I\":\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef is_bored(S):\n    # Split the string into sentences using the delimiters '.', '?', and '!'\n    sentences = []\n    current_sentence = \"\"\n    for char in S:\n        if char in '.?!':\n            if current_sentence.strip():  # Only add non-empty sentences\n                sentences.append(current_sentence.strip())\n            current_sentence = \"\"\n        else:\n            current_sentence += char\n    # Handle any remaining sentence that doesn't end with a delimiter\n    if current_sentence.strip():\n        sentences.append(current_sentence.strip())\n    \n    # Count how many sentences start with \"I\"\n    count = 0\n    for sentence in sentences:\n        # Split the sentence into words and check if the first word is \"I\"\n        words = sentence.split()\n        if words and words[0] == \"I\":\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [1802], "completion_tokens": [180], "no_of_try": 1, "is_solved": true, "language": "Python3"}
