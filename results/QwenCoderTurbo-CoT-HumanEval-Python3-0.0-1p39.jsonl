{"task_id": "HumanEval/152", "prompt": "\ndef compare(game,guess):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n", "entry_point": "compare", "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "sample_io": ["assert compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) == [0,0,0,0,3,3]", "assert compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) == [4,4,1,0,0,6]"], "source_codes": ["\ndef compare(game, guess):\n    \"\"\"\n    Compare the actual game scores with the guesses and return the absolute differences.\n    \n    Args:\n        game (list): List of actual scores\n        guess (list): List of guessed scores\n        \n    Returns:\n        list: List of absolute differences between actual and guessed scores\n    \"\"\"\n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate through both lists simultaneously\n    for actual, predicted in zip(game, guess):\n        # Calculate the absolute difference between actual and predicted scores\n        diff = abs(actual - predicted)\n        # Append the difference to the result list\n        differences.append(diff)\n    \n    # Return the list of differences\n    return differences\n\n\n"], "responses": ["```python\ndef compare(game, guess):\n    \"\"\"\n    Compare the actual game scores with the guesses and return the absolute differences.\n    \n    Args:\n        game (list): List of actual scores\n        guess (list): List of guessed scores\n        \n    Returns:\n        list: List of absolute differences between actual and guessed scores\n    \"\"\"\n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate through both lists simultaneously\n    for actual, predicted in zip(game, guess):\n        # Calculate the absolute difference between actual and predicted scores\n        diff = abs(actual - predicted)\n        # Append the difference to the result list\n        differences.append(diff)\n    \n    # Return the list of differences\n    return differences\n```"], "prompt_tokens": [1925], "completion_tokens": [153], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/153", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "sample_io": ["assert Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'"], "source_codes": ["\ndef Strongest_Extension(class_name, extensions):\n    max_strength = None\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        CAP = sum(1 for c in ext if c.isupper())\n        SM = sum(1 for c in ext if c.islower())\n        strength = CAP - SM\n        \n        if max_strength is None or strength > max_strength:\n            max_strength = strength\n            strongest_ext = ext\n            \n    return f\"{class_name}.{strongest_ext}\"\n\n\n"], "responses": ["```python\ndef Strongest_Extension(class_name, extensions):\n    max_strength = None\n    strongest_ext = \"\"\n    \n    for ext in extensions:\n        CAP = sum(1 for c in ext if c.isupper())\n        SM = sum(1 for c in ext if c.islower())\n        strength = CAP - SM\n        \n        if max_strength is None or strength > max_strength:\n            max_strength = strength\n            strongest_ext = ext\n            \n    return f\"{class_name}.{strongest_ext}\"\n```"], "prompt_tokens": [1972], "completion_tokens": [104], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/154", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "sample_io": ["assert cycpattern_check(\"abcd\",\"abd\") == False", "assert cycpattern_check(\"hello\",\"ell\") == True", "assert cycpattern_check(\"whassup\",\"psus\") == False", "assert cycpattern_check(\"abab\",\"baa\") == True", "assert cycpattern_check(\"efef\",\"eeff\") == False", "assert cycpattern_check(\"himenss\",\"simen\") == True"], "source_codes": ["\ndef cycpattern_check(a, b):\n    # If b is empty, it's technically a substring of any string\n    if not b:\n        return True\n    \n    # If b is longer than a, it cannot be a substring\n    if len(b) > len(a):\n        return False\n    \n    # Generate all possible rotations of string b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation of b is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    # If no rotation is found as a substring, return False\n    return False\n\n\n"], "responses": ["```python\ndef cycpattern_check(a, b):\n    # If b is empty, it's technically a substring of any string\n    if not b:\n        return True\n    \n    # If b is longer than a, it cannot be a substring\n    if len(b) > len(a):\n        return False\n    \n    # Generate all possible rotations of string b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation of b is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    # If no rotation is found as a substring, return False\n    return False\n```"], "prompt_tokens": [1824], "completion_tokens": [143], "no_of_try": 1, "is_solved": true, "language": "Python3"}
{"task_id": "HumanEval/155", "prompt": "\ndef even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n", "entry_point": "even_odd_count", "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "sample_io": ["assert even_odd_count(-12) == (1, 1)", "assert even_odd_count(123) == (1, 2)"], "source_codes": ["\ndef even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n    \n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Convert the absolute value of the number to a string to process each digit\n    digits = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit character in the string\n    for digit_char in digits:\n        # Convert the character back to an integer\n        digit = int(digit_char)\n        \n        # Check if the digit is even or odd and increment the respective counter\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return a tuple containing the counts of even and odd digits\n    return (even_count, odd_count)\n\n\n"], "responses": ["```python\ndef even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n    \n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Convert the absolute value of the number to a string to process each digit\n    digits = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit character in the string\n    for digit_char in digits:\n        # Convert the character back to an integer\n        digit = int(digit_char)\n        \n        # Check if the digit is even or odd and increment the respective counter\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return a tuple containing the counts of even and odd digits\n    return (even_count, odd_count)\n```"], "prompt_tokens": [1763], "completion_tokens": [220], "no_of_try": 1, "is_solved": true, "language": "Python3"}
