{"name": "mbpp_234_volume_cube", "language": "Python3", "prompt": "def volume_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the volume of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "volume_cube", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(2) == 8\n    assert candidate(5) == 125\n\ndef test_check():\n    check(volume_cube)\n\ntest_check()\n", "sample_io": ["assert volume_cube(3) == 27"], "source_codes": ["\ndef volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    return l ** 3\n\n\n"], "responses": ["```python\ndef volume_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n    \"\"\"\n    return l ** 3\n```"], "prompt_tokens": [78], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_234_volume_cube"}
{"name": "mbpp_89_closest_num", "language": "Python3", "prompt": "def closest_num(N: int) -> int:\n    \"\"\"\n\tWrite a function to find the closest smaller number than n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "closest_num", "test": "def check(candidate):\n    assert candidate(11) == 10\n    assert candidate(7) == 6\n    assert candidate(12) == 11\n\ndef test_check():\n    check(closest_num)\n\ntest_check()\n", "sample_io": ["assert closest_num(11) == 10"], "source_codes": ["\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n\n\n"], "responses": ["```python\ndef closest_num(N: int) -> int:\n    \"\"\"\n    Find the closest smaller number than n.\n    \"\"\"\n    return N - 1\n```"], "prompt_tokens": [75], "completion_tokens": [34], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_89_closest_num"}
{"name": "mbpp_245_max_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum", "test": "def check(candidate):\n    assert candidate([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n    assert candidate([80, 60, 30, 40, 20, 10]) == 210\n    assert candidate([2, 3, 14, 16, 21, 23, 29, 30]) == 138\n\ndef test_check():\n    check(max_sum)\n\ntest_check()\n", "sample_io": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"], "source_codes": ["\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Initialize arrays to store maximum sum of increasing and decreasing subsequences\n    # inc[i] stores the maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] such that inc[i] stores the maximum sum of increasing subsequence ending at i\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] such that dec[i] stores the maximum sum of decreasing subsequence starting at i\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # inc[i] + dec[i] - arr[i] because arr[i] is counted twice\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum\n\n\n"], "responses": ["```python\ndef max_sum(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Initialize arrays to store maximum sum of increasing and decreasing subsequences\n    # inc[i] stores the maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Fill inc[] such that inc[i] stores the maximum sum of increasing subsequence ending at i\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] such that dec[i] stores the maximum sum of decreasing subsequence starting at i\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        # inc[i] + dec[i] - arr[i] because arr[i] is counted twice\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum\n```"], "prompt_tokens": [107], "completion_tokens": [334], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_245_max_sum"}
{"name": "mbpp_237_check_occurences", "language": "Python3", "prompt": "from typing import List, Tuple, Dict\n\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_occurences", "test": "def check(candidate):\n    assert candidate([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }\n    assert candidate([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]) == { (2, 4): 2, (3, 6): 2, (4, 7): 1 }\n    assert candidate([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]) == { (2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1 }\n\ndef test_check():\n    check(check_occurences)\n\ntest_check()\n", "sample_io": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == { (1, 3): 2, (2, 5): 2, (3, 6): 1 }"], "source_codes": ["\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        if item in result:\n            result[item] += 1\n        else:\n            result[item] = 1\n    return result\n\n\n"], "responses": ["```python\ndef check_occurences(test_list: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for item in test_list:\n        if item in result:\n            result[item] += 1\n        else:\n            result[item] = 1\n    return result\n```"], "prompt_tokens": [116], "completion_tokens": [103], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_237_check_occurences"}
{"name": "mbpp_77_is_Diff", "language": "Python3", "prompt": "def is_Diff(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether a number is divisible by 11.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Diff", "test": "def check(candidate):\n    assert candidate(12345) == False\n    assert candidate(1212112) == True\n    assert candidate(1212) == False\n\ndef test_check():\n    check(is_Diff)\n\ntest_check()\n", "sample_io": ["assert is_Diff(12345) == False"], "source_codes": ["\ndef is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n    \"\"\"\n    # Convert number to string to access individual digits\n    str_n = str(abs(n))  # Use absolute value to handle negative numbers\n    \n    # Calculate alternating sum of digits\n    alternating_sum = 0\n    for i, digit in enumerate(str_n):\n        if i % 2 == 0:\n            alternating_sum += int(digit)\n        else:\n            alternating_sum -= int(digit)\n    \n    # A number is divisible by 11 if the alternating sum is divisible by 11\n    return alternating_sum % 11 == 0\n\n\n"], "responses": ["```python\ndef is_Diff(n: int) -> bool:\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n    \"\"\"\n    # Convert number to string to access individual digits\n    str_n = str(abs(n))  # Use absolute value to handle negative numbers\n    \n    # Calculate alternating sum of digits\n    alternating_sum = 0\n    for i, digit in enumerate(str_n):\n        if i % 2 == 0:\n            alternating_sum += int(digit)\n        else:\n            alternating_sum -= int(digit)\n    \n    # A number is divisible by 11 if the alternating sum is divisible by 11\n    return alternating_sum % 11 == 0\n```"], "prompt_tokens": [80], "completion_tokens": [153], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_77_is_Diff"}
{"name": "mbpp_123_amicable_numbers_sum", "language": "Python3", "prompt": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n\tWrite a function to sum all amicable numbers from 1 to a specified number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "amicable_numbers_sum", "test": "def check(candidate):\n    assert candidate(999) == 504\n    assert candidate(9999) == 31626\n    assert candidate(99) == 0\n\ndef test_check():\n    check(amicable_numbers_sum)\n\ntest_check()\n", "sample_io": ["assert amicable_numbers_sum(999) == 504"], "source_codes": ["\ndef amicable_numbers_sum(limit: int) -> int:\n    def sum_of_divisors(n):\n        if n <= 1:\n            return 0\n        divisors_sum = 1  # 1 is always a divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and b <= limit:  # Ensure b is within limit and avoid duplicates\n            if sum_of_divisors(b) == a:\n                amicable_sum += a + b\n    \n    return amicable_sum\n\n\n"], "responses": ["```python\ndef amicable_numbers_sum(limit: int) -> int:\n    def sum_of_divisors(n):\n        if n <= 1:\n            return 0\n        divisors_sum = 1  # 1 is always a divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Avoid counting the square root twice\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and b <= limit:  # Ensure b is within limit and avoid duplicates\n            if sum_of_divisors(b) == a:\n                amicable_sum += a + b\n    \n    return amicable_sum\n```"], "prompt_tokens": [82], "completion_tokens": [197], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_123_amicable_numbers_sum"}
{"name": "mbpp_420_cube_Sum", "language": "Python3", "prompt": "def cube_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the cube sum of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_Sum", "test": "def check(candidate):\n    assert candidate(2) == 72\n    assert candidate(3) == 288\n    assert candidate(4) == 800\n\ndef test_check():\n    check(cube_Sum)\n\ntest_check()\n", "sample_io": ["assert cube_Sum(2) == 72"], "source_codes": ["\ndef cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The first n even natural numbers are: 2, 4, 6, 8, ..., 2n\n    We need to calculate: 2³ + 4³ + 6³ + ... + (2n)³\n    \n    This can be simplified as: 8(1³ + 2³ + 3³ + ... + n³)\n    Using the formula for sum of cubes: 1³ + 2³ + 3³ + ... + n³ = [n(n+1)/2]²\n    \n    Therefore: 8 × [n(n+1)/2]² = 2n²(n+1)²\n    \"\"\"\n    return 2 * n * n * (n + 1) * (n + 1)\n\n\n"], "responses": ["```python\ndef cube_Sum(n: int) -> int:\n    \"\"\"\n    Find the cube sum of first n even natural numbers.\n    \n    The first n even natural numbers are: 2, 4, 6, 8, ..., 2n\n    We need to calculate: 2³ + 4³ + 6³ + ... + (2n)³\n    \n    This can be simplified as: 8(1³ + 2³ + 3³ + ... + n³)\n    Using the formula for sum of cubes: 1³ + 2³ + 3³ + ... + n³ = [n(n+1)/2]²\n    \n    Therefore: 8 × [n(n+1)/2]² = 2n²(n+1)²\n    \"\"\"\n    return 2 * n * n * (n + 1) * (n + 1)\n```"], "prompt_tokens": [80], "completion_tokens": [194], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_420_cube_Sum"}
{"name": "mbpp_585_expensive_items", "language": "Python3", "prompt": "from typing import List, Dict, Union\n\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n\tWrite a function to find the n most expensive items in a given dataset.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "expensive_items", "test": "def check(candidate):\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }], 2) == [{ 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-1', 'price': 101.1 }]\n    assert candidate([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }, { 'name': 'Item-3', 'price': 45.09 }, { 'name': 'Item-4', 'price': 22.75 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]\n\ndef test_check():\n    check(expensive_items)\n\ntest_check()\n", "sample_io": ["assert expensive_items([{ 'name': 'Item-1', 'price': 101.1 }, { 'name': 'Item-2', 'price': 555.22 }], 1) == [{ 'name': 'Item-2', 'price': 555.22 }]"], "source_codes": ["\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \n    Args:\n        items: List of dictionaries containing item information with 'price' key\n        n: Number of most expensive items to return\n        \n    Returns:\n        List of n most expensive items sorted by price in descending order\n    \"\"\"\n    # Sort items by price in descending order and return the first n items\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]\n\n\n"], "responses": ["```python\ndef expensive_items(items: List[Dict[str, Union[str, float]]], n: int) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \n    Args:\n        items: List of dictionaries containing item information with 'price' key\n        n: Number of most expensive items to return\n        \n    Returns:\n        List of n most expensive items sorted by price in descending order\n    \"\"\"\n    # Sort items by price in descending order and return the first n items\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]\n```"], "prompt_tokens": [109], "completion_tokens": [140], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_585_expensive_items"}
{"name": "mbpp_20_is_woodall", "language": "Python3", "prompt": "def is_woodall(x: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given number is woodball or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_woodall", "test": "def check(candidate):\n    assert candidate(383) == True\n    assert candidate(254) == False\n    assert candidate(200) == False\n\ndef test_check():\n    check(is_woodall)\n\ntest_check()\n", "sample_io": ["assert is_woodall(383) == True"], "source_codes": ["\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is woodball or not.\n    A Woodall number is a number of the form n*2^n - 1 where n >= 1.\n    \"\"\"\n    if x < 1:\n        return False\n    \n    # Try different values of n starting from 1\n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n\n\n"], "responses": ["```python\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Write a function to check if the given number is woodball or not.\n    A Woodall number is a number of the form n*2^n - 1 where n >= 1.\n    \"\"\"\n    if x < 1:\n        return False\n    \n    # Try different values of n starting from 1\n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n```"], "prompt_tokens": [80], "completion_tokens": [139], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_20_is_woodall"}
{"name": "mbpp_805_max_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that returns the list in a list of lists whose sum of elements is the highest.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_list", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]\n    assert candidate([[3, 2, 1], [6, 5, 4], [12, 11, 10]]) == [12, 11, 10]\n    assert candidate([[2, 3, 1]]) == [2, 3, 1]\n\ndef test_check():\n    check(max_sum_list)\n\ntest_check()\n", "sample_io": ["assert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"], "source_codes": ["\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n\n\n"], "responses": ["```python\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n```"], "prompt_tokens": [93], "completion_tokens": [102], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_805_max_sum_list"}
{"name": "mbpp_806_max_run_uppercase", "language": "Python3", "prompt": "def max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to find maximum run of uppercase characters in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_run_uppercase", "test": "def check(candidate):\n    assert candidate('GeMKSForGERksISBESt') == 5\n    assert candidate('PrECIOusMOVemENTSYT') == 6\n    assert candidate('GooGLEFluTTER') == 4\n\ndef test_check():\n    check(max_run_uppercase)\n\ntest_check()\n", "sample_io": ["assert max_run_uppercase('GeMKSForGERksISBESt') == 5"], "source_codes": ["\ndef max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n    Find maximum run of uppercase characters in the given string.\n    \"\"\"\n    if not test_str:\n        return 0\n    \n    max_count = 0\n    current_count = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    return max_count\n\n\n"], "responses": ["```python\ndef max_run_uppercase(test_str: str) -> int:\n    \"\"\"\n    Find maximum run of uppercase characters in the given string.\n    \"\"\"\n    if not test_str:\n        return 0\n    \n    max_count = 0\n    current_count = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    return max_count\n```"], "prompt_tokens": [81], "completion_tokens": [105], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_806_max_run_uppercase"}
{"name": "mbpp_455_check_monthnumb_number", "language": "Python3", "prompt": "def check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 31 days or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumb_number", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(2) == False\n    assert candidate(6) == False\n\ndef test_check():\n    check(check_monthnumb_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumb_number(5) == True"], "source_codes": ["\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    return monthnum2 in months_with_31_days\n\n\n"], "responses": ["```python\ndef check_monthnumb_number(monthnum2: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n    \"\"\"\n    # Months with 31 days: January(1), March(3), May(5), July(7), August(8), October(10), December(12)\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    return monthnum2 in months_with_31_days\n```"], "prompt_tokens": [86], "completion_tokens": [126], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_455_check_monthnumb_number"}
{"name": "mbpp_577_last_Digit_Factorial", "language": "Python3", "prompt": "def last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit in factorial of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit_Factorial", "test": "def check(candidate):\n    assert candidate(4) == 4\n    assert candidate(21) == 0\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit_Factorial)\n\ntest_check()\n", "sample_io": ["assert last_Digit_Factorial(4) == 4"], "source_codes": ["\ndef last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n    Find the last digit in factorial of a given number.\n    \"\"\"\n    if n < 0:\n        return None\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # For n >= 5, factorial will have trailing zeros\n    # So we only need to consider up to 4!\n    if n >= 5:\n        return 0\n    \n    # Calculate factorial for n = 2, 3, 4\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    return factorial % 10\n\n\n"], "responses": ["```python\ndef last_Digit_Factorial(n: int) -> int:\n    \"\"\"\n    Find the last digit in factorial of a given number.\n    \"\"\"\n    if n < 0:\n        return None\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # For n >= 5, factorial will have trailing zeros\n    # So we only need to consider up to 4!\n    if n >= 5:\n        return 0\n    \n    # Calculate factorial for n = 2, 3, 4\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    return factorial % 10\n```"], "prompt_tokens": [83], "completion_tokens": [150], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_577_last_Digit_Factorial"}
{"name": "mbpp_555_difference", "language": "Python3", "prompt": "def difference(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "difference", "test": "def check(candidate):\n    assert candidate(3) == 30\n    assert candidate(5) == 210\n    assert candidate(2) == 6\n\ndef test_check():\n    check(difference)\n\ntest_check()\n", "sample_io": ["assert difference(3) == 30"], "source_codes": ["\ndef difference(n: int) -> int:\n    \"\"\"\n    Find the difference between the sum of cubes of the first n natural numbers \n    and the sum of the first n natural numbers.\n    \"\"\"\n    # Sum of first n natural numbers: n(n+1)/2\n    sum_n = n * (n + 1) // 2\n    \n    # Sum of cubes of first n natural numbers: [n(n+1)/2]^2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Return the difference\n    return sum_cubes - sum_n\n\n\n"], "responses": ["```python\ndef difference(n: int) -> int:\n    \"\"\"\n    Find the difference between the sum of cubes of the first n natural numbers \n    and the sum of the first n natural numbers.\n    \"\"\"\n    # Sum of first n natural numbers: n(n+1)/2\n    sum_n = n * (n + 1) // 2\n    \n    # Sum of cubes of first n natural numbers: [n(n+1)/2]^2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Return the difference\n    return sum_cubes - sum_n\n```"], "prompt_tokens": [91], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_555_difference"}
{"name": "mbpp_456_reverse_string_list", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n\tWrite a function to reverse each string in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_string_list", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    assert candidate(['john', 'amal', 'joel', 'george']) == ['nhoj', 'lama', 'leoj', 'egroeg']\n    assert candidate(['jack', 'john', 'mary']) == ['kcaj', 'nhoj', 'yram']\n\ndef test_check():\n    check(reverse_string_list)\n\ntest_check()\n", "sample_io": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"], "source_codes": ["\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n\n\n"], "responses": ["```python\ndef reverse_string_list(stringlist: List[str]) -> List[str]:\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in stringlist]\n```"], "prompt_tokens": [87], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_456_reverse_string_list"}
{"name": "mbpp_587_list_tuple", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n\tWrite a function to convert a list to a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_587_list_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_tuple", "test": "def check(candidate):\n    assert candidate([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)\n    assert candidate([2, 4, 5, 6, 2, 3, 4, 4, 7]) == (2, 4, 5, 6, 2, 3, 4, 4, 7)\n    assert candidate([58, 44, 56]) == (58, 44, 56)\n\ndef test_check():\n    check(list_tuple)\n\ntest_check()\n", "sample_io": ["assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"], "source_codes": ["\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n\n\n"], "responses": ["```python\ndef list_tuple(listx: List[int]) -> Any:\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(listx)\n```"], "prompt_tokens": [83], "completion_tokens": [39], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_587_list_tuple"}
{"name": "mbpp_612_merge", "language": "Python3", "prompt": "from typing import List, Any\n\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    assert candidate([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]\n    assert candidate([['x', 'y', 'z'], ['a', 'b', 'c'], ['m', 'n', 'o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'], ['z', 'c', 'o']]\n\ndef test_check():\n    check(merge)\n\ntest_check()\n", "sample_io": ["assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"], "source_codes": ["\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    first_elements = []\n    second_elements = []\n    \n    for sublist in lst:\n        first_elements.append(sublist[0])\n        second_elements.append(sublist[1])\n    \n    return [first_elements, second_elements]\n\n\n"], "responses": ["```python\ndef merge(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists\n    where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    if not lst:\n        return [[], []]\n    \n    first_elements = []\n    second_elements = []\n    \n    for sublist in lst:\n        first_elements.append(sublist[0])\n        second_elements.append(sublist[1])\n    \n    return [first_elements, second_elements]\n```"], "prompt_tokens": [117], "completion_tokens": [121], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_612_merge"}
{"name": "mbpp_12_sort_matrix", "language": "Python3", "prompt": "from typing import List\n\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_matrix", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    assert candidate([[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n    assert candidate([[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\n\ndef test_check():\n    check(sort_matrix)\n\ntest_check()\n", "sample_io": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"], "source_codes": ["\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(M, key=lambda row: sum(row))\n\n\n"], "responses": ["```python\ndef sort_matrix(M: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(M, key=lambda row: sum(row))\n```"], "prompt_tokens": [91], "completion_tokens": [50], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_12_sort_matrix"}
{"name": "mbpp_584_find_adverbs", "language": "Python3", "prompt": "def find_adverbs(text: str) -> str:\n    \"\"\"\n\tWrite a function to find the first adverb ending with ly and its positions in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverbs", "test": "def check(candidate):\n    assert candidate('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'\n    assert candidate('Please handle the situation carefuly') == '28-36: carefuly'\n    assert candidate('Complete the task quickly') == '18-25: quickly'\n\ndef test_check():\n    check(find_adverbs)\n\ntest_check()\n", "sample_io": ["assert find_adverbs('Clearly, he has no excuse for such behavior.') == '0-7: Clearly'"], "source_codes": ["\nimport re\n\ndef find_adverbs(text: str) -> str:\n    # Find all words ending with 'ly' using regex\n    pattern = r'\\b\\w+ly\\b'\n    matches = re.finditer(pattern, text)\n    \n    # Get the first match\n    for match in matches:\n        word = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{word} at position {start_pos}-{end_pos}\"\n    \n    # If no adverb found\n    return \"No adverb found\"\n\n\n"], "responses": ["```python\nimport re\n\ndef find_adverbs(text: str) -> str:\n    # Find all words ending with 'ly' using regex\n    pattern = r'\\b\\w+ly\\b'\n    matches = re.finditer(pattern, text)\n    \n    # Get the first match\n    for match in matches:\n        word = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        return f\"{word} at position {start_pos}-{end_pos}\"\n    \n    # If no adverb found\n    return \"No adverb found\"\n```"], "prompt_tokens": [84], "completion_tokens": [119], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_584_find_adverbs"}
{"name": "mbpp_86_centered_hexagonal_number", "language": "Python3", "prompt": "def centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth centered hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "centered_hexagonal_number", "test": "def check(candidate):\n    assert candidate(10) == 271\n    assert candidate(2) == 7\n    assert candidate(9) == 217\n\ndef test_check():\n    check(centered_hexagonal_number)\n\ntest_check()\n", "sample_io": ["assert centered_hexagonal_number(10) == 271"], "source_codes": ["\ndef centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n    Find the nth centered hexagonal number.\n    \n    A centered hexagonal number is given by the formula: 3n(n-1) + 1\n    \"\"\"\n    return 3 * n * (n - 1) + 1\n\n\n"], "responses": ["```python\ndef centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n    Find the nth centered hexagonal number.\n    \n    A centered hexagonal number is given by the formula: 3n(n-1) + 1\n    \"\"\"\n    return 3 * n * (n - 1) + 1\n```"], "prompt_tokens": [76], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_86_centered_hexagonal_number"}
{"name": "mbpp_130_max_occurrences", "language": "Python3", "prompt": "from typing import List\n\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the item with maximum frequency in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_occurrences", "test": "def check(candidate):\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2\n    assert candidate([2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]) == 8\n    assert candidate([10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]) == 20\n\ndef test_check():\n    check(max_occurrences)\n\ntest_check()\n", "sample_io": ["assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2"], "source_codes": ["\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Count frequency of each number\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    return max_freq\n\n\n"], "responses": ["```python\ndef max_occurrences(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    # Count frequency of each number\n    freq_count = {}\n    for num in nums:\n        freq_count[num] = freq_count.get(num, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    return max_freq\n```"], "prompt_tokens": [85], "completion_tokens": [105], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_130_max_occurrences"}
{"name": "mbpp_580_extract_even", "language": "Python3", "prompt": "from typing import Tuple, Any\n\ndef extract_even(test_tuple: Tuple[int, int, Tuple[int, int, Tuple[int, int]], int, int]) -> Any:\n    \"\"\"\n\tWrite a function to remove uneven elements in the nested mixed tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_even", "test": "def check(candidate):\n    assert candidate((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n    assert candidate((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))\n    assert candidate((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)\n\ndef test_check():\n    check(extract_even)\n\ntest_check()\n", "sample_io": ["assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"], "source_codes": ["\ndef extract_even(test_tuple):\n    \"\"\"\n    Remove uneven elements from a nested mixed tuple, keeping only even numbers.\n    \n    Args:\n        test_tuple: A nested tuple containing integers\n        \n    Returns:\n        A new tuple with only even numbers, maintaining the nested structure\n    \"\"\"\n    result = []\n    \n    for element in test_tuple:\n        if isinstance(element, tuple):\n            # Recursively process nested tuples\n            nested_result = extract_even(element)\n            # Only add non-empty nested tuples\n            if nested_result:\n                result.append(nested_result)\n        elif isinstance(element, int) and element % 2 == 0:\n            # Keep even integers\n            result.append(element)\n    \n    return tuple(result)\n\n\n"], "responses": ["```python\ndef extract_even(test_tuple):\n    \"\"\"\n    Remove uneven elements from a nested mixed tuple, keeping only even numbers.\n    \n    Args:\n        test_tuple: A nested tuple containing integers\n        \n    Returns:\n        A new tuple with only even numbers, maintaining the nested structure\n    \"\"\"\n    result = []\n    \n    for element in test_tuple:\n        if isinstance(element, tuple):\n            # Recursively process nested tuples\n            nested_result = extract_even(element)\n            # Only add non-empty nested tuples\n            if nested_result:\n                result.append(nested_result)\n        elif isinstance(element, int) and element % 2 == 0:\n            # Keep even integers\n            result.append(element)\n    \n    return tuple(result)\n```"], "prompt_tokens": [101], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_580_extract_even"}
{"name": "mbpp_742_area_tetrahedron", "language": "Python3", "prompt": "def area_tetrahedron(side: int) -> float:\n    \"\"\"\n\tWrite a function to caluclate the area of a tetrahedron.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "area_tetrahedron", "test": "def check(candidate):\n    assert candidate(3) == 15.588457268119894\n    assert candidate(20) == 692.8203230275509\n    assert candidate(10) == 173.20508075688772\n\ndef test_check():\n    check(area_tetrahedron)\n\ntest_check()\n", "sample_io": ["assert area_tetrahedron(3) == 15.588457268119894"], "source_codes": ["\ndef area_tetrahedron(side: int) -> float:\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    The area of one equilateral triangle with side length 's' is (sqrt(3)/4) * s²\n    So the total surface area is 4 * (sqrt(3)/4) * s² = sqrt(3) * s²\n    \n    Args:\n        side: The length of each edge of the tetrahedron\n        \n    Returns:\n        The surface area of the tetrahedron\n    \"\"\"\n    import math\n    return math.sqrt(3) * side * side\n\n\n"], "responses": ["```python\ndef area_tetrahedron(side: int) -> float:\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    The area of one equilateral triangle with side length 's' is (sqrt(3)/4) * s²\n    So the total surface area is 4 * (sqrt(3)/4) * s² = sqrt(3) * s²\n    \n    Args:\n        side: The length of each edge of the tetrahedron\n        \n    Returns:\n        The surface area of the tetrahedron\n    \"\"\"\n    import math\n    return math.sqrt(3) * side * side\n```"], "prompt_tokens": [84], "completion_tokens": [154], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_742_area_tetrahedron"}
{"name": "mbpp_610_remove_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_kth_element", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], 4) == [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], 5) == [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10]\n\ndef test_check():\n    check(remove_kth_element)\n\ntest_check()\n", "sample_io": ["assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"], "source_codes": ["\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    if L < 0 or L >= len(list1):\n        return list1.copy()\n    \n    result = list1.copy()\n    result.pop(L)\n    return result\n\n\n"], "responses": ["```python\ndef remove_kth_element(list1: List[int], L: int) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    \"\"\"\n    if L < 0 or L >= len(list1):\n        return list1.copy()\n    \n    result = list1.copy()\n    result.pop(L)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [89], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_610_remove_kth_element"}
{"name": "mbpp_394_check_distinct", "language": "Python3", "prompt": "from typing import List\n\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if given list contains no duplicates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_distinct", "test": "def check(candidate):\n    assert candidate([1, 4, 5, 6, 1, 4]) == False\n    assert candidate([1, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 6]) == True\n\ndef test_check():\n    check(check_distinct)\n\ntest_check()\n", "sample_io": ["assert check_distinct([1, 4, 5, 6, 1, 4]) == False"], "source_codes": ["\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))\n\n\n"], "responses": ["```python\ndef check_distinct(test_tup: List[int]) -> bool:\n    \"\"\"\n    Write a function to check if given list contains no duplicates.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))\n```"], "prompt_tokens": [84], "completion_tokens": [49], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_394_check_distinct"}
{"name": "mbpp_793_last", "language": "Python3", "prompt": "from typing import List\n\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last position of an element in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 1) == 0\n    assert candidate([1, 1, 1, 2, 3, 4], 1) == 2\n    assert candidate([2, 3, 2, 3, 6, 8, 9], 3) == 3\n\ndef test_check():\n    check(last)\n\ntest_check()\n", "sample_io": ["assert last([1, 2, 3], 1) == 0"], "source_codes": ["\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n    Find the last position of an element in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers\n        x: The element to find\n        \n    Returns:\n        The index of the last occurrence of x, or -1 if not found\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return result\n\n\n"], "responses": ["```python\ndef last(arr: List[int], x: int) -> int:\n    \"\"\"\n    Find the last position of an element in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers\n        x: The element to find\n        \n    Returns:\n        The index of the last occurrence of x, or -1 if not found\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return result\n```"], "prompt_tokens": [89], "completion_tokens": [175], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_793_last"}
{"name": "mbpp_728_sum_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_list", "test": "def check(candidate):\n    assert candidate([10, 20, 30], [15, 25, 35]) == [25, 45, 65]\n    assert candidate([1, 2, 3], [5, 6, 7]) == [6, 8, 10]\n    assert candidate([15, 20, 30], [15, 45, 75]) == [30, 65, 105]\n\ndef test_check():\n    check(sum_list)\n\ntest_check()\n", "sample_io": ["assert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"], "source_codes": ["\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n\n\n"], "responses": ["```python\ndef sum_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(lst1, lst2)]\n```"], "prompt_tokens": [119], "completion_tokens": [85], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_728_sum_list"}
{"name": "mbpp_566_sum_digits", "language": "Python3", "prompt": "def sum_digits(n: int) -> int:\n    \"\"\"\n\tWrite a function to get the sum of the digits of a non-negative integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_digits", "test": "def check(candidate):\n    assert candidate(345) == 12\n    assert candidate(12) == 3\n    assert candidate(97) == 16\n\ndef test_check():\n    check(sum_digits)\n\ntest_check()\n", "sample_io": ["assert sum_digits(345) == 12"], "source_codes": ["\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n\n\n"], "responses": ["```python\ndef sum_digits(n: int) -> int:\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n```"], "prompt_tokens": [79], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_566_sum_digits"}
{"name": "mbpp_290_max_length", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list of maximum length in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1], [5, 7], [10, 12, 14, 15]]) == (4, [10, 12, 14, 15])\n    assert candidate([[5], [15, 20, 25]]) == (3, [15, 20, 25])\n\ndef test_check():\n    check(max_length)\n\ntest_check()\n", "sample_io": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list of maximum length in a list of lists.\n    \n    Args:\n        list1: A list of lists containing integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with maximum length\n    \"\"\"\n    if not list1:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for sublist in list1:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    \n    return (max_len, max_list)\n\n\n"], "responses": ["```python\ndef max_length(list1: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list of maximum length in a list of lists.\n    \n    Args:\n        list1: A list of lists containing integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with maximum length\n    \"\"\"\n    if not list1:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for sublist in list1:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    \n    return (max_len, max_list)\n```"], "prompt_tokens": [93], "completion_tokens": [137], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_290_max_length"}
{"name": "mbpp_413_extract_nth_element", "language": "Python3", "prompt": "from typing import List, Tuple, Any\n\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract the nth element from a given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_nth_element", "test": "def check(candidate):\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2) == [99, 96, 94, 98]\n    assert candidate([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1) == [98, 97, 91, 94]\n\ndef test_check():\n    check(extract_nth_element)\n\ntest_check()\n", "sample_io": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"], "source_codes": ["\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    return [tuple_item[n] for tuple_item in list1]\n\n\n"], "responses": ["```python\ndef extract_nth_element(list1: List[Tuple[str, int, int]], n: int) -> List[Any]:\n    \"\"\"\n    Write a function to extract the nth element from a given list of tuples.\n    \"\"\"\n    return [tuple_item[n] for tuple_item in list1]\n```"], "prompt_tokens": [101], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_413_extract_nth_element"}
{"name": "mbpp_628_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(string: str) -> str:\n    \"\"\"\n\tWrite a function to replace all spaces in the given string with '%20'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('My Name is Dawood') == 'My%20Name%20is%20Dawood'\n    assert candidate('I am a Programmer') == 'I%20am%20a%20Programmer'\n    assert candidate('I love Coding') == 'I%20love%20Coding'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('My Name is Dawood') == 'My%20Name%20is%20Dawood'"], "source_codes": ["\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n\n\n"], "responses": ["```python\ndef replace_spaces(string: str) -> str:\n    \"\"\"\n    Write a function to replace all spaces in the given string with '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n```"], "prompt_tokens": [79], "completion_tokens": [45], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_628_replace_spaces"}
{"name": "mbpp_417_group_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to find common first element in given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "group_tuples", "test": "def check(candidate):\n    assert candidate([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]\n    assert candidate([['a', 'b'], ['a', 'c'], ['d', 'e']]) == [['a', 'b', 'c'], ['d', 'e']]\n    assert candidate([['f', 'g'], ['f', 'g'], ['h', 'i']]) == [['f', 'g', 'g'], ['h', 'i']]\n\ndef test_check():\n    check(group_tuples)\n\ntest_check()\n", "sample_io": ["assert group_tuples([['x', 'y'], ['x', 'z'], ['w', 't']]) == [['x', 'y', 'z'], ['w', 't']]"], "source_codes": ["\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find common first element in given list of lists.\n    \"\"\"\n    if not Input:\n        return []\n    \n    # Dictionary to store groups with same first element\n    groups = {}\n    \n    # Group lists by their first element\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].extend(lst)\n    \n    # Convert dictionary to list of lists\n    result = []\n    for key in groups:\n        result.append(groups[key])\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find lists that have the same first element and group them together.\n\nLet me think through the approach:\n1. Group lists by their first element\n2. Return the grouped lists\n\n```python\ndef group_tuples(Input: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to find common first element in given list of lists.\n    \"\"\"\n    if not Input:\n        return []\n    \n    # Dictionary to store groups with same first element\n    groups = {}\n    \n    # Group lists by their first element\n    for lst in Input:\n        if lst:  # Check if list is not empty\n            first_element = lst[0]\n            if first_element not in groups:\n                groups[first_element] = []\n            groups[first_element].extend(lst)\n    \n    # Convert dictionary to list of lists\n    result = []\n    for key in groups:\n        result.append(groups[key])\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [196], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_417_group_tuples"}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum_repeated", "test": "def check(candidate):\n    assert candidate([10, 20, -30, -1], 4, 3) == 30\n    assert candidate([-1, 10, 20], 3, 2) == 59\n    assert candidate([-1, -2, -3], 3, 3) == -1\n\ndef test_check():\n    check(max_sub_array_sum_repeated)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"], "source_codes": ["\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, simply apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate total sum of array\n    total_sum = sum(a)\n    \n    # Create array of size 2*n by concatenating a with itself\n    extended_array = a + a\n    \n    # Find maximum subarray sum in extended array\n    max_kadane_extended = kadane(extended_array)\n    \n    # If total sum is negative, the best subarray won't span multiple copies\n    if total_sum < 0:\n        return max_kadane_extended\n    \n    # If total sum is positive, we can include (k-2) full arrays in between\n    # The result is max of: \n    # 1. Maximum subarray in extended array (at most 2 copies)\n    # 2. Maximum prefix + (k-2) * total_sum + Maximum suffix\n    max_prefix = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix = max(max_prefix, current_sum)\n    \n    max_suffix = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix = max(max_suffix, current_sum)\n    \n    # Return maximum of the two cases\n    return max(max_kadane_extended, max_prefix + max_suffix + (k - 2) * total_sum)\n\n\n"], "responses": ["```python\ndef max_sub_array_sum_repeated(a: List[int], n: int, k: int) -> int:\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # If k is 1, simply apply Kadane's algorithm\n    if k == 1:\n        return kadane(a)\n    \n    # Calculate total sum of array\n    total_sum = sum(a)\n    \n    # Create array of size 2*n by concatenating a with itself\n    extended_array = a + a\n    \n    # Find maximum subarray sum in extended array\n    max_kadane_extended = kadane(extended_array)\n    \n    # If total sum is negative, the best subarray won't span multiple copies\n    if total_sum < 0:\n        return max_kadane_extended\n    \n    # If total sum is positive, we can include (k-2) full arrays in between\n    # The result is max of: \n    # 1. Maximum subarray in extended array (at most 2 copies)\n    # 2. Maximum prefix + (k-2) * total_sum + Maximum suffix\n    max_prefix = float('-inf')\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_prefix = max(max_prefix, current_sum)\n    \n    max_suffix = float('-inf')\n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        max_suffix = max(max_suffix, current_sum)\n    \n    # Return maximum of the two cases\n    return max(max_kadane_extended, max_prefix + max_suffix + (k - 2) * total_sum)\n```"], "prompt_tokens": [108], "completion_tokens": [418], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_286_max_sub_array_sum_repeated"}
{"name": "mbpp_66_pos_count", "language": "Python3", "prompt": "from typing import List\n\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of positive numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pos_count", "test": "def check(candidate):\n    assert candidate([1, -2, 3, -4]) == 2\n    assert candidate([3, 4, 5, -1]) == 3\n    assert candidate([1, 2, 3, 4]) == 4\n\ndef test_check():\n    check(pos_count)\n\ntest_check()\n", "sample_io": ["assert pos_count([1, -2, 3, -4]) == 2"], "source_codes": ["\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef pos_count(list: List[int]) -> int:\n    \"\"\"\n    Write a python function to count the number of positive numbers in a list.\n    \"\"\"\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n```"], "prompt_tokens": [84], "completion_tokens": [65], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_66_pos_count"}
{"name": "mbpp_450_extract_string", "language": "Python3", "prompt": "from typing import List\n\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n\tWrite a function to extract specified size of strings from a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_string", "test": "def check(candidate):\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 6) == ['Python']\n    assert candidate(['Python', 'list', 'exercises', 'practice', 'solution'], 9) == ['exercises']\n\ndef test_check():\n    check(extract_string)\n\ntest_check()\n", "sample_io": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"], "source_codes": ["\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]\n\n\n"], "responses": ["```python\ndef extract_string(str: List[str], l: int) -> List[str]:\n    \"\"\"\n    Write a function to extract specified size of strings from a given list of string values.\n    \"\"\"\n    return [s for s in str if len(s) == l]\n```"], "prompt_tokens": [91], "completion_tokens": [58], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_450_extract_string"}
{"name": "mbpp_444_trim_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to trim each list by k in the given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "trim_tuple", "test": "def check(candidate):\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]\n    assert candidate([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 1) == [[3, 2, 1], [4, 9, 2], [1, 2, 3], [8, 2, 1]]\n    assert candidate([[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]], 1) == [[8, 4], [8, 12], [1, 7], [6, 9]]\n\ndef test_check():\n    check(trim_tuple)\n\ntest_check()\n", "sample_io": ["assert trim_tuple([[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], 2) == [[2], [9], [2], [2]]"], "source_codes": ["\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    result = []\n    for sublist in test_list:\n        if len(sublist) >= 2 * K:\n            trimmed = sublist[K:-K]\n            result.append(trimmed)\n        else:\n            result.append([])\n    return result\n\n\n"], "responses": ["```python\ndef trim_tuple(test_list: List[List[int]], K: int) -> List[List[int]]:\n    \"\"\"\n    Write a function to trim each list by k in the given lists.\n    \"\"\"\n    result = []\n    for sublist in test_list:\n        if len(sublist) >= 2 * K:\n            trimmed = sublist[K:-K]\n            result.append(trimmed)\n        else:\n            result.append([])\n    return result\n```"], "prompt_tokens": [91], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_444_trim_tuple"}
{"name": "mbpp_439_multiple_to_single", "language": "Python3", "prompt": "from typing import List\n\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n\tWrite a function to join a list of multiple integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiple_to_single", "test": "def check(candidate):\n    assert candidate([11, 33, 50]) == 113350\n    assert candidate([-1, 2, 3, 4, 5, 6]) == -123456\n    assert candidate([10, 15, 20, 25]) == 10152025\n\ndef test_check():\n    check(multiple_to_single)\n\ntest_check()\n", "sample_io": ["assert multiple_to_single([11, 33, 50]) == 113350"], "source_codes": ["\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n    \n    Args:\n        L: List of integers\n        \n    Returns:\n        Single integer formed by concatenating all integers in the list\n        \n    Examples:\n        >>> multiple_to_single([1, 2, 3])\n        123\n        >>> multiple_to_single([4, 5, 6, 7])\n        4567\n        >>> multiple_to_single([0, 1, 2])\n        12\n    \"\"\"\n    # Convert each integer to string, join them, then convert back to integer\n    return int(''.join(map(str, L)))\n\n\n"], "responses": ["```python\ndef multiple_to_single(L: List[int]) -> int:\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n    \n    Args:\n        L: List of integers\n        \n    Returns:\n        Single integer formed by concatenating all integers in the list\n        \n    Examples:\n        >>> multiple_to_single([1, 2, 3])\n        123\n        >>> multiple_to_single([4, 5, 6, 7])\n        4567\n        >>> multiple_to_single([0, 1, 2])\n        12\n    \"\"\"\n    # Convert each integer to string, join them, then convert back to integer\n    return int(''.join(map(str, L)))\n```"], "prompt_tokens": [85], "completion_tokens": [154], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_439_multiple_to_single"}
{"name": "mbpp_162_sum_series", "language": "Python3", "prompt": "def sum_series(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_series", "test": "def check(candidate):\n    assert candidate(6) == 12\n    assert candidate(10) == 30\n    assert candidate(9) == 25\n\ndef test_check():\n    check(sum_series)\n\ntest_check()\n", "sample_io": ["assert sum_series(6) == 12"], "source_codes": ["\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4) + ... (until n-x <= 0).\n    \"\"\"\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n\n\n"], "responses": ["```python\ndef sum_series(n: int) -> int:\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n    For instance: n + (n-2) + (n-4) + ... (until n-x <= 0).\n    \"\"\"\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n```"], "prompt_tokens": [111], "completion_tokens": [100], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_162_sum_series"}
{"name": "mbpp_224_count_Set_Bits", "language": "Python3", "prompt": "def count_Set_Bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of set bits (binary digits with value 1) in a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Set_Bits", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(4) == 1\n    assert candidate(6) == 2\n\ndef test_check():\n    check(count_Set_Bits)\n\ntest_check()\n", "sample_io": ["assert count_Set_Bits(2) == 1"], "source_codes": ["\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n\n"], "responses": ["```python\ndef count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n```"], "prompt_tokens": [89], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_224_count_Set_Bits"}
{"name": "mbpp_309_maximum", "language": "Python3", "prompt": "def maximum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximum", "test": "def check(candidate):\n    assert candidate(5, 10) == 10\n    assert candidate(-1, -2) == -1\n    assert candidate(9, 7) == 9\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n", "sample_io": ["assert maximum(5, 10) == 10"], "source_codes": ["\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n\n\n"], "responses": ["```python\ndef maximum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n```"], "prompt_tokens": [78], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_309_maximum"}
{"name": "mbpp_632_move_zero", "language": "Python3", "prompt": "from typing import List\n\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to move all zeroes to the end of the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_zero", "test": "def check(candidate):\n    assert candidate([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]\n    assert candidate([2, 3, 2, 0, 0, 4, 0, 5, 0]) == [2, 3, 2, 4, 5, 0, 0, 0, 0]\n    assert candidate([0, 1, 0, 1, 1]) == [1, 1, 1, 0, 0]\n\ndef test_check():\n    check(move_zero)\n\ntest_check()\n", "sample_io": ["assert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"], "source_codes": ["\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \"\"\"\n    # Count the number of zeros\n    zero_count = num_list.count(0)\n    \n    # Create a new list without zeros\n    result = [num for num in num_list if num != 0]\n    \n    # Append zeros at the end\n    result.extend([0] * zero_count)\n    \n    return result\n\n\n"], "responses": ["```python\ndef move_zero(num_list: List[int]) -> List[int]:\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \"\"\"\n    # Count the number of zeros\n    zero_count = num_list.count(0)\n    \n    # Create a new list without zeros\n    result = [num for num in num_list if num != 0]\n    \n    # Append zeros at the end\n    result.extend([0] * zero_count)\n    \n    return result\n```"], "prompt_tokens": [87], "completion_tokens": [101], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_632_move_zero"}
{"name": "mbpp_168_frequency", "language": "Python3", "prompt": "from typing import List\n\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurrences of a number in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency", "test": "def check(candidate):\n    assert candidate([1, 2, 3], 4) == 0\n    assert candidate([1, 2, 2, 3, 3, 3, 4], 3) == 3\n    assert candidate([0, 1, 2, 3, 1, 2], 1) == 2\n\ndef test_check():\n    check(frequency)\n\ntest_check()\n", "sample_io": ["assert frequency([1, 2, 3], 4) == 0"], "source_codes": ["\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers\n        x: Integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    return a.count(x)\n\n\n"], "responses": ["```python\ndef frequency(a: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n    \n    Args:\n        a: List of integers\n        x: Integer to count occurrences of\n        \n    Returns:\n        Number of times x appears in list a\n    \"\"\"\n    return a.count(x)\n```"], "prompt_tokens": [89], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_168_frequency"}
{"name": "mbpp_749_sort_numeric_strings", "language": "Python3", "prompt": "from typing import List\n\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_numeric_strings", "test": "def check(candidate):\n    assert candidate(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    assert candidate(['2', '3', '8', '4', '7', '9', '8', '2', '6', '5', '1', '6', '1', '2', '3', '4', '6', '9', '1', '2']) == [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]\n    assert candidate(['1', '3', '5', '7', '1', '3', '13', '15', '17', '5', '7 ', '9', '1', '11']) == [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]\n\ndef test_check():\n    check(sort_numeric_strings)\n\ntest_check()\n", "sample_io": ["assert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"], "source_codes": ["\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: List of strings representing numbers\n        \n    Returns:\n        List of integers sorted numerically\n    \"\"\"\n    # Convert strings to integers and sort numerically\n    return sorted([int(num) for num in nums_str])\n\n\n"], "responses": ["```python\ndef sort_numeric_strings(nums_str: List[str]) -> List[int]:\n    \"\"\"\n    Sort a given list of strings of numbers numerically.\n    \n    Args:\n        nums_str: List of strings representing numbers\n        \n    Returns:\n        List of integers sorted numerically\n    \"\"\"\n    # Convert strings to integers and sort numerically\n    return sorted([int(num) for num in nums_str])\n```"], "prompt_tokens": [105], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_749_sort_numeric_strings"}
{"name": "mbpp_97_frequency_lists", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_97_frequency_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "frequency_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1 }\n    assert candidate([[20, 30, 40, 17], [18, 16, 14, 13], [10, 20, 30, 40]]) == { 20: 2, 30: 2, 40: 2, 17: 1, 18: 1, 16: 1, 14: 1, 13: 1, 10: 1 }\n\ndef test_check():\n    check(frequency_lists)\n\ntest_check()\n", "sample_io": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == { 1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1 }"], "source_codes": ["\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = []\n    for sublist in list1:\n        for element in sublist:\n            flattened.append(element)\n    \n    # Count frequency of each element\n    frequency_dict = {}\n    for element in flattened:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict\n\n\n"], "responses": ["```python\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = []\n    for sublist in list1:\n        for element in sublist:\n            flattened.append(element)\n    \n    # Count frequency of each element\n    frequency_dict = {}\n    for element in flattened:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict\n```"], "prompt_tokens": [97], "completion_tokens": [125], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_97_frequency_lists"}
{"name": "mbpp_429_and_tuples", "language": "Python3", "prompt": "from typing import Tuple\n\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to extract the elementwise and tuples from the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_429_and_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "and_tuples", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)\n    assert candidate((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)\n    assert candidate((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)\n\ndef test_check():\n    check(and_tuples)\n\ntest_check()\n", "sample_io": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"], "source_codes": ["\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef and_tuples(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to extract the elementwise and tuples from the given two tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [115], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_429_and_tuples"}
{"name": "mbpp_759_is_decimal", "language": "Python3", "prompt": "def is_decimal(num: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether a given string is a decimal number with a precision of 2.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_decimal", "test": "def check(candidate):\n    assert candidate('123.11') == True\n    assert candidate('e666.86') == False\n    assert candidate('3.124587') == False\n    assert candidate('1.11') == True\n    assert candidate('1.1.11') == False\n\ndef test_check():\n    check(is_decimal)\n\ntest_check()\n", "sample_io": ["assert is_decimal('123.11') == True"], "source_codes": ["\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    num = num.strip()\n    \n    # Check if empty string\n    if not num:\n        return False\n    \n    # Check for valid decimal format with exactly 2 decimal places\n    parts = num.split('.')\n    \n    # Must have exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    # Check if decimal part has exactly 2 digits\n    if len(decimal_part) != 2:\n        return False\n    \n    # Check if both parts contain only digits (integer part can be empty or have digits)\n    if integer_part and not integer_part.isdigit():\n        return False\n    \n    if not decimal_part.isdigit():\n        return False\n    \n    # Handle case where integer part is empty (like \".12\")\n    if not integer_part and num.startswith('.'):\n        return False\n    \n    # Handle negative numbers\n    if integer_part.startswith('-'):\n        # Remove the negative sign for digit check\n        if len(integer_part) > 1 and integer_part[1:].isdigit():\n            return True\n        elif len(integer_part) == 1:  # Just \"-\"\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef is_decimal(num: str) -> bool:\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    num = num.strip()\n    \n    # Check if empty string\n    if not num:\n        return False\n    \n    # Check for valid decimal format with exactly 2 decimal places\n    parts = num.split('.')\n    \n    # Must have exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    # Check if decimal part has exactly 2 digits\n    if len(decimal_part) != 2:\n        return False\n    \n    # Check if both parts contain only digits (integer part can be empty or have digits)\n    if integer_part and not integer_part.isdigit():\n        return False\n    \n    if not decimal_part.isdigit():\n        return False\n    \n    # Handle case where integer part is empty (like \".12\")\n    if not integer_part and num.startswith('.'):\n        return False\n    \n    # Handle negative numbers\n    if integer_part.startswith('-'):\n        # Remove the negative sign for digit check\n        if len(integer_part) > 1 and integer_part[1:].isdigit():\n            return True\n        elif len(integer_part) == 1:  # Just \"-\"\n            return False\n    \n    return True\n```"], "prompt_tokens": [83], "completion_tokens": [283], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_759_is_decimal"}
{"name": "mbpp_599_sum_average", "language": "Python3", "prompt": "from typing import Tuple\n\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n\tWrite a function to find sum and average of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_599_sum_average.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_average", "test": "def check(candidate):\n    assert candidate(10) == (55, 5.5)\n    assert candidate(15) == (120, 8.0)\n    assert candidate(20) == (210, 10.5)\n\ndef test_check():\n    check(sum_average)\n\ntest_check()\n", "sample_io": ["assert sum_average(10) == (55, 5.5)"], "source_codes": ["\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Find sum and average of first n natural numbers.\n    \n    Args:\n        number (int): The count of first natural numbers\n        \n    Returns:\n        Tuple[int, float]: A tuple containing (sum, average)\n    \"\"\"\n    if number <= 0:\n        return (0, 0.0)\n    \n    # Sum of first n natural numbers = n * (n + 1) / 2\n    total_sum = number * (number + 1) // 2\n    \n    # Average = sum / count\n    average = total_sum / number\n    \n    return (total_sum, average)\n\n\n"], "responses": ["```python\ndef sum_average(number: int) -> Tuple[int, float]:\n    \"\"\"\n    Find sum and average of first n natural numbers.\n    \n    Args:\n        number (int): The count of first natural numbers\n        \n    Returns:\n        Tuple[int, float]: A tuple containing (sum, average)\n    \"\"\"\n    if number <= 0:\n        return (0, 0.0)\n    \n    # Sum of first n natural numbers = n * (n + 1) / 2\n    total_sum = number * (number + 1) // 2\n    \n    # Average = sum / count\n    average = total_sum / number\n    \n    return (total_sum, average)\n```"], "prompt_tokens": [85], "completion_tokens": [144], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_599_sum_average"}
{"name": "mbpp_804_is_product_even", "language": "Python3", "prompt": "from typing import List\n\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether the product of numbers in a list is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_804_is_product_even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_product_even", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 4]) == True\n    assert candidate([1, 1]) == False\n\ndef test_check():\n    check(is_product_even)\n\ntest_check()\n", "sample_io": ["assert is_product_even([1, 2, 3]) == True"], "source_codes": ["\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if product is even, False if product is odd\n    \"\"\"\n    # If any number in the list is even, the product will be even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If all numbers are odd, the product will be odd\n    return False\n\n\n"], "responses": ["```python\ndef is_product_even(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if product is even, False if product is odd\n    \"\"\"\n    # If any number in the list is even, the product will be even\n    for num in arr:\n        if num % 2 == 0:\n            return True\n    \n    # If all numbers are odd, the product will be odd\n    return False\n```"], "prompt_tokens": [88], "completion_tokens": [119], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_804_is_product_even"}
{"name": "mbpp_103_eulerian_num", "language": "Python3", "prompt": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a function to find the Eulerian number a(n, m).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "eulerian_num", "test": "def check(candidate):\n    assert candidate(3, 1) == 4\n    assert candidate(4, 1) == 11\n    assert candidate(5, 3) == 26\n\ndef test_check():\n    check(eulerian_num)\n\ntest_check()\n", "sample_io": ["assert eulerian_num(3, 1) == 4"], "source_codes": ["\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Write a function to find the Eulerian number a(n, m).\n    \"\"\"\n    # Handle base cases\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    \n    # Use dynamic programming to build up the solution\n    # Create a table to store Eulerian numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Initialize base cases\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(1, min(i, m + 1)):\n            dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]\n\n\n"], "responses": ["Looking at this problem, I need to implement a function to calculate Eulerian numbers A(n,m), which count the number of permutations of n elements with exactly m ascents.\n\nThe Eulerian numbers follow this recurrence relation:\n- A(n,m) = (n-m) × A(n-1,m-1) + (m+1) × A(n-1,m)\n- Base cases: A(0,0) = 1, A(n,0) = 1 for n ≥ 1, A(n,m) = 0 if m < 0 or m ≥ n\n\n```python\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Write a function to find the Eulerian number a(n, m).\n    \"\"\"\n    # Handle base cases\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    if m == 0:\n        return 1\n    \n    # Use dynamic programming to build up the solution\n    # Create a table to store Eulerian numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Initialize base cases\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(1, min(i, m + 1)):\n            dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]\n```"], "prompt_tokens": [82], "completion_tokens": [382], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_103_eulerian_num"}
{"name": "mbpp_391_convert_list_dictionary", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    \"\"\"\n\tWrite a function to convert more than one list to nested dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_391_convert_list_dictionary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert_list_dictionary", "test": "def check(candidate):\n    assert candidate(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }, { 'S002': { 'Leyton Marsh': 98 } }, { 'S003': { 'Duncan Boyle': 89 } }, { 'S004': { 'Saim Richards': 92 } }]\n    assert candidate(['abc', 'def', 'ghi', 'jkl'], ['python', 'program', 'language', 'programs'], [100, 200, 300, 400]) == [{ 'abc': { 'python': 100 } }, { 'def': { 'program': 200 } }, { 'ghi': { 'language': 300 } }, { 'jkl': { 'programs': 400 } }]\n    assert candidate(['A1', 'A2', 'A3', 'A4'], ['java', 'C', 'C++', 'DBMS'], [10, 20, 30, 40]) == [{ 'A1': { 'java': 10 } }, { 'A2': { 'C': 20 } }, { 'A3': { 'C++': 30 } }, { 'A4': { 'DBMS': 40 } }]\n\ndef test_check():\n    check(convert_list_dictionary)\n\ntest_check()\n", "sample_io": ["assert convert_list_dictionary(['S001', 'S002', 'S003', 'S004'], ['Adina Park', 'Leyton Marsh', 'Duncan Boyle', 'Saim Richards'], [85, 98, 89, 92]) == [{ 'S001': { 'Adina Park': 85 } }]"], "source_codes": ["\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    result = []\n    for i in range(len(l1)):\n        inner_dict = {l2[i]: l3[i]}\n        outer_dict = {l1[i]: inner_dict}\n        result.append(outer_dict)\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to convert three lists into a nested dictionary structure where:\n- The first list (l1) contains keys for the outer dictionary\n- The second list (l2) contains keys for the inner dictionary  \n- The third list (l3) contains values for the inner dictionary\n\nThe return type suggests a list of dictionaries, each with structure: `{l1_item: {l2_item: l3_item}}`\n\nLet me trace through what this should look like:\n- If we have l1=['a','b'], l2=['x','y'], l3=[1,2]\n- Result should be [{'a': {'x': 1}}, {'b': {'y': 2}}]\n\n```python\ndef convert_list_dictionary(l1: List[str], l2: List[str], l3: List[int]) -> List[Dict[str, Dict[str, int]]]:\n    result = []\n    for i in range(len(l1)):\n        inner_dict = {l2[i]: l3[i]}\n        outer_dict = {l1[i]: inner_dict}\n        result.append(outer_dict)\n    return result\n```"], "prompt_tokens": [107], "completion_tokens": [237], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_391_convert_list_dictionary"}
{"name": "mbpp_635_heap_sort", "language": "Python3", "prompt": "from typing import List\n\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_sort", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    assert candidate([7, 1, 9, 5]) == [1, 5, 7, 9]\n\ndef test_check():\n    check(heap_sort)\n\ntest_check()\n", "sample_io": ["assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "source_codes": ["\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list using heap sort algorithm.\n    \"\"\"\n    # Convert to list if needed and make a copy to avoid modifying original\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Heapify subtree rooted at index i.\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\n\n"], "responses": ["```python\ndef heap_sort(iterable: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list using heap sort algorithm.\n    \"\"\"\n    # Convert to list if needed and make a copy to avoid modifying original\n    arr = list(iterable)\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call heapify on the reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int) -> None:\n    \"\"\"\n    Heapify subtree rooted at index i.\n    \"\"\"\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # If left child exists and is greater than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child exists and is greater than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n```"], "prompt_tokens": [80], "completion_tokens": [350], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_635_heap_sort"}
{"name": "mbpp_270_sum_even_and_even_index", "language": "Python3", "prompt": "from typing import List\n\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even numbers at even positions of a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_even_and_even_index", "test": "def check(candidate):\n    assert candidate([5, 6, 12, 1, 18, 8]) == 30\n    assert candidate([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26\n    assert candidate([5, 6, 12, 1]) == 12\n\ndef test_check():\n    check(sum_even_and_even_index)\n\ntest_check()\n", "sample_io": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"], "source_codes": ["\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of even numbers at even indices\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # Iterate through even indices only\n        if arr[i] % 2 == 0:  # Check if the number at even index is even\n            total += arr[i]\n    return total\n\n\n"], "responses": ["```python\ndef sum_even_and_even_index(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of even numbers at even positions of a list.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of even numbers at even indices\n    \"\"\"\n    total = 0\n    for i in range(0, len(arr), 2):  # Iterate through even indices only\n        if arr[i] % 2 == 0:  # Check if the number at even index is even\n            total += arr[i]\n    return total\n```"], "prompt_tokens": [90], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_270_sum_even_and_even_index"}
{"name": "mbpp_787_text_match_three", "language": "Python3", "prompt": "def text_match_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by three 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('caacabbbba') == True\n\ndef test_check():\n    check(text_match_three)\n\ntest_check()\n", "sample_io": ["assert text_match_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r'ab{3}'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_three(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by three 'b'.\n    \"\"\"\n    pattern = r'ab{3}'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [81], "completion_tokens": [58], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_787_text_match_three"}
{"name": "mbpp_765_is_polite", "language": "Python3", "prompt": "def is_polite(n: int) -> int:\n    \"\"\"\n\tWrite a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_polite", "test": "def check(candidate):\n    assert candidate(7) == 11\n    assert candidate(4) == 7\n    assert candidate(9) == 13\n\ndef test_check():\n    check(is_polite)\n\ntest_check()\n", "sample_io": ["assert is_polite(7) == 11"], "source_codes": ["\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as the sum of \n    two or more consecutive positive integers.\n    \"\"\"\n    count = 0\n    num = 1\n    \n    while count < n:\n        # Check if num is a power of 2\n        # A number is a power of 2 if (num & (num - 1)) == 0\n        if (num & (num - 1)) != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num\n\n\n"], "responses": ["Looking at this problem, I need to find the nth polite number. A polite number is a positive integer that can be expressed as the sum of two or more consecutive positive integers.\n\nFrom mathematical analysis, polite numbers are all positive integers except powers of 2. This is because powers of 2 cannot be expressed as sums of consecutive positive integers.\n\nSo the approach is to count up from 1, skipping powers of 2, until I've found the nth polite number.\n\n```python\ndef is_polite(n: int) -> int:\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be expressed as the sum of \n    two or more consecutive positive integers.\n    \"\"\"\n    count = 0\n    num = 1\n    \n    while count < n:\n        # Check if num is a power of 2\n        # A number is a power of 2 if (num & (num - 1)) == 0\n        if (num & (num - 1)) != 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num\n```"], "prompt_tokens": [84], "completion_tokens": [242], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_765_is_polite"}
{"name": "mbpp_459_remove_uppercase", "language": "Python3", "prompt": "def remove_uppercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove uppercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_uppercase", "test": "def check(candidate):\n    assert candidate('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\n    assert candidate('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'\n    assert candidate('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'\n\ndef test_check():\n    check(remove_uppercase)\n\ntest_check()\n", "sample_io": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"], "source_codes": ["\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.isupper():\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef remove_uppercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove uppercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.isupper():\n            result += char\n    return result\n```"], "prompt_tokens": [78], "completion_tokens": [61], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_459_remove_uppercase"}
{"name": "mbpp_16_text_lowercase_underscore", "language": "Python3", "prompt": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n\tWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_lowercase_underscore", "test": "def check(candidate):\n    assert candidate('aab_cbbbc') == True\n    assert candidate('aab_Abbbc') == False\n    assert candidate('Aaab_abbbc') == False\n\ndef test_check():\n    check(text_lowercase_underscore)\n\ntest_check()\n", "sample_io": ["assert text_lowercase_underscore('aab_cbbbc') == True"], "source_codes": ["\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    # Pattern explanation:\n    # [a-z]+ - one or more lowercase letters\n    # _ - exactly one underscore\n    # [a-z]+ - one or more lowercase letters\n    pattern = r'[a-z]+_[a-z]+'\n    \n    # Search for the pattern in the text\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    # Pattern explanation:\n    # [a-z]+ - one or more lowercase letters\n    # _ - exactly one underscore\n    # [a-z]+ - one or more lowercase letters\n    pattern = r'[a-z]+_[a-z]+'\n    \n    # Search for the pattern in the text\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [89], "completion_tokens": [116], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_16_text_lowercase_underscore"}
{"name": "mbpp_731_lateralsurface_cone", "language": "Python3", "prompt": "def lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cone given radius r and the height h.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cone", "test": "def check(candidate):\n    assert candidate(5, 12) == 204.20352248333654\n    assert candidate(10, 15) == 566.3586699569488\n    assert candidate(19, 17) == 1521.8090132193388\n\ndef test_check():\n    check(lateralsurface_cone)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cone(5, 12) == 204.20352248333654"], "source_codes": ["\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \n    The lateral surface area of a cone is π * r * l, where l is the slant height.\n    The slant height l = √(r² + h²)\n    \"\"\"\n    # Calculate the slant height\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * l\n    \n    return lateral_surface_area\n\n\n"], "responses": ["```python\nimport math\n\ndef lateralsurface_cone(r: int, h: int) -> float:\n    \"\"\"\n    Find the lateral surface area of a cone given radius r and the height h.\n    \n    The lateral surface area of a cone is π * r * l, where l is the slant height.\n    The slant height l = √(r² + h²)\n    \"\"\"\n    # Calculate the slant height\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * l\n    \n    return lateral_surface_area\n```"], "prompt_tokens": [90], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_731_lateralsurface_cone"}
{"name": "mbpp_802_count_rotation", "language": "Python3", "prompt": "from typing import List\n\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_rotation", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == 1\n    assert candidate([4, 5, 1, 2, 3]) == 2\n    assert candidate([7, 8, 9, 1, 2, 3]) == 3\n    assert candidate([1, 2, 3]) == 0\n    assert candidate([1, 3, 2]) == 2\n\ndef test_check():\n    check(count_rotation)\n\ntest_check()\n", "sample_io": ["assert count_rotation([3, 2, 1]) == 1"], "source_codes": ["\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n    Count the number of rotations required to generate a sorted array.\n    \n    Args:\n        arr: A rotated sorted array\n        \n    Returns:\n        Number of rotations (index of minimum element)\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    low, high = 0, n - 1\n    \n    # If array is not rotated\n    if arr[low] <= arr[high]:\n        return 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        prev = (mid - 1 + n) % n\n        next_idx = (mid + 1) % n\n        \n        # Check if mid is the minimum element\n        if arr[mid] <= arr[prev] and arr[mid] <= arr[next_idx]:\n            return mid\n        elif arr[mid] <= arr[high]:\n            # Minimum element is in left half\n            high = mid - 1\n        else:\n            # Minimum element is in right half\n            low = mid + 1\n    \n    return 0\n\n\n"], "responses": ["Looking at this problem, I need to count how many rotations are required to generate a sorted array from a given rotated sorted array.\n\nThe key insight is that in a rotated sorted array, the number of rotations equals the index of the minimum element. This is because the minimum element was originally at index 0, and after k rotations, it moves to index k.\n\nTo find the minimum element efficiently, I can use binary search since the array was originally sorted.\n\n```python\ndef count_rotation(arr: List[int]) -> int:\n    \"\"\"\n    Count the number of rotations required to generate a sorted array.\n    \n    Args:\n        arr: A rotated sorted array\n        \n    Returns:\n        Number of rotations (index of minimum element)\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    low, high = 0, n - 1\n    \n    # If array is not rotated\n    if arr[low] <= arr[high]:\n        return 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        prev = (mid - 1 + n) % n\n        next_idx = (mid + 1) % n\n        \n        # Check if mid is the minimum element\n        if arr[mid] <= arr[prev] and arr[mid] <= arr[next_idx]:\n            return mid\n        elif arr[mid] <= arr[high]:\n            # Minimum element is in left half\n            high = mid - 1\n        else:\n            # Minimum element is in right half\n            low = mid + 1\n    \n    return 0\n```"], "prompt_tokens": [108], "completion_tokens": [333], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_802_count_rotation"}
{"name": "mbpp_782_odd_length_sum", "language": "Python3", "prompt": "from typing import List\n\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_length_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 4]) == 14\n    assert candidate([1, 2, 1, 2]) == 15\n    assert candidate([1, 7]) == 8\n\ndef test_check():\n    check(odd_length_sum)\n\ntest_check()\n", "sample_io": ["assert odd_length_sum([1, 2, 4]) == 14"], "source_codes": ["\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of all odd length subarrays\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    # For each element, calculate how many odd length subarrays include it\n    for i in range(n):\n        # Count of subarrays that include arr[i]\n        # Left choices: we can start from index 0 to i (i+1 choices)\n        # Right choices: we can end from index i to n-1 (n-i choices)\n        # Total subarrays including arr[i]: (i+1) * (n-i)\n        \n        # Count of odd length subarrays including arr[i]\n        # For odd length subarrays, we need to count how many start and end positions\n        # create subarrays of odd length that include arr[i]\n        \n        # Method 2: Direct calculation\n        # Number of ways to choose left boundary: (i+1)\n        # Number of ways to choose right boundary: (n-i)\n        # Total subarrays including element at index i: (i+1) * (n-i)\n        \n        # Of these, half will be odd length (approximately)\n        # More precisely: if total is even, exactly half are odd\n        # If total is odd, (total+1)/2 are odd\n        \n        total_subarrays = (i + 1) * (n - i)\n        odd_count = (total_subarrays + 1) // 2\n        \n        total_sum += arr[i] * odd_count\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef odd_length_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of all odd length subarrays.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Sum of all odd length subarrays\n    \"\"\"\n    n = len(arr)\n    total_sum = 0\n    \n    # For each element, calculate how many odd length subarrays include it\n    for i in range(n):\n        # Count of subarrays that include arr[i]\n        # Left choices: we can start from index 0 to i (i+1 choices)\n        # Right choices: we can end from index i to n-1 (n-i choices)\n        # Total subarrays including arr[i]: (i+1) * (n-i)\n        \n        # Count of odd length subarrays including arr[i]\n        # For odd length subarrays, we need to count how many start and end positions\n        # create subarrays of odd length that include arr[i]\n        \n        # Method 2: Direct calculation\n        # Number of ways to choose left boundary: (i+1)\n        # Number of ways to choose right boundary: (n-i)\n        # Total subarrays including element at index i: (i+1) * (n-i)\n        \n        # Of these, half will be odd length (approximately)\n        # More precisely: if total is even, exactly half are odd\n        # If total is odd, (total+1)/2 are odd\n        \n        total_subarrays = (i + 1) * (n - i)\n        odd_count = (total_subarrays + 1) // 2\n        \n        total_sum += arr[i] * odd_count\n    \n    return total_sum\n```"], "prompt_tokens": [103], "completion_tokens": [359], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_782_odd_length_sum"}
{"name": "mbpp_470_add_pairwise", "language": "Python3", "prompt": "from typing import Tuple\n\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the pairwise addition of the neighboring elements of the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_pairwise", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n    assert candidate((2, 6, 8, 9, 11)) == (8, 14, 17, 20)\n    assert candidate((3, 7, 9, 10, 12)) == (10, 16, 19, 22)\n\ndef test_check():\n    check(add_pairwise)\n\ntest_check()\n", "sample_io": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)"], "source_codes": ["\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n\n\n"], "responses": ["```python\ndef add_pairwise(test_tup: Tuple[int, int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Find the pairwise addition of the neighboring elements of the given tuple.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n```"], "prompt_tokens": [104], "completion_tokens": [92], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_470_add_pairwise"}
{"name": "mbpp_17_square_perimeter", "language": "Python3", "prompt": "def square_perimeter(a: int) -> int:\n    \"\"\"\n\tWrite a function that returns the perimeter of a square given its side length as input.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_perimeter", "test": "def check(candidate):\n    assert candidate(10) == 40\n    assert candidate(5) == 20\n    assert candidate(4) == 16\n\ndef test_check():\n    check(square_perimeter)\n\ntest_check()\n", "sample_io": ["assert square_perimeter(10) == 40"], "source_codes": ["\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n\n\n"], "responses": ["```python\ndef square_perimeter(a: int) -> int:\n    \"\"\"\n    Write a function that returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * a\n```"], "prompt_tokens": [81], "completion_tokens": [44], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_17_square_perimeter"}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "Python3", "prompt": "def all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the bits are unset in the given range or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Bits_Set_In_The_Given_Range", "test": "def check(candidate):\n    assert candidate(4, 1, 2) == True\n    assert candidate(17, 2, 4) == True\n    assert candidate(39, 4, 6) == False\n\ndef test_check():\n    check(all_Bits_Set_In_The_Given_Range)\n\ntest_check()\n", "sample_io": ["assert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"], "source_codes": ["\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1  # This creates mask_length number of 1s\n    \n    # Shift the mask to align with positions [l, r]\n    mask = mask << (l - 1)\n    \n    # Check if any bit in the range is set (1)\n    # If (n & mask) == 0, then all bits in range are unset (0)\n    return (n & mask) == 0\n\n\n"], "responses": ["Looking at this problem, I need to check if all bits are unset (0) in a given range [l, r] of number n.\n\nLet me think step by step:\n1. I need to check bits from position l to r (inclusive)\n2. All bits in this range should be 0 for the function to return True\n3. I can create a mask that has 1s only in the range [l, r] and use bitwise operations\n\nApproach:\n- Create a mask with 1s from position l to r\n- Apply this mask to n using AND operation\n- If result is 0, then all bits in that range are unset\n\nTo create the mask:\n- Create a sequence of 1s up to position (r-l+1)\n- Shift it left by (l-1) positions\n\nWait, let me reconsider the indexing. Typically bit positions are counted from right starting at position 1.\n\nFor example, if n = 8 (binary: 1000), l = 2, r = 3:\n- Bits at positions 2 and 3 should both be 0\n- Position 1 = 0, Position 2 = 0, Position 3 = 0, Position 4 = 1\n\nActually, let me re-read... \"all the bits are unset in the given range\" - so I want to check if all bits in range [l,r] are 0.\n\n```python\ndef all_Bits_Set_In_The_Given_Range(n: int, l: int, r: int) -> bool:\n    # Create a mask with 1s in the range [l, r]\n    # First create a mask with (r-l+1) consecutive 1s\n    mask_length = r - l + 1\n    mask = (1 << mask_length) - 1  # This creates mask_length number of 1s\n    \n    # Shift the mask to align with positions [l, r]\n    mask = mask << (l - 1)\n    \n    # Check if any bit in the range is set (1)\n    # If (n & mask) == 0, then all bits in range are unset (0)\n    return (n & mask) == 0\n```"], "prompt_tokens": [99], "completion_tokens": [477], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_228_all_Bits_Set_In_The_Given_Range"}
{"name": "mbpp_240_replace_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_240_replace_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_list", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate(['red', 'blue', 'green'], ['yellow']) == ['red', 'blue', 'yellow']\n\ndef test_check():\n    check(replace_list)\n\ntest_check()\n", "sample_io": ["assert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"], "source_codes": ["\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if not list1:\n        return list2.copy()\n    \n    # Create a new list with all elements except the last one from list1\n    result = list1[:-1]\n    # Add all elements from list2\n    result.extend(list2)\n    return result\n\n\n"], "responses": ["```python\ndef replace_list(list1: List[Any], list2: List[Any]) -> List[Any]:\n    \"\"\"\n    Takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if not list1:\n        return list2.copy()\n    \n    # Create a new list with all elements except the last one from list1\n    result = list1[:-1]\n    # Add all elements from list2\n    result.extend(list2)\n    return result\n```"], "prompt_tokens": [104], "completion_tokens": [106], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_240_replace_list"}
{"name": "mbpp_447_cube_nums", "language": "Python3", "prompt": "from typing import List\n\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find cubes of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cube_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    assert candidate([10, 20, 30]) == [1000, 8000, 27000]\n    assert candidate([12, 15]) == [1728, 3375]\n\ndef test_check():\n    check(cube_nums)\n\ntest_check()\n", "sample_io": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"], "source_codes": ["\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n\n\n"], "responses": ["```python\ndef cube_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find cubes of individual elements in a list.\n    \"\"\"\n    return [num ** 3 for num in nums]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_447_cube_nums"}
{"name": "mbpp_261_division_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "division_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)\n    assert candidate((12, 6, 8, 16), (6, 3, 4, 4)) == (2, 2, 2, 4)\n    assert candidate((20, 14, 36, 18), (5, 7, 6, 9)) == (4, 2, 6, 2)\n\ndef test_check():\n    check(division_elements)\n\ntest_check()\n", "sample_io": ["assert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)"], "source_codes": ["\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    return tuple(a // b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef division_elements(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    return tuple(a // b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [119], "completion_tokens": [93], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_261_division_elements"}
{"name": "mbpp_581_surface_Area", "language": "Python3", "prompt": "def surface_Area(b: int, s: int) -> int:\n    \"\"\"\n\tWrite a python function to find the surface area of a square pyramid with a given base edge and height.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surface_Area", "test": "def check(candidate):\n    assert candidate(3, 4) == 33\n    assert candidate(4, 5) == 56\n    assert candidate(1, 2) == 5\n\ndef test_check():\n    check(surface_Area)\n\ntest_check()\n", "sample_io": ["assert surface_Area(3, 4) == 33"], "source_codes": ["\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and slant height.\n    \n    Args:\n        b: base edge length\n        s: slant height\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area (square base)\n    base_area = b * b\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n\n\n"], "responses": ["```python\ndef surface_Area(b: int, s: int) -> int:\n    \"\"\"\n    Find the surface area of a square pyramid with a given base edge and slant height.\n    \n    Args:\n        b: base edge length\n        s: slant height\n    \n    Returns:\n        surface area of the square pyramid\n    \"\"\"\n    # Base area (square base)\n    base_area = b * b\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * b * s)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area)\n```"], "prompt_tokens": [89], "completion_tokens": [140], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_581_surface_Area"}
{"name": "mbpp_283_validate", "language": "Python3", "prompt": "def validate(n: int) -> bool:\n    \"\"\"\n\tWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "validate", "test": "def check(candidate):\n    assert candidate(1234) == True\n    assert candidate(51241) == False\n    assert candidate(321) == True\n\ndef test_check():\n    check(validate)\n\ntest_check()\n", "sample_io": ["assert validate(1234) == True"], "source_codes": ["\ndef validate(n: int) -> bool:\n    \"\"\"\n    Takes in an integer and checks whether the frequency of each digit in the integer \n    is less than or equal to the digit itself.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        bool: True if frequency of each digit <= digit value, False otherwise\n    \"\"\"\n    # Convert to string to easily iterate through digits\n    # Handle negative numbers by taking absolute value\n    digits_str = str(abs(n))\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit itself\n    for digit, frequency in digit_count.items():\n        if frequency > digit:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef validate(n: int) -> bool:\n    \"\"\"\n    Takes in an integer and checks whether the frequency of each digit in the integer \n    is less than or equal to the digit itself.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        bool: True if frequency of each digit <= digit value, False otherwise\n    \"\"\"\n    # Convert to string to easily iterate through digits\n    # Handle negative numbers by taking absolute value\n    digits_str = str(abs(n))\n    \n    # Count frequency of each digit\n    digit_count = {}\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit itself\n    for digit, frequency in digit_count.items():\n        if frequency > digit:\n            return False\n    \n    return True\n```"], "prompt_tokens": [91], "completion_tokens": [190], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_283_validate"}
{"name": "mbpp_284_check_element", "language": "Python3", "prompt": "from typing import List, Any\n\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n\tWrite a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_284_check_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_element", "test": "def check(candidate):\n    assert candidate(['green', 'orange', 'black', 'white'], 'blue') == False\n    assert candidate([1, 2, 3, 4], 7) == False\n    assert candidate(['green', 'green', 'green', 'green'], 'green') == True\n\ndef test_check():\n    check(check_element)\n\ntest_check()\n", "sample_io": ["assert check_element(['green', 'orange', 'black', 'white'], 'blue') == False"], "source_codes": ["\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef check_element(list: List[Any], element: Any) -> bool:\n    \"\"\"\n    Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\n    \"\"\"\n    for item in list:\n        if item != element:\n            return False\n    return True\n```"], "prompt_tokens": [100], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_284_check_element"}
{"name": "mbpp_101_kth_element", "language": "Python3", "prompt": "from typing import List\n\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find the kth element in the given array using 1-based indexing.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "kth_element", "test": "def check(candidate):\n    assert candidate([12, 3, 5, 7, 19], 2) == 3\n    assert candidate([17, 24, 8, 23], 3) == 8\n    assert candidate([16, 21, 25, 36, 4], 4) == 36\n\ndef test_check():\n    check(kth_element)\n\ntest_check()\n", "sample_io": ["assert kth_element([12, 3, 5, 7, 19], 2) == 3"], "source_codes": ["\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr: List of integers\n        k: Position (1-based indexing)\n    \n    Returns:\n        The kth element in the array\n    \n    Raises:\n        IndexError: If k is out of bounds\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    return arr[k - 1]\n\n\n"], "responses": ["```python\ndef kth_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr: List of integers\n        k: Position (1-based indexing)\n    \n    Returns:\n        The kth element in the array\n    \n    Raises:\n        IndexError: If k is out of bounds\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    \n    return arr[k - 1]\n```"], "prompt_tokens": [93], "completion_tokens": [117], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_101_kth_element"}
{"name": "mbpp_461_upper_ctr", "language": "Python3", "prompt": "def upper_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the upper case characters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "upper_ctr", "test": "def check(candidate):\n    assert candidate('PYthon') == 1\n    assert candidate('BigData') == 1\n    assert candidate('program') == 0\n\ndef test_check():\n    check(upper_ctr)\n\ntest_check()\n", "sample_io": ["assert upper_ctr('PYthon') == 1"], "source_codes": ["\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef upper_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count the upper case characters in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n```"], "prompt_tokens": [78], "completion_tokens": [62], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_461_upper_ctr"}
{"name": "mbpp_593_removezero_ip", "language": "Python3", "prompt": "def removezero_ip(ip: str) -> str:\n    \"\"\"\n\tWrite a function to remove leading zeroes from an ip address.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "removezero_ip", "test": "def check(candidate):\n    assert candidate('216.08.094.196') == '216.8.94.196'\n    assert candidate('12.01.024') == '12.1.24'\n    assert candidate('216.08.094.0196') == '216.8.94.196'\n\ndef test_check():\n    check(removezero_ip)\n\ntest_check()\n", "sample_io": ["assert removezero_ip('216.08.094.196') == '216.8.94.196'"], "source_codes": ["\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address by dots\n    parts = ip.split('.')\n    \n    # Remove leading zeros from each part\n    cleaned_parts = []\n    for part in parts:\n        # Convert to integer and back to string to remove leading zeros\n        # This also handles the case where part is \"000\" -> \"0\"\n        cleaned_part = str(int(part))\n        cleaned_parts.append(cleaned_part)\n    \n    # Join the parts back with dots\n    return '.'.join(cleaned_parts)\n\n\n"], "responses": ["```python\ndef removezero_ip(ip: str) -> str:\n    \"\"\"\n    Write a function to remove leading zeroes from an ip address.\n    \"\"\"\n    # Split the IP address by dots\n    parts = ip.split('.')\n    \n    # Remove leading zeros from each part\n    cleaned_parts = []\n    for part in parts:\n        # Convert to integer and back to string to remove leading zeros\n        # This also handles the case where part is \"000\" -> \"0\"\n        cleaned_part = str(int(part))\n        cleaned_parts.append(cleaned_part)\n    \n    # Join the parts back with dots\n    return '.'.join(cleaned_parts)\n```"], "prompt_tokens": [76], "completion_tokens": [136], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_593_removezero_ip"}
{"name": "mbpp_788_new_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n\tWrite a function to create a new tuple from the given string and list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "new_tuple", "test": "def check(candidate):\n    assert candidate(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')\n    assert candidate(['We', 'are'], 'Developers') == ('We', 'are', 'Developers')\n    assert candidate(['Part', 'is'], 'Wrong') == ('Part', 'is', 'Wrong')\n\ndef test_check():\n    check(new_tuple)\n\ntest_check()\n", "sample_io": ["assert new_tuple(['WEB', 'is'], 'best') == ('WEB', 'is', 'best')"], "source_codes": ["\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    first_element = test_list[0] if test_list else \"\"\n    last_element = test_list[-1] if test_list else \"\"\n    return (first_element, test_str, last_element)\n\n\n"], "responses": ["Looking at the function signature and docstring, I need to create a function that takes a list of strings and a string, then returns a tuple containing three strings.\n\nLet me analyze what the function should do:\n- Input: `test_list` (List[str]) and `test_str` (str)\n- Output: A tuple with exactly 3 strings\n\nSince the problem doesn't specify the exact logic, I'll make a reasonable assumption based on common patterns - perhaps taking the first element from the list, the string itself, and maybe the last element from the list.\n\nHowever, looking more carefully at the function name \"new_tuple\" and the parameters, a common interpretation would be to combine the list elements and string in some way to form a 3-element tuple.\n\nLet me implement a solution that takes:\n1. First element of the list (or empty string if list is empty)\n2. The input string\n3. Last element of the list (or empty string if list is empty)\n\n```python\ndef new_tuple(test_list: List[str], test_str: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Write a function to create a new tuple from the given string and list.\n    \"\"\"\n    first_element = test_list[0] if test_list else \"\"\n    last_element = test_list[-1] if test_list else \"\"\n    return (first_element, test_str, last_element)\n```"], "prompt_tokens": [97], "completion_tokens": [287], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_788_new_tuple"}
{"name": "mbpp_777_find_sum", "language": "Python3", "prompt": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of non-repeated elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n    assert candidate([1, 10, 9, 4, 2, 10, 10, 45, 4]) == 71\n    assert candidate([12, 10, 9, 45, 2, 10, 10, 45, 10]) == 78\n\ndef test_check():\n    check(find_sum)\n\ntest_check()\n", "sample_io": ["assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21"], "source_codes": ["\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Sum elements that appear exactly once\n    total = 0\n    for num, count in freq.items():\n        if count == 1:\n            total += num\n    \n    return total\n\n\n"], "responses": ["```python\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Sum elements that appear exactly once\n    total = 0\n    for num, count in freq.items():\n        if count == 1:\n            total += num\n    \n    return total\n```"], "prompt_tokens": [87], "completion_tokens": [108], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_777_find_sum"}
{"name": "mbpp_586_split_Arr", "language": "Python3", "prompt": "from typing import List\n\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to split a list at the nth eelment and add the first part to the end.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_Arr", "test": "def check(candidate):\n    assert candidate([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]\n    assert candidate([1, 2, 3, 4], 1) == [2, 3, 4, 1]\n    assert candidate([0, 1, 2, 3, 4, 5, 6, 7], 3) == [3, 4, 5, 6, 7, 0, 1, 2]\n\ndef test_check():\n    check(split_Arr)\n\ntest_check()\n", "sample_io": ["assert split_Arr([12, 10, 5, 6, 52, 36], 2) == [5, 6, 52, 36, 12, 10]"], "source_codes": ["\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    if n >= len(l):\n        return l\n    return l[n:] + l[:n]\n\n\n"], "responses": ["```python\ndef split_Arr(l: List[int], n: int) -> List[int]:\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    if n >= len(l):\n        return l\n    return l[n:] + l[:n]\n```"], "prompt_tokens": [98], "completion_tokens": [64], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_586_split_Arr"}
{"name": "mbpp_104_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([[' red ', 'green'], ['blue ', ' black'], [' orange', 'brown']]) == [[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]\n    assert candidate([['zilver', 'gold'], ['magnesium', 'aluminium'], ['steel', 'bronze']]) == [['gold', 'zilver'], ['aluminium', 'magnesium'], ['bronze', 'steel']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n\n\n"], "responses": ["```python\ndef sort_sublists(input_list: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in input_list]\n```"], "prompt_tokens": [90], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_104_sort_sublists"}
{"name": "mbpp_472_check_Consecutive", "language": "Python3", "prompt": "from typing import List\n\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given list contains consecutive numbers or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_Consecutive", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 2, 3, 5, 6]) == False\n    assert candidate([1, 2, 1]) == False\n\ndef test_check():\n    check(check_Consecutive)\n\ntest_check()\n", "sample_io": ["assert check_Consecutive([1, 2, 3, 4, 5]) == True"], "source_codes": ["\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to check for consecutive sequence\n    sorted_list = sorted(l)\n    \n    # Check if each element is one more than the previous element\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] != sorted_list[i-1] + 1:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_Consecutive(l: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    \n    # Sort the list to check for consecutive sequence\n    sorted_list = sorted(l)\n    \n    # Check if each element is one more than the previous element\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] != sorted_list[i-1] + 1:\n            return False\n    \n    return True\n```"], "prompt_tokens": [86], "completion_tokens": [121], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_472_check_Consecutive"}
{"name": "mbpp_310_string_to_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a given string to a list of characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_tuple", "test": "def check(candidate):\n    assert candidate('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n    assert candidate('item1') == ['i', 't', 'e', 'm', '1']\n    assert candidate('15.10') == ['1', '5', '.', '1', '0']\n\ndef test_check():\n    check(string_to_tuple)\n\ntest_check()\n", "sample_io": ["assert string_to_tuple('python 3.0') == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']"], "source_codes": ["\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n\n\n"], "responses": ["```python\ndef string_to_tuple(str1: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a given string to a list of characters.\n    \"\"\"\n    return list(str1)\n```"], "prompt_tokens": [85], "completion_tokens": [43], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_310_string_to_tuple"}
{"name": "mbpp_266_lateralsurface_cube", "language": "Python3", "prompt": "def lateralsurface_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the lateral surface area of a cube given its side length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lateralsurface_cube", "test": "def check(candidate):\n    assert candidate(5) == 100\n    assert candidate(9) == 324\n    assert candidate(10) == 400\n\ndef test_check():\n    check(lateralsurface_cube)\n\ntest_check()\n", "sample_io": ["assert lateralsurface_cube(5) == 100"], "source_codes": ["\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    # Lateral surface area of a cube = 4 * (side length)^2\n    return 4 * l * l\n\n\n"], "responses": ["```python\ndef lateralsurface_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the lateral surface area of a cube given its side length.\n    \"\"\"\n    # Lateral surface area of a cube = 4 * (side length)^2\n    return 4 * l * l\n```"], "prompt_tokens": [82], "completion_tokens": [67], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_266_lateralsurface_cube"}
{"name": "mbpp_271_even_Power_Sum", "language": "Python3", "prompt": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_Power_Sum", "test": "def check(candidate):\n    assert candidate(2) == 1056\n    assert candidate(3) == 8832\n    assert candidate(1) == 32\n\ndef test_check():\n    check(even_Power_Sum)\n\ntest_check()\n", "sample_io": ["assert even_Power_Sum(2) == 1056"], "source_codes": ["\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 5\n    return total\n\n\n"], "responses": ["Looking at this problem, I need to:\n1. Find the first n even natural numbers\n2. Raise each to the 5th power\n3. Sum them up\n\nThe first n even natural numbers are: 2, 4, 6, 8, ..., 2n\n\nSo I need to calculate: 2^5 + 4^5 + 6^5 + ... + (2n)^5\n\n```python\ndef even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 5\n    return total\n```"], "prompt_tokens": [95], "completion_tokens": [178], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_271_even_Power_Sum"}
{"name": "mbpp_238_number_of_substrings", "language": "Python3", "prompt": "def number_of_substrings(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_of_substrings", "test": "def check(candidate):\n    assert candidate('abc') == 6\n    assert candidate('abcd') == 10\n    assert candidate('abcde') == 15\n\ndef test_check():\n    check(number_of_substrings)\n\ntest_check()\n", "sample_io": ["assert number_of_substrings('abc') == 6"], "source_codes": ["\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n    \n    For a string of length n, the number of non-empty substrings is n*(n+1)/2.\n    This is because:\n    - Substrings of length 1: n possibilities\n    - Substrings of length 2: (n-1) possibilities\n    - ...\n    - Substrings of length n: 1 possibility\n    \n    Total = n + (n-1) + (n-2) + ... + 1 = n*(n+1)/2\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n\n\n"], "responses": ["```python\ndef number_of_substrings(str: str) -> int:\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n    \n    For a string of length n, the number of non-empty substrings is n*(n+1)/2.\n    This is because:\n    - Substrings of length 1: n possibilities\n    - Substrings of length 2: (n-1) possibilities\n    - ...\n    - Substrings of length n: 1 possibility\n    \n    Total = n + (n-1) + (n-2) + ... + 1 = n*(n+1)/2\n    \"\"\"\n    n = len(str)\n    return n * (n + 1) // 2\n```"], "prompt_tokens": [83], "completion_tokens": [158], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_238_number_of_substrings"}
{"name": "mbpp_592_sum_Of_product", "language": "Python3", "prompt": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the product of consecutive binomial co-efficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_product", "test": "def check(candidate):\n    assert candidate(3) == 15\n    assert candidate(4) == 56\n    assert candidate(1) == 1\n\ndef test_check():\n    check(sum_Of_product)\n\ntest_check()\n", "sample_io": ["assert sum_Of_product(3) == 15"], "source_codes": ["\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    This equals C(2n, n-1) = (2n)! / ((n-1)! * (n+1)!)\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Calculate C(2n, n-1)\n    # Using the formula: C(n,k) = n! / (k! * (n-k)!)\n    # C(2n, n-1) = (2n)! / ((n-1)! * (n+1)!)\n    \n    # More efficient calculation to avoid large factorials\n    # C(2n, n-1) = (2n * (2n-1) * ... * (n+2)) / ((n-1)!)\n    \n    result = 1\n    for i in range(n+2, 2*n + 1):\n        result *= i\n    \n    for i in range(1, n):\n        result //= i\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of products of consecutive binomial coefficients.\n\nLet me think about what this means:\n- For a given n, I need to consider binomial coefficients C(n,0), C(n,1), C(n,2), ..., C(n,n)\n- The products of consecutive pairs would be: C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n- So the sum would be: Σ(k=0 to n-1) C(n,k) * C(n,k+1)\n\nThere's a known combinatorial identity for this sum. Let me work through it:\n\nThe sum of products of consecutive binomial coefficients C(n,k) * C(n,k+1) equals C(2n, n-1).\n\nThis can be derived using Vandermonde's identity or by recognizing that this sum counts certain lattice paths.\n\nLet me verify with a small example:\nFor n=2: C(2,0)*C(2,1) + C(2,1)*C(2,2) = 1*2 + 2*1 = 4\nAnd C(4,1) = 4 ✓\n\n```python\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    This equals C(2n, n-1) = (2n)! / ((n-1)! * (n+1)!)\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Calculate C(2n, n-1)\n    # Using the formula: C(n,k) = n! / (k! * (n-k)!)\n    # C(2n, n-1) = (2n)! / ((n-1)! * (n+1)!)\n    \n    # More efficient calculation to avoid large factorials\n    # C(2n, n-1) = (2n * (2n-1) * ... * (n+2)) / ((n-1)!)\n    \n    result = 1\n    for i in range(n+2, 2*n + 1):\n        result *= i\n    \n    for i in range(1, n):\n        result //= i\n    \n    return result\n```"], "prompt_tokens": [83], "completion_tokens": [499], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_592_sum_Of_product"}
{"name": "mbpp_74_is_samepatterns", "language": "Python3", "prompt": "from typing import List\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n\tWrite a function to check whether it follows the sequence given in the patterns array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_samepatterns", "test": "def check(candidate):\n    assert candidate(['red', 'green', 'green'], ['a', 'b', 'b']) == True\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b', 'b']) == False\n    assert candidate(['red', 'green', 'greenn'], ['a', 'b']) == False\n\ndef test_check():\n    check(is_samepatterns)\n\ntest_check()\n", "sample_io": ["assert is_samepatterns(['red', 'green', 'green'], ['a', 'b', 'b']) == True"], "source_codes": ["\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Check whether the colors follow the same sequence pattern as the patterns array.\n    \n    Args:\n        colors: List of color strings\n        patterns: List of pattern strings\n    \n    Returns:\n        bool: True if colors follow the same pattern as patterns, False otherwise\n    \"\"\"\n    # If lengths are different, they can't follow the same pattern\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from colors to patterns and vice versa\n    color_to_pattern = {}\n    pattern_to_color = {}\n    \n    # Check each position\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n        \n        # Check if color already has a mapping\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        \n        # Check if pattern already has a mapping\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    \n    return True\n\n\n"], "responses": ["```python\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n    \"\"\"\n    Check whether the colors follow the same sequence pattern as the patterns array.\n    \n    Args:\n        colors: List of color strings\n        patterns: List of pattern strings\n    \n    Returns:\n        bool: True if colors follow the same pattern as patterns, False otherwise\n    \"\"\"\n    # If lengths are different, they can't follow the same pattern\n    if len(colors) != len(patterns):\n        return False\n    \n    # Create mappings from colors to patterns and vice versa\n    color_to_pattern = {}\n    pattern_to_color = {}\n    \n    # Check each position\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n        \n        # Check if color already has a mapping\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        \n        # Check if pattern already has a mapping\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    \n    return True\n```"], "prompt_tokens": [91], "completion_tokens": [255], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_74_is_samepatterns"}
{"name": "mbpp_415_max_Product", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n\tWrite a python function to find a pair with highest product from a given array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)\n    assert candidate([0, -1, -2, -4, 5, 0, -6]) == (-4, -6)\n    assert candidate([1, 2, 3]) == (2, 3)\n\ndef test_check():\n    check(max_Product)\n\ntest_check()\n", "sample_io": ["assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"], "source_codes": ["\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily find candidates for maximum product\n    arr_sorted = sorted(arr)\n    n = len(arr_sorted)\n    \n    # The maximum product can be either:\n    # 1. Product of two largest numbers (both positive)\n    # 2. Product of two smallest numbers (both negative)\n    product1 = arr_sorted[0] * arr_sorted[1]  # Two smallest\n    product2 = arr_sorted[n-1] * arr_sorted[n-2]  # Two largest\n    \n    if product1 > product2:\n        # Return the pair with smaller absolute values first for consistency\n        return (arr_sorted[0], arr_sorted[1])\n    else:\n        return (arr_sorted[n-2], arr_sorted[n-1])\n\n\n"], "responses": ["```python\ndef max_Product(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair with highest product from a given array of integers.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array to easily find candidates for maximum product\n    arr_sorted = sorted(arr)\n    n = len(arr_sorted)\n    \n    # The maximum product can be either:\n    # 1. Product of two largest numbers (both positive)\n    # 2. Product of two smallest numbers (both negative)\n    product1 = arr_sorted[0] * arr_sorted[1]  # Two smallest\n    product2 = arr_sorted[n-1] * arr_sorted[n-2]  # Two largest\n    \n    if product1 > product2:\n        # Return the pair with smaller absolute values first for consistency\n        return (arr_sorted[0], arr_sorted[1])\n    else:\n        return (arr_sorted[n-2], arr_sorted[n-1])\n```"], "prompt_tokens": [92], "completion_tokens": [218], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_415_max_Product"}
{"name": "mbpp_781_count_divisors", "language": "Python3", "prompt": "def count_divisors(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_divisors", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(100) == False\n    assert candidate(125) == True\n\ndef test_check():\n    check(count_divisors)\n\ntest_check()\n", "sample_io": ["assert count_divisors(10) == True"], "source_codes": ["\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Check whether the count of divisors is even.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        True if the count of divisors is even, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count % 2 == 0\n\n\n"], "responses": ["```python\ndef count_divisors(n: int) -> bool:\n    \"\"\"\n    Check whether the count of divisors is even.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        True if the count of divisors is even, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count % 2 == 0\n```"], "prompt_tokens": [101], "completion_tokens": [114], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_781_count_divisors"}
{"name": "mbpp_441_surfacearea_cube", "language": "Python3", "prompt": "def surfacearea_cube(l: int) -> int:\n    \"\"\"\n\tWrite a function to find the surface area of a cube of a given size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cube", "test": "def check(candidate):\n    assert candidate(5) == 150\n    assert candidate(3) == 54\n    assert candidate(10) == 600\n\ndef test_check():\n    check(surfacearea_cube)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cube(5) == 150"], "source_codes": ["\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n\n\n"], "responses": ["```python\ndef surfacearea_cube(l: int) -> int:\n    \"\"\"\n    Write a function to find the surface area of a cube of a given size.\n    \"\"\"\n    return 6 * l * l\n```"], "prompt_tokens": [80], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_441_surfacearea_cube"}
{"name": "mbpp_396_check_char", "language": "Python3", "prompt": "def check_char(string: str) -> str:\n    \"\"\"\n\tWrite a function to check whether the given string starts and ends with the same character or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_char", "test": "def check(candidate):\n    assert candidate('abba') == 'Valid'\n    assert candidate('a') == 'Valid'\n    assert candidate('abcd') == 'Invalid'\n\ndef test_check():\n    check(check_char)\n\ntest_check()\n", "sample_io": ["assert check_char('abba') == 'Valid'"], "source_codes": ["\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"No\"\n    \n    # Handle single character string\n    if len(string) == 1:\n        return \"Yes\"\n    \n    # Check if first and last characters are the same\n    if string[0] == string[-1]:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n\n"], "responses": ["```python\ndef check_char(string: str) -> str:\n    \"\"\"\n    Write a function to check whether the given string starts and ends with the same character or not.\n    \"\"\"\n    # Handle empty string case\n    if len(string) == 0:\n        return \"No\"\n    \n    # Handle single character string\n    if len(string) == 1:\n        return \"Yes\"\n    \n    # Check if first and last characters are the same\n    if string[0] == string[-1]:\n        return \"Yes\"\n    else:\n        return \"No\"\n```"], "prompt_tokens": [82], "completion_tokens": [119], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_396_check_char"}
{"name": "mbpp_757_count_reverse_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n\tWrite a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_reverse_pairs", "test": "def check(candidate):\n    assert candidate(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2\n    assert candidate(['geeks', 'best', 'for', 'skeeg']) == 1\n    assert candidate(['makes', 'best', 'sekam', 'for', 'rof']) == 2\n\ndef test_check():\n    check(count_reverse_pairs)\n\ntest_check()\n", "sample_io": ["assert count_reverse_pairs(['julia', 'best', 'tseb', 'for', 'ailuj']) == 2"], "source_codes": ["\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for string in test_list:\n        reversed_string = string[::-1]\n        if reversed_string in seen:\n            count += 1\n        seen.add(string)\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_reverse_pairs(test_list: List[str]) -> int:\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for string in test_list:\n        reversed_string = string[::-1]\n        if reversed_string in seen:\n            count += 1\n        seen.add(string)\n    \n    return count\n```"], "prompt_tokens": [108], "completion_tokens": [85], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_757_count_reverse_pairs"}
{"name": "mbpp_75_find_tuples", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n\tWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_tuples", "test": "def check(candidate):\n    assert candidate([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    assert candidate([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]\n    assert candidate([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]\n\ndef test_check():\n    check(find_tuples)\n\ntest_check()\n", "sample_io": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"], "source_codes": ["\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        if all(element % K == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return result\n\n\n"], "responses": ["```python\ndef find_tuples(test_list: List[Tuple[int, int, int]], K: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        if all(element % K == 0 for element in tuple_item):\n            result.append(tuple_item)\n    return result\n```"], "prompt_tokens": [109], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_75_find_tuples"}
{"name": "mbpp_785_tuple_str_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function to convert tuple string to integer tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_str_int", "test": "def check(candidate):\n    assert candidate('(7, 8, 9)') == (7, 8, 9)\n    assert candidate('(1, 2, 3)') == (1, 2, 3)\n    assert candidate('(4, 5, 6)') == (4, 5, 6)\n    assert candidate('(7, 81, 19)') == (7, 81, 19)\n\ndef test_check():\n    check(tuple_str_int)\n\ntest_check()\n", "sample_io": ["assert tuple_str_int('(7, 8, 9)') == (7, 8, 9)"], "source_codes": ["\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Convert tuple string to integer tuple.\n    \"\"\"\n    # Remove parentheses and split by comma\n    cleaned_str = test_str.strip('()')\n    # Split by comma and convert each element to integer\n    elements = [int(x.strip()) for x in cleaned_str.split(',')]\n    # Return as tuple\n    return tuple(elements)\n\n\n"], "responses": ["```python\ndef tuple_str_int(test_str: str) -> Tuple[int, int, int]:\n    \"\"\"\n    Convert tuple string to integer tuple.\n    \"\"\"\n    # Remove parentheses and split by comma\n    cleaned_str = test_str.strip('()')\n    # Split by comma and convert each element to integer\n    elements = [int(x.strip()) for x in cleaned_str.split(',')]\n    # Return as tuple\n    return tuple(elements)\n```"], "prompt_tokens": [86], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_785_tuple_str_int"}
{"name": "mbpp_776_count_vowels", "language": "Python3", "prompt": "def count_vowels(test_str: str) -> int:\n    \"\"\"\n\tWrite a function to count those characters which have vowels as their neighbors in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_vowels", "test": "def check(candidate):\n    assert candidate('bestinstareels') == 7\n    assert candidate('partofthejourneyistheend') == 12\n    assert candidate('amazonprime') == 5\n\ndef test_check():\n    check(count_vowels)\n\ntest_check()\n", "sample_io": ["assert count_vowels('bestinstareels') == 7"], "source_codes": ["\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) < 3:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Check each character (except first and last) to see if it has vowel neighbors\n    for i in range(1, len(test_str) - 1):\n        if test_str[i-1] in vowels and test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_vowels(test_str: str) -> int:\n    \"\"\"\n    Write a function to count those characters which have vowels as their neighbors in the given string.\n    \"\"\"\n    if len(test_str) < 3:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Check each character (except first and last) to see if it has vowel neighbors\n    for i in range(1, len(test_str) - 1):\n        if test_str[i-1] in vowels and test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [84], "completion_tokens": [138], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_776_count_vowels"}
{"name": "mbpp_277_dict_filter", "language": "Python3", "prompt": "from typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n\tWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dict_filter", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 170) == { 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 180) == { 'Alden Cantrell': 180, 'Pierre Cox': 190 }\n    assert candidate({ 'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190 }, 190) == { 'Pierre Cox': 190 }\n\ndef test_check():\n    check(dict_filter)\n\ntest_check()\n", "sample_io": ["assert dict_filter(3) == 27"], "source_codes": ["\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n\n\n"], "responses": ["```python\nfrom typing import Dict\n\ndef dict_filter(dict: Dict[str, int], n: int) -> Dict[str, int]:\n    \"\"\"\n    Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in dict.items() if value >= n}\n```"], "prompt_tokens": [106], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_277_dict_filter"}
{"name": "mbpp_468_max_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product", "test": "def check(candidate):\n    assert candidate([3, 100, 4, 5, 150, 6]) == 3000\n    assert candidate([4, 42, 55, 68, 80]) == 50265600\n    assert candidate([10, 22, 9, 33, 21, 50, 41, 60]) == 2460\n\ndef test_check():\n    check(max_product)\n\ntest_check()\n", "sample_io": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000"], "source_codes": ["\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]\n    \n    # For each element, check all previous elements\n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element (increasing condition)\n            if arr[i] > arr[j]:\n                # Update dp[i] if multiplying gives a larger product\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # Return the maximum product among all possible subsequences\n    return max(dp)\n\n\n"], "responses": ["```python\ndef max_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [arr[i] for i in range(n)]\n    \n    # For each element, check all previous elements\n    for i in range(1, n):\n        for j in range(i):\n            # If current element is greater than previous element (increasing condition)\n            if arr[i] > arr[j]:\n                # Update dp[i] if multiplying gives a larger product\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # Return the maximum product among all possible subsequences\n    return max(dp)\n```"], "prompt_tokens": [90], "completion_tokens": [163], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_468_max_product"}
{"name": "mbpp_279_is_num_decagonal", "language": "Python3", "prompt": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth decagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_num_decagonal", "test": "def check(candidate):\n    assert candidate(3) == 27\n    assert candidate(7) == 175\n    assert candidate(10) == 370\n\ndef test_check():\n    check(is_num_decagonal)\n\ntest_check()\n", "sample_io": ["assert is_num_decagonal(3) == 27"], "source_codes": ["\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Find the nth decagonal number.\n    \n    A decagonal number is a figurate number that represents a decagon.\n    The formula for the nth decagonal number is: 4n² - 3n\n    \n    Args:\n        n (int): The position of the decagonal number to find (1-indexed)\n    \n    Returns:\n        int: The nth decagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 4 * n * n - 3 * n\n\n\n"], "responses": ["```python\ndef is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Find the nth decagonal number.\n    \n    A decagonal number is a figurate number that represents a decagon.\n    The formula for the nth decagonal number is: 4n² - 3n\n    \n    Args:\n        n (int): The position of the decagonal number to find (1-indexed)\n    \n    Returns:\n        int: The nth decagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 4 * n * n - 3 * n\n```"], "prompt_tokens": [76], "completion_tokens": [133], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_279_is_num_decagonal"}
{"name": "mbpp_3_is_not_prime", "language": "Python3", "prompt": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to identify non-prime numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_not_prime", "test": "def check(candidate):\n    assert candidate(2) == False\n    assert candidate(10) == True\n    assert candidate(35) == True\n    assert candidate(37) == False\n\ndef test_check():\n    check(is_not_prime)\n\ntest_check()\n", "sample_io": ["assert is_not_prime(2) == False"], "source_codes": ["\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_not_prime(n: int) -> bool:\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n```"], "prompt_tokens": [75], "completion_tokens": [80], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_3_is_not_prime"}
{"name": "mbpp_88_freq_count", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_88_freq_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "freq_count", "test": "def check(candidate):\n    assert candidate([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }\n    assert candidate([1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4]) == { 1: 3, 2: 2, 3: 3, 4: 3 }\n    assert candidate([5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5]) == { 10: 1, 5: 3, 6: 2, 7: 2, 4: 2, 9: 2 }\n\ndef test_check():\n    check(freq_count)\n\ntest_check()\n", "sample_io": ["assert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == { 10: 4, 20: 4, 40: 2, 50: 2, 30: 1 }"], "source_codes": ["\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    for element in list1:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict\n\n\n"], "responses": ["```python\ndef freq_count(list1: List[int]) -> Dict[int, int]:\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    frequency_dict = {}\n    for element in list1:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict\n```"], "prompt_tokens": [95], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_88_freq_count"}
{"name": "mbpp_259_maximize_elements", "language": "Python3", "prompt": "from typing import List\n\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to maximize the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maximize_elements", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[7, 8], [5, 10], [3, 10], [8, 11]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[8, 9], [6, 11], [4, 11], [9, 12]]\n\ndef test_check():\n    check(maximize_elements)\n\ntest_check()\n", "sample_io": ["assert maximize_elements([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]]"], "source_codes": ["\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through corresponding sublists\n    for i in range(len(test_tup1)):\n        sublist = []\n        # Iterate through corresponding elements in sublists\n        for j in range(len(test_tup1[i])):\n            # Take the maximum of corresponding elements\n            max_element = max(test_tup1[i][j], test_tup2[i][j])\n            sublist.append(max_element)\n        result.append(sublist)\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to create a function that maximizes elements from two lists of lists. Based on the function signature and description, it seems like I should compare corresponding elements from both input lists and return the maximum values.\n\nLet me analyze what \"maximize the given two lists\" could mean:\n- Compare corresponding elements and take the maximum\n- This would work element-wise across the nested lists\n\nHere's my solution:\n\n```python\ndef maximize_elements(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to maximize the given two lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through corresponding sublists\n    for i in range(len(test_tup1)):\n        sublist = []\n        # Iterate through corresponding elements in sublists\n        for j in range(len(test_tup1[i])):\n            # Take the maximum of corresponding elements\n            max_element = max(test_tup1[i][j], test_tup2[i][j])\n            sublist.append(max_element)\n        result.append(sublist)\n    \n    return result\n```"], "prompt_tokens": [94], "completion_tokens": [229], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_259_maximize_elements"}
{"name": "mbpp_568_empty_list", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n\tWrite a function to create a list of N empty dictionaries.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "empty_list", "test": "def check(candidate):\n    assert candidate(5) == [{  }, {  }, {  }, {  }, {  }]\n    assert candidate(6) == [{  }, {  }, {  }, {  }, {  }, {  }]\n    assert candidate(7) == [{  }, {  }, {  }, {  }, {  }, {  }, {  }]\n\ndef test_check():\n    check(empty_list)\n\ntest_check()\n", "sample_io": ["assert empty_list(5) == [{  }, {  }, {  }, {  }, {  }]"], "source_codes": ["\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n\n\n"], "responses": ["```python\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n```"], "prompt_tokens": [88], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_568_empty_list"}
{"name": "mbpp_285_text_match_two_three", "language": "Python3", "prompt": "def text_match_two_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_two_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n\ndef test_check():\n    check(text_match_two_three)\n\ntest_check()\n", "sample_io": ["assert text_match_two_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [89], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_285_text_match_two_three"}
{"name": "mbpp_721_maxAverageOfPath", "language": "Python3", "prompt": "from typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maxAverageOfPath", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n    assert candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2\n    assert candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8\n\ndef test_check():\n    check(maxAverageOfPath)\n\ntest_check()\n", "sample_io": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"], "source_codes": ["\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    n = len(cost)\n    \n    # dp[i][j] represents the maximum sum to reach cell (i,j)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize the first cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill the first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # The number of cells in any path from top-left to bottom-right is 2*n - 1\n    path_length = 2 * n - 1\n    \n    # Return the maximum average\n    return dp[n-1][n-1] / path_length\n\n\n"], "responses": ["```python\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    n = len(cost)\n    \n    # dp[i][j] represents the maximum sum to reach cell (i,j)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize the first cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill the first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # The number of cells in any path from top-left to bottom-right is 2*n - 1\n    path_length = 2 * n - 1\n    \n    # Return the maximum average\n    return dp[n-1][n-1] / path_length\n```"], "prompt_tokens": [159], "completion_tokens": [288], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_721_maxAverageOfPath"}
{"name": "mbpp_797_sum_in_range", "language": "Python3", "prompt": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd natural numbers within the range l and r.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_in_range", "test": "def check(candidate):\n    assert candidate(2, 5) == 8\n    assert candidate(5, 7) == 12\n    assert candidate(7, 13) == 40\n\ndef test_check():\n    check(sum_in_range)\n\ntest_check()\n", "sample_io": ["assert sum_in_range(2, 5) == 8"], "source_codes": ["\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Find the sum of all odd natural numbers within the range l and r (inclusive).\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:\n            total += i\n    return total\n\n\n"], "responses": ["```python\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Find the sum of all odd natural numbers within the range l and r (inclusive).\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:\n            total += i\n    return total\n```"], "prompt_tokens": [88], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_797_sum_in_range"}
{"name": "mbpp_4_heap_queue_largest", "language": "Python3", "prompt": "from typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_queue_largest", "test": "def check(candidate):\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n\ndef test_check():\n    check(heap_queue_largest)\n\ntest_check()\n", "sample_io": ["assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"], "source_codes": ["\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to get n largest elements in descending order\n    return heapq.nlargest(n, nums)\n\n\n"], "responses": ["```python\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to get n largest elements in descending order\n    return heapq.nlargest(n, nums)\n```"], "prompt_tokens": [97], "completion_tokens": [105], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_4_heap_queue_largest"}
{"name": "mbpp_120_max_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 200\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 484\n\ndef test_check():\n    check(max_product_tuple)\n\ntest_check()\n", "sample_io": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"], "source_codes": ["\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tuple_pair in list1:\n        # Calculate the product of the two numbers in the tuple\n        product = tuple_pair[0] * tuple_pair[1]\n        # Take the absolute value of the product\n        abs_product = abs(product)\n        # Update the maximum absolute product found so far\n        max_product = max(max_product, abs_product)\n    \n    return max_product\n\n\n"], "responses": ["```python\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_product = float('-inf')\n    \n    for tuple_pair in list1:\n        # Calculate the product of the two numbers in the tuple\n        product = tuple_pair[0] * tuple_pair[1]\n        # Take the absolute value of the product\n        abs_product = abs(product)\n        # Update the maximum absolute product found so far\n        max_product = max(max_product, abs_product)\n    \n    return max_product\n```"], "prompt_tokens": [97], "completion_tokens": [142], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_120_max_product_tuple"}
{"name": "mbpp_230_replace_blank", "language": "Python3", "prompt": "def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n\tWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_blank", "test": "def check(candidate):\n    assert candidate('hello people', '@') == 'hello@people'\n    assert candidate('python program language', '$') == 'python$program$language'\n    assert candidate('blank space', '-') == 'blank-space'\n\ndef test_check():\n    check(replace_blank)\n\ntest_check()\n", "sample_io": ["assert replace_blank('hello people', '@') == 'hello@people'"], "source_codes": ["\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n\n\n"], "responses": ["```python\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n```"], "prompt_tokens": [94], "completion_tokens": [59], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_230_replace_blank"}
{"name": "mbpp_600_is_Even", "language": "Python3", "prompt": "def is_Even(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Even", "test": "def check(candidate):\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(3) == False\n\ndef test_check():\n    check(is_Even)\n\ntest_check()\n", "sample_io": ["assert is_Even(1) == False"], "source_codes": ["\ndef is_Even(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given number is even or not.\n    \"\"\"\n    return n % 2 == 0\n\n\n"], "responses": ["```python\ndef is_Even(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given number is even or not.\n    \"\"\"\n    return n % 2 == 0\n```"], "prompt_tokens": [79], "completion_tokens": [45], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_600_is_Even"}
{"name": "mbpp_440_find_adverb_position", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n\tWrite a function to find the first adverb and their positions in a given sentence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverb_position", "test": "def check(candidate):\n    assert candidate('clearly!! we can see the sky') == (0, 7, 'clearly')\n    assert candidate('seriously!! there are many roses') == (0, 9, 'seriously')\n    assert candidate('unfortunately!! sita is going to home') == (0, 13, 'unfortunately')\n\ndef test_check():\n    check(find_adverb_position)\n\ntest_check()\n", "sample_io": ["assert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')"], "source_codes": ["\nimport re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n    Returns a tuple of (start_position, end_position, adverb_text).\n    If no adverb is found, returns (-1, -1, \"\").\n    \"\"\"\n    # Common adverb patterns - words ending with 'ly'\n    # This is a simplified approach - a complete solution would use NLP libraries\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches\n    matches = list(re.finditer(pattern, text))\n    \n    if matches:\n        # Return the first match\n        first_match = matches[0]\n        start_pos = first_match.start()\n        end_pos = first_match.end()\n        adverb = first_match.group()\n        return (start_pos, end_pos, adverb)\n    else:\n        # No adverb found\n        return (-1, -1, \"\")\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    result = find_adverb_position(\"She quickly ran to the store.\")\n    print(result)  # Expected: (4, 11, \"quickly\")\n    \n    # Test case 2\n    result = find_adverb_position(\"He spoke very softly.\")\n    print(result)  # Expected: (10, 19, \"very\")\n    \n    # Test case 3\n    result = find_adverb_position(\"The cat sat quietly.\")\n    print(result)  # Expected: (12, 18, \"quietly\")\n    \n    # Test case 4 - no adverb\n    result = find_adverb_position(\"The dog ran fast.\")\n    print(result)  # Expected: (-1, -1, \"\")\n\n\n"], "responses": ["```python\nimport re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n    Returns a tuple of (start_position, end_position, adverb_text).\n    If no adverb is found, returns (-1, -1, \"\").\n    \"\"\"\n    # Common adverb patterns - words ending with 'ly'\n    # This is a simplified approach - a complete solution would use NLP libraries\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches\n    matches = list(re.finditer(pattern, text))\n    \n    if matches:\n        # Return the first match\n        first_match = matches[0]\n        start_pos = first_match.start()\n        end_pos = first_match.end()\n        adverb = first_match.group()\n        return (start_pos, end_pos, adverb)\n    else:\n        # No adverb found\n        return (-1, -1, \"\")\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    result = find_adverb_position(\"She quickly ran to the store.\")\n    print(result)  # Expected: (4, 11, \"quickly\")\n    \n    # Test case 2\n    result = find_adverb_position(\"He spoke very softly.\")\n    print(result)  # Expected: (10, 19, \"very\")\n    \n    # Test case 3\n    result = find_adverb_position(\"The cat sat quietly.\")\n    print(result)  # Expected: (12, 18, \"quietly\")\n    \n    # Test case 4 - no adverb\n    result = find_adverb_position(\"The dog ran fast.\")\n    print(result)  # Expected: (-1, -1, \"\")\n```"], "prompt_tokens": [92], "completion_tokens": [389], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_440_find_adverb_position"}
{"name": "mbpp_773_occurance_substring", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "occurance_substring", "test": "def check(candidate):\n    assert candidate('python programming, python language', 'python') == ('python', 0, 6)\n    assert candidate('python programming,programming language', 'programming') == ('programming', 7, 18)\n    assert candidate('python programming,programming language', 'language') == ('language', 31, 39)\n    assert candidate('c++ programming, c++ language', 'python') == None\n\ndef test_check():\n    check(occurance_substring)\n\ntest_check()\n", "sample_io": ["assert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"], "source_codes": ["\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n    \n    Args:\n        text: The string to search in\n        pattern: The substring to search for\n    \n    Returns:\n        A tuple containing (pattern, start_index, end_index) or None if not found\n    \"\"\"\n    # Handle edge cases\n    if not pattern:\n        return None\n    \n    # Find the first occurrence of the pattern\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate end index\n    end_index = start_index + len(pattern) - 1\n    \n    return (pattern, start_index, end_index)\n\n\n"], "responses": ["```python\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n    \n    Args:\n        text: The string to search in\n        pattern: The substring to search for\n    \n    Returns:\n        A tuple containing (pattern, start_index, end_index) or None if not found\n    \"\"\"\n    # Handle edge cases\n    if not pattern:\n        return None\n    \n    # Find the first occurrence of the pattern\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate end index\n    end_index = start_index + len(pattern) - 1\n    \n    return (pattern, start_index, end_index)\n```"], "prompt_tokens": [108], "completion_tokens": [186], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_773_occurance_substring"}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "Python3", "prompt": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_total_number_of_sequences", "test": "def check(candidate):\n    assert candidate(10, 4) == 4\n    assert candidate(5, 2) == 6\n    assert candidate(16, 3) == 84\n\ndef test_check():\n    check(get_total_number_of_sequences)\n\ntest_check()\n", "sample_io": ["assert get_total_number_of_sequences(10, 4) == 4"], "source_codes": ["\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n    \n    @lru_cache(maxsize=None)\n    def dp(pos, prev):\n        # Base case: if we've filled all positions\n        if pos == n:\n            return 1\n        \n        # Count valid sequences from this state\n        count = 0\n        # The current element must be >= 2*prev and <= m\n        start = 2 * prev\n        if start <= m:\n            for curr in range(start, m + 1):\n                count += dp(pos + 1, curr)\n        \n        return count\n    \n    # Start with position 0 and previous value 1 (since first element must be >= 1)\n    # But actually, we need to consider all possible first elements from 1 to m\n    total = 0\n    for first in range(1, m + 1):\n        total += dp(1, first)\n    \n    return total\n\n\n"], "responses": ["Looking at this problem, I need to count sequences of length `n` where each element is a positive integer, bounded by `m`, and each element is at least twice the previous element.\n\nLet me think about this step by step:\n\n1. This is a dynamic programming problem where I need to track valid sequences\n2. For each position in the sequence, I need to consider what values are valid given the previous element\n3. If the previous element is `prev`, then the current element must be in the range `[2*prev, m]`\n4. I can use memoization to avoid recomputing the same subproblems\n\nLet me define a recursive function with memoization:\n- State: `dp(pos, prev)` = number of ways to fill positions `pos` to `n-1` given that the element at position `pos-1` is `prev`\n- Base case: when `pos == n`, we have completed a valid sequence\n- Transition: for each valid value `curr` in `[2*prev, m]`, recursively compute `dp(pos+1, curr)`\n\n```python\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    from functools import lru_cache\n    \n    @lru_cache(maxsize=None)\n    def dp(pos, prev):\n        # Base case: if we've filled all positions\n        if pos == n:\n            return 1\n        \n        # Count valid sequences from this state\n        count = 0\n        # The current element must be >= 2*prev and <= m\n        start = 2 * prev\n        if start <= m:\n            for curr in range(start, m + 1):\n                count += dp(pos + 1, curr)\n        \n        return count\n    \n    # Start with position 0 and previous value 1 (since first element must be >= 1)\n    # But actually, we need to consider all possible first elements from 1 to m\n    total = 0\n    for first in range(1, m + 1):\n        total += dp(1, first)\n    \n    return total\n```"], "prompt_tokens": [119], "completion_tokens": [442], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_239_get_total_number_of_sequences"}
{"name": "mbpp_265_list_split", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_split", "test": "def check(candidate):\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]]\n    assert candidate(['python', 'java', 'C', 'C++', 'DBMS', 'SQL'], 2) == [['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]\n\ndef test_check():\n    check(list_split)\n\ntest_check()\n", "sample_io": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"], "source_codes": ["\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Takes in a list and an integer n and splits a list for every nth element,\n    returning a list of the resulting lists.\n    \"\"\"\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer\")\n    \n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i + step])\n    \n    return result\n\n\n"], "responses": ["```python\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n    Takes in a list and an integer n and splits a list for every nth element,\n    returning a list of the resulting lists.\n    \"\"\"\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer\")\n    \n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i:i + step])\n    \n    return result\n```"], "prompt_tokens": [106], "completion_tokens": [102], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_265_list_split"}
{"name": "mbpp_412_remove_odd", "language": "Python3", "prompt": "from typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove odd numbers from a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [2]\n    assert candidate([2, 4, 6]) == [2, 4, 6]\n    assert candidate([10, 20, 3]) == [10, 20]\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd([1, 2, 3]) == [2]"], "source_codes": ["\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [num for num in l if num % 2 == 0]\n\n\n"], "responses": ["```python\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [num for num in l if num % 2 == 0]\n```"], "prompt_tokens": [83], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_412_remove_odd"}
{"name": "mbpp_414_overlapping", "language": "Python3", "prompt": "from typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "overlapping", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False\n    assert candidate([1, 2, 3], [4, 5, 6]) == False\n    assert candidate([1, 4, 5], [1, 4, 5]) == True\n\ndef test_check():\n    check(overlapping)\n\ntest_check()\n", "sample_io": ["assert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"], "source_codes": ["\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence or not.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n\n\n"], "responses": ["```python\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence or not.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any intersection between the two sets\n    return bool(set1 & set2)\n```"], "prompt_tokens": [94], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_414_overlapping"}
{"name": "mbpp_160_find_solution", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_solution", "test": "def check(candidate):\n    assert candidate(2, 3, 7) == (2, 1)\n    assert candidate(4, 2, 7) == None\n    assert candidate(1, 13, 17) == (4, 1)\n\ndef test_check():\n    check(find_solution)\n\ntest_check()\n", "sample_io": ["assert find_solution(2, 3, 7) == (2, 1)"], "source_codes": ["\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    \"\"\"\n    # Handle special cases\n    if a == 0 and b == 0:\n        if n == 0:\n            return (0, 0)  # Any solution works, return (0,0)\n        else:\n            return None    # No solution exists\n    \n    if a == 0:\n        if n % b == 0:\n            return (0, n // b)\n        else:\n            return None\n    \n    if b == 0:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    \n    # Extended Euclidean Algorithm to find gcd and coefficients\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return x, 1, 0\n        else:\n            gcd, s, t = extended_gcd(y, x % y)\n            return gcd, t, s - (x // y) * t\n    \n    # Find gcd and coefficients\n    gcd, s, t = extended_gcd(a, b)\n    \n    # Check if solution exists\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution\n    scale = n // gcd\n    x = s * scale\n    y = t * scale\n    \n    return (x, y)\n\n\n"], "responses": ["```python\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    \"\"\"\n    # Handle special cases\n    if a == 0 and b == 0:\n        if n == 0:\n            return (0, 0)  # Any solution works, return (0,0)\n        else:\n            return None    # No solution exists\n    \n    if a == 0:\n        if n % b == 0:\n            return (0, n // b)\n        else:\n            return None\n    \n    if b == 0:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    \n    # Extended Euclidean Algorithm to find gcd and coefficients\n    def extended_gcd(x: int, y: int) -> Tuple[int, int, int]:\n        if y == 0:\n            return x, 1, 0\n        else:\n            gcd, s, t = extended_gcd(y, x % y)\n            return gcd, t, s - (x // y) * t\n    \n    # Find gcd and coefficients\n    gcd, s, t = extended_gcd(a, b)\n    \n    # Check if solution exists\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution\n    scale = n // gcd\n    x = s * scale\n    y = t * scale\n    \n    return (x, y)\n```"], "prompt_tokens": [111], "completion_tokens": [339], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_160_find_solution"}
{"name": "mbpp_559_max_sub_array_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of the largest contiguous sublist in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum", "test": "def check(candidate):\n    assert candidate([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    assert candidate([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8\n    assert candidate([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10\n\ndef test_check():\n    check(max_sub_array_sum)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"], "source_codes": ["\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the sum of the largest contiguous sublist in the given list using Kadane's algorithm.\n    \"\"\"\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        # Either extend the existing subarray or start a new one\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        # Update the maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "responses": ["```python\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n    Find the sum of the largest contiguous sublist in the given list using Kadane's algorithm.\n    \"\"\"\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        # Either extend the existing subarray or start a new one\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        # Update the maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```"], "prompt_tokens": [92], "completion_tokens": [150], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_559_max_sub_array_sum"}
{"name": "mbpp_809_check_smaller", "language": "Python3", "prompt": "from typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n\tWrite a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_smaller", "test": "def check(candidate):\n    assert candidate((1, 2, 3), (2, 3, 4)) == False\n    assert candidate((4, 5, 6), (3, 4, 5)) == True\n    assert candidate((11, 12, 13), (10, 11, 12)) == True\n\ndef test_check():\n    check(check_smaller)\n\ntest_check()\n", "sample_io": ["assert check_smaller((1, 2, 3), (2, 3, 4)) == False"], "source_codes": ["\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    return all(test_tup2[i] < test_tup1[i] for i in range(len(test_tup1)))\n\n\n"], "responses": ["```python\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    return all(test_tup2[i] < test_tup1[i] for i in range(len(test_tup1)))\n```"], "prompt_tokens": [111], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_809_check_smaller"}
{"name": "mbpp_629_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to find even numbers from a list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [2, 4]\n    assert candidate([4, 5, 6, 7, 8, 0, 1]) == [4, 6, 8, 0]\n    assert candidate([8, 12, 15, 19]) == [8, 12]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5]) == [2, 4]"], "source_codes": ["\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]\n\n\n"], "responses": ["```python\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]\n```"], "prompt_tokens": [83], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_629_Split"}
{"name": "mbpp_723_count_same_pair", "language": "Python3", "prompt": "from typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n\tThe input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_same_pair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 11\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 1\n    assert candidate([0, 1, 1, 2], [0, 1, 2, 2]) == 3\n\ndef test_check():\n    check(count_same_pair)\n\ntest_check()\n", "sample_io": ["assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"], "source_codes": ["\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n    \"\"\"\n    count = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n    \"\"\"\n    count = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            count += 1\n    return count\n```"], "prompt_tokens": [103], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_723_count_same_pair"}
{"name": "mbpp_242_count_charac", "language": "Python3", "prompt": "def count_charac(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the total number of characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_charac", "test": "def check(candidate):\n    assert candidate('python programming') == 18\n    assert candidate('language') == 8\n    assert candidate('words') == 5\n\ndef test_check():\n    check(count_charac)\n\ntest_check()\n", "sample_io": ["assert count_charac('python programming') == 18"], "source_codes": ["\ndef count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)\n\n\n"], "responses": ["```python\ndef count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)\n```"], "prompt_tokens": [79], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_242_count_charac"}
{"name": "mbpp_616_tuple_modulo", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function which takes two tuples of the same length and performs the element wise modulo.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_modulo", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n    assert candidate((11, 5, 6, 7), (6, 7, 8, 6)) == (5, 5, 6, 1)\n    assert candidate((12, 6, 7, 8), (7, 8, 9, 7)) == (5, 6, 7, 1)\n\ndef test_check():\n    check(tuple_modulo)\n\ntest_check()\n", "sample_io": ["assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)"], "source_codes": ["\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "responses": ["```python\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n```"], "prompt_tokens": [118], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_616_tuple_modulo"}
{"name": "mbpp_583_catalan_number", "language": "Python3", "prompt": "def catalan_number(num: int) -> int:\n    \"\"\"\n\tWrite a function which returns nth catalan number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "catalan_number", "test": "def check(candidate):\n    assert candidate(10) == 16796\n    assert candidate(9) == 4862\n    assert candidate(7) == 429\n\ndef test_check():\n    check(catalan_number)\n\ntest_check()\n", "sample_io": ["assert catalan_number(10) == 16796"], "source_codes": ["\ndef catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns nth catalan number.\n    \"\"\"\n    if num <= 1:\n        return 1\n    \n    # Using dynamic programming to calculate catalan numbers\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]\n\n\n"], "responses": ["```python\ndef catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns nth catalan number.\n    \"\"\"\n    if num <= 1:\n        return 1\n    \n    # Using dynamic programming to calculate catalan numbers\n    catalan = [0] * (num + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]\n```"], "prompt_tokens": [74], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_583_catalan_number"}
{"name": "mbpp_129_magic_square_test", "language": "Python3", "prompt": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to calculate whether the matrix is a magic square.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "magic_square_test", "test": "def check(candidate):\n    assert candidate([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n\ndef test_check():\n    check(magic_square_test)\n\ntest_check()\n", "sample_io": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True"], "source_codes": ["\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    \"\"\"\n    if not my_matrix or not my_matrix[0]:\n        return False\n    \n    n = len(my_matrix)\n    \n    # Check if matrix is square\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as reference\n    target_sum = sum(my_matrix[0])\n    \n    # Check all rows\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum:\n            return False\n    \n    # Check all columns\n    for j in range(n):\n        col_sum = sum(my_matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    diag_sum = sum(my_matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(my_matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n    \"\"\"\n    if not my_matrix or not my_matrix[0]:\n        return False\n    \n    n = len(my_matrix)\n    \n    # Check if matrix is square\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as reference\n    target_sum = sum(my_matrix[0])\n    \n    # Check all rows\n    for i in range(n):\n        if sum(my_matrix[i]) != target_sum:\n            return False\n    \n    # Check all columns\n    for j in range(n):\n        col_sum = sum(my_matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    diag_sum = sum(my_matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(my_matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n```"], "prompt_tokens": [85], "completion_tokens": [272], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_129_magic_square_test"}
{"name": "mbpp_61_count_Substrings", "language": "Python3", "prompt": "def count_Substrings(s: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Substrings", "test": "def check(candidate):\n    assert candidate('112112') == 6\n    assert candidate('111') == 6\n    assert candidate('1101112') == 12\n\ndef test_check():\n    check(count_Substrings)\n\ntest_check()\n", "sample_io": ["assert count_Substrings('112112') == 6"], "source_codes": ["\ndef count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    # For each starting position\n    for i in range(n):\n        digit_sum = 0\n        length = 0\n        \n        # Extend the substring from position i\n        for j in range(i, n):\n            # Add the current character to our calculations\n            if s[j].isdigit():\n                digit_sum += int(s[j])\n            else:\n                # If it's not a digit, we can't include it in valid substrings\n                break\n            \n            length += 1\n            \n            # Check if sum of digits equals length\n            if digit_sum == length:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["Looking at this problem, I need to count substrings where the sum of digits equals the length of the substring.\n\nLet me think through the approach:\n1. For each possible substring, calculate the sum of its digits\n2. Check if this sum equals the length of the substring\n3. Count all such substrings\n\nI can optimize this by using a nested loop approach where for each starting position, I extend the substring one character at a time, keeping track of both the running sum and length.\n\n```python\ndef count_Substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    # For each starting position\n    for i in range(n):\n        digit_sum = 0\n        length = 0\n        \n        # Extend the substring from position i\n        for j in range(i, n):\n            # Add the current character to our calculations\n            if s[j].isdigit():\n                digit_sum += int(s[j])\n            else:\n                # If it's not a digit, we can't include it in valid substrings\n                break\n            \n            length += 1\n            \n            # Check if sum of digits equals length\n            if digit_sum == length:\n                count += 1\n    \n    return count\n```"], "prompt_tokens": [85], "completion_tokens": [258], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_61_count_Substrings"}
{"name": "mbpp_287_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 20\n    assert candidate(3) == 56\n    assert candidate(4) == 120\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 20"], "source_codes": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n    \"\"\"\n    # First n even natural numbers are: 2, 4, 6, ..., 2n\n    # Sum of squares = 2^2 + 4^2 + 6^2 + ... + (2n)^2\n    # = 4(1^2 + 2^2 + 3^2 + ... + n^2)\n    # = 4 * n(n+1)(2n+1)/6\n    # = 2 * n(n+1)(2n+1)/3\n    \n    return 2 * n * (n + 1) * (2 * n + 1) // 3\n\n\n"], "responses": ["```python\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n    \"\"\"\n    # First n even natural numbers are: 2, 4, 6, ..., 2n\n    # Sum of squares = 2^2 + 4^2 + 6^2 + ... + (2n)^2\n    # = 4(1^2 + 2^2 + 3^2 + ... + n^2)\n    # = 4 * n(n+1)(2n+1)/6\n    # = 2 * n(n+1)(2n+1)/3\n    \n    return 2 * n * (n + 1) * (2 * n + 1) // 3\n```"], "prompt_tokens": [86], "completion_tokens": [182], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_287_square_Sum"}
{"name": "mbpp_93_power", "language": "Python3", "prompt": "def power(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the value of 'a' to the power 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power", "test": "def check(candidate):\n    assert candidate(3, 4) == 81\n    assert candidate(2, 3) == 8\n    assert candidate(5, 5) == 3125\n\ndef test_check():\n    check(power)\n\ntest_check()\n", "sample_io": ["assert power(3, 4) == 81"], "source_codes": ["\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    return a ** b\n\n\n"], "responses": ["```python\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    return a ** b\n```"], "prompt_tokens": [83], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_93_power"}
{"name": "mbpp_607_find_literals", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n\tWrite a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_literals", "test": "def check(candidate):\n    assert candidate('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    assert candidate('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)\n    assert candidate('Hardest choices required strongest will', 'will') == ('will', 35, 39)\n\ndef test_check():\n    check(find_literals)\n\ntest_check()\n", "sample_io": ["assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"], "source_codes": ["\nimport re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern. The function should return the matching substring, a start index and an end index.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        # Return empty string and -1 indices when no match is found\n        return (\"\", -1, -1)\n\n\n"], "responses": ["```python\nimport re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern. The function should return the matching substring, a start index and an end index.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        # Return empty string and -1 indices when no match is found\n        return (\"\", -1, -1)\n```"], "prompt_tokens": [106], "completion_tokens": [114], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_607_find_literals"}
{"name": "mbpp_94_index_minimum", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n\tGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_minimum", "test": "def check(candidate):\n    assert candidate([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    assert candidate([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'\n    assert candidate([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'\n\ndef test_check():\n    check(index_minimum)\n\ntest_check()\n", "sample_io": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"], "source_codes": ["\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_tuple = min(test_list, key=lambda x: x[1])\n    return min_tuple[0]\n\n\n"], "responses": ["```python\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_tuple = min(test_list, key=lambda x: x[1])\n    return min_tuple[0]\n```"], "prompt_tokens": [100], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_94_index_minimum"}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "Python3", "prompt": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sum_Of_Powers_Of_Two", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(7) == False\n    assert candidate(14) == True\n\ndef test_check():\n    check(is_Sum_Of_Powers_Of_Two)\n\ntest_check()\n", "sample_io": ["assert is_Sum_Of_Powers_Of_Two(10) == True"], "source_codes": ["\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \"\"\"\n    # A number can be represented as sum of non-zero powers of 2 if and only if it's positive\n    # Because any positive integer can be expressed as sum of distinct powers of 2 (binary representation)\n    # For example: 5 = 4 + 1 = 2^2 + 2^0, 6 = 4 + 2 = 2^2 + 2^1\n    # But 0 cannot be represented as sum of non-zero powers of 2\n    return n > 0\n\n\n"], "responses": ["```python\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \"\"\"\n    # A number can be represented as sum of non-zero powers of 2 if and only if it's positive\n    # Because any positive integer can be expressed as sum of distinct powers of 2 (binary representation)\n    # For example: 5 = 4 + 1 = 2^2 + 2^0, 6 = 4 + 2 = 2^2 + 2^1\n    # But 0 cannot be represented as sum of non-zero powers of 2\n    return n > 0\n```"], "prompt_tokens": [94], "completion_tokens": [158], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_138_is_Sum_Of_Powers_Of_Two"}
{"name": "mbpp_594_diff_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the difference of the first even and first odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "diff_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n    assert candidate([1, 5, 7, 9, 10]) == 9\n\ndef test_check():\n    check(diff_even_odd)\n\ntest_check()\n", "sample_io": ["assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"], "source_codes": ["\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference of the first even and first odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even number\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    # Find the first odd number\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    \n    # If both first even and first odd numbers exist, return their difference\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    \n    # If either first even or first odd number doesn't exist, return None or raise an exception\n    # Based on the function signature expecting an int return, we'll return 0 if one is missing\n    return 0\n\n\n"], "responses": ["```python\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the difference of the first even and first odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    # Find the first even number\n    for num in list1:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    # Find the first odd number\n    for num in list1:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    \n    # If both first even and first odd numbers exist, return their difference\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    \n    # If either first even or first odd number doesn't exist, return None or raise an exception\n    # Based on the function signature expecting an int return, we'll return 0 if one is missing\n    return 0\n```"], "prompt_tokens": [91], "completion_tokens": [204], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_594_diff_even_odd"}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "Python3", "prompt": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_binomial_Coeff_Sum", "test": "def check(candidate):\n    assert candidate(4) == 8\n    assert candidate(6) == 32\n    assert candidate(2) == 2\n\ndef test_check():\n    check(even_binomial_Coeff_Sum)\n\ntest_check()\n", "sample_io": ["assert even_binomial_Coeff_Sum(4) == 8"], "source_codes": ["\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Find the sum of even index binomial coefficients for (1+x)^n\n    This is equivalent to finding the sum of C(n,0) + C(n,2) + C(n,4) + ...\n    \"\"\"\n    # Using the property that sum of even index coefficients = 2^(n-1)\n    # This can be derived from binomial theorem:\n    # (1+1)^n = sum of all coefficients = 2^n\n    # (1-1)^n = alternating sum = 0\n    # Adding these: 2 * (sum of even coefficients) = 2^n\n    # Therefore: sum of even coefficients = 2^(n-1)\n    \n    if n == 0:\n        return 1\n    \n    return 2 ** (n - 1)\n\n\n"], "responses": ["```python\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Find the sum of even index binomial coefficients for (1+x)^n\n    This is equivalent to finding the sum of C(n,0) + C(n,2) + C(n,4) + ...\n    \"\"\"\n    # Using the property that sum of even index coefficients = 2^(n-1)\n    # This can be derived from binomial theorem:\n    # (1+1)^n = sum of all coefficients = 2^n\n    # (1-1)^n = alternating sum = 0\n    # Adding these: 2 * (sum of even coefficients) = 2^n\n    # Therefore: sum of even coefficients = 2^(n-1)\n    \n    if n == 0:\n        return 1\n    \n    return 2 ** (n - 1)\n```"], "prompt_tokens": [90], "completion_tokens": [190], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_274_even_binomial_Coeff_Sum"}
{"name": "mbpp_126_sum", "language": "Python3", "prompt": "def sum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of common divisors of two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum", "test": "def check(candidate):\n    assert candidate(10, 15) == 6\n    assert candidate(100, 150) == 93\n    assert candidate(4, 6) == 3\n\ndef test_check():\n    check(sum)\n\ntest_check()\n", "sample_io": ["assert sum(10, 15) == 6"], "source_codes": ["\ndef sum(a: int, b: int) -> int:\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n    \"\"\"\n    # Find the greatest common divisor (GCD) of a and b\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Get the GCD of a and b\n    gcd_value = gcd(a, b)\n    \n    # Find all divisors of the GCD and sum them up\n    divisor_sum = 0\n    for i in range(1, int(gcd_value**0.5) + 1):\n        if gcd_value % i == 0:\n            divisor_sum += i\n            # Add the corresponding divisor (gcd_value // i) if it's different from i\n            if i != gcd_value // i:\n                divisor_sum += gcd_value // i\n    \n    return divisor_sum\n\n\n"], "responses": ["```python\ndef sum(a: int, b: int) -> int:\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n    \"\"\"\n    # Find the greatest common divisor (GCD) of a and b\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Get the GCD of a and b\n    gcd_value = gcd(a, b)\n    \n    # Find all divisors of the GCD and sum them up\n    divisor_sum = 0\n    for i in range(1, int(gcd_value**0.5) + 1):\n        if gcd_value % i == 0:\n            divisor_sum += i\n            # Add the corresponding divisor (gcd_value // i) if it's different from i\n            if i != gcd_value // i:\n                divisor_sum += gcd_value // i\n    \n    return divisor_sum\n```"], "prompt_tokens": [83], "completion_tokens": [198], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_126_sum"}
{"name": "mbpp_769_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the difference between two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Diff", "test": "def check(candidate):\n    assert candidate([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 1]) == [2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3], [6, 7, 1]) == [2, 3, 6, 7]\n\ndef test_check():\n    check(Diff)\n\ntest_check()\n", "sample_io": ["assert Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"], "source_codes": ["\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    return [item for item in li1 if item not in li2]\n\n\n"], "responses": ["```python\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to get the difference between two lists.\n    \"\"\"\n    return [item for item in li1 if item not in li2]\n```"], "prompt_tokens": [88], "completion_tokens": [55], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_769_Diff"}
{"name": "mbpp_796_return_sum", "language": "Python3", "prompt": "from typing import Dict\n\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n\tWrite function to find the sum of all items in the given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_796_return_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "return_sum", "test": "def check(candidate):\n    assert candidate({ 'a': 100, 'b': 200, 'c': 300 }) == 600\n    assert candidate({ 'a': 25, 'b': 18, 'c': 45 }) == 88\n    assert candidate({ 'a': 36, 'b': 39, 'c': 49 }) == 124\n\ndef test_check():\n    check(return_sum)\n\ntest_check()\n", "sample_io": ["assert return_sum({ 'a': 100, 'b': 200, 'c': 300 }) == 600"], "source_codes": ["\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n    Write function to find the sum of all items in the given dictionary.\n    \"\"\"\n    return sum(dict.values())\n\n\n"], "responses": ["```python\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n    Write function to find the sum of all items in the given dictionary.\n    \"\"\"\n    return sum(dict.values())\n```"], "prompt_tokens": [85], "completion_tokens": [42], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_796_return_sum"}
{"name": "mbpp_574_surfacearea_cylinder", "language": "Python3", "prompt": "def surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the surface area of a cylinder.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cylinder", "test": "def check(candidate):\n    assert candidate(10, 5) == 942.45\n    assert candidate(4, 5) == 226.18800000000002\n    assert candidate(4, 10) == 351.848\n\ndef test_check():\n    check(surfacearea_cylinder)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cylinder(10, 5) == 942.45"], "source_codes": ["\nimport math\n\ndef surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n    Find the surface area of a cylinder.\n    \n    Surface area = 2πr² + 2πrh\n    where r is radius and h is height\n    \n    Args:\n        r (int): radius of the cylinder\n        h (int): height of the cylinder\n    \n    Returns:\n        float: surface area of the cylinder\n    \"\"\"\n    # Calculate the surface area using the formula\n    # Surface area = 2πr² + 2πrh = 2πr(r + h)\n    surface_area = 2 * math.pi * r * (r + h)\n    \n    return surface_area\n\n\n"], "responses": ["```python\nimport math\n\ndef surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n    Find the surface area of a cylinder.\n    \n    Surface area = 2πr² + 2πrh\n    where r is radius and h is height\n    \n    Args:\n        r (int): radius of the cylinder\n        h (int): height of the cylinder\n    \n    Returns:\n        float: surface area of the cylinder\n    \"\"\"\n    # Calculate the surface area using the formula\n    # Surface area = 2πr² + 2πrh = 2πr(r + h)\n    surface_area = 2 * math.pi * r * (r + h)\n    \n    return surface_area\n```"], "prompt_tokens": [81], "completion_tokens": [154], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_574_surfacearea_cylinder"}
{"name": "mbpp_783_rgb_to_hsv", "language": "Python3", "prompt": "from typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    \"\"\"\n\tWrite a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rgb_to_hsv", "test": "def check(candidate):\n    assert candidate(255, 255, 255) == [0.0, 0.0, 100.0]\n    assert candidate(0, 215, 0) == [120.0, 100.0, 84.31372549019608]\n    assert candidate(10, 215, 110) == [149.26829268292684, 95.34883720930233, 84.31372549019608]\n\ndef test_check():\n    check(rgb_to_hsv)\n\ntest_check()\n", "sample_io": ["assert rgb_to_hsv(255, 255, 255) == [0.0, 0.0, 100.0]"], "source_codes": ["\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Normalize RGB values to range [0, 1]\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n    \n    # Find maximum and minimum values\n    c_max = max(r_norm, g_norm, b_norm)\n    c_min = min(r_norm, g_norm, b_norm)\n    diff = c_max - c_min\n    \n    # Calculate Hue\n    if diff == 0:\n        h = 0\n    elif c_max == r_norm:\n        h = (60 * ((g_norm - b_norm) / diff) + 360) % 360\n    elif c_max == g_norm:\n        h = (60 * ((b_norm - r_norm) / diff) + 120) % 360\n    else:  # c_max == b_norm\n        h = (60 * ((r_norm - g_norm) / diff) + 240) % 360\n    \n    # Calculate Saturation\n    if c_max == 0:\n        s = 0\n    else:\n        s = (diff / c_max) * 100\n    \n    # Calculate Value\n    v = c_max * 100\n    \n    return [h, s, v]\n\n\n"], "responses": ["```python\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Normalize RGB values to range [0, 1]\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n    \n    # Find maximum and minimum values\n    c_max = max(r_norm, g_norm, b_norm)\n    c_min = min(r_norm, g_norm, b_norm)\n    diff = c_max - c_min\n    \n    # Calculate Hue\n    if diff == 0:\n        h = 0\n    elif c_max == r_norm:\n        h = (60 * ((g_norm - b_norm) / diff) + 360) % 360\n    elif c_max == g_norm:\n        h = (60 * ((b_norm - r_norm) / diff) + 120) % 360\n    else:  # c_max == b_norm\n        h = (60 * ((r_norm - g_norm) / diff) + 240) % 360\n    \n    # Calculate Saturation\n    if c_max == 0:\n        s = 0\n    else:\n        s = (diff / c_max) * 100\n    \n    # Calculate Value\n    v = c_max * 100\n    \n    return [h, s, v]\n```"], "prompt_tokens": [110], "completion_tokens": [317], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_783_rgb_to_hsv"}
{"name": "mbpp_70_get_equal", "language": "Python3", "prompt": "from typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to find whether all the given lists have equal length or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_equal", "test": "def check(candidate):\n    assert candidate([[11, 22, 33], [44, 55, 66]]) == True\n    assert candidate([[1, 2, 3], [4, 5, 6, 7]]) == False\n    assert candidate([[1, 2], [3, 4]]) == True\n\ndef test_check():\n    check(get_equal)\n\ntest_check()\n", "sample_io": ["assert get_equal([[11, 22, 33], [44, 55, 66]]) == True"], "source_codes": ["\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to find whether all the given lists have equal length or not.\n    \"\"\"\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    \n    for lst in Input:\n        if len(lst) != first_length:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n    Write a function to find whether all the given lists have equal length or not.\n    \"\"\"\n    if not Input:\n        return True\n    \n    first_length = len(Input[0])\n    \n    for lst in Input:\n        if len(lst) != first_length:\n            return False\n    \n    return True\n```"], "prompt_tokens": [86], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_70_get_equal"}
{"name": "mbpp_267_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 10\n    assert candidate(3) == 35\n    assert candidate(4) == 84\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 10"], "source_codes": ["\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i * i\n    return total\n\n\n"], "responses": ["```python\ndef square_Sum(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, 2 * n + 1, 2):\n        total += i * i\n    return total\n```"], "prompt_tokens": [89], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_267_square_Sum"}
{"name": "mbpp_171_perimeter_pentagon", "language": "Python3", "prompt": "def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n\tWrite a function to find the perimeter of a regular pentagon from the length of its sides.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perimeter_pentagon", "test": "def check(candidate):\n    assert candidate(5) == 25\n    assert candidate(10) == 50\n    assert candidate(15) == 75\n\ndef test_check():\n    check(perimeter_pentagon)\n\ntest_check()\n", "sample_io": ["assert perimeter_pentagon(5) == 25"], "source_codes": ["\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a\n\n\n"], "responses": ["```python\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a\n```"], "prompt_tokens": [84], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_171_perimeter_pentagon"}
{"name": "mbpp_222_check_type", "language": "Python3", "prompt": "from typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if all the elements in tuple have same data type or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_type", "test": "def check(candidate):\n    assert candidate((5, 6, 7, 3, 5, 6)) == True\n    assert candidate((1, 2, '4')) == False\n    assert candidate((3, 2, 1, 4, 5)) == True\n\ndef test_check():\n    check(check_type)\n\ntest_check()\n", "sample_io": ["assert check_type((5, 6, 7, 3, 5, 6)) == True"], "source_codes": ["\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    if not test_tuple:  # Handle empty tuple\n        return True\n    \n    first_type = type(test_tuple[0])\n    return all(type(element) == first_type for element in test_tuple)\n\n\n"], "responses": ["```python\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n    \"\"\"\n    if not test_tuple:  # Handle empty tuple\n        return True\n    \n    first_type = type(test_tuple[0])\n    return all(type(element) == first_type for element in test_tuple)\n```"], "prompt_tokens": [87], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_222_check_type"}
{"name": "mbpp_164_are_equivalent", "language": "Python3", "prompt": "def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n\tWrite a function to determine if the sum of the divisors of two integers are the same.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "are_equivalent", "test": "def check(candidate):\n    assert candidate(36, 57) == False\n    assert candidate(2, 4) == False\n    assert candidate(23, 47) == True\n\ndef test_check():\n    check(are_equivalent)\n\ntest_check()\n", "sample_io": ["assert are_equivalent(36, 57) == False"], "source_codes": ["\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisor_sum += i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n\n\n"], "responses": ["```python\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    \n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisor_sum += i\n        return divisor_sum\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n```"], "prompt_tokens": [89], "completion_tokens": [128], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_164_are_equivalent"}
{"name": "mbpp_803_is_perfect_square", "language": "Python3", "prompt": "def is_perfect_square(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_perfect_square", "test": "def check(candidate):\n    assert candidate(10) == False\n    assert candidate(36) == True\n    assert candidate(14) == False\n    assert candidate(196) == True\n    assert candidate(125) == False\n    assert candidate(15625) == True\n\ndef test_check():\n    check(is_perfect_square)\n\ntest_check()\n", "sample_io": ["assert is_perfect_square(10) == False"], "source_codes": ["\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search approach\n    left, right = 1, n // 2 + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search approach\n    left, right = 1, n // 2 + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n```"], "prompt_tokens": [102], "completion_tokens": [175], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_803_is_perfect_square"}
{"name": "mbpp_305_start_withp", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n\tWrite a function to return two words from a list of words starting with letter 'p'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "start_withp", "test": "def check(candidate):\n    assert candidate(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')\n    assert candidate(['Python Programming', 'Java Programming']) == ('Python', 'Programming')\n    assert candidate(['Pqrst Pqr', 'qrstuv']) == ('Pqrst', 'Pqr')\n\ndef test_check():\n    check(start_withp)\n\ntest_check()\n", "sample_io": ["assert start_withp(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')"], "source_codes": ["\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = [word for word in words if word.lower().startswith('p')]\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    else:\n        raise ValueError(\"Not enough words starting with 'p'\")\n\n\n"], "responses": ["```python\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = [word for word in words if word.lower().startswith('p')]\n    \n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    else:\n        raise ValueError(\"Not enough words starting with 'p'\")\n```"], "prompt_tokens": [93], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_305_start_withp"}
{"name": "mbpp_617_min_Jumps", "language": "Python3", "prompt": "from typing import Tuple\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n\tWrite a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Jumps", "test": "def check(candidate):\n    assert candidate((3, 4), 11) == 3.5\n    assert candidate((3, 4), 0) == 0\n    assert candidate((11, 14), 11) == 1\n\ndef test_check():\n    check(min_Jumps)\n\ntest_check()\n", "sample_io": ["assert min_Jumps((3, 4), 11) == 3.5"], "source_codes": ["\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n    Find the minimum number of jumps required to reach point (d, 0) from origin (0, 0)\n    using jumps of given lengths in a 2D plane.\n    \n    Args:\n        steps: A tuple containing two jump lengths (a, b)\n        d: Target distance on x-axis\n    \n    Returns:\n        Minimum number of jumps required, or infinity if impossible\n    \"\"\"\n    a, b = steps\n    \n    # If d is 0, we're already at target\n    if d == 0:\n        return 0.0\n    \n    # If both jump lengths are 0, impossible to move\n    if a == 0 and b == 0:\n        return float('inf')\n    \n    # If one jump length is 0, only use the other\n    if a == 0:\n        if d % b == 0:\n            return float(abs(d) // b)\n        else:\n            return float('inf')\n    \n    if b == 0:\n        if d % a == 0:\n            return float(abs(d) // a)\n        else:\n            return float('inf')\n    \n    # Both jumps available - use BFS to find minimum jumps\n    from collections import deque\n    \n    # Queue stores (x, y, jumps_count)\n    queue = deque([(0, 0, 0)])\n    visited = set()\n    visited.add((0, 0))\n    \n    # Limit search to reasonable bounds\n    max_distance = abs(d) + max(a, b)\n    \n    while queue:\n        x, y, jumps = queue.popleft()\n        \n        # Check if we reached the target\n        if x == d and y == 0:\n            return float(jumps)\n        \n        # If we've made too many jumps or gone too far, skip\n        if jumps > abs(d) + 10:  # Reasonable upper bound\n            continue\n            \n        # Try both jump types in all directions\n        # Jump of length a\n        for dx, dy in [(a, 0), (-a, 0), (0, a), (0, -a)]:\n            new_x, new_y = x + dx, y + dy\n            if (new_x, new_y) not in visited and abs(new_x) <= max_distance and abs(new_y) <= max_distance:\n                visited.add((new_x, new_y))\n                queue.append((new_x, new_y, jumps + 1))\n        \n        # Jump of length b\n        for dx, dy in [(b, 0), (-b, 0), (0, b), (0, -b)]:\n            new_x, new_y = x + dx, y + dy\n            if (new_x, new_y) not in visited and abs(new_x) <= max_distance and abs(new_y) <= max_distance:\n                visited.add((new_x, new_y))\n                queue.append((new_x, new_y, jumps + 1))\n    \n    # If we can't reach the target\n    return float('inf')\n\n\n"], "responses": ["```python\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n    Find the minimum number of jumps required to reach point (d, 0) from origin (0, 0)\n    using jumps of given lengths in a 2D plane.\n    \n    Args:\n        steps: A tuple containing two jump lengths (a, b)\n        d: Target distance on x-axis\n    \n    Returns:\n        Minimum number of jumps required, or infinity if impossible\n    \"\"\"\n    a, b = steps\n    \n    # If d is 0, we're already at target\n    if d == 0:\n        return 0.0\n    \n    # If both jump lengths are 0, impossible to move\n    if a == 0 and b == 0:\n        return float('inf')\n    \n    # If one jump length is 0, only use the other\n    if a == 0:\n        if d % b == 0:\n            return float(abs(d) // b)\n        else:\n            return float('inf')\n    \n    if b == 0:\n        if d % a == 0:\n            return float(abs(d) // a)\n        else:\n            return float('inf')\n    \n    # Both jumps available - use BFS to find minimum jumps\n    from collections import deque\n    \n    # Queue stores (x, y, jumps_count)\n    queue = deque([(0, 0, 0)])\n    visited = set()\n    visited.add((0, 0))\n    \n    # Limit search to reasonable bounds\n    max_distance = abs(d) + max(a, b)\n    \n    while queue:\n        x, y, jumps = queue.popleft()\n        \n        # Check if we reached the target\n        if x == d and y == 0:\n            return float(jumps)\n        \n        # If we've made too many jumps or gone too far, skip\n        if jumps > abs(d) + 10:  # Reasonable upper bound\n            continue\n            \n        # Try both jump types in all directions\n        # Jump of length a\n        for dx, dy in [(a, 0), (-a, 0), (0, a), (0, -a)]:\n            new_x, new_y = x + dx, y + dy\n            if (new_x, new_y) not in visited and abs(new_x) <= max_distance and abs(new_y) <= max_distance:\n                visited.add((new_x, new_y))\n                queue.append((new_x, new_y, jumps + 1))\n        \n        # Jump of length b\n        for dx, dy in [(b, 0), (-b, 0), (0, b), (0, -b)]:\n            new_x, new_y = x + dx, y + dy\n            if (new_x, new_y) not in visited and abs(new_x) <= max_distance and abs(new_y) <= max_distance:\n                visited.add((new_x, new_y))\n                queue.append((new_x, new_y, jumps + 1))\n    \n    # If we can't reach the target\n    return float('inf')\n```"], "prompt_tokens": [111], "completion_tokens": [661], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_617_min_Jumps"}
{"name": "mbpp_117_list_to_float", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n\tWrite a function to convert all possible convertible elements in a list of lists to floats.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_to_float", "test": "def check(candidate):\n    assert candidate([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\n    assert candidate([('4', '4'), ('2', '27'), ('4.12', '9'), ('7', '11')]) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\n    assert candidate([('6', '78'), ('5', '26.45'), ('1.33', '4'), ('82', '13')]) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\n\ndef test_check():\n    check(list_to_float)\n\ntest_check()\n", "sample_io": ["assert list_to_float([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Write a function to convert all possible convertible elements in a list of lists to floats.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        converted_tuple = []\n        for element in tuple_item:\n            try:\n                converted_tuple.append(float(element))\n            except ValueError:\n                # If conversion fails, keep the original element\n                converted_tuple.append(element)\n        result.append(tuple(converted_tuple))\n    return result\n\n\n"], "responses": ["```python\nfrom typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Write a function to convert all possible convertible elements in a list of lists to floats.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        converted_tuple = []\n        for element in tuple_item:\n            try:\n                converted_tuple.append(float(element))\n            except ValueError:\n                # If conversion fails, keep the original element\n                converted_tuple.append(element)\n        result.append(tuple(converted_tuple))\n    return result\n```"], "prompt_tokens": [99], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_117_list_to_float"}
{"name": "mbpp_425_count_element_in_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n\tWrite a function to count the number of sublists containing a particular element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_425_count_element_in_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_element_in_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'A') == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'E') == 1\n\ndef test_check():\n    check(count_element_in_list)\n\ntest_check()\n", "sample_io": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"], "source_codes": ["\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n        list1: A list of lists\n        x: The element to search for\n        \n    Returns:\n        The count of sublists that contain the element x\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n        list1: A list of lists\n        x: The element to search for\n        \n    Returns:\n        The count of sublists that contain the element x\n    \"\"\"\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [106], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_425_count_element_in_list"}
{"name": "mbpp_67_bell_number", "language": "Python3", "prompt": "def bell_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the number of ways to partition a set of Bell numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(10) == 115975\n    assert candidate(56) == 6775685320645824322581483068371419745979053216268760300\n\ndef test_check():\n    check(bell_number)\n\ntest_check()\n", "sample_io": ["assert bell_number(2) == 2"], "source_codes": ["\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Args:\n        n: Non-negative integer\n        \n    Returns:\n        The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Initialize Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle using the recurrence relation\n    for i in range(1, n + 1):\n        # First element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]\n\n\n"], "responses": ["```python\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Args:\n        n: Non-negative integer\n        \n    Returns:\n        The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Initialize Bell triangle\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle using the recurrence relation\n    for i in range(1, n + 1):\n        # First element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]\n```"], "prompt_tokens": [80], "completion_tokens": [237], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_67_bell_number"}
{"name": "mbpp_404_minimum", "language": "Python3", "prompt": "def minimum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "minimum", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(-5, -4) == -5\n    assert candidate(0, 0) == 0\n\ndef test_check():\n    check(minimum)\n\ntest_check()\n", "sample_io": ["assert minimum(1, 2) == 1"], "source_codes": ["\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n\n\n"], "responses": ["```python\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n```"], "prompt_tokens": [78], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_404_minimum"}
{"name": "mbpp_14_find_Volume", "language": "Python3", "prompt": "def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n\tWrite a python function to find the volume of a triangular prism.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Volume", "test": "def check(candidate):\n    assert candidate(10, 8, 6) == 240\n    assert candidate(3, 2, 2) == 6\n    assert candidate(1, 2, 1) == 1\n\ndef test_check():\n    check(find_Volume)\n\ntest_check()\n", "sample_io": ["assert find_Volume(10, 8, 6) == 240"], "source_codes": ["\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Write a python function to find the volume of a triangular prism.\n    \"\"\"\n    # Volume of triangular prism = (1/2) * base * height * length\n    # where base and height are of the triangular face\n    # and length is the depth/length of the prism\n    return (l * b * h) // 2\n\n\n"], "responses": ["```python\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Write a python function to find the volume of a triangular prism.\n    \"\"\"\n    # Volume of triangular prism = (1/2) * base * height * length\n    # where base and height are of the triangular face\n    # and length is the depth/length of the prism\n    return (l * b * h) // 2\n```"], "prompt_tokens": [85], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_14_find_Volume"}
{"name": "mbpp_8_square_nums", "language": "Python3", "prompt": "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find squares of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30]) == [100, 400, 900]\n    assert candidate([12, 15]) == [144, 225]\n\ndef test_check():\n    check(square_nums)\n\ntest_check()\n", "sample_io": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]\n\n\n"], "responses": ["```python\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [num ** 2 for num in nums]\n```"], "prompt_tokens": [83], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_8_square_nums"}
{"name": "mbpp_722_filter_data", "language": "Python3", "prompt": "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n\tThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_data", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.9, 67) == { 'Cierra Vega': (6.2, 70), 'Kierra Gentry': (6.0, 68) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.7, 64) == { 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }\n\ndef test_check():\n    check(filter_data)\n\ntest_check()\n", "sample_io": ["assert filter_data({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }"], "source_codes": ["\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n    Filter students that have height and weight above the minimum.\n    \n    Args:\n        students: Dictionary with student names as keys and (height, weight) tuples as values\n        h: Minimum height threshold\n        w: Minimum weight threshold\n    \n    Returns:\n        Dictionary containing only students who meet both height and weight criteria\n    \"\"\"\n    filtered_students = {}\n    \n    for name, (height, weight) in students.items():\n        if height > h and weight > w:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students\n\n\n"], "responses": ["```python\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n    Filter students that have height and weight above the minimum.\n    \n    Args:\n        students: Dictionary with student names as keys and (height, weight) tuples as values\n        h: Minimum height threshold\n        w: Minimum weight threshold\n    \n    Returns:\n        Dictionary containing only students who meet both height and weight criteria\n    \"\"\"\n    filtered_students = {}\n    \n    for name, (height, weight) in students.items():\n        if height > h and weight > w:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students\n```"], "prompt_tokens": [145], "completion_tokens": [150], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_722_filter_data"}
{"name": "mbpp_244_next_Perfect_Square", "language": "Python3", "prompt": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n\tWrite a python function to find the next perfect square greater than a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_Perfect_Square", "test": "def check(candidate):\n    assert candidate(35) == 36\n    assert candidate(6) == 9\n    assert candidate(9) == 16\n\ndef test_check():\n    check(next_Perfect_Square)\n\ntest_check()\n", "sample_io": ["assert next_Perfect_Square(35) == 36"], "source_codes": ["\ndef next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Find the next perfect square greater than a given number.\n    \n    Args:\n        N (int): The given number\n        \n    Returns:\n        int: The next perfect square greater than N\n    \"\"\"\n    # Find the square root of N and take the ceiling\n    import math\n    sqrt_N = math.ceil(math.sqrt(N))\n    \n    # If N is already a perfect square, we need the next one\n    if sqrt_N * sqrt_N == N:\n        sqrt_N += 1\n    \n    # Return the next perfect square\n    return sqrt_N * sqrt_N\n\n\n"], "responses": ["```python\ndef next_Perfect_Square(N: int) -> int:\n    \"\"\"\n    Find the next perfect square greater than a given number.\n    \n    Args:\n        N (int): The given number\n        \n    Returns:\n        int: The next perfect square greater than N\n    \"\"\"\n    # Find the square root of N and take the ceiling\n    import math\n    sqrt_N = math.ceil(math.sqrt(N))\n    \n    # If N is already a perfect square, we need the next one\n    if sqrt_N * sqrt_N == N:\n        sqrt_N += 1\n    \n    # Return the next perfect square\n    return sqrt_N * sqrt_N\n```"], "prompt_tokens": [82], "completion_tokens": [137], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_244_next_Perfect_Square"}
{"name": "mbpp_755_second_smallest", "language": "Python3", "prompt": "from typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find the second smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "second_smallest", "test": "def check(candidate):\n    assert candidate([1, 2, -8, -2, 0, -2]) == -2\n    assert candidate([1, 1, -0.5, 0, 2, -2, -2]) == -0.5\n    assert candidate([2, 2]) == None\n    assert candidate([2, 2, 2]) == None\n\ndef test_check():\n    check(second_smallest)\n\ntest_check()\n", "sample_io": ["assert second_smallest([1, 2, -8, -2, 0, -2]) == -2"], "source_codes": ["\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n    Find the second smallest number in a list.\n    \n    Args:\n        numbers: A list of integers or floats\n        \n    Returns:\n        The second smallest number, or None if there are fewer than 2 distinct numbers\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 distinct numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest\n    return float(unique_numbers[1])\n\n\n"], "responses": ["```python\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n    Find the second smallest number in a list.\n    \n    Args:\n        numbers: A list of integers or floats\n        \n    Returns:\n        The second smallest number, or None if there are fewer than 2 distinct numbers\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    # Remove duplicates and sort\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 distinct numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest\n    return float(unique_numbers[1])\n```"], "prompt_tokens": [92], "completion_tokens": [142], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_755_second_smallest"}
{"name": "mbpp_405_check_tuplex", "language": "Python3", "prompt": "from typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n\tWrite a function to check whether an element exists within a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_405_check_tuplex.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_tuplex", "test": "def check(candidate):\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], '5') == False\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 3) == True\n\ndef test_check():\n    check(check_tuplex)\n\ntest_check()\n", "sample_io": ["assert check_tuplex(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True"], "source_codes": ["\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex\n\n\n"], "responses": ["```python\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n    Write a function to check whether an element exists within a tuple.\n    \"\"\"\n    return tuple1 in tuplex\n```"], "prompt_tokens": [99], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_405_check_tuplex"}
{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n\n\n"], "responses": ["```python\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n    \"\"\"\n    return n // m\n```"], "prompt_tokens": [84], "completion_tokens": [46], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": ["\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Start with list of numbers from 1 to n\n    candidates = list(range(1, n + 1))\n    ludic_numbers = []\n    index = 0\n    \n    while index < len(candidates):\n        # The current number is ludic\n        ludic_num = candidates[index]\n        ludic_numbers.append(ludic_num)\n        \n        # Remove every ludic_num-th element from the remaining list\n        # Start from the next position after current index\n        new_candidates = []\n        for i in range(index + 1):\n            new_candidates.append(candidates[i])\n        \n        # Remove every ludic_num-th element starting from index+1\n        count = 0\n        for i in range(index + 1, len(candidates)):\n            count += 1\n            if count % ludic_num != 0:\n                new_candidates.append(candidates[i])\n        \n        candidates = new_candidates\n        index += 1\n    \n    return ludic_numbers\n\n\n"], "responses": ["Looking at this problem, I need to generate Ludic numbers (also known as Lucid numbers) up to a given integer n.\n\nLudic numbers are generated using a sieve-like process:\n1. Start with the list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]\n2. The first number (1) is ludic\n3. Remove every 1st number from the remaining list (which removes nothing)\n4. The next number (2) is ludic\n5. Remove every 2nd number from the remaining list\n6. The next number (3) is ludic\n7. Remove every 3rd number from the remaining list\n8. Continue this process...\n\nLet me implement this algorithm:\n\n```python\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Start with list of numbers from 1 to n\n    candidates = list(range(1, n + 1))\n    ludic_numbers = []\n    index = 0\n    \n    while index < len(candidates):\n        # The current number is ludic\n        ludic_num = candidates[index]\n        ludic_numbers.append(ludic_num)\n        \n        # Remove every ludic_num-th element from the remaining list\n        # Start from the next position after current index\n        new_candidates = []\n        for i in range(index + 1):\n            new_candidates.append(candidates[i])\n        \n        # Remove every ludic_num-th element starting from index+1\n        count = 0\n        for i in range(index + 1, len(candidates)):\n            count += 1\n            if count % ludic_num != 0:\n                new_candidates.append(candidates[i])\n        \n        candidates = new_candidates\n        index += 1\n    \n    return ludic_numbers\n```"], "prompt_tokens": [89], "completion_tokens": [400], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # sum_ending_here: sum of products of all subarrays ending at current position\n    # total_sum: cumulative sum of all products so far\n    sum_ending_here = 0\n    total_sum = 0\n    \n    for num in arr:\n        # All previous subarrays ending at previous position can be extended\n        # by multiplying with current number, plus current number alone\n        sum_ending_here = sum_ending_here * num + num\n        total_sum += sum_ending_here\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of products of all possible subarrays (contiguous subsequences) of a given list.\n\nLet me think about an efficient approach. Instead of generating all subarrays explicitly, I can use a mathematical insight:\n\nFor each element at index i, I need to count how many subarrays include this element and contribute its value to the product. \n\nHowever, there's a more direct approach using dynamic programming. For each position, I can keep track of the sum of products of all subarrays ending at that position.\n\nLet me trace through a small example:\n- For array [1, 2, 3]:\n  - Subarrays: [1], [2], [3], [1,2], [2,3], [1,2,3]\n  - Products: 1, 2, 3, 2, 6, 6\n  - Sum: 1+2+3+2+6+6 = 20\n\nA better approach is to use the fact that when we add a new element, all previous subarrays can be extended by multiplying with this element, plus the new element itself forms a new subarray.\n\n```python\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # sum_ending_here: sum of products of all subarrays ending at current position\n    # total_sum: cumulative sum of all products so far\n    sum_ending_here = 0\n    total_sum = 0\n    \n    for num in arr:\n        # All previous subarrays ending at previous position can be extended\n        # by multiplying with current number, plus current number alone\n        sum_ending_here = sum_ending_here * num + num\n        total_sum += sum_ending_here\n    \n    return total_sum\n```"], "prompt_tokens": [111], "completion_tokens": [386], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Extract values between quotation marks from a string.\n    \"\"\"\n    # Use regex to find all substrings between quotes\n    # This pattern matches both single and double quotes\n    pattern = r'\"([^\"]*)\"|\\'([^\\']*)\\''\n    matches = re.findall(pattern, text)\n    \n    # Extract the non-empty groups from the matches\n    result = []\n    for match in matches:\n        # match will be a tuple with one empty string and one actual match\n        # We take the non-empty one\n        value = match[0] if match[0] else match[1]\n        result.append(value)\n    \n    return result\n\n\n"], "responses": ["```python\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Extract values between quotation marks from a string.\n    \"\"\"\n    # Use regex to find all substrings between quotes\n    # This pattern matches both single and double quotes\n    pattern = r'\"([^\"]*)\"|\\'([^\\']*)\\''\n    matches = re.findall(pattern, text)\n    \n    # Extract the non-empty groups from the matches\n    result = []\n    for match in matches:\n        # match will be a tuple with one empty string and one actual match\n        # We take the non-empty one\n        value = match[0] if match[0] else match[1]\n        result.append(value)\n    \n    return result\n```"], "prompt_tokens": [82], "completion_tokens": [159], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": ["\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Check if the list is empty or has only one element, it's considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if the list is sorted in ascending order\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n    Write a function to check whether a specified list is sorted or not.\n    \"\"\"\n    # Check if the list is empty or has only one element, it's considered sorted\n    if len(list1) <= 1:\n        return True\n    \n    # Check if the list is sorted in ascending order\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [85], "completion_tokens": [114], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n\n\n"], "responses": ["```python\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a dictionary by value.\n    \"\"\"\n    return sorted(dict1.items(), key=lambda x: x[1])\n```"], "prompt_tokens": [91], "completion_tokens": [54], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Flatten a list and sum all of its elements recursively.\n    \"\"\"\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n\n\n"], "responses": ["```python\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n    Flatten a list and sum all of its elements recursively.\n    \"\"\"\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n```"], "prompt_tokens": [93], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to find union\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "responses": ["```python\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \"\"\"\n    # Convert lists to sets to find union\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [124], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Define pattern to match strings starting with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, string))\n\n\n"], "responses": ["```python\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Define pattern to match strings starting with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, string))\n```"], "prompt_tokens": [82], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": ["\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    The largest triangle is formed when:\n    - The base is the diameter of the semicircle (length 2r)\n    - The third vertex is at the top of the semicircle (height r)\n    - This creates a right triangle with area = (1/2) * 2r * r = r²\n    \n    Args:\n        r: radius of the semicircle\n        \n    Returns:\n        Area of the largest inscribed triangle, or None if radius is invalid\n    \"\"\"\n    if r <= 0:\n        return None\n    \n    return r * r\n\n\n"], "responses": ["Looking at this problem, I need to find the area of the largest triangle that can be inscribed in a semicircle with radius r.\n\nLet me think about this step by step:\n\n1. A semicircle is half of a circle, so it has a curved arc and a straight diameter\n2. To maximize the area of a triangle inscribed in this semicircle, I need to consider where to place the vertices\n3. One key insight is that for a triangle inscribed in a semicircle, if one side is the diameter, then the third vertex on the arc will create a right triangle (by Thales' theorem)\n4. Among all such triangles with the diameter as base, the one with maximum height will have its third vertex at the top of the semicircle (the point farthest from the diameter)\n\nSo the optimal triangle has:\n- Base = diameter of semicircle = 2r\n- Height = radius of semicircle = r\n\nTherefore, the area = (1/2) × base × height = (1/2) × 2r × r = r²\n\n```python\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    The largest triangle is formed when:\n    - The base is the diameter of the semicircle (length 2r)\n    - The third vertex is at the top of the semicircle (height r)\n    - This creates a right triangle with area = (1/2) * 2r * r = r²\n    \n    Args:\n        r: radius of the semicircle\n        \n    Returns:\n        Area of the largest inscribed triangle, or None if radius is invalid\n    \"\"\"\n    if r <= 0:\n        return None\n    \n    return r * r\n```"], "prompt_tokens": [96], "completion_tokens": [393], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [74], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # Initialize variables to track maximum and minimum products ending at current position\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        \n        # Update max and min products ending at current position\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        \n        # Update overall maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "responses": ["```python\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    # Initialize variables to track maximum and minimum products ending at current position\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If current element is negative, swap max and min\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        \n        # Update max and min products ending at current position\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        \n        # Update overall maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n```"], "prompt_tokens": [86], "completion_tokens": [216], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    # Find the first occurrence of x using binary search\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find the first occurrence of x\n    first_index = find_first_occurrence(arr, x)\n    \n    # If x is not found, it can't be a majority element\n    if first_index == -1:\n        return False\n    \n    # Since the array is sorted, if x is a majority element,\n    # it must also appear at index first_index + n//2\n    last_index = first_index + n // 2\n    \n    # Check if the element at last_index is still x\n    if last_index < n and arr[last_index] == x:\n        return True\n    else:\n        return False\n\n\n"], "responses": ["```python\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element \n    and returns whether the element is the majority element in the given sorted array. \n    (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    # Find the first occurrence of x using binary search\n    def find_first_occurrence(arr, x):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                result = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    # Find the first occurrence of x\n    first_index = find_first_occurrence(arr, x)\n    \n    # If x is not found, it can't be a majority element\n    if first_index == -1:\n        return False\n    \n    # Since the array is sorted, if x is a majority element,\n    # it must also appear at index first_index + n//2\n    last_index = first_index + n // 2\n    \n    # Check if the element at last_index is still x\n    if last_index < n and arr[last_index] == x:\n        return True\n    else:\n        return False\n```"], "prompt_tokens": [127], "completion_tokens": [334], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": ["\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    return len(text) >= 2 and text[0] == 'a' and text[-1] == 'b'\n\n\n"], "responses": ["```python\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    return len(text) >= 2 and text[0] == 'a' and text[-1] == 'b'\n```"], "prompt_tokens": [88], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "responses": ["```python\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n```"], "prompt_tokens": [80], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n\n\n"], "responses": ["```python\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(item) for item in list_]\n```"], "prompt_tokens": [94], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    if len(s) == 0:\n        return True\n    \n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n    \"\"\"\n    if len(s) == 0:\n        return True\n    \n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True\n```"], "prompt_tokens": [81], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": ["\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n```"], "prompt_tokens": [87], "completion_tokens": [72], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k <= 0:\n        return input\n    \n    # If k is greater than array length, reverse the entire array\n    if k >= len(input):\n        return input[::-1]\n    \n    # Reverse the first k elements and keep the rest as is\n    return input[:k][::-1] + input[k:]\n\n\n"], "responses": ["```python\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n    Write a python function to reverse an array upto a given position.\n    \"\"\"\n    # Handle edge cases\n    if not input or k <= 0:\n        return input\n    \n    # If k is greater than array length, reverse the entire array\n    if k >= len(input):\n        return input[::-1]\n    \n    # Reverse the first k elements and keep the rest as is\n    return input[:k][::-1] + input[k:]\n```"], "prompt_tokens": [90], "completion_tokens": [118], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)\n\n\n"], "responses": ["```python\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) - min(nums)\n```"], "prompt_tokens": [87], "completion_tokens": [53], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flatten a given nested list structure.\n    \"\"\"\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n\n\n"], "responses": ["```python\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flatten a given nested list structure.\n    \"\"\"\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n```"], "prompt_tokens": [90], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        row = []\n        for j in range(len(test_tup1[i])):\n            row.append(test_tup1[i][j] * test_tup2[i][j])\n        result.append(row)\n    return result\n\n\n"], "responses": ["Looking at this problem, I need to perform index-wise multiplication of corresponding elements from two 2D lists.\n\nLet me think through this step by step:\n1. I have two 2D lists (List[List[int]])\n2. I need to multiply corresponding elements at the same indices\n3. The result should be a new 2D list with the multiplied values\n\nFor example:\n- If test_tup1 = [[1, 2], [3, 4]] and test_tup2 = [[5, 6], [7, 8]]\n- Result should be [[1*5, 2*6], [3*7, 4*8]] = [[5, 12], [21, 32]]\n\n```python\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Perform index wise multiplication of list elements in the given two lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        row = []\n        for j in range(len(test_tup1[i])):\n            row.append(test_tup1[i][j] * test_tup2[i][j])\n        result.append(row)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [264], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes algorithm\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)\n\n\n"], "responses": ["```python\ndef count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Use Sieve of Eratosthenes algorithm\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)\n```"], "prompt_tokens": [91], "completion_tokens": [178], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n    \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    return sum(list1[m:n+1])\n\n\n"], "responses": ["```python\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        list1: List of integers\n        m: Starting index (inclusive)\n        n: Ending index (inclusive)\n    \n    Returns:\n        Sum of elements from index m to n (inclusive)\n    \"\"\"\n    return sum(list1[m:n+1])\n```"], "prompt_tokens": [99], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": ["\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using comb sort algorithm.\n    \"\"\"\n    if not nums:\n        return nums\n    \n    n = len(nums)\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Calculate next gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        \n        swapped = False\n        i = 0\n        \n        # Compare elements with current gap\n        while i + gap < n:\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n            i += 1\n    \n    return nums\n\n\n"], "responses": ["```python\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of elements using comb sort algorithm.\n    \"\"\"\n    if not nums:\n        return nums\n    \n    n = len(nums)\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n    \n    while gap > 1 or swapped:\n        # Calculate next gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        \n        swapped = False\n        i = 0\n        \n        # Compare elements with current gap\n        while i + gap < n:\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n            i += 1\n    \n    return nums\n```"], "prompt_tokens": [80], "completion_tokens": [175], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return text1.replace(\" \", \"\")\n\n\n"], "responses": ["```python\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return text1.replace(\" \", \"\")\n```"], "prompt_tokens": [79], "completion_tokens": [44], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    \n    return dp[m][n][o]\n\n\n"], "responses": ["```python\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n    Find the longest common subsequence for the given three string sequences.\n    \n    Args:\n        X, Y, Z: Three input strings\n        \n    Returns:\n        Length of the longest common subsequence\n    \"\"\"\n    m, n, o = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    \n    return dp[m][n][o]\n```"], "prompt_tokens": [109], "completion_tokens": [271], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": ["\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n\n\n"], "responses": ["```python\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in two numbers and returns a list with the second number and then the first number.\n    \"\"\"\n    return [b, a]\n```"], "prompt_tokens": [95], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "responses": ["```python\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n```"], "prompt_tokens": [98], "completion_tokens": [62], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n    \n    Args:\n        nums: A tuple containing exactly 3 positive integers\n        \n    Returns:\n        An integer formed by concatenating the digits of the tuple elements\n        \n    Examples:\n        >>> tuple_to_int((1, 2, 3))\n        123\n        >>> tuple_to_int((10, 25, 30))\n        102530\n    \"\"\"\n    # Convert each number to string, concatenate them, then convert back to integer\n    return int(''.join(str(num) for num in nums))\n\n\n"], "responses": ["```python\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n    \n    Args:\n        nums: A tuple containing exactly 3 positive integers\n        \n    Returns:\n        An integer formed by concatenating the digits of the tuple elements\n        \n    Examples:\n        >>> tuple_to_int((1, 2, 3))\n        123\n        >>> tuple_to_int((10, 25, 30))\n        102530\n    \"\"\"\n    # Convert each number to string, concatenate them, then convert back to integer\n    return int(''.join(str(num) for num in nums))\n```"], "prompt_tokens": [90], "completion_tokens": [151], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (can be positive or negative)\n    \n    Returns:\n        The first digit of the absolute value of n\n    \"\"\"\n    # Handle the case where n is 0\n    if n == 0:\n        return 0\n    \n    # Take absolute value to handle negative numbers\n    n = abs(n)\n    \n    # Keep dividing by 10 until we get a single digit\n    while n >= 10:\n        n //= 10\n    \n    return n\n\n\n"], "responses": ["```python\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer (can be positive or negative)\n    \n    Returns:\n        The first digit of the absolute value of n\n    \"\"\"\n    # Handle the case where n is 0\n    if n == 0:\n        return 0\n    \n    # Take absolute value to handle negative numbers\n    n = abs(n)\n    \n    # Keep dividing by 10 until we get a single digit\n    while n >= 10:\n        n //= 10\n    \n    return n\n```"], "prompt_tokens": [78], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n\n\n"], "responses": ["```python\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split(' ')\n```"], "prompt_tokens": [88], "completion_tokens": [45], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": ["\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Minimum difference between any two elements\n    \"\"\"\n    # Sort the array to make adjacent elements have minimum differences\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Check differences between consecutive elements\n    for i in range(1, n):\n        diff = arr[i] - arr[i-1]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n\n"], "responses": ["```python\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Minimum difference between any two elements\n    \"\"\"\n    # Sort the array to make adjacent elements have minimum differences\n    arr.sort()\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Check differences between consecutive elements\n    for i in range(1, n):\n        diff = arr[i] - arr[i-1]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n```"], "prompt_tokens": [108], "completion_tokens": [154], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["\nimport heapq\nfrom typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Use a min heap to keep track of pairs with their sums\n    # Each entry in heap: (sum, index_in_nums1, index_in_nums2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Use a set to avoid duplicate pairs\n    visited = {(0, 0)}\n    result = []\n    \n    while heap and len(result) < k:\n        # Get the pair with minimum sum\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        # Move to next element in nums1 (if valid and not visited)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Move to next element in nums2 (if valid and not visited)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "responses": ["```python\nimport heapq\nfrom typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Use a min heap to keep track of pairs with their sums\n    # Each entry in heap: (sum, index_in_nums1, index_in_nums2)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Use a set to avoid duplicate pairs\n    visited = {(0, 0)}\n    result = []\n    \n    while heap and len(result) < k:\n        # Get the pair with minimum sum\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs to heap\n        # Move to next element in nums1 (if valid and not visited)\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Move to next element in nums2 (if valid and not visited)\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n```"], "prompt_tokens": [111], "completion_tokens": [352], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return str1\n    \n    result = []\n    \n    for i, char in enumerate(str1):\n        # If current character is uppercase and it's not the first character\n        if char.isupper() and i > 0:\n            # Check if the previous character is not a space\n            if str1[i-1] != ' ':\n                result.append(' ')\n        \n        result.append(char)\n    \n    return ''.join(result)\n\n\n"], "responses": ["```python\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return str1\n    \n    result = []\n    \n    for i, char in enumerate(str1):\n        # If current character is uppercase and it's not the first character\n        if char.isupper() and i > 0:\n            # Check if the previous character is not a space\n            if str1[i-1] != ' ':\n                result.append(' ')\n        \n        result.append(char)\n    \n    return ''.join(result)\n```"], "prompt_tokens": [82], "completion_tokens": [130], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": ["\nimport cmath\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number (int is not correct for complex numbers,\n                 but assuming this refers to a complex number input)\n    \n    Returns:\n        Tuple containing (magnitude, phase) - polar coordinates\n    \"\"\"\n    # Convert to complex number if it's not already\n    complex_num = complex(numbers)\n    \n    # Get magnitude (r) and phase (theta)\n    magnitude = abs(complex_num)\n    phase = cmath.phase(complex_num)\n    \n    return (magnitude, phase)\n\n\n"], "responses": ["```python\nimport cmath\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \n    Args:\n        numbers: A complex number (int is not correct for complex numbers,\n                 but assuming this refers to a complex number input)\n    \n    Returns:\n        Tuple containing (magnitude, phase) - polar coordinates\n    \"\"\"\n    # Convert to complex number if it's not already\n    complex_num = complex(numbers)\n    \n    # Get magnitude (r) and phase (theta)\n    magnitude = abs(complex_num)\n    phase = cmath.phase(complex_num)\n    \n    return (magnitude, phase)\n```"], "prompt_tokens": [82], "completion_tokens": [137], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_252_convert"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n\n\n"], "responses": ["```python\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n```"], "prompt_tokens": [85], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n    \n    Returns:\n        float: The median value\n    \n    Examples:\n        >>> median_numbers(1, 2, 3)\n        2\n        >>> median_numbers(5, 1, 3)\n        3\n        >>> median_numbers(10, 20, 15)\n        15\n    \"\"\"\n    # Sort the three numbers and return the middle one\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n\n\n"], "responses": ["```python\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a, b, c: Three integers\n    \n    Returns:\n        float: The median value\n    \n    Examples:\n        >>> median_numbers(1, 2, 3)\n        2\n        >>> median_numbers(5, 1, 3)\n        3\n        >>> median_numbers(10, 20, 15)\n        15\n    \"\"\"\n    # Sort the three numbers and return the middle one\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n```"], "prompt_tokens": [82], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["\nfrom typing import List, Union\nfrom itertools import combinations\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    result = []\n    \n    # Add empty combination\n    result.append([])\n    \n    # Generate combinations of all possible lengths\n    for r in range(1, len(list1) + 1):\n        for combo in combinations(list1, r):\n            result.append(list(combo))\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List, Union\nfrom itertools import combinations\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n    Write a function to find all possible combinations of the elements of a given list.\n    \"\"\"\n    result = []\n    \n    # Add empty combination\n    result.append([])\n    \n    # Generate combinations of all possible lengths\n    for r in range(1, len(list1) + 1):\n        for combo in combinations(list1, r):\n            result.append(list(combo))\n    \n    return result\n```"], "prompt_tokens": [97], "completion_tokens": [121], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": ["\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    def is_divisible_by_its_digits(num):\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit == 0 or num % digit != 0:\n                return False\n        return True\n    \n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_its_digits(num):\n            result.append(num)\n    \n    return result\n\n\n"], "responses": ["```python\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    def is_divisible_by_its_digits(num):\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit == 0 or num % digit != 0:\n                return False\n        return True\n    \n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_its_digits(num):\n            result.append(num)\n    \n    return result\n```"], "prompt_tokens": [125], "completion_tokens": [111], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "responses": ["```python\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n```"], "prompt_tokens": [86], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string of words.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result\n\n\n"], "responses": ["```python\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string of words.\n    \"\"\"\n    # Split the string into words\n    words = str.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [87], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n    \"\"\"\n    if not s:  # Empty list is sublist of any list\n        return True\n    \n    if len(s) > len(l):  # Sublist cannot be longer than main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if the sublist matches at this position\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n    \"\"\"\n    if not s:  # Empty list is sublist of any list\n        return True\n    \n    if len(s) > len(l):  # Sublist cannot be longer than main list\n        return False\n    \n    # Check each possible starting position in the main list\n    for i in range(len(l) - len(s) + 1):\n        # Check if the sublist matches at this position\n        if l[i:i + len(s)] == s:\n            return True\n    \n    return False\n```"], "prompt_tokens": [90], "completion_tokens": [139], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": ["\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any common element using set intersection\n    return bool(set1 & set2)\n\n\n"], "responses": ["```python\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n    Write a function that takes two lists and returns true if they have at least one common element.\n    \"\"\"\n    # Convert lists to sets for efficient intersection operation\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check if there's any common element using set intersection\n    return bool(set1 & set2)\n```"], "prompt_tokens": [101], "completion_tokens": [98], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "responses": ["```python\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n```"], "prompt_tokens": [82], "completion_tokens": [51], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": ["\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list using pancake sorting algorithm.\n    Returns a list of k-values representing the sequence of pancake flips.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    result = []\n    n = len(arr)\n    \n    # Start from the largest element and work downwards\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        \n        # If the maximum is already at the end, skip\n        if max_index == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip it to the beginning\n        if max_index != 0:\n            # Flip from 0 to max_index (inclusive)\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            result.append(max_index + 1)\n        \n        # Flip from 0 to size-1 (inclusive) to move max to its correct position\n        arr[:size] = reversed(arr[:size])\n        result.append(size)\n    \n    return result\n\n\n"], "responses": ["```python\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list using pancake sorting algorithm.\n    Returns a list of k-values representing the sequence of pancake flips.\n    \"\"\"\n    if not nums:\n        return []\n    \n    # Make a copy to avoid modifying the original list\n    arr = nums[:]\n    result = []\n    n = len(arr)\n    \n    # Start from the largest element and work downwards\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = 0\n        for i in range(1, size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        \n        # If the maximum is already at the end, skip\n        if max_index == size - 1:\n            continue\n            \n        # If the maximum is not at the beginning, flip it to the beginning\n        if max_index != 0:\n            # Flip from 0 to max_index (inclusive)\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            result.append(max_index + 1)\n        \n        # Flip from 0 to size-1 (inclusive) to move max to its correct position\n        arr[:size] = reversed(arr[:size])\n        result.append(size)\n    \n    return result\n```"], "prompt_tokens": [81], "completion_tokens": [291], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return the first N elements\n    products.sort(reverse=True)\n    return products[:N]\n\n\n"], "responses": ["```python\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n    \"\"\"\n    # Generate all possible products\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort in descending order and return the first N elements\n    products.sort(reverse=True)\n    return products[:N]\n```"], "prompt_tokens": [104], "completion_tokens": [115], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": ["\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Find the third side of a right angled triangle given two sides.\n    \n    Args:\n        w (int): One side of the triangle\n        h (int): Another side of the triangle\n    \n    Returns:\n        float: The third side of the triangle\n    \"\"\"\n    # Using Pythagorean theorem: c = sqrt(a² + b²)\n    # where c is the hypotenuse and a, b are the other two sides\n    import math\n    return math.sqrt(w**2 + h**2)\n\n\n"], "responses": ["```python\ndef otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n    Find the third side of a right angled triangle given two sides.\n    \n    Args:\n        w (int): One side of the triangle\n        h (int): Another side of the triangle\n    \n    Returns:\n        float: The third side of the triangle\n    \"\"\"\n    # Using Pythagorean theorem: c = sqrt(a² + b²)\n    # where c is the hypotenuse and a, b are the other two sides\n    import math\n    return math.sqrt(w**2 + h**2)\n```"], "prompt_tokens": [83], "completion_tokens": [130], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, extend with the given list, then convert back to tuple\n    result = list(test_tup)\n    result.extend(test_list)\n    return tuple(result)\n\n\n"], "responses": ["```python\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    \"\"\"\n    # Convert tuple to list, extend with the given list, then convert back to tuple\n    result = list(test_tup)\n    result.extend(test_list)\n    return tuple(result)\n```"], "prompt_tokens": [103], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)\n\n\n"], "responses": ["```python\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)\n```"], "prompt_tokens": [115], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
{"name": "mbpp_395_first_non_repeating_character", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first non-repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_non_repeating_character", "test": "def check(candidate):\n    assert candidate('abcabc') == None\n    assert candidate('abc') == 'a'\n    assert candidate('ababc') == 'c'\n\ndef test_check():\n    check(first_non_repeating_character)\n\ntest_check()\n", "sample_io": ["assert first_non_repeating_character('abcabc') == None"], "source_codes": ["\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n        str1: Input string to search\n        \n    Returns:\n        The first non-repeating character, or None if all characters repeat\n    \"\"\"\n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n\n\n"], "responses": ["```python\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n        str1: Input string to search\n        \n    Returns:\n        The first non-repeating character, or None if all characters repeat\n    \"\"\"\n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n```"], "prompt_tokens": [90], "completion_tokens": [141], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_395_first_non_repeating_character"}
{"name": "mbpp_457_Find_Min", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min", "test": "def check(candidate):\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert candidate([[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1]\n    assert candidate([['x'], ['x', 'y'], ['x', 'y', 'z']]) == ['x']\n\ndef test_check():\n    check(Find_Min)\n\ntest_check()\n", "sample_io": ["assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"], "source_codes": ["\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the sublist having minimum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    min_length = float('inf')\n    min_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n\n\n"], "responses": ["```python\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the sublist having minimum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    min_length = float('inf')\n    min_sublist = []\n    \n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n```"], "prompt_tokens": [85], "completion_tokens": [95], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_457_Find_Min"}
{"name": "mbpp_725_extract_quotation", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks \" \" of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_quotation", "test": "def check(candidate):\n    assert candidate('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    assert candidate('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']\n    assert candidate('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']\n    assert candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == []\n\ndef test_check():\n    check(extract_quotation)\n\ntest_check()\n", "sample_io": ["assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"], "source_codes": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text1)\n    \n    # Convert the matches to a list and return\n    return matches\n\n\n"], "responses": ["```python\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, text1)\n    \n    # Convert the matches to a list and return\n    return matches\n```"], "prompt_tokens": [89], "completion_tokens": [97], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_725_extract_quotation"}
{"name": "mbpp_9_find_Rotations", "language": "Python3", "prompt": "def find_Rotations(str: str) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Rotations", "test": "def check(candidate):\n    assert candidate('aaaa') == 1\n    assert candidate('ab') == 2\n    assert candidate('abc') == 3\n\ndef test_check():\n    check(find_Rotations)\n\ntest_check()\n", "sample_io": ["assert find_Rotations('aaaa') == 1"], "source_codes": ["\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Try all possible rotations from 1 to n\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        # Check if rotated string is same as original\n        if rotated == str:\n            return i\n    \n    # If no rotation found (should not happen for valid input), return n\n    return n\n\n\n"], "responses": ["```python\ndef find_Rotations(str: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(str)\n    \n    # Try all possible rotations from 1 to n\n    for i in range(1, n + 1):\n        # Rotate the string by i positions\n        rotated = str[i:] + str[:i]\n        # Check if rotated string is same as original\n        if rotated == str:\n            return i\n    \n    # If no rotation found (should not happen for valid input), return n\n    return n\n```"], "prompt_tokens": [89], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_9_find_Rotations"}
{"name": "mbpp_792_count_list", "language": "Python3", "prompt": "from typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of lists in a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    assert candidate([[1, 2], [2, 3], [4, 5]]) == 3\n    assert candidate([[1, 0], [2, 0]]) == 2\n\ndef test_check():\n    check(count_list)\n\ntest_check()\n", "sample_io": ["assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"], "source_codes": ["\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of lists in a given list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        The number of lists in the input_list\n    \"\"\"\n    return len(input_list)\n\n\n"], "responses": ["```python\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of lists in a given list of lists.\n    \n    Args:\n        input_list: A list containing lists of integers\n        \n    Returns:\n        The number of lists in the input_list\n    \"\"\"\n    return len(input_list)\n```"], "prompt_tokens": [88], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_792_count_list"}
{"name": "mbpp_477_is_lower", "language": "Python3", "prompt": "def is_lower(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert the given string to lower case.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_lower", "test": "def check(candidate):\n    assert candidate('InValid') == 'invalid'\n    assert candidate('TruE') == 'true'\n    assert candidate('SenTenCE') == 'sentence'\n\ndef test_check():\n    check(is_lower)\n\ntest_check()\n", "sample_io": ["assert is_lower('InValid') == 'invalid'"], "source_codes": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "responses": ["```python\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n```"], "prompt_tokens": [76], "completion_tokens": [37], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_477_is_lower"}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "Python3", "prompt": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n\tWrite a python function to find the average of cubes of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Average_Of_Cube", "test": "def check(candidate):\n    assert candidate(2) == 4.5\n    assert candidate(3) == 12\n    assert candidate(1) == 1\n\ndef test_check():\n    check(find_Average_Of_Cube)\n\ntest_check()\n", "sample_io": ["assert find_Average_Of_Cube(2) == 4.5"], "source_codes": ["\ndef find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n    Write a python function to find the average of cubes of first n natural numbers.\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # Sum of cubes of first n natural numbers = [n(n+1)/2]^2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Average = sum / count\n    average = sum_of_cubes / n\n    \n    return float(average)\n\n\n"], "responses": ["```python\ndef find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n    Write a python function to find the average of cubes of first n natural numbers.\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # Sum of cubes of first n natural numbers = [n(n+1)/2]^2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Average = sum / count\n    average = sum_of_cubes / n\n    \n    return float(average)\n```"], "prompt_tokens": [83], "completion_tokens": [121], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_422_find_Average_Of_Cube"}
{"name": "mbpp_637_noprofit_noloss", "language": "Python3", "prompt": "def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given amount has no profit and no loss\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "noprofit_noloss", "test": "def check(candidate):\n    assert candidate(1500, 1200) == False\n    assert candidate(100, 100) == True\n    assert candidate(2000, 5000) == False\n\ndef test_check():\n    check(noprofit_noloss)\n\ntest_check()\n", "sample_io": ["assert noprofit_noloss(1500, 1200) == False"], "source_codes": ["\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n\n\n"], "responses": ["```python\ndef noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given amount has no profit and no loss\n    \"\"\"\n    return actual_cost == sale_amount\n```"], "prompt_tokens": [89], "completion_tokens": [54], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_637_noprofit_noloss"}
{"name": "mbpp_557_toggle_string", "language": "Python3", "prompt": "def toggle_string(string: str) -> str:\n    \"\"\"\n\tWrite a function to toggle the case of all characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_string", "test": "def check(candidate):\n    assert candidate('Python') == 'pYTHON'\n    assert candidate('Pangram') == 'pANGRAM'\n    assert candidate('LIttLE') == 'liTTle'\n\ndef test_check():\n    check(toggle_string)\n\ntest_check()\n", "sample_io": ["assert toggle_string('Python') == 'pYTHON'"], "source_codes": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n```"], "prompt_tokens": [77], "completion_tokens": [79], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_557_toggle_string"}
{"name": "mbpp_786_right_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the right insertion point for a specified value in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "right_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(right_insertion)\n\ntest_check()\n", "sample_io": ["assert right_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "responses": ["```python\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n```"], "prompt_tokens": [91], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_786_right_insertion"}
{"name": "mbpp_807_first_odd", "language": "Python3", "prompt": "from typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the first odd number in a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5]) == 1\n    assert candidate([2, 4, 1, 3]) == 1\n    assert candidate([8, 9, 1]) == 9\n\ndef test_check():\n    check(first_odd)\n\ntest_check()\n", "sample_io": ["assert first_odd([1, 3, 5]) == 1"], "source_codes": ["\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    raise ValueError(\"No odd number found in the list\")\n\n\n"], "responses": ["```python\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    raise ValueError(\"No odd number found in the list\")\n```"], "prompt_tokens": [86], "completion_tokens": [65], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_807_first_odd"}
{"name": "mbpp_631_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace whitespaces with an underscore and vice versa in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert candidate('The_Avengers') == 'The Avengers'\n    assert candidate('Fast and Furious') == 'Fast_and_Furious'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"], "source_codes": ["\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = \"\"\n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = \"\"\n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result\n```"], "prompt_tokens": [81], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_631_replace_spaces"}
{"name": "mbpp_573_unique_product", "language": "Python3", "prompt": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to calculate the product of the unique numbers in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_product", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    assert candidate([1, 2, 3, 1]) == 6\n    assert candidate([7, 8, 9, 0, 1, 1]) == 0\n\ndef test_check():\n    check(unique_product)\n\ntest_check()\n", "sample_io": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"], "source_codes": ["\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Convert list to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n\n\n"], "responses": ["```python\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Convert list to set to get unique elements\n    unique_numbers = set(list_data)\n    \n    # Calculate product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n```"], "prompt_tokens": [87], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_573_unique_product"}
{"name": "mbpp_643_text_match_wordz_middle", "language": "Python3", "prompt": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks if a strings contains 'z', except at the start and end of the word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz_middle", "test": "def check(candidate):\n    assert candidate('pythonzabc.') == True\n    assert candidate('zxyabc.') == False\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz_middle)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz_middle('pythonzabc.') == True"], "source_codes": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    words = text.split()\n    \n    for word in words:\n        # Check if word has at least 3 characters (so we can have middle positions)\n        if len(word) >= 3:\n            # Check if 'z' or 'Z' appears in the middle (not first or last character)\n            for i in range(1, len(word) - 1):\n                if word[i].lower() == 'z':\n                    return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    words = text.split()\n    \n    for word in words:\n        # Check if word has at least 3 characters (so we can have middle positions)\n        if len(word) >= 3:\n            # Check if 'z' or 'Z' appears in the middle (not first or last character)\n            for i in range(1, len(word) - 1):\n                if word[i].lower() == 'z':\n                    return True\n    \n    return False\n```"], "prompt_tokens": [88], "completion_tokens": [141], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_643_text_match_wordz_middle"}
{"name": "mbpp_299_max_aggregate", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n\tWrite a function to calculate the maximum aggregate from the list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_aggregate", "test": "def check(candidate):\n    assert candidate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)\n    assert candidate([('Juan Whelan', 50), ('Sabah Colley', 48), ('Peter Nichols', 37), ('Juan Whelan', 22), ('Sabah Colley', 14)]) == ('Juan Whelan', 72)\n    assert candidate([('Juan Whelan', 10), ('Sabah Colley', 20), ('Peter Nichols', 30), ('Juan Whelan', 40), ('Sabah Colley', 50)]) == ('Sabah Colley', 70)\n\ndef test_check():\n    check(max_aggregate)\n\ntest_check()\n", "sample_io": ["assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"], "source_codes": ["\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return (\"\", 0)\n    \n    # Group by name and sum the values\n    aggregate_dict = {}\n    for name, value in stdata:\n        if name in aggregate_dict:\n            aggregate_dict[name] += value\n        else:\n            aggregate_dict[name] = value\n    \n    # Find the entry with maximum aggregate\n    max_name = \"\"\n    max_value = float('-inf')\n    \n    for name, total in aggregate_dict.items():\n        if total > max_value:\n            max_value = total\n            max_name = name\n    \n    return (max_name, max_value)\n\n\n"], "responses": ["```python\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n    \"\"\"\n    if not stdata:\n        return (\"\", 0)\n    \n    # Group by name and sum the values\n    aggregate_dict = {}\n    for name, value in stdata:\n        if name in aggregate_dict:\n            aggregate_dict[name] += value\n        else:\n            aggregate_dict[name] = value\n    \n    # Find the entry with maximum aggregate\n    max_name = \"\"\n    max_value = float('-inf')\n    \n    for name, total in aggregate_dict.items():\n        if total > max_value:\n            max_value = total\n            max_name = name\n    \n    return (max_name, max_value)\n```"], "prompt_tokens": [94], "completion_tokens": [168], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_299_max_aggregate"}
{"name": "mbpp_474_replace_char", "language": "Python3", "prompt": "def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n\tWrite a function to replace characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_char", "test": "def check(candidate):\n    assert candidate('polygon', 'y', 'l') == 'pollgon'\n    assert candidate('character', 'c', 'a') == 'aharaater'\n    assert candidate('python', 'l', 'a') == 'python'\n\ndef test_check():\n    check(replace_char)\n\ntest_check()\n", "sample_io": ["assert replace_char('polygon', 'y', 'l') == 'pollgon'"], "source_codes": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    return str1.replace(ch, newch)\n\n\n"], "responses": ["```python\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    return str1.replace(ch, newch)\n```"], "prompt_tokens": [83], "completion_tokens": [50], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_474_replace_char"}
{"name": "mbpp_433_check_greater", "language": "Python3", "prompt": "from typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the entered number is greater than the elements of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_greater", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 4) == False\n    assert candidate([2, 3, 4, 5, 6], 8) == True\n    assert candidate([9, 7, 4, 8, 6, 1], 11) == True\n\ndef test_check():\n    check(check_greater)\n\ntest_check()\n", "sample_io": ["assert check_greater([1, 2, 3, 4, 5], 4) == False"], "source_codes": ["\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    for element in arr:\n        if number <= element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    for element in arr:\n        if number <= element:\n            return False\n    return True\n```"], "prompt_tokens": [92], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_433_check_greater"}
{"name": "mbpp_427_change_date_format", "language": "Python3", "prompt": "def change_date_format(dt: str) -> str:\n    \"\"\"\n\tWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "change_date_format", "test": "def check(candidate):\n    assert candidate('2026-01-02') == '02-01-2026'\n    assert candidate('2020-11-13') == '13-11-2020'\n    assert candidate('2021-04-26') == '26-04-2021'\n\ndef test_check():\n    check(change_date_format)\n\ntest_check()\n", "sample_io": ["assert change_date_format('2026-01-02') == '02-01-2026'"], "source_codes": ["\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \"\"\"\n    # Split the date string by '-'\n    parts = dt.split('-')\n    \n    # Rearrange the parts from [year, month, day] to [day, month, year]\n    return f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n\n\n"], "responses": ["```python\ndef change_date_format(dt: str) -> str:\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \"\"\"\n    # Split the date string by '-'\n    parts = dt.split('-')\n    \n    # Rearrange the parts from [year, month, day] to [day, month, year]\n    return f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n```"], "prompt_tokens": [82], "completion_tokens": [91], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_427_change_date_format"}
{"name": "mbpp_442_positive_count", "language": "Python3", "prompt": "from typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n\tWrite a function to find the ration of positive numbers in an array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "positive_count", "test": "def check(candidate):\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54\n    assert candidate([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56\n\ndef test_check():\n    check(positive_count)\n\ntest_check()\n", "sample_io": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"], "source_codes": ["\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Find the ratio of positive numbers in an array of integers.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        float: Ratio of positive numbers (0 if no positive numbers or empty list)\n    \"\"\"\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n\n\n"], "responses": ["```python\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n    Find the ratio of positive numbers in an array of integers.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        float: Ratio of positive numbers (0 if no positive numbers or empty list)\n    \"\"\"\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n```"], "prompt_tokens": [85], "completion_tokens": [101], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_442_positive_count"}
{"name": "mbpp_453_sumofFactors", "language": "Python3", "prompt": "def sumofFactors(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even factors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sumofFactors", "test": "def check(candidate):\n    assert candidate(18) == 26\n    assert candidate(30) == 48\n    assert candidate(6) == 8\n\ndef test_check():\n    check(sumofFactors)\n\ntest_check()\n", "sample_io": ["assert sumofFactors(18) == 26"], "source_codes": ["\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # If n is odd, it has no even factors\n    if n % 2 == 1:\n        return 0\n    \n    # Find all factors and sum the even ones\n    sum_even_factors = 0\n    \n    # Check all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:  # i is a factor of n\n            if i % 2 == 0:  # i is even\n                sum_even_factors += i\n    \n    return sum_even_factors\n\n\n"], "responses": ["```python\ndef sumofFactors(n: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # If n is odd, it has no even factors\n    if n % 2 == 1:\n        return 0\n    \n    # Find all factors and sum the even ones\n    sum_even_factors = 0\n    \n    # Check all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:  # i is a factor of n\n            if i % 2 == 0:  # i is even\n                sum_even_factors += i\n    \n    return sum_even_factors\n```"], "prompt_tokens": [79], "completion_tokens": [165], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_453_sumofFactors"}
{"name": "mbpp_478_remove_lowercase", "language": "Python3", "prompt": "def remove_lowercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove lowercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_lowercase", "test": "def check(candidate):\n    assert candidate('PYTHon') == 'PYTH'\n    assert candidate('FInD') == 'FID'\n    assert candidate('STRinG') == 'STRG'\n\ndef test_check():\n    check(remove_lowercase)\n\ntest_check()\n", "sample_io": ["assert remove_lowercase('PYTHon') == 'PYTH'"], "source_codes": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.islower():\n            result += char\n    return result\n\n\n"], "responses": ["```python\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    result = \"\"\n    for char in str1:\n        if not char.islower():\n            result += char\n    return result\n```"], "prompt_tokens": [77], "completion_tokens": [60], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_478_remove_lowercase"}
{"name": "mbpp_18_remove_dirty_chars", "language": "Python3", "prompt": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n\tWrite a function to remove characters from the first string which are present in the second string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_dirty_chars", "test": "def check(candidate):\n    assert candidate('probasscurve', 'pros') == 'bacuve'\n    assert candidate('digitalindia', 'talent') == 'digiidi'\n    assert candidate('exoticmiles', 'toxic') == 'emles'\n\ndef test_check():\n    check(remove_dirty_chars)\n\ntest_check()\n", "sample_io": ["assert remove_dirty_chars('probasscurve', 'pros') == 'bacuve'"], "source_codes": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n    \"\"\"\n    # Create a set of characters from the second string for efficient lookup\n    chars_to_remove = set(second_string)\n    \n    # Build result string by including only characters not in the removal set\n    result = ''.join(char for char in string if char not in chars_to_remove)\n    \n    return result\n\n\n"], "responses": ["```python\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n    \"\"\"\n    # Create a set of characters from the second string for efficient lookup\n    chars_to_remove = set(second_string)\n    \n    # Build result string by including only characters not in the removal set\n    result = ''.join(char for char in string if char not in chars_to_remove)\n    \n    return result\n```"], "prompt_tokens": [87], "completion_tokens": [106], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_18_remove_dirty_chars"}
{"name": "mbpp_730_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function to remove consecutive duplicates of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd', 'a', 'a']) == ['a', 'b', 'c', 'd', 'a']\n\ndef test_check():\n    check(consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"], "source_codes": ["\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n        \n    Examples:\n        >>> consecutive_duplicates([0, 0, 1, 2, 2, 2, 3])\n        [0, 1, 2, 3]\n        >>> consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        ['a', 'b', 'c']\n        >>> consecutive_duplicates([])\n        []\n        >>> consecutive_duplicates([1])\n        [1]\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = [nums[0]]  # Start with the first element\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:  # Only add if different from previous\n            result.append(nums[i])\n    \n    return result\n\n\n"], "responses": ["```python\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n        \n    Examples:\n        >>> consecutive_duplicates([0, 0, 1, 2, 2, 2, 3])\n        [0, 1, 2, 3]\n        >>> consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        ['a', 'b', 'c']\n        >>> consecutive_duplicates([])\n        []\n        >>> consecutive_duplicates([1])\n        [1]\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = [nums[0]]  # Start with the first element\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:  # Only add if different from previous\n            result.append(nums[i])\n    \n    return result\n```"], "prompt_tokens": [84], "completion_tokens": [208], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_730_consecutive_duplicates"}
{"name": "mbpp_446_count_Occurrence", "language": "Python3", "prompt": "from typing import Any, List\n\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n\tWrite a python function to count the occurence of all elements of list in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Occurrence", "test": "def check(candidate):\n    assert candidate(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    assert candidate((1, 2, 3, 1, 4, 6, 7, 1, 4), [1, 4, 7]) == 6\n    assert candidate((1, 2, 3, 4, 5, 6), [1, 2]) == 2\n\ndef test_check():\n    check(count_Occurrence)\n\ntest_check()\n", "sample_io": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"], "source_codes": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count\n\n\n"], "responses": ["```python\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n    Write a python function to count the occurence of all elements of list in a tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count\n```"], "prompt_tokens": [96], "completion_tokens": [68], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_446_count_Occurrence"}
{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n\n\n"], "responses": ["```python\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n```"], "prompt_tokens": [84], "completion_tokens": [102], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Find the nth Jacobsthal number.\n    The sequence is: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    Recurrence relation: J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    Base cases: J(0) = 0, J(1) = 1\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to avoid recursion overhead\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["```python\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Find the nth Jacobsthal number.\n    The sequence is: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    Recurrence relation: J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    Base cases: J(0) = 0, J(1) = 1\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Use iterative approach to avoid recursion overhead\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n```"], "prompt_tokens": [160], "completion_tokens": [245], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val\n\n\n"], "responses": ["```python\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return max_val - min_val\n```"], "prompt_tokens": [90], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove duplicate numbers from a given list of numbers.\n    \"\"\"\n    unique_nums = []\n    seen = set()\n    \n    for num in nums:\n        if num not in seen:\n            unique_nums.append(num)\n            seen.add(num)\n    \n    return unique_nums\n\n\n"], "responses": ["```python\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove duplicate numbers from a given list of numbers.\n    \"\"\"\n    unique_nums = []\n    seen = set()\n    \n    for num in nums:\n        if num not in seen:\n            unique_nums.append(num)\n            seen.add(num)\n    \n    return unique_nums\n```"], "prompt_tokens": [86], "completion_tokens": [73], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, and the result is the product of these counts.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n\n\n"], "responses": ["```python\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n    \n    The XOR of two numbers is odd if and only if one number is even and the other is odd.\n    So we count the number of even and odd numbers, and the result is the product of these counts.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n```"], "prompt_tokens": [92], "completion_tokens": [139], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": ["\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of increasing subsequence from prefix until ith index \n    and also including a given kth element which is after i, i.e., k > i.\n    \"\"\"\n    if k <= index:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    dp[0] = a[0]\n    \n    # Fill dp array for indices 0 to index\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find maximum sum subsequence ending at some index <= index that can be extended to include a[k]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    \n    # Return the maximum sum including a[k]\n    return max_sum + a[k] if max_sum > 0 else a[k]\n\n\n"], "responses": ["```python\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of increasing subsequence from prefix until ith index \n    and also including a given kth element which is after i, i.e., k > i.\n    \"\"\"\n    if k <= index:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    dp[0] = a[0]\n    \n    # Fill dp array for indices 0 to index\n    for i in range(1, index + 1):\n        dp[i] = a[i]\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find maximum sum subsequence ending at some index <= index that can be extended to include a[k]\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    \n    # Return the maximum sum including a[k]\n    return max_sum + a[k] if max_sum > 0 else a[k]\n```"], "prompt_tokens": [122], "completion_tokens": [274], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    # This gives us the highest power of 2 less than or equal to n\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    \n    return 1 << power\n\n\n"], "responses": ["```python\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Find the position of the most significant bit\n    # This gives us the highest power of 2 less than or equal to n\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    \n    return 1 << power\n```"], "prompt_tokens": [88], "completion_tokens": [114], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        inner_list = []\n        for j in range(len(test_tup1[i])):\n            inner_list.append(test_tup1[i][j] + test_tup2[i][j])\n        result.append(inner_list)\n    return result\n\n\n"], "responses": ["```python\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup1)):\n        inner_list = []\n        for j in range(len(test_tup1[i])):\n            inner_list.append(test_tup1[i][j] + test_tup2[i][j])\n        result.append(inner_list)\n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [117], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_401_add_nested_tuples"}
{"name": "mbpp_435_last_Digit", "language": "Python3", "prompt": "def last_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit", "test": "def check(candidate):\n    assert candidate(123) == 3\n    assert candidate(25) == 5\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit)\n\ntest_check()\n", "sample_io": ["assert last_Digit(123) == 3"], "source_codes": ["\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10\n\n\n"], "responses": ["```python\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number\n    \"\"\"\n    return abs(n) % 10\n```"], "prompt_tokens": [78], "completion_tokens": [65], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_435_last_Digit"}
{"name": "mbpp_611_max_of_nth", "language": "Python3", "prompt": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n\tWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_of_nth", "test": "def check(candidate):\n    assert candidate([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    assert candidate([[6, 7, 8], [2, 4, 6], [9, 10, 20]], 1) == 10\n    assert candidate([[7, 8, 9], [3, 5, 7], [10, 11, 21]], 1) == 11\n\ndef test_check():\n    check(max_of_nth)\n\ntest_check()\n", "sample_io": ["assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"], "source_codes": ["\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Extract the N-th column from each row and find the maximum\n    column_values = [row[N] for row in test_list]\n    return max(column_values)\n\n\n"], "responses": ["```python\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    # Extract the N-th column from each row and find the maximum\n    column_values = [row[N] for row in test_list]\n    return max(column_values)\n```"], "prompt_tokens": [99], "completion_tokens": [86], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_611_max_of_nth"}
{"name": "mbpp_280_sequential_search", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n\tWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequential_search", "test": "def check(candidate):\n    assert candidate([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)\n    assert candidate([12, 32, 45, 62, 35, 47, 44, 61], 61) == (True, 7)\n    assert candidate([9, 10, 17, 19, 22, 39, 48, 56], 48) == (True, 6)\n\ndef test_check():\n    check(sequential_search)\n\ntest_check()\n", "sample_io": ["assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"], "source_codes": ["\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing \n    a boolean that indicates if the element is in the array and the index position \n    of the element (or -1 if the element is not found).\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return (True, i)\n    return (False, -1)\n\n\n"], "responses": ["```python\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing \n    a boolean that indicates if the element is in the array and the index position \n    of the element (or -1 if the element is not found).\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return (True, i)\n    return (False, -1)\n```"], "prompt_tokens": [124], "completion_tokens": [110], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_280_sequential_search"}
{"name": "mbpp_576_is_Sub_Array", "language": "Python3", "prompt": "from typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list is sublist of another or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sub_Array", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 5], [1, 2]) == False\n    assert candidate([1, 2, 1], [1, 2, 1]) == True\n    assert candidate([1, 0, 2, 2], [2, 2, 0]) == False\n\ndef test_check():\n    check(is_Sub_Array)\n\ntest_check()\n", "sample_io": ["assert is_Sub_Array([1, 4, 3, 5], [1, 2]) == False"], "source_codes": ["\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Check whether list A is a sublist of list B or not.\n    A sublist means all elements of A appear in B in the same order consecutively.\n    \"\"\"\n    if len(A) == 0:\n        return True\n    \n    if len(B) == 0:\n        return False\n    \n    # Check each possible starting position in B\n    for i in range(len(B) - len(A) + 1):\n        # Check if A matches the subarray of B starting at position i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n    Check whether list A is a sublist of list B or not.\n    A sublist means all elements of A appear in B in the same order consecutively.\n    \"\"\"\n    if len(A) == 0:\n        return True\n    \n    if len(B) == 0:\n        return False\n    \n    # Check each possible starting position in B\n    for i in range(len(B) - len(A) + 1):\n        # Check if A matches the subarray of B starting at position i\n        if B[i:i + len(A)] == A:\n            return True\n    \n    return False\n```"], "prompt_tokens": [91], "completion_tokens": [146], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_576_is_Sub_Array"}
{"name": "mbpp_131_reverse_vowels", "language": "Python3", "prompt": "def reverse_vowels(str1: str) -> str:\n    \"\"\"\n\tWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_vowels", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('USA') == 'ASU'\n    assert candidate('ab') == 'ab'\n\ndef test_check():\n    check(reverse_vowels)\n\ntest_check()\n", "sample_io": ["assert reverse_vowels('Python') == 'Python'"], "source_codes": ["\ndef reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)\n\n\n"], "responses": ["```python\ndef reverse_vowels(str1: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(str1)\n    left, right = 0, len(s_list) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)\n```"], "prompt_tokens": [87], "completion_tokens": [164], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_131_reverse_vowels"}
{"name": "mbpp_432_median_trapezium", "language": "Python3", "prompt": "def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n\tWrite a function to find the median length of a trapezium.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_trapezium", "test": "def check(candidate):\n    assert candidate(15, 25, 35) == 20\n    assert candidate(10, 20, 30) == 15\n    assert candidate(6, 9, 4) == 7.5\n\ndef test_check():\n    check(median_trapezium)\n\ntest_check()\n", "sample_io": ["assert median_trapezium(15, 25, 35) == 20"], "source_codes": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints\n    of the non-parallel sides. Its length equals the average of the lengths\n    of the two parallel bases.\n    \n    Args:\n        base1 (int): Length of the first parallel base\n        base2 (int): Length of the second parallel base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The length of the median\n    \"\"\"\n    return (base1 + base2) / 2.0\n\n\n"], "responses": ["```python\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints\n    of the non-parallel sides. Its length equals the average of the lengths\n    of the two parallel bases.\n    \n    Args:\n        base1 (int): Length of the first parallel base\n        base2 (int): Length of the second parallel base\n        height (int): Height of the trapezium\n    \n    Returns:\n        float: The length of the median\n    \"\"\"\n    return (base1 + base2) / 2.0\n```"], "prompt_tokens": [91], "completion_tokens": [158], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_432_median_trapezium"}
{"name": "mbpp_161_remove_elements", "language": "Python3", "prompt": "from typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to remove all elements from a given list present in another list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_elements", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]\n\ndef test_check():\n    check(remove_elements)\n\ntest_check()\n", "sample_io": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"], "source_codes": ["\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Filter out elements that are present in list2\n    return [element for element in list1 if element not in set2]\n\n\n"], "responses": ["```python\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to remove all elements from a given list present in another list.\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    set2 = set(list2)\n    \n    # Filter out elements that are present in list2\n    return [element for element in list1 if element not in set2]\n```"], "prompt_tokens": [93], "completion_tokens": [97], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_161_remove_elements"}
{"name": "mbpp_597_find_kth", "language": "Python3", "prompt": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find kth element from the given two sorted arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_kth", "test": "def check(candidate):\n    assert candidate([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    assert candidate([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256\n    assert candidate([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8\n\ndef test_check():\n    check(find_kth)\n\ntest_check()\n", "sample_io": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"], "source_codes": ["\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Find kth element from the given two sorted arrays.\n    \"\"\"\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if len(arr1) == 0:\n        return arr2[k-1]\n    \n    if k == 1:\n        return min(arr1[0], arr2[0])\n    \n    # Binary search approach\n    left, right = 0, min(k, len(arr1))\n    \n    while left <= right:\n        # Partition arr1 and arr2\n        mid1 = (left + right) // 2\n        mid2 = k - mid1\n        \n        # Handle boundary cases\n        max_left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        min_right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        \n        max_left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        min_right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = mid1 - 1\n        else:\n            left = mid1 + 1\n    \n    return -1  # This should not happen for valid input\n\n\n"], "responses": ["```python\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n    Find kth element from the given two sorted arrays.\n    \"\"\"\n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Handle edge cases\n    if len(arr1) == 0:\n        return arr2[k-1]\n    \n    if k == 1:\n        return min(arr1[0], arr2[0])\n    \n    # Binary search approach\n    left, right = 0, min(k, len(arr1))\n    \n    while left <= right:\n        # Partition arr1 and arr2\n        mid1 = (left + right) // 2\n        mid2 = k - mid1\n        \n        # Handle boundary cases\n        max_left1 = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        min_right1 = float('inf') if mid1 == len(arr1) else arr1[mid1]\n        \n        max_left2 = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        min_right2 = float('inf') if mid2 == len(arr2) else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = mid1 - 1\n        else:\n            left = mid1 + 1\n    \n    return -1  # This should not happen for valid input\n```"], "prompt_tokens": [96], "completion_tokens": [370], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_597_find_kth"}
{"name": "mbpp_226_odd_values_string", "language": "Python3", "prompt": "def odd_values_string(str: str) -> str:\n    \"\"\"\n\tWrite a python function to remove the characters which have odd index values of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_values_string", "test": "def check(candidate):\n    assert candidate('abcdef') == 'ace'\n    assert candidate('python') == 'pto'\n    assert candidate('data') == 'dt'\n    assert candidate('lambs') == 'lms'\n\ndef test_check():\n    check(odd_values_string)\n\ntest_check()\n", "sample_io": ["assert odd_values_string('abcdef') == 'ace'"], "source_codes": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:  # Keep characters at even indices (0, 2, 4, ...)\n            result += str[i]\n    return result\n\n\n"], "responses": ["```python\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:  # Keep characters at even indices (0, 2, 4, ...)\n            result += str[i]\n    return result\n```"], "prompt_tokens": [82], "completion_tokens": [87], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_226_odd_values_string"}
{"name": "mbpp_278_count_first_elements", "language": "Python3", "prompt": "from typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n\tWrite a function to find the number of elements that occurs before the list element in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_first_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, (4, 6), 10]) == 3\n    assert candidate([2, 9, (5, 7), 11]) == 2\n    assert candidate([11, 15, 5, 8, (2, 3), 8]) == 4\n\ndef test_check():\n    check(count_first_elements)\n\ntest_check()\n", "sample_io": ["assert count_first_elements([1, 5, 7, (4, 6), 10]) == 3"], "source_codes": ["\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    count = 0\n    for element in test_tup:\n        if isinstance(element, list):\n            return count\n        count += 1\n    return count\n\n\n"], "responses": ["Looking at this problem, I need to find the number of elements that occur before the first list element in a tuple.\n\nLet me analyze what's needed:\n1. Iterate through the tuple elements\n2. Check if each element is a list\n3. Count elements until I find the first list\n4. Return that count\n\n```python\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    count = 0\n    for element in test_tup:\n        if isinstance(element, list):\n            return count\n        count += 1\n    return count\n```"], "prompt_tokens": [104], "completion_tokens": [153], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_278_count_first_elements"}
{"name": "mbpp_269_ascii_value", "language": "Python3", "prompt": "def ascii_value(k: str) -> int:\n    \"\"\"\n\tWrite a function to find the ascii value of a character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "ascii_value", "test": "def check(candidate):\n    assert candidate('A') == 65\n    assert candidate('R') == 82\n    assert candidate('S') == 83\n\ndef test_check():\n    check(ascii_value)\n\ntest_check()\n", "sample_io": ["assert ascii_value('A') == 65"], "source_codes": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    return ord(k)\n\n\n"], "responses": ["```python\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \"\"\"\n    return ord(k)\n```"], "prompt_tokens": [75], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_269_ascii_value"}
{"name": "mbpp_739_find_Index", "language": "Python3", "prompt": "def find_Index(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Index", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 14\n    assert candidate(4) == 45\n\ndef test_check():\n    check(find_Index)\n\ntest_check()\n", "sample_io": ["assert find_Index(2) == 4"], "source_codes": ["\nimport math\n\ndef find_Index(n: int) -> int:\n    \"\"\"\n    Find the index of smallest triangular number with n digits.\n    \n    A triangular number is of the form k(k+1)/2.\n    We want the smallest k such that k(k+1)/2 has n digits.\n    \n    A number has n digits if it's >= 10^(n-1).\n    So we need k(k+1)/2 >= 10^(n-1).\n    This gives us k^2 + k >= 2 * 10^(n-1).\n    Solving: k >= sqrt(2 * 10^(n-1) + 1/4) - 1/2.\n    \n    We can use binary search or direct calculation.\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    # Calculate the lower bound using the formula\n    target = 2 * (10 ** (n - 1))\n    # k^2 + k >= target\n    # k >= (-1 + sqrt(1 + 4*target)) / 2\n    discriminant = 1 + 4 * target\n    lower_bound = (-1 + math.sqrt(discriminant)) / 2\n    \n    # Start checking from the ceiling of lower_bound\n    k = math.ceil(lower_bound)\n    \n    # Verify that k(k+1)/2 has at least n digits\n    # If not, increment k until it does\n    while True:\n        triangular = k * (k + 1) // 2\n        if len(str(triangular)) >= n:\n            return k\n        k += 1\n\n\n"], "responses": ["```python\nimport math\n\ndef find_Index(n: int) -> int:\n    \"\"\"\n    Find the index of smallest triangular number with n digits.\n    \n    A triangular number is of the form k(k+1)/2.\n    We want the smallest k such that k(k+1)/2 has n digits.\n    \n    A number has n digits if it's >= 10^(n-1).\n    So we need k(k+1)/2 >= 10^(n-1).\n    This gives us k^2 + k >= 2 * 10^(n-1).\n    Solving: k >= sqrt(2 * 10^(n-1) + 1/4) - 1/2.\n    \n    We can use binary search or direct calculation.\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    # Calculate the lower bound using the formula\n    target = 2 * (10 ** (n - 1))\n    # k^2 + k >= target\n    # k >= (-1 + sqrt(1 + 4*target)) / 2\n    discriminant = 1 + 4 * target\n    lower_bound = (-1 + math.sqrt(discriminant)) / 2\n    \n    # Start checking from the ceiling of lower_bound\n    k = math.ceil(lower_bound)\n    \n    # Verify that k(k+1)/2 has at least n digits\n    # If not, increment k until it does\n    while True:\n        triangular = k * (k + 1) // 2\n        if len(str(triangular)) >= n:\n            return k\n        k += 1\n```"], "prompt_tokens": [100], "completion_tokens": [351], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_739_find_Index"}
{"name": "mbpp_19_test_duplicate", "language": "Python3", "prompt": "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to find whether a given array of integers contains any duplicate element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_duplicate", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 4]) == True\n    assert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True\n\ndef test_check():\n    check(test_duplicate)\n\ntest_check()\n", "sample_io": ["assert test_duplicate([1, 2, 3, 4, 5]) == False"], "source_codes": ["\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n\n"], "responses": ["```python\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in arraynums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n```"], "prompt_tokens": [86], "completion_tokens": [69], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_19_test_duplicate"}
{"name": "mbpp_62_smallest_num", "language": "Python3", "prompt": "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "smallest_num", "test": "def check(candidate):\n    assert candidate([10, 20, 1, 45, 99]) == 1\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([45, 46, 50, 60]) == 45\n\ndef test_check():\n    check(smallest_num)\n\ntest_check()\n", "sample_io": ["assert smallest_num([10, 20, 1, 45, 99]) == 1"], "source_codes": ["\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    return min(xs)\n\n\n"], "responses": ["```python\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    return min(xs)\n```"], "prompt_tokens": [81], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_62_smallest_num"}
{"name": "mbpp_746_sector_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sector_area", "test": "def check(candidate):\n    assert candidate(4, 45) == 6.283185307179586\n    assert candidate(9, 45) == 31.808625617596654\n    assert candidate(9, 361) == None\n\ndef test_check():\n    check(sector_area)\n\ntest_check()\n", "sample_io": ["assert sector_area(4, 45) == 6.283185307179586"], "source_codes": ["\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n    Find area of a sector given radius and angle in degrees.\n    Returns None if angle is larger than 360 degrees.\n    \"\"\"\n    if a > 360:\n        return None\n    \n    # Formula: Area = (θ/360) * π * r²\n    area = (a / 360) * 3.141592653589793 * (r ** 2)\n    return area\n\n\n"], "responses": ["```python\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n    Find area of a sector given radius and angle in degrees.\n    Returns None if angle is larger than 360 degrees.\n    \"\"\"\n    if a > 360:\n        return None\n    \n    # Formula: Area = (θ/360) * π * r²\n    area = (a / 360) * 3.141592653589793 * (r ** 2)\n    return area\n```"], "prompt_tokens": [109], "completion_tokens": [124], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_746_sector_area"}
{"name": "mbpp_142_count_samepair", "language": "Python3", "prompt": "from typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n\tWrite a function to count number items that are identical in the same position of three given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_samepair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 4\n    assert candidate([1, 2, 3, 4, 2, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 5\n\ndef test_check():\n    check(count_samepair)\n\ntest_check()\n", "sample_io": ["assert count_samepair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3"], "source_codes": ["\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    count = 0\n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min(len(list1), len(list2), len(list3))):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    count = 0\n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min(len(list1), len(list2), len(list3))):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n```"], "prompt_tokens": [102], "completion_tokens": [115], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_142_count_samepair"}
{"name": "mbpp_400_extract_freq", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to extract the number of unique tuples in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_freq", "test": "def check(candidate):\n    assert candidate([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    assert candidate([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    assert candidate([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n\ndef test_check():\n    check(extract_freq)\n\ntest_check()\n", "sample_io": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"], "source_codes": ["\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n\n\n"], "responses": ["```python\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n    \"\"\"\n    return len(set(test_list))\n```"], "prompt_tokens": [91], "completion_tokens": [48], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_400_extract_freq"}
{"name": "mbpp_595_min_Swaps", "language": "Python3", "prompt": "from typing import Any\n\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n\tWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Swaps", "test": "def check(candidate):\n    assert candidate('1101', '1110') == 1\n    assert candidate('111', '000') == 'Not Possible'\n    assert candidate('111', '110') == 'Not Possible'\n\ndef test_check():\n    check(min_Swaps)\n\ntest_check()\n", "sample_io": ["assert min_Swaps('1101', '1110') == 1"], "source_codes": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n    Count minimum number of swaps required to convert one binary number \n    represented as a string to another.\n    \"\"\"\n    # Check if both strings have same length\n    if len(str1) != len(str2):\n        return -1\n    \n    # Count positions where characters differ\n    diff_positions = []\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            diff_positions.append(i)\n    \n    # If no differences, no swaps needed\n    if len(diff_positions) == 0:\n        return 0\n    \n    # Count mismatches: positions where str1 has '0' but str2 has '1' and vice versa\n    count_0_to_1 = 0  # positions where str1='0' and str2='1'\n    count_1_to_0 = 0  # positions where str1='1' and str2='0'\n    \n    for i in diff_positions:\n        if str1[i] == '0' and str2[i] == '1':\n            count_0_to_1 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_1_to_0 += 1\n    \n    # If the counts don't match, conversion is impossible\n    if count_0_to_1 != count_1_to_0:\n        return -1\n    \n    # Minimum swaps needed is half the total mismatches (since each swap fixes 2 positions)\n    # But we need to be more careful - each swap can fix at most 2 mismatched positions\n    # The minimum number of swaps is count_0_to_1 (or count_1_to_0 since they're equal)\n    return count_0_to_1\n\n\n"], "responses": ["```python\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n    Count minimum number of swaps required to convert one binary number \n    represented as a string to another.\n    \"\"\"\n    # Check if both strings have same length\n    if len(str1) != len(str2):\n        return -1\n    \n    # Count positions where characters differ\n    diff_positions = []\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            diff_positions.append(i)\n    \n    # If no differences, no swaps needed\n    if len(diff_positions) == 0:\n        return 0\n    \n    # Count mismatches: positions where str1 has '0' but str2 has '1' and vice versa\n    count_0_to_1 = 0  # positions where str1='0' and str2='1'\n    count_1_to_0 = 0  # positions where str1='1' and str2='0'\n    \n    for i in diff_positions:\n        if str1[i] == '0' and str2[i] == '1':\n            count_0_to_1 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_1_to_0 += 1\n    \n    # If the counts don't match, conversion is impossible\n    if count_0_to_1 != count_1_to_0:\n        return -1\n    \n    # Minimum swaps needed is half the total mismatches (since each swap fixes 2 positions)\n    # But we need to be more careful - each swap can fix at most 2 mismatched positions\n    # The minimum number of swaps is count_0_to_1 (or count_1_to_0 since they're equal)\n    return count_0_to_1\n```"], "prompt_tokens": [99], "completion_tokens": [393], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_595_min_Swaps"}
{"name": "mbpp_135_hexagonal_num", "language": "Python3", "prompt": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "hexagonal_num", "test": "def check(candidate):\n    assert candidate(10) == 190\n    assert candidate(5) == 45\n    assert candidate(7) == 91\n\ndef test_check():\n    check(hexagonal_num)\n\ntest_check()\n", "sample_io": ["assert hexagonal_num(10) == 190"], "source_codes": ["\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    The nth hexagonal number is given by the formula: H(n) = n(2n - 1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n\n\n"], "responses": ["```python\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Find the nth hexagonal number.\n    \n    The nth hexagonal number is given by the formula: H(n) = n(2n - 1)\n    \n    Args:\n        n (int): The position of the hexagonal number (1-indexed)\n        \n    Returns:\n        int: The nth hexagonal number\n        \n    Examples:\n        >>> hexagonal_num(1)\n        1\n        >>> hexagonal_num(2)\n        6\n        >>> hexagonal_num(3)\n        15\n        >>> hexagonal_num(4)\n        28\n    \"\"\"\n    return n * (2 * n - 1)\n```"], "prompt_tokens": [75], "completion_tokens": [152], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_135_hexagonal_num"}
{"name": "mbpp_800_remove_all_spaces", "language": "Python3", "prompt": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_all_spaces", "test": "def check(candidate):\n    assert candidate('python  program') == 'pythonprogram'\n    assert candidate('python   programming    language') == 'pythonprogramminglanguage'\n    assert candidate('python                     program') == 'pythonprogram'\n    assert candidate('   python                     program') == 'pythonprogram'\n\ndef test_check():\n    check(remove_all_spaces)\n\ntest_check()\n", "sample_io": ["assert remove_all_spaces('python  program') == 'pythonprogram'"], "source_codes": ["\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n\n\n"], "responses": ["```python\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return text.replace(\" \", \"\")\n```"], "prompt_tokens": [76], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_800_remove_all_spaces"}
{"name": "mbpp_127_multiply_int", "language": "Python3", "prompt": "def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n\tWrite a function to multiply two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_int", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(5, 10) == 50\n    assert candidate(4, 8) == 32\n\ndef test_check():\n    check(multiply_int)\n\ntest_check()\n", "sample_io": ["assert multiply_int(10, 20) == 200"], "source_codes": ["\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n\n\n"], "responses": ["```python\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n```"], "prompt_tokens": [75], "completion_tokens": [38], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_127_multiply_int"}
{"name": "mbpp_764_number_ctr", "language": "Python3", "prompt": "def number_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count number of digits in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_ctr", "test": "def check(candidate):\n    assert candidate('program2bedone') == 1\n    assert candidate('3wonders') == 1\n    assert candidate('123') == 3\n    assert candidate('3wond-1ers2') == 3\n\ndef test_check():\n    check(number_ctr)\n\ntest_check()\n", "sample_io": ["assert number_ctr('program2bedone') == 1"], "source_codes": ["\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n```"], "prompt_tokens": [77], "completion_tokens": [56], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_764_number_ctr"}
{"name": "mbpp_767_get_pairs_count", "language": "Python3", "prompt": "from typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose sum is equal to ‘sum’. The funtion gets as input a list of numbers and the sum,\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_pairs_count", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1], 2) == 6\n    assert candidate([1, 5, 7, -1, 5], 6) == 3\n    assert candidate([1, -2, 3], 1) == 1\n    assert candidate([-1, -2, 3], -3) == 1\n\ndef test_check():\n    check(get_pairs_count)\n\ntest_check()\n", "sample_io": ["assert get_pairs_count([1, 1, 1, 1], 2) == 6"], "source_codes": ["\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum to find pairs for\n    \n    Returns:\n        Number of pairs whose sum equals the target sum\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through array to find pairs\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in frequency map\n        if complement in freq:\n            # If both numbers are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since we counted each pair twice, divide by 2\n    return count // 2\n\n\n"], "responses": ["```python\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n    Count the number of pairs whose sum is equal to 'sum'.\n    \n    Args:\n        arr: List of integers\n        sum: Target sum to find pairs for\n    \n    Returns:\n        Number of pairs whose sum equals the target sum\n    \"\"\"\n    # Use a dictionary to store frequency of each element\n    freq = {}\n    count = 0\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through array to find pairs\n    for num in arr:\n        complement = sum - num\n        \n        # If complement exists in frequency map\n        if complement in freq:\n            # If both numbers are same, we need at least 2 occurrences\n            if complement == num:\n                count += freq[complement] - 1\n            else:\n                # Add frequency of complement\n                count += freq[complement]\n    \n    # Since we counted each pair twice, divide by 2\n    return count // 2\n```"], "prompt_tokens": [106], "completion_tokens": [237], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_767_get_pairs_count"}
{"name": "mbpp_99_decimal_to_binary", "language": "Python3", "prompt": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n\tWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(8) == '1000'\n    assert candidate(18) == '10010'\n    assert candidate(7) == '111'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "sample_io": ["assert decimal_to_binary(8) == '1000'"], "source_codes": ["\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n\n\n"], "responses": ["```python\ndef decimal_to_binary(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    \n    return binary\n```"], "prompt_tokens": [87], "completion_tokens": [87], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_99_decimal_to_binary"}
{"name": "mbpp_119_search", "language": "Python3", "prompt": "from typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the element that appears only once in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "search", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8\n    assert candidate([1, 2, 2, 3, 3, 4, 4]) == 1\n\ndef test_check():\n    check(search)\n\ntest_check()\n", "sample_io": ["assert search([1, 1, 2, 2, 3]) == 3"], "source_codes": ["\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If pair matches, single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If pair doesn't match, single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n\n\n"], "responses": ["```python\ndef search(arr: List[int]) -> int:\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n    All other elements appear exactly twice.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even for proper pair checking\n        if mid % 2 == 1:\n            mid -= 1\n            \n        # If pair matches, single element is on the right side\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            # If pair doesn't match, single element is on the left side or at mid\n            right = mid\n    \n    return arr[left]\n```"], "prompt_tokens": [85], "completion_tokens": [165], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_119_search"}
{"name": "mbpp_92_is_undulating", "language": "Python3", "prompt": "def is_undulating(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is undulating or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_undulating", "test": "def check(candidate):\n    assert candidate(1212121) == True\n    assert candidate(1991) == False\n    assert candidate(121) == True\n\ndef test_check():\n    check(is_undulating)\n\ntest_check()\n", "sample_io": ["assert is_undulating(1212121) == True"], "source_codes": ["\ndef is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n    \"\"\"\n    # Convert number to string to easily access digits\n    s = str(n)\n    \n    # A number is undulating if it has at least 3 digits\n    if len(s) < 3:\n        return False\n    \n    # Check if the pattern alternates between two different digits\n    # Pattern should be like abab... or ababa...\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # First two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check the alternating pattern\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef is_undulating(n: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is undulating or not.\n    \"\"\"\n    # Convert number to string to easily access digits\n    s = str(n)\n    \n    # A number is undulating if it has at least 3 digits\n    if len(s) < 3:\n        return False\n    \n    # Check if the pattern alternates between two different digits\n    # Pattern should be like abab... or ababa...\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # First two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check the alternating pattern\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True\n```"], "prompt_tokens": [80], "completion_tokens": [233], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_92_is_undulating"}
{"name": "mbpp_105_count", "language": "Python3", "prompt": "from typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n\tWrite a python function to count true booleans in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count", "test": "def check(candidate):\n    assert candidate([True, False, True]) == 2\n    assert candidate([False, False]) == 0\n    assert candidate([True, True, True]) == 3\n\ndef test_check():\n    check(count)\n\ntest_check()\n", "sample_io": ["assert count([True, False, True]) == 2"], "source_codes": ["\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n\n\n"], "responses": ["```python\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return lst.count(True)\n```"], "prompt_tokens": [83], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_105_count"}
{"name": "mbpp_766_pair_wise", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to return a list of all pairs of consecutive items in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_wise", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    assert candidate([1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)]\n    assert candidate([5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n\ndef test_check():\n    check(pair_wise)\n\ntest_check()\n", "sample_io": ["assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"], "source_codes": ["\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n\n\n"], "responses": ["```python\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    result = []\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    return result\n```"], "prompt_tokens": [96], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_766_pair_wise"}
{"name": "mbpp_464_check_value", "language": "Python3", "prompt": "from typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n\tWrite a function to check if all values are same in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_value", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 12) == True\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 5) == False\n\ndef test_check():\n    check(check_value)\n\ntest_check()\n", "sample_io": ["assert check_value({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False"], "source_codes": ["\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True (vacuous truth)\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n\n\n"], "responses": ["```python\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Get all values from the dictionary\n    values = list(dict.values())\n    \n    # If dictionary is empty, return True (vacuous truth)\n    if not values:\n        return True\n    \n    # Check if all values are equal to n\n    return all(value == n for value in values)\n```"], "prompt_tokens": [89], "completion_tokens": [103], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_464_check_value"}
{"name": "mbpp_443_largest_neg", "language": "Python3", "prompt": "from typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest negative number from the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "largest_neg", "test": "def check(candidate):\n    assert candidate([1, 2, 3, -4, -6]) == -6\n    assert candidate([1, 2, 3, -8, -9]) == -9\n    assert candidate([1, 2, 3, 4, -1]) == -1\n\ndef test_check():\n    check(largest_neg)\n\ntest_check()\n", "sample_io": ["assert largest_neg([1, 2, 3, -4, -6]) == -6"], "source_codes": ["\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_nums = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_nums:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_nums)\n\n\n"], "responses": ["```python\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Find the largest negative number from the given list.\n    \"\"\"\n    # Filter out negative numbers\n    neg_nums = [num for num in list1 if num < 0]\n    \n    # If no negative numbers exist, raise an exception or return None\n    if not neg_nums:\n        raise ValueError(\"No negative numbers in the list\")\n    \n    # Return the maximum (largest) negative number\n    return max(neg_nums)\n```"], "prompt_tokens": [85], "completion_tokens": [109], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_443_largest_neg"}
{"name": "mbpp_602_first_repeated_char", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_repeated_char", "test": "def check(candidate):\n    assert candidate('abcabc') == 'a'\n    assert candidate('abc') == None\n    assert candidate('123123') == '1'\n\ndef test_check():\n    check(first_repeated_char)\n\ntest_check()\n", "sample_io": ["assert first_repeated_char('abcabc') == 'a'"], "source_codes": ["\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first repeated character in a given string.\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n\n\n"], "responses": ["```python\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Write a python function to find the first repeated character in a given string.\n    \"\"\"\n    seen = set()\n    \n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    \n    return None\n```"], "prompt_tokens": [87], "completion_tokens": [71], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_602_first_repeated_char"}
{"name": "mbpp_770_odd_num_sum", "language": "Python3", "prompt": "def odd_num_sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of fourth power of first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_num_sum", "test": "def check(candidate):\n    assert candidate(2) == 82\n    assert candidate(3) == 707\n    assert candidate(4) == 3108\n\ndef test_check():\n    check(odd_num_sum)\n\ntest_check()\n", "sample_io": ["assert odd_num_sum(2) == 82"], "source_codes": ["\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 4\n    return total\n\n\n"], "responses": ["```python\ndef odd_num_sum(n: int) -> int:\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n: Number of odd natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 4\n    return total\n```"], "prompt_tokens": [82], "completion_tokens": [108], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_770_odd_num_sum"}
{"name": "mbpp_424_extract_rear", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n\tWrite a function to extract only the rear index element of each string in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_rear", "test": "def check(candidate):\n    assert candidate(('Mers', 'for', 'Vers')) == ['s', 'r', 's']\n    assert candidate(('Avenge', 'for', 'People')) == ['e', 'r', 'e']\n    assert candidate(('Gotta', 'get', 'go')) == ['a', 't', 'o']\n\ndef test_check():\n    check(extract_rear)\n\ntest_check()\n", "sample_io": ["assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"], "source_codes": ["\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in test_tuple]\n\n\n"], "responses": ["```python\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in test_tuple]\n```"], "prompt_tokens": [96], "completion_tokens": [58], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_424_extract_rear"}
{"name": "mbpp_133_sum_negativenum", "language": "Python3", "prompt": "from typing import List\n\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of the negative numbers of a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_negativenum", "test": "def check(candidate):\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32\n    assert candidate([10, 15, -14, 13, -18, 12, -20]) == -52\n    assert candidate([19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894\n\ndef test_check():\n    check(sum_negativenum)\n\ntest_check()\n", "sample_io": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"], "source_codes": ["\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n\n\n"], "responses": ["```python\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    \"\"\"\n    return sum(num for num in nums if num < 0)\n```"], "prompt_tokens": [90], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_133_sum_negativenum"}
{"name": "mbpp_760_unique_Element", "language": "Python3", "prompt": "from typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list of numbers contains only one distinct element or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_Element", "test": "def check(candidate):\n    assert candidate([1, 1, 1]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == False\n\ndef test_check():\n    check(unique_Element)\n\ntest_check()\n", "sample_io": ["assert unique_Element([1, 1, 1]) == True"], "source_codes": ["\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    \"\"\"\n    if len(arr) == 0:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n    \"\"\"\n    if len(arr) == 0:\n        return True\n    \n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return False\n    return True\n```"], "prompt_tokens": [88], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_760_unique_Element"}
{"name": "mbpp_281_all_unique", "language": "Python3", "prompt": "from typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check if the elements of a given list are unique or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_unique", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == True\n\ndef test_check():\n    check(all_unique)\n\ntest_check()\n", "sample_io": ["assert all_unique([1, 2, 3]) == True"], "source_codes": ["\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n\n\n"], "responses": ["```python\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    return len(test_list) == len(set(test_list))\n```"], "prompt_tokens": [88], "completion_tokens": [52], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_281_all_unique"}
{"name": "mbpp_406_find_Parity", "language": "Python3", "prompt": "def find_Parity(x: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether the parity of a given number is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Parity", "test": "def check(candidate):\n    assert candidate(12) == False\n    assert candidate(7) == True\n    assert candidate(10) == False\n\ndef test_check():\n    check(find_Parity)\n\ntest_check()\n", "sample_io": ["assert find_Parity(12) == False"], "source_codes": ["\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        bool: True if parity is odd, False if parity is even\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if count is even\n    return count % 2 == 1\n\n\n"], "responses": ["```python\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Find whether the parity of a given number is odd.\n    \n    Parity is odd when the number of 1-bits in the binary representation is odd.\n    \n    Args:\n        x: An integer\n        \n    Returns:\n        bool: True if parity is odd, False if parity is even\n    \"\"\"\n    # Handle negative numbers by taking absolute value\n    x = abs(x)\n    \n    # Count the number of 1-bits\n    count = 0\n    while x:\n        count += x & 1  # Check if the least significant bit is 1\n        x >>= 1         # Right shift to check the next bit\n    \n    # Return True if count is odd, False if count is even\n    return count % 2 == 1\n```"], "prompt_tokens": [80], "completion_tokens": [178], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_406_find_Parity"}
{"name": "mbpp_562_Find_Max_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 4], [5, 6, 7, 8]]) == 4\n    assert candidate([[0, 1], [2, 2], [3, 2, 1]]) == 3\n    assert candidate([[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5\n\ndef test_check():\n    check(Find_Max_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"], "source_codes": ["\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    \n    return max_length\n```"], "prompt_tokens": [85], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_562_Find_Max_Length"}
{"name": "mbpp_87_merge_dictionaries_three", "language": "Python3", "prompt": "from typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to merge three dictionaries into a single dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_dictionaries_three", "test": "def check(candidate):\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'L': 'lavender', 'B': 'Blue' }) == { 'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'L': 'lavender', 'B': 'Blue' }, { 'G': 'Green', 'W': 'White' }) == { 'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White' }\n\ndef test_check():\n    check(merge_dictionaries_three)\n\ntest_check()\n", "sample_io": ["assert merge_dictionaries_three({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }"], "source_codes": ["\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n\n\n"], "responses": ["```python\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to merge three dictionaries into a single dictionary.\n    \"\"\"\n    result = {}\n    result.update(dict1)\n    result.update(dict2)\n    result.update(dict3)\n    return result\n```"], "prompt_tokens": [105], "completion_tokens": [82], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_87_merge_dictionaries_three"}
{"name": "mbpp_11_remove_Occ", "language": "Python3", "prompt": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n\tWrite a python function to remove first and last occurrence of a given character from the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_Occ", "test": "def check(candidate):\n    assert candidate('hello', 'l') == 'heo'\n    assert candidate('abcda', 'a') == 'bcd'\n    assert candidate('PHP', 'P') == 'H'\n\ndef test_check():\n    check(remove_Occ)\n\ntest_check()\n", "sample_io": ["assert remove_Occ('hello', 'l') == 'heo'"], "source_codes": ["\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Write a python function to remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n\n\n"], "responses": ["```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Write a python function to remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Find the first occurrence\n    first_index = s.find(ch)\n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Remove last first (to keep first_index valid)\n    result = s[:last_index] + s[last_index + 1:]\n    # Then remove first\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [201], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_11_remove_Occ"}
{"name": "mbpp_751_check_min_heap", "language": "Python3", "prompt": "from typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_min_heap", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 10, 15]) == True\n    assert candidate([2, 10, 4, 5, 3, 15]) == False\n\ndef test_check():\n    check(check_min_heap)\n\ntest_check()\n", "sample_io": ["assert check_min_heap([1, 2, 3, 4, 5, 6]) == True"], "source_codes": ["\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    A min heap satisfies the property that for every node i,\n    arr[i] <= arr[2*i+1] and arr[i] <= arr[2*i+2] (if they exist).\n    \n    Args:\n        arr: List of integers representing a binary tree in level order\n        \n    Returns:\n        bool: True if array represents a min heap, False otherwise\n    \"\"\"\n    n = len(arr)\n    \n    # Check each internal node\n    for i in range((n - 2) // 2 + 1):\n        # Check left child\n        left_child = 2 * i + 1\n        if left_child < n and arr[i] > arr[left_child]:\n            return False\n            \n        # Check right child\n        right_child = 2 * i + 2\n        if right_child < n and arr[i] > arr[right_child]:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    A min heap satisfies the property that for every node i,\n    arr[i] <= arr[2*i+1] and arr[i] <= arr[2*i+2] (if they exist).\n    \n    Args:\n        arr: List of integers representing a binary tree in level order\n        \n    Returns:\n        bool: True if array represents a min heap, False otherwise\n    \"\"\"\n    n = len(arr)\n    \n    # Check each internal node\n    for i in range((n - 2) // 2 + 1):\n        # Check left child\n        left_child = 2 * i + 1\n        if left_child < n and arr[i] > arr[left_child]:\n            return False\n            \n        # Check right child\n        right_child = 2 * i + 2\n        if right_child < n and arr[i] > arr[right_child]:\n            return False\n    \n    return True\n```"], "prompt_tokens": [109], "completion_tokens": [220], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_751_check_min_heap"}
{"name": "mbpp_410_min_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 2\n    assert candidate(['Python', 15, 20, 25]) == 15\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 20\n\ndef test_check():\n    check(min_val)\n\ntest_check()\n", "sample_io": ["assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"], "source_codes": ["\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n    Only considers integer values in the list.\n    \"\"\"\n    # Filter out only integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of integer values\n    if int_values:\n        return min(int_values)\n    else:\n        # If no integers in list, raise an exception or handle as needed\n        raise ValueError(\"No integer values found in the list\")\n\n\n"], "responses": ["```python\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n    Only considers integer values in the list.\n    \"\"\"\n    # Filter out only integer values\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the minimum of integer values\n    if int_values:\n        return min(int_values)\n    else:\n        # If no integers in list, raise an exception or handle as needed\n        raise ValueError(\"No integer values found in the list\")\n```"], "prompt_tokens": [90], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_410_min_val"}
{"name": "mbpp_578_interleave_lists", "language": "Python3", "prompt": "from typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to interleave 3 lists of the same length into a single flat list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "interleave_lists", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    assert candidate([10, 20], [15, 2], [5, 10]) == [10, 15, 5, 20, 2, 10]\n    assert candidate([11, 44], [10, 15], [20, 5]) == [11, 10, 20, 44, 15, 5]\n\ndef test_check():\n    check(interleave_lists)\n\ntest_check()\n", "sample_io": ["assert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"], "source_codes": ["\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n\n"], "responses": ["```python\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [88], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_578_interleave_lists"}
{"name": "mbpp_90_len_log", "language": "Python3", "prompt": "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "len_log", "test": "def check(candidate):\n    assert candidate(['python', 'PHP', 'bigdata']) == 7\n    assert candidate(['a', 'ab', 'abc']) == 3\n    assert candidate(['small', 'big', 'tall']) == 5\n\ndef test_check():\n    check(len_log)\n\ntest_check()\n", "sample_io": ["assert len_log(['python', 'PHP', 'bigdata']) == 7"], "source_codes": ["\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n\n\n"], "responses": ["```python\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    if not list1:\n        return 0\n    \n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n```"], "prompt_tokens": [83], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_90_len_log"}
{"name": "mbpp_452_loss_amount", "language": "Python3", "prompt": "def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n\tWrite a function that gives loss amount on a sale if the given amount has loss else return 0.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "loss_amount", "test": "def check(candidate):\n    assert candidate(1500, 1200) == 0\n    assert candidate(100, 200) == 100\n    assert candidate(2000, 5000) == 3000\n\ndef test_check():\n    check(loss_amount)\n\ntest_check()\n", "sample_io": ["assert loss_amount(1500, 1200) == 0"], "source_codes": ["\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n```"], "prompt_tokens": [90], "completion_tokens": [70], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_452_loss_amount"}
{"name": "mbpp_798__sum", "language": "Python3", "prompt": "from typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([15, 12, 13, 10]) == 50\n    assert candidate([0, 1, 2]) == 3\n\ndef test_check():\n    check(_sum)\n\ntest_check()\n", "sample_io": ["assert _sum([1, 2, 3]) == 6"], "source_codes": ["\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    return sum(arr)\n\n\n"], "responses": ["```python\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    return sum(arr)\n```"], "prompt_tokens": [81], "completion_tokens": [37], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_798__sum"}
{"name": "mbpp_393_max_length_list", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list with maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length_list", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5])\n    assert candidate([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9])\n\ndef test_check():\n    check(max_length_list)\n\ntest_check()\n", "sample_io": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list of lists containing integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = input_list[0]\n    max_len = len(max_list)\n    \n    for lst in input_list[1:]:\n        current_len = len(lst)\n        if current_len > max_len:\n            max_len = current_len\n            max_list = lst\n    \n    return (max_len, max_list)\n\n\n"], "responses": ["```python\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Find the list with maximum length from the input list of lists.\n    \n    Args:\n        input_list: A list of lists containing integers\n        \n    Returns:\n        A tuple containing the maximum length and the list with that length\n    \"\"\"\n    if not input_list:\n        return (0, [])\n    \n    max_list = input_list[0]\n    max_len = len(max_list)\n    \n    for lst in input_list[1:]:\n        current_len = len(lst)\n        if current_len > max_len:\n            max_len = current_len\n            max_list = lst\n    \n    return (max_len, max_list)\n```"], "prompt_tokens": [89], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_393_max_length_list"}
{"name": "mbpp_272_rear_extract", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rear_extract", "test": "def check(candidate):\n    assert candidate([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n    assert candidate([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\n    assert candidate([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\n\ndef test_check():\n    check(rear_extract)\n\ntest_check()\n", "sample_io": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"], "source_codes": ["\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [tuple_item[-1] for tuple_item in test_list]\n\n\n"], "responses": ["```python\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [tuple_item[-1] for tuple_item in test_list]\n```"], "prompt_tokens": [101], "completion_tokens": [65], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_272_rear_extract"}
{"name": "mbpp_564_count_Pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Pairs", "test": "def check(candidate):\n    assert candidate([1, 2, 1], 3) == 2\n    assert candidate([1, 1, 1, 1], 4) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 10\n\ndef test_check():\n    check(count_Pairs)\n\ntest_check()\n", "sample_io": ["assert count_Pairs([1, 2, 1], 3) == 2"], "source_codes": ["\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Calculate total possible pairs\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with equal elements\n    equal_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            equal_pairs += count * (count - 1) // 2\n    \n    return total_pairs - equal_pairs\n\n\n"], "responses": ["```python\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Calculate total possible pairs\n    total_pairs = n * (n - 1) // 2\n    \n    # Subtract pairs with equal elements\n    equal_pairs = 0\n    for count in freq.values():\n        if count > 1:\n            equal_pairs += count * (count - 1) // 2\n    \n    return total_pairs - equal_pairs\n```"], "prompt_tokens": [98], "completion_tokens": [148], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_564_count_Pairs"}
{"name": "mbpp_438_count_bidirectional", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to count bidirectional tuple pairs.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_bidirectional", "test": "def check(candidate):\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3\n    assert candidate([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4\n\ndef test_check():\n    check(count_bidirectional)\n\ntest_check()\n", "sample_io": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3"], "source_codes": ["\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    # Convert list to set for faster lookup\n    tuple_set = set(test_list)\n    \n    # Count bidirectional pairs\n    count = 0\n    for a, b in test_list:\n        # Check if the reverse tuple exists and is different from original\n        if (b, a) in tuple_set and (a, b) != (b, a):\n            count += 1\n    \n    # Divide by 2 to avoid double counting\n    return count // 2\n\n\n"], "responses": ["Looking at this problem, I need to count bidirectional tuple pairs. This means counting pairs of tuples where one tuple is the reverse of another tuple.\n\nFor example, if I have tuples (1,2) and (2,1), these form a bidirectional pair.\n\nLet me think through the approach:\n1. For each tuple in the list, I need to check if its reverse also exists in the list\n2. Count such pairs, but avoid double counting\n\nHere's my approach:\n- Convert the list to a set for O(1) lookup\n- For each tuple, check if its reverse exists in the set\n- Count valid pairs and divide by 2 to avoid double counting\n\n```python\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    # Convert list to set for faster lookup\n    tuple_set = set(test_list)\n    \n    # Count bidirectional pairs\n    count = 0\n    for a, b in test_list:\n        # Check if the reverse tuple exists and is different from original\n        if (b, a) in tuple_set and (a, b) != (b, a):\n            count += 1\n    \n    # Divide by 2 to avoid double counting\n    return count // 2\n```"], "prompt_tokens": [87], "completion_tokens": [265], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_438_count_bidirectional"}
{"name": "mbpp_640_remove_parenthesis", "language": "Python3", "prompt": "from typing import List\n\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n\tWrite a function to remove the parenthesis and what is inbetween them from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_parenthesis", "test": "def check(candidate):\n    assert candidate(['python (chrome)']) == 'python'\n    assert candidate(['string(.abc)']) == 'string'\n    assert candidate(['alpha(num)']) == 'alpha'\n\ndef test_check():\n    check(remove_parenthesis)\n\ntest_check()\n", "sample_io": ["assert remove_parenthesis(['python (chrome)']) == 'python'"], "source_codes": ["\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove the parenthesis and what is in between them from a string.\n    \"\"\"\n    result = []\n    \n    for item in items:\n        new_string = \"\"\n        skip = 0\n        \n        for char in item:\n            if char == '(':\n                skip += 1\n            elif char == ')' and skip > 0:\n                skip -= 1\n            elif skip == 0:\n                new_string += char\n        \n        result.append(new_string)\n    \n    return ' '.join(result)\n\n\n"], "responses": ["```python\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n    Remove the parenthesis and what is in between them from a string.\n    \"\"\"\n    result = []\n    \n    for item in items:\n        new_string = \"\"\n        skip = 0\n        \n        for char in item:\n            if char == '(':\n                skip += 1\n            elif char == ')' and skip > 0:\n                skip -= 1\n            elif skip == 0:\n                new_string += char\n        \n        result.append(new_string)\n    \n    return ' '.join(result)\n```"], "prompt_tokens": [88], "completion_tokens": [119], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_640_remove_parenthesis"}
{"name": "mbpp_72_dif_Square", "language": "Python3", "prompt": "def dif_Square(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dif_Square", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(10) == False\n    assert candidate(15) == True\n\ndef test_check():\n    check(dif_Square)\n\ntest_check()\n", "sample_io": ["assert dif_Square(5) == True"], "source_codes": ["\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n is not congruent to 2 modulo 4).\n    \n    This is because:\n    - If n = a² - b² = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even, then n is divisible by 4\n    - If both are odd, then n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n\n\n"], "responses": ["```python\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as the difference of two squares if and only if\n    n is not of the form 4k + 2 (i.e., n is not congruent to 2 modulo 4).\n    \n    This is because:\n    - If n = a² - b² = (a+b)(a-b), then either both (a+b) and (a-b) are even,\n      or both are odd\n    - If both are even, then n is divisible by 4\n    - If both are odd, then n is odd\n    - So n cannot be of the form 4k + 2\n    \"\"\"\n    return n % 4 != 2\n```"], "prompt_tokens": [86], "completion_tokens": [182], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_72_dif_Square"}
{"name": "mbpp_448_cal_sum", "language": "Python3", "prompt": "def cal_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of perrin numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cal_sum", "test": "def check(candidate):\n    assert candidate(9) == 49\n    assert candidate(10) == 66\n    assert candidate(11) == 88\n\ndef test_check():\n    check(cal_sum)\n\ntest_check()\n", "sample_io": ["assert cal_sum(9) == 49"], "source_codes": ["\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of first 3 terms\n    \n    # Calculate remaining terms and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to calculate the sum of Perrin numbers up to the nth term.\n\nThe Perrin sequence is defined as:\n- P(0) = 3\n- P(1) = 0  \n- P(2) = 2\n- P(n) = P(n-2) + P(n-3) for n > 2\n\nLet me trace through a few terms:\n- P(0) = 3\n- P(1) = 0\n- P(2) = 2\n- P(3) = P(1) + P(0) = 0 + 3 = 3\n- P(4) = P(2) + P(1) = 2 + 0 = 2\n- P(5) = P(3) + P(2) = 3 + 2 = 5\n\nSo the sequence starts: 3, 0, 2, 3, 2, 5, ...\n\nTo calculate the sum of Perrin numbers, I'll generate the first n+1 terms (from P(0) to P(n)) and sum them up.\n\n```python\ndef cal_sum(n: int) -> int:\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Handle base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3 + 0  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = p0 + p1 + p2  # Sum of first 3 terms\n    \n    # Calculate remaining terms and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0  # P(i) = P(i-2) + P(i-3)\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n```"], "prompt_tokens": [76], "completion_tokens": [532], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_448_cal_sum"}
{"name": "mbpp_96_divisor", "language": "Python3", "prompt": "def divisor(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of divisors of a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisor", "test": "def check(candidate):\n    assert candidate(15) == 4\n    assert candidate(12) == 6\n    assert candidate(9) == 3\n\ndef test_check():\n    check(divisor)\n\ntest_check()\n", "sample_io": ["assert divisor(15) == 4"], "source_codes": ["\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n\n\n"], "responses": ["```python\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The number of divisors of n\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    count = 0\n    n = abs(n)  # Handle negative numbers\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square case\n            else:\n                count += 2  # Count both i and n//i\n    \n    return count\n```"], "prompt_tokens": [78], "completion_tokens": [150], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_96_divisor"}
{"name": "mbpp_296_get_Inv_Count", "language": "Python3", "prompt": "from typing import List\n\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count inversions in an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Inv_Count", "test": "def check(candidate):\n    assert candidate([1, 20, 6, 4, 5]) == 5\n    assert candidate([1, 2, 1]) == 1\n    assert candidate([1, 2, 5, 6, 1]) == 3\n\ndef test_check():\n    check(get_Inv_Count)\n\ntest_check()\n", "sample_io": ["assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"], "source_codes": ["\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two sorted halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    # Create a temporary array for merging\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr[:], temp_arr, 0, len(arr) - 1)\n\n\n"], "responses": ["```python\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n    Count inversions in an array using merge sort approach.\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two sorted halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy back merged elements to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    # Create a temporary array for merging\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr[:], temp_arr, 0, len(arr) - 1)\n```"], "prompt_tokens": [83], "completion_tokens": [435], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_296_get_Inv_Count"}
{"name": "mbpp_57_find_Max_Num", "language": "Python3", "prompt": "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest number that can be formed with the given list of digits.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Max_Num", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 321\n    assert candidate([4, 5, 6, 1]) == 6541\n    assert candidate([1, 2, 3, 9]) == 9321\n\ndef test_check():\n    check(find_Max_Num)\n\ntest_check()\n", "sample_io": ["assert find_Max_Num([1, 2, 3]) == 321"], "source_codes": ["\ndef find_Max_Num(arr: List[int]) -> int:\n    # Convert all numbers to strings for comparison\n    str_arr = [str(num) for num in arr]\n    \n    # Sort using custom comparator\n    # For two numbers a and b, compare a+b with b+a\n    # If a+b > b+a, then a should come before b\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all numbers are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all strings to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n\n\n"], "responses": ["```python\ndef find_Max_Num(arr: List[int]) -> int:\n    # Convert all numbers to strings for comparison\n    str_arr = [str(num) for num in arr]\n    \n    # Sort using custom comparator\n    # For two numbers a and b, compare a+b with b+a\n    # If a+b > b+a, then a should come before b\n    str_arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Handle edge case where all numbers are 0\n    if str_arr[0] == '0':\n        return 0\n    \n    # Join all strings to form the largest number\n    result = ''.join(str_arr)\n    \n    # Convert back to integer\n    return int(result)\n```"], "prompt_tokens": [90], "completion_tokens": [156], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_57_find_Max_Num"}
{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n\n\n"], "responses": ["```python\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for value in sublist:\n            total += value\n    return total\n```"], "prompt_tokens": [95], "completion_tokens": [75], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n\n\n"], "responses": ["```python\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n```"], "prompt_tokens": [90], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're dealing with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d bits\n    # (n >> (32 - d)) gets the bits that would overflow and shifts them right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n\n\n"], "responses": ["```python\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \"\"\"\n    # Normalize d to be within 0-31 range since we're dealing with 32-bit numbers\n    d = d % 32\n    \n    # Left rotate: shift left by d bits and OR with the bits that overflowed\n    # (n << d) shifts left by d bits\n    # (n >> (32 - d)) gets the bits that would overflow and shifts them right\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n```"], "prompt_tokens": [93], "completion_tokens": [153], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": ["\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D table to store results of subproblems\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table bottom-up\n    # cl is length of substring\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            \n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    return dp[0][n - 1]\n\n\n"], "responses": ["```python\ndef lps(str: str) -> int:\n    n = len(str)\n    \n    # Create a 2D table to store results of subproblems\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table bottom-up\n    # cl is length of substring\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            \n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    return dp[0][n - 1]\n```"], "prompt_tokens": [84], "completion_tokens": [231], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_247_lps"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in the binary representation\n    num_bits = n.bit_length()\n    \n    # If there are less than 3 bits, there are no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all bits set except first and last\n    # For example, for 8 bits: 01111110\n    mask = (1 << (num_bits - 2)) - 1  # Create sequence of (num_bits-2) ones\n    mask = mask << 1  # Shift left by 1 to make room for the first bit\n    \n    # XOR with mask to toggle the middle bits\n    result = n ^ mask\n    \n    return result\n\n\n"], "responses": ["```python\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits in the binary representation\n    num_bits = n.bit_length()\n    \n    # If there are less than 3 bits, there are no middle bits to toggle\n    if num_bits < 3:\n        return n\n    \n    # Create a mask with all bits set except first and last\n    # For example, for 8 bits: 01111110\n    mask = (1 << (num_bits - 2)) - 1  # Create sequence of (num_bits-2) ones\n    mask = mask << 1  # Shift left by 1 to make room for the first bit\n    \n    # XOR with mask to toggle the middle bits\n    result = n ^ mask\n    \n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [191], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n\n\n"], "responses": ["```python\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n```"], "prompt_tokens": [82], "completion_tokens": [41], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n\n\n"], "responses": ["```python\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n```"], "prompt_tokens": [83], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n\n"], "responses": ["```python\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n```"], "prompt_tokens": [74], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
{"name": "mbpp_167_next_power_of_2", "language": "Python3", "prompt": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest power of 2 greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_power_of_2", "test": "def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 8\n    assert candidate(17) == 32\n\ndef test_check():\n    check(next_power_of_2)\n\ntest_check()\n", "sample_io": ["assert next_power_of_2(0) == 1"], "source_codes": ["\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    power = 0\n    temp = n\n    while temp > 0:\n        temp >>= 1\n        power += 1\n    \n    return 1 << power\n\n\n"], "responses": ["```python\ndef next_power_of_2(n: int) -> int:\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the position of the most significant bit\n    # and return 2 raised to that position + 1\n    power = 0\n    temp = n\n    while temp > 0:\n        temp >>= 1\n        power += 1\n    \n    return 1 << power\n```"], "prompt_tokens": [85], "completion_tokens": [144], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_167_next_power_of_2"}
{"name": "mbpp_756_text_match_zero_one", "language": "Python3", "prompt": "def text_match_zero_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_zero_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('dsabbbba') == True\n    assert candidate('asbbbba') == False\n    assert candidate('abaaa') == True\n\ndef test_check():\n    check(text_match_zero_one)\n\ntest_check()\n", "sample_io": ["assert text_match_zero_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [106], "completion_tokens": [64], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_756_text_match_zero_one"}
{"name": "mbpp_633_pair_xor_Sum", "language": "Python3", "prompt": "from typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of xor of all pairs of numbers in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_xor_Sum", "test": "def check(candidate):\n    assert candidate([5, 9, 7, 6], 4) == 47\n    assert candidate([7, 3, 5], 3) == 12\n    assert candidate([7, 3], 2) == 4\n\ndef test_check():\n    check(pair_xor_Sum)\n\ntest_check()\n", "sample_io": ["assert pair_xor_Sum([5, 9, 7, 6], 4) == 47"], "source_codes": ["\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    if n <= 1:\n        return 0\n    \n    total_sum = 0\n    \n    # Check for each bit position (assuming 32-bit integers)\n    for bit in range(32):\n        # Count how many numbers have this bit set\n        count_set = 0\n        for num in arr:\n            if num & (1 << bit):\n                count_set += 1\n        \n        # Count of numbers with this bit unset\n        count_unset = n - count_set\n        \n        # Number of pairs where XOR will have this bit set\n        pairs_with_bit_set = count_set * count_unset\n        \n        # Add contribution of this bit to total sum\n        total_sum += pairs_with_bit_set * (1 << bit)\n    \n    return total_sum\n\n\n"], "responses": ["Looking at this problem, I need to find the sum of XOR of all pairs of numbers in the given list.\n\nLet me think about this step by step:\n\n1. For a list of n elements, there are n*(n-1)/2 pairs\n2. I need to calculate XOR for each pair and sum them up\n3. However, there's a more efficient approach using bit manipulation\n\nThe key insight is to think about each bit position separately:\n- For each bit position, count how many numbers have that bit set to 1\n- If there are k numbers with bit set to 1, then there are (n-k) numbers with bit set to 0\n- The XOR of a pair will have that bit set to 1 if exactly one of the two numbers has that bit set to 1\n- So the number of pairs where this bit contributes to the XOR sum is k * (n-k)\n- Each such contribution adds 2^bit_position to the total sum\n\n```python\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    if n <= 1:\n        return 0\n    \n    total_sum = 0\n    \n    # Check for each bit position (assuming 32-bit integers)\n    for bit in range(32):\n        # Count how many numbers have this bit set\n        count_set = 0\n        for num in arr:\n            if num & (1 << bit):\n                count_set += 1\n        \n        # Count of numbers with this bit unset\n        count_unset = n - count_set\n        \n        # Number of pairs where XOR will have this bit set\n        pairs_with_bit_set = count_set * count_unset\n        \n        # Add contribution of this bit to total sum\n        total_sum += pairs_with_bit_set * (1 << bit)\n    \n    return total_sum\n```"], "prompt_tokens": [95], "completion_tokens": [384], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_633_pair_xor_Sum"}
{"name": "mbpp_458_rectangle_area", "language": "Python3", "prompt": "def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to find the area of a rectangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rectangle_area", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(10, 5) == 50\n    assert candidate(4, 2) == 8\n\ndef test_check():\n    check(rectangle_area)\n\ntest_check()\n", "sample_io": ["assert rectangle_area(10, 20) == 200"], "source_codes": ["\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n\n\n"], "responses": ["```python\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n```"], "prompt_tokens": [78], "completion_tokens": [40], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_458_rectangle_area"}
{"name": "mbpp_738_geometric_sum", "language": "Python3", "prompt": "def geometric_sum(n: int) -> float:\n    \"\"\"\n\tWrite a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "geometric_sum", "test": "def check(candidate):\n    assert candidate(7) == 1.9921875\n    assert candidate(4) == 1.9375\n    assert candidate(8) == 1.99609375\n\ndef test_check():\n    check(geometric_sum)\n\ntest_check()\n", "sample_io": ["assert geometric_sum(7) == 1.9921875"], "source_codes": ["\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n\n\n"], "responses": ["Looking at this problem, I need to calculate the geometric sum of n-1. Based on the context and typical geometric series problems, this likely refers to the sum of a geometric series where each term is half of the previous one, starting with 1.\n\nThe geometric sum formula for the series 1 + 1/2 + 1/4 + 1/8 + ... up to n terms is:\nSum = 2 - 1/(2^(n-1))\n\nBut since we want the sum of \"n-1\" terms, I'll calculate the sum of the first (n-1) terms of this geometric series.\n\nLet me implement this recursively as suggested by the exercise reference:\n\n```python\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n```\n\nWait, let me reconsider the problem. Looking at the reference URL, this is about calculating the geometric sum recursively. The standard geometric sum being referred to is likely: 1 + 1/2 + 1/4 + 1/8 + ... + 1/(2^(n-1)) for n terms.\n\nBut the problem says \"geometric sum of n-1\", so I think it wants the sum of the first (n-1) terms of this series.\n\nLet me revise:\n\n```python\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms: 1 + 1/2 + 1/4 + ... + 1/2^(n-2)\n    \"\"\"\n    if n <= 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n```\n\nActually, let me think more carefully. If n=1, then n-1=0, so we want sum of 0 terms = 0.\nIf n=2, then n-1=1, so we want sum of 1 term = 1.\nIf n=3, then n-1=2, so we want sum of 2 terms = 1 + 1/2 = 1.5.\n\n```python\ndef geometric_sum(n: int) -> float:\n    \"\"\"\n    Calculate the geometric sum of n-1 terms of the series 1 + 1/2 + 1/4 + 1/8 + ...\n    \"\"\"\n    if n <= 1:\n        return 0\n    else:\n        return 1 / (2 ** (n - 2)) + geometric_sum(n - 1)\n```"], "prompt_tokens": [101], "completion_tokens": [614], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_738_geometric_sum"}
{"name": "mbpp_426_filter_oddnumbers", "language": "Python3", "prompt": "from typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to filter odd numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_oddnumbers", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 20, 45, 67, 84, 93]) == [45, 67, 93]\n    assert candidate([5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3]\n\ndef test_check():\n    check(filter_oddnumbers)\n\ntest_check()\n", "sample_io": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"], "source_codes": ["\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\n\n"], "responses": ["```python\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n```"], "prompt_tokens": [79], "completion_tokens": [47], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_426_filter_oddnumbers"}
{"name": "mbpp_437_remove_odd", "language": "Python3", "prompt": "def remove_odd(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove odd characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate('python') == 'yhn'\n    assert candidate('program') == 'rga'\n    assert candidate('language') == 'agae'\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd('python') == 'yhn'"], "source_codes": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join(char for i, char in enumerate(str1) if i % 2 == 0)\n\n\n"], "responses": ["```python\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return ''.join(char for i, char in enumerate(str1) if i % 2 == 0)\n```"], "prompt_tokens": [75], "completion_tokens": [54], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_437_remove_odd"}
{"name": "mbpp_227_min_of_three", "language": "Python3", "prompt": "def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find minimum of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_of_three", "test": "def check(candidate):\n    assert candidate(10, 20, 0) == 0\n    assert candidate(19, 15, 18) == 15\n    assert candidate(-10, -20, -30) == -30\n\ndef test_check():\n    check(min_of_three)\n\ntest_check()\n", "sample_io": ["assert min_of_three(10, 20, 0) == 0"], "source_codes": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n\n"], "responses": ["```python\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n```"], "prompt_tokens": [82], "completion_tokens": [48], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_227_min_of_three"}
{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n\n\n"], "responses": ["```python\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n```"], "prompt_tokens": [86], "completion_tokens": [50], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [83], "completion_tokens": [59], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    \n    # For n >= 2\n    # same[i] = number of ways where post i has same color as post i-1\n    # diff[i] = number of ways where post i has different color from post i-1\n    \n    same = k * 1  # For 2nd post same as 1st: k choices for first, 1 for second\n    diff = k * (k - 1)  # For 2nd post different from 1st: k choices for first, k-1 for second\n    \n    # For each subsequent post\n    for i in range(3, n + 1):\n        # If current post has same color as previous, previous must be different from the one before it\n        new_same = diff * 1\n        \n        # If current post has different color from previous, previous can be same or different\n        new_diff = (same + diff) * (k - 1)\n        \n        same = new_same\n        diff = new_diff\n    \n    return same + diff\n\n\n"], "responses": ["```python\ndef count_no_of_ways(n: int, k: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    \n    # For n >= 2\n    # same[i] = number of ways where post i has same color as post i-1\n    # diff[i] = number of ways where post i has different color from post i-1\n    \n    same = k * 1  # For 2nd post same as 1st: k choices for first, 1 for second\n    diff = k * (k - 1)  # For 2nd post different from 1st: k choices for first, k-1 for second\n    \n    # For each subsequent post\n    for i in range(3, n + 1):\n        # If current post has same color as previous, previous must be different from the one before it\n        new_same = diff * 1\n        \n        # If current post has different color from previous, previous can be same or different\n        new_diff = (same + diff) * (k - 1)\n        \n        same = new_same\n        diff = new_diff\n    \n    return same + diff\n```"], "prompt_tokens": [107], "completion_tokens": [262], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        Remainder of product when divided by n\n    \"\"\"\n    if not arr or n == 0:\n        return 0\n    \n    result = 1\n    for num in arr:\n        result = (result * num) % n\n    \n    return result\n\n\n"], "responses": ["```python\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        Remainder of product when divided by n\n    \"\"\"\n    if not arr or n == 0:\n        return 0\n    \n    result = 1\n    for num in arr:\n        result = (result * num) % n\n    \n    return result\n```"], "prompt_tokens": [89], "completion_tokens": [108], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n\n\n"], "responses": ["```python\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n```"], "prompt_tokens": [90], "completion_tokens": [49], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Check whether the given array is monotonic or not.\n    An array is monotonic if it is either entirely non-increasing or non-decreasing.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    increasing = all(A[i] <= A[i+1] for i in range(len(A)-1))\n    \n    # Check if array is monotonic decreasing\n    decreasing = all(A[i] >= A[i+1] for i in range(len(A)-1))\n    \n    return increasing or decreasing\n\n\n"], "responses": ["```python\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Check whether the given array is monotonic or not.\n    An array is monotonic if it is either entirely non-increasing or non-decreasing.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    increasing = all(A[i] <= A[i+1] for i in range(len(A)-1))\n    \n    # Check if array is monotonic decreasing\n    decreasing = all(A[i] >= A[i+1] for i in range(len(A)-1))\n    \n    return increasing or decreasing\n```"], "prompt_tokens": [88], "completion_tokens": [138], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": ["\ndef parabola_directrix(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the directrix of a parabola y = ax^2 + bx + c.\n    \n    The directrix of a parabola y = ax^2 + bx + c is y = c - (b^2 + 1)/(4a)\n    \"\"\"\n    return c - (b**2 + 1)/(4*a)\n\n\n"], "responses": ["Looking at this problem, I need to find the directrix of a parabola given in the standard form y = ax² + bx + c.\n\nLet me think through the steps:\n\n1. For a parabola in the form y = ax² + bx + c, I need to convert it to the standard form to find the focus and directrix\n2. The standard form of a parabola with vertical axis is (x - h)² = 4p(y - k), where (h,k) is the vertex and p is the distance from vertex to focus\n3. The directrix is the line y = k - p\n\nSteps to solve:\n1. Find the vertex (h, k) by completing the square or using calculus\n2. Rewrite in standard form to find p\n3. Calculate the directrix as y = k - p\n\nFor y = ax² + bx + c:\n- Vertex x-coordinate: h = -b/(2a)\n- Vertex y-coordinate: k = a(-b/(2a))² + b(-b/(2a)) + c = c - b²/(4a)\n- From the standard form, 4p = 1/a, so p = 1/(4a)\n\nTherefore, directrix: y = k - p = (c - b²/(4a)) - 1/(4a) = c - b²/(4a) - 1/(4a) = c - (b² + 1)/(4a)\n\n```python\ndef parabola_directrix(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the directrix of a parabola y = ax^2 + bx + c.\n    \n    The directrix of a parabola y = ax^2 + bx + c is y = c - (b^2 + 1)/(4a)\n    \"\"\"\n    return c - (b**2 + 1)/(4*a)\n```"], "prompt_tokens": [88], "completion_tokens": [415], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": ["\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n    return result\n\n\n"], "responses": ["```python\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n    return result\n```"], "prompt_tokens": [87], "completion_tokens": [67], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_618_div_list"}
{"name": "mbpp_421_concatenate_tuple", "language": "Python3", "prompt": "from typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n\tWrite a function to concatenate each element of tuple by the delimiter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "concatenate_tuple", "test": "def check(candidate):\n    assert candidate(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'\n    assert candidate(('QWE', 'is', 4, 'RTY')) == 'QWE-is-4-RTY'\n    assert candidate(('ZEN', 'is', 4, 'OP')) == 'ZEN-is-4-OP'\n\ndef test_check():\n    check(concatenate_tuple)\n\ntest_check()\n", "sample_io": ["assert concatenate_tuple(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'"], "source_codes": ["\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with a delimiter\n    # Using underscore as the delimiter as it's commonly used\n    return \"_\".join(str(element) for element in test_tup)\n\n\n"], "responses": ["```python\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n    Write a function to concatenate each element of tuple by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with a delimiter\n    # Using underscore as the delimiter as it's commonly used\n    return \"_\".join(str(element) for element in test_tup)\n```"], "prompt_tokens": [90], "completion_tokens": [83], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_421_concatenate_tuple"}
{"name": "mbpp_750_add_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n\tWrite a function to add the given tuple to the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_tuple", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    assert candidate([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]\n    assert candidate([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]\n\ndef test_check():\n    check(add_tuple)\n\ntest_check()\n", "sample_io": ["assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"], "source_codes": ["\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list with it\n    result = test_list.copy()  # Create a copy to avoid modifying the original list\n    result.extend(list(test_tup))\n    return result\n\n\n"], "responses": ["```python\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list with it\n    result = test_list.copy()  # Create a copy to avoid modifying the original list\n    result.extend(list(test_tup))\n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [92], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_750_add_tuple"}
{"name": "mbpp_304_find_Element", "language": "Python3", "prompt": "from typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    \"\"\"\n\tWrite a python function to find element at a given index after number of rotations.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3\n    assert candidate([1, 2, 3, 4], [[0, 1], [0, 2]], 1, 2) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [[0, 1], [0, 2]], 1, 1) == 1\n\ndef test_check():\n    check(find_Element)\n\ntest_check()\n", "sample_io": ["assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3"], "source_codes": ["\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Perform the specified number of rotations\n    for _ in range(rotations):\n        # For each range, perform a right rotation\n        for start, end in ranges:\n            if start < end and start >= 0 and end < len(result_arr):\n                # Right rotation: move last element to first position\n                temp = result_arr[end]\n                for i in range(end, start, -1):\n                    result_arr[i] = result_arr[i-1]\n                result_arr[start] = temp\n    \n    # Return the element at the specified index\n    return result_arr[index]\n\n\n"], "responses": ["Looking at this problem, I need to find the element at a given index after performing a certain number of rotations on an array within specified ranges.\n\nLet me break down the approach:\n1. For each rotation, I need to rotate the elements in the specified ranges\n2. After all rotations, return the element at the given index\n\nHowever, looking at the function signature and the description, it seems like we might be doing multiple rotations on the same array structure. Let me implement a solution that handles range-based rotations.\n\n```python\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    # Create a copy of the array to avoid modifying the original\n    result_arr = arr[:]\n    \n    # Perform the specified number of rotations\n    for _ in range(rotations):\n        # For each range, perform a right rotation\n        for start, end in ranges:\n            if start < end and start >= 0 and end < len(result_arr):\n                # Right rotation: move last element to first position\n                temp = result_arr[end]\n                for i in range(end, start, -1):\n                    result_arr[i] = result_arr[i-1]\n                result_arr[start] = temp\n    \n    # Return the element at the specified index\n    return result_arr[index]\n```"], "prompt_tokens": [99], "completion_tokens": [274], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_304_find_Element"}
{"name": "mbpp_740_tuple_to_dict", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_dict", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }\n    assert candidate((1, 2, 3, 4, 5, 6)) == { 1: 2, 3: 4, 5: 6 }\n    assert candidate((7, 8, 9, 10, 11, 12)) == { 7: 8, 9: 10, 11: 12 }\n\ndef test_check():\n    check(tuple_to_dict)\n\ntest_check()\n", "sample_io": ["assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }"], "source_codes": ["\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert a tuple to a key-value dictionary using adjacent elements.\n    Elements at even indices become keys, elements at odd indices become values.\n    \"\"\"\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result\n\n\n"], "responses": ["```python\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert a tuple to a key-value dictionary using adjacent elements.\n    Elements at even indices become keys, elements at odd indices become values.\n    \"\"\"\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result\n```"], "prompt_tokens": [126], "completion_tokens": [104], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_740_tuple_to_dict"}
{"name": "mbpp_627_find_First_Missing", "language": "Python3", "prompt": "from typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest missing number from a sorted list of natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_First_Missing", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3]) == 4\n    assert candidate([0, 1, 2, 6, 9]) == 3\n    assert candidate([2, 3, 5, 8, 9]) == 0\n\ndef test_check():\n    check(find_First_Missing)\n\ntest_check()\n", "sample_io": ["assert find_First_Missing([0, 1, 2, 3]) == 4"], "source_codes": ["\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \n    Args:\n        array: A sorted list of natural numbers\n        \n    Returns:\n        The smallest missing natural number\n    \"\"\"\n    # Handle edge cases\n    if not array:\n        return 0\n    \n    # If the first element is not 0, then 0 is missing\n    if array[0] > 0:\n        return 0\n    \n    # Binary search approach for O(log n) time complexity\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the element at mid index is equal to mid,\n        # then all elements before mid are in correct positions\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If array[mid] != mid, the missing number is mid or before mid\n            right = mid - 1\n    \n    # At the end, left will be the smallest missing number\n    return left\n\n\n"], "responses": ["```python\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n    \n    Args:\n        array: A sorted list of natural numbers\n        \n    Returns:\n        The smallest missing natural number\n    \"\"\"\n    # Handle edge cases\n    if not array:\n        return 0\n    \n    # If the first element is not 0, then 0 is missing\n    if array[0] > 0:\n        return 0\n    \n    # Binary search approach for O(log n) time complexity\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the element at mid index is equal to mid,\n        # then all elements before mid are in correct positions\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If array[mid] != mid, the missing number is mid or before mid\n            right = mid - 1\n    \n    # At the end, left will be the smallest missing number\n    return left\n```"], "prompt_tokens": [89], "completion_tokens": [242], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_627_find_First_Missing"}
{"name": "mbpp_294_max_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 5\n    assert candidate(['Python', 15, 20, 25]) == 25\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 50\n\ndef test_check():\n    check(max_val)\n\ntest_check()\n", "sample_io": ["assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"], "source_codes": ["\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only the integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the maximum of the integer values\n    return max(int_values)\n\n\n"], "responses": ["```python\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    # Filter out only the integer values from the list\n    int_values = [x for x in listval if isinstance(x, int)]\n    \n    # Return the maximum of the integer values\n    return max(int_values)\n```"], "prompt_tokens": [90], "completion_tokens": [86], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_294_max_val"}
{"name": "mbpp_165_count_char_position", "language": "Python3", "prompt": "def count_char_position(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_char_position", "test": "def check(candidate):\n    assert candidate('xbcefg') == 2\n    assert candidate('ABcED') == 3\n    assert candidate('AbgdeF') == 5\n\ndef test_check():\n    check(count_char_position)\n\ntest_check()\n", "sample_io": ["assert count_char_position('xbcefg') == 2"], "source_codes": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i in range(len(str1)):\n        char = str1[i]\n        # Check if character is a letter\n        if char.isalpha():\n            # Get the position of the character in alphabet (a=1, b=2, ..., z=26)\n            alphabet_position = ord(char) - ord('a') + 1\n            # Compare with position in string (1-indexed)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n\n\n"], "responses": ["```python\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i in range(len(str1)):\n        char = str1[i]\n        # Check if character is a letter\n        if char.isalpha():\n            # Get the position of the character in alphabet (a=1, b=2, ..., z=26)\n            alphabet_position = ord(char) - ord('a') + 1\n            # Compare with position in string (1-indexed)\n            if alphabet_position == i + 1:\n                count += 1\n    \n    return count\n```"], "prompt_tokens": [95], "completion_tokens": [170], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_165_count_char_position"}
{"name": "mbpp_589_perfect_squares", "language": "Python3", "prompt": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find perfect squares between two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perfect_squares", "test": "def check(candidate):\n    assert candidate(1, 30) == [1, 4, 9, 16, 25]\n    assert candidate(50, 100) == [64, 81, 100]\n    assert candidate(100, 200) == [100, 121, 144, 169, 196]\n\ndef test_check():\n    check(perfect_squares)\n\ntest_check()\n", "sample_io": ["assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"], "source_codes": ["\nfrom typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Find perfect squares between two given numbers.\n    \n    Args:\n        a: First number (inclusive)\n        b: Second number (inclusive)\n    \n    Returns:\n        List of perfect squares between a and b (inclusive)\n    \"\"\"\n    # Ensure a is the smaller number\n    if a > b:\n        a, b = b, a\n    \n    # Find the smallest integer whose square is >= a\n    start = math.ceil(math.sqrt(a))\n    \n    # Find the largest integer whose square is <= b\n    end = math.floor(math.sqrt(b))\n    \n    # Generate perfect squares\n    result = []\n    for i in range(start, end + 1):\n        square = i * i\n        if a <= square <= b:\n            result.append(square)\n    \n    return result\n\n\n"], "responses": ["```python\nfrom typing import List\nimport math\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n    Find perfect squares between two given numbers.\n    \n    Args:\n        a: First number (inclusive)\n        b: Second number (inclusive)\n    \n    Returns:\n        List of perfect squares between a and b (inclusive)\n    \"\"\"\n    # Ensure a is the smaller number\n    if a > b:\n        a, b = b, a\n    \n    # Find the smallest integer whose square is >= a\n    start = math.ceil(math.sqrt(a))\n    \n    # Find the largest integer whose square is <= b\n    end = math.floor(math.sqrt(b))\n    \n    # Generate perfect squares\n    result = []\n    for i in range(start, end + 1):\n        square = i * i\n        if a <= square <= b:\n            result.append(square)\n    \n    return result\n```"], "prompt_tokens": [86], "completion_tokens": [192], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_589_perfect_squares"}
{"name": "mbpp_744_check_none", "language": "Python3", "prompt": "from typing import Any\n\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuple has any none value or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_none", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6, None)) == True\n    assert candidate((7, 8, 9, 11, 14)) == False\n    assert candidate((1, 2, 3, 4, None)) == True\n\ndef test_check():\n    check(check_none)\n\ntest_check()\n", "sample_io": ["assert check_none((10, 4, 5, 6, None)) == True"], "source_codes": ["\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    for item in test_tup:\n        if item is None:\n            return True\n    \n    return False\n\n\n"], "responses": ["```python\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    \"\"\"\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    for item in test_tup:\n        if item is None:\n            return True\n    \n    return False\n```"], "prompt_tokens": [86], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_744_check_none"}
{"name": "mbpp_726_multiply_elements", "language": "Python3", "prompt": "from typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, 8, 10]) == [5, 35, 56, 80]\n    assert candidate([2, 4, 5, 6, 7]) == [8, 20, 30, 42]\n    assert candidate([12, 13, 14, 9, 15]) == [156, 182, 126, 135]\n    assert candidate([12]) == []\n\ndef test_check():\n    check(multiply_elements)\n\ntest_check()\n", "sample_io": ["assert multiply_elements([1, 5, 7, 8, 10]) == [5, 35, 56, 80]"], "source_codes": ["\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N \n    where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return result\n\n\n"], "responses": ["```python\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n    Takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N \n    where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return result\n```"], "prompt_tokens": [124], "completion_tokens": [111], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_726_multiply_elements"}
{"name": "mbpp_736_left_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(left_insertion)\n\ntest_check()\n", "sample_io": ["assert left_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "responses": ["```python\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n```"], "prompt_tokens": [118], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_736_left_insertion"}
{"name": "mbpp_63_max_difference", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between available pairs in the given tuple list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_difference", "test": "def check(candidate):\n    assert candidate([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    assert candidate([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    assert candidate([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n\ndef test_check():\n    check(max_difference)\n\ntest_check()\n", "sample_io": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"], "source_codes": ["\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\n\n"], "responses": ["```python\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n```"], "prompt_tokens": [93], "completion_tokens": [92], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_63_max_difference"}
{"name": "mbpp_264_dog_age", "language": "Python3", "prompt": "def dog_age(h_age: int) -> int:\n    \"\"\"\n\tWrite a function to calculate a dog's age in dog's years.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dog_age", "test": "def check(candidate):\n    assert candidate(12) == 61\n    assert candidate(15) == 73\n    assert candidate(24) == 109\n\ndef test_check():\n    check(dog_age)\n\ntest_check()\n", "sample_io": ["assert dog_age(12) == 61"], "source_codes": ["\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + (h_age - 2) * 4\n\n\n"], "responses": ["```python\ndef dog_age(h_age: int) -> int:\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n    \"\"\"\n    if h_age <= 0:\n        return 0\n    elif h_age == 1:\n        return 10\n    elif h_age == 2:\n        return 21\n    else:\n        return 21 + (h_age - 2) * 4\n```"], "prompt_tokens": [78], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_264_dog_age"}
{"name": "mbpp_273_substract_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "substract_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    assert candidate((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    assert candidate((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n\ndef test_check():\n    check(substract_elements)\n\ntest_check()\n", "sample_io": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"], "source_codes": ["\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (test_tup1[0] - test_tup2[0], test_tup1[1] - test_tup2[1], test_tup1[2] - test_tup2[2])\n\n\n"], "responses": ["```python\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (test_tup1[0] - test_tup2[0], test_tup1[1] - test_tup2[1], test_tup1[2] - test_tup2[2])\n```"], "prompt_tokens": [123], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_273_substract_elements"}
{"name": "mbpp_83_get_Char", "language": "Python3", "prompt": "def get_Char(strr: str) -> str:\n    \"\"\"\n\tWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Char", "test": "def check(candidate):\n    assert candidate('abc') == 'f'\n    assert candidate('gfg') == 't'\n    assert candidate('ab') == 'c'\n\ndef test_check():\n    check(get_Char)\n\ntest_check()\n", "sample_io": ["assert get_Char('abc') == 'f'"], "source_codes": ["\ndef get_Char(strr: str) -> str:\n    # Calculate the sum of ASCII values of all characters in the string\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Take modulo 26 to get a value between 0 and 25\n    mod_value = ascii_sum % 26\n    \n    # Convert to character by adding to 'a' (ASCII 97)\n    # This gives us a character from 'a' to 'z'\n    result_char = chr(ord('a') + mod_value)\n    \n    return result_char\n\n\n"], "responses": ["```python\ndef get_Char(strr: str) -> str:\n    # Calculate the sum of ASCII values of all characters in the string\n    ascii_sum = sum(ord(char) for char in strr)\n    \n    # Take modulo 26 to get a value between 0 and 25\n    mod_value = ascii_sum % 26\n    \n    # Convert to character by adding to 'a' (ASCII 97)\n    # This gives us a character from 'a' to 'z'\n    result_char = chr(ord('a') + mod_value)\n    \n    return result_char\n```"], "prompt_tokens": [91], "completion_tokens": [125], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_83_get_Char"}
{"name": "mbpp_91_find_substring", "language": "Python3", "prompt": "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string is present as a substring in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_substring", "test": "def check(candidate):\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ack') == True\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'abc') == False\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ange') == True\n\ndef test_check():\n    check(find_substring)\n\ntest_check()\n", "sample_io": ["assert find_substring(['red', 'black', 'white', 'green', 'orange'], 'ack') == True"], "source_codes": ["\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False\n\n\n"], "responses": ["```python\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False\n```"], "prompt_tokens": [97], "completion_tokens": [70], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_91_find_substring"}
{"name": "mbpp_100_next_smallest_palindrome", "language": "Python3", "prompt": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_smallest_palindrome", "test": "def check(candidate):\n    assert candidate(99) == 101\n    assert candidate(1221) == 1331\n    assert candidate(120) == 121\n\ndef test_check():\n    check(next_smallest_palindrome)\n\ntest_check()\n", "sample_io": ["assert next_smallest_palindrome(99) == 101"], "source_codes": ["\ndef next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n    \n    Args:\n        num: An integer\n        \n    Returns:\n        The next smallest palindrome as an integer\n    \"\"\"\n    num += 1\n    \n    while True:\n        # Convert number to string to check if it's palindrome\n        str_num = str(num)\n        \n        # Check if the number is a palindrome\n        if str_num == str_num[::-1]:\n            return num\n        \n        num += 1\n\n\n"], "responses": ["```python\ndef next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n    \n    Args:\n        num: An integer\n        \n    Returns:\n        The next smallest palindrome as an integer\n    \"\"\"\n    num += 1\n    \n    while True:\n        # Convert number to string to check if it's palindrome\n        str_num = str(num)\n        \n        # Check if the number is a palindrome\n        if str_num == str_num[::-1]:\n            return num\n        \n        num += 1\n```"], "prompt_tokens": [85], "completion_tokens": [115], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_100_next_smallest_palindrome"}
{"name": "mbpp_282_sub_list", "language": "Python3", "prompt": "from typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to subtract two lists element-wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sub_list", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\n    assert candidate([1, 2], [3, 4]) == [-2, -2]\n    assert candidate([90, 120], [50, 70]) == [40, 50]\n\ndef test_check():\n    check(sub_list)\n\ntest_check()\n", "sample_io": ["assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"], "source_codes": ["\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    return [a - b for a, b in zip(nums1, nums2)]\n\n\n"], "responses": ["```python\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    return [a - b for a, b in zip(nums1, nums2)]\n```"], "prompt_tokens": [87], "completion_tokens": [56], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_282_sub_list"}
{"name": "mbpp_790_even_position", "language": "Python3", "prompt": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every even index contains even numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_position", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == False\n    assert candidate([1, 2, 3]) == False\n    assert candidate([2, 1, 4]) == True\n\ndef test_check():\n    check(even_position)\n\ntest_check()\n", "sample_io": ["assert even_position([3, 2, 1]) == False"], "source_codes": ["\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True\n\n\n"], "responses": ["```python\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n    \"\"\"\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            return False\n    return True\n```"], "prompt_tokens": [87], "completion_tokens": [73], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_790_even_position"}
{"name": "mbpp_411_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert the given snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('android_tv') == 'AndroidTv'\n    assert candidate('google_pixel') == 'GooglePixel'\n    assert candidate('apple_watch') == 'AppleWatch'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('android_tv') == 'AndroidTv'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert the given snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the rest\n    camel_case = words[0] + ''.join(word.capitalize() for word in words[1:])\n    \n    return camel_case\n\n\n"], "responses": ["```python\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert the given snake case string to camel case string.\n    \"\"\"\n    # Split the string by underscore\n    words = word.split('_')\n    \n    # Keep the first word as is, capitalize the rest\n    camel_case = words[0] + ''.join(word.capitalize() for word in words[1:])\n    \n    return camel_case\n```"], "prompt_tokens": [80], "completion_tokens": [88], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_411_snake_to_camel"}
{"name": "mbpp_754_extract_index_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n\tWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_index_list", "test": "def check(candidate):\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 6, 5], [0, 1, 2, 3, 4, 6, 7]) == [1, 6]\n    assert candidate([1, 1, 3, 4, 6, 5, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 5]\n    assert candidate([1, 2, 3, 4, 6, 6, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == []\n\ndef test_check():\n    check(extract_index_list)\n\ntest_check()\n", "sample_io": ["assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"], "source_codes": ["\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    \n    # Get the minimum length to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Check each index position\n    for i in range(min_length):\n        # If element at index i is the same in all three lists, add it to result\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result\n\n\n"], "responses": ["```python\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    \n    # Get the minimum length to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Check each index position\n    for i in range(min_length):\n        # If element at index i is the same in all three lists, add it to result\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result\n```"], "prompt_tokens": [134], "completion_tokens": [185], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_754_extract_index_list"}
{"name": "mbpp_56_checks", "language": "Python3", "prompt": "def checks(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check if a given number is one less than twice its reverse.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "checks", "test": "def check(candidate):\n    assert candidate(70) == False\n    assert candidate(23) == False\n    assert candidate(73) == True\n\ndef test_check():\n    check(checks)\n\ntest_check()\n", "sample_io": ["assert checks(70) == False"], "source_codes": ["\ndef checks(n: int) -> bool:\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    # Convert number to string to easily reverse it\n    str_n = str(n)\n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    # Check if n equals 2 * reversed_n - 1\n    return n == 2 * reversed_n - 1\n\n\n"], "responses": ["```python\ndef checks(n: int) -> bool:\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    # Convert number to string to easily reverse it\n    str_n = str(n)\n    # Reverse the string and convert back to integer\n    reversed_n = int(str_n[::-1])\n    # Check if n equals 2 * reversed_n - 1\n    return n == 2 * reversed_n - 1\n```"], "prompt_tokens": [80], "completion_tokens": [99], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_56_checks"}
{"name": "mbpp_724_power_base_sum", "language": "Python3", "prompt": "def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n\tWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power_base_sum", "test": "def check(candidate):\n    assert candidate(2, 100) == 115\n    assert candidate(8, 10) == 37\n    assert candidate(8, 15) == 62\n    assert candidate(3, 3) == 9\n\ndef test_check():\n    check(power_base_sum)\n\ntest_check()\n", "sample_io": ["assert power_base_sum(2, 100) == 115"], "source_codes": ["\ndef power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base (int): The base number\n        power (int): The power to raise the base to\n    \n    Returns:\n        int: Sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n\n\n"], "responses": ["```python\ndef power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base (int): The base number\n        power (int): The power to raise the base to\n    \n    Returns:\n        int: Sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n```"], "prompt_tokens": [93], "completion_tokens": [142], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_724_power_base_sum"}
{"name": "mbpp_268_find_star_num", "language": "Python3", "prompt": "def find_star_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th star number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_star_num", "test": "def check(candidate):\n    assert candidate(3) == 37\n    assert candidate(4) == 73\n    assert candidate(5) == 121\n\ndef test_check():\n    check(find_star_num)\n\ntest_check()\n", "sample_io": ["assert find_star_num(3) == 37"], "source_codes": ["\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th star number.\n    \"\"\"\n    return 6 * n * (n - 1) + 1\n\n\n"], "responses": ["Looking at this problem, I need to find the n-th star number.\n\nStar numbers are a sequence of numbers that represent the number of dots in a centered hexagram (six-pointed star) pattern. The formula for the n-th star number is:\n\nStar number = 6n(n-1) + 1\n\nLet me verify this with the first few star numbers:\n- For n=1: 6×1×0 + 1 = 1\n- For n=2: 6×2×1 + 1 = 13\n- For n=3: 6×3×2 + 1 = 37\n\nThis matches the known sequence of star numbers.\n\n```python\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th star number.\n    \"\"\"\n    return 6 * n * (n - 1) + 1\n```"], "prompt_tokens": [76], "completion_tokens": [193], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_268_find_star_num"}
{"name": "mbpp_251_insert_element", "language": "Python3", "prompt": "from typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n\tWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "insert_element", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    assert candidate(['python', 'java'], 'program') == ['program', 'python', 'program', 'java']\n    assert candidate(['happy', 'sad'], 'laugh') == ['laugh', 'happy', 'laugh', 'sad']\n\ndef test_check():\n    check(insert_element)\n\ntest_check()\n", "sample_io": ["assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"], "source_codes": ["\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n\n\n"], "responses": ["```python\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n```"], "prompt_tokens": [102], "completion_tokens": [74], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_251_insert_element"}
{"name": "mbpp_428_shell_sort", "language": "Python3", "prompt": "from typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given array by using shell sort.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "shell_sort", "test": "def check(candidate):\n    assert candidate([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    assert candidate([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]\n    assert candidate([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]\n\ndef test_check():\n    check(shell_sort)\n\ntest_check()\n", "sample_io": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"], "source_codes": ["\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given array by using shell sort.\n    \"\"\"\n    n = len(my_list)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            \n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            my_list[j] = temp\n        \n        gap //= 2\n    \n    return my_list\n\n\n"], "responses": ["```python\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given array by using shell sort.\n    \"\"\"\n    n = len(my_list)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            \n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            my_list[j] = temp\n        \n        gap //= 2\n    \n    return my_list\n```"], "prompt_tokens": [84], "completion_tokens": [126], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_428_shell_sort"}
{"name": "mbpp_476_big_sum", "language": "Python3", "prompt": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the largest and smallest value in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 4\n    assert candidate([-1, 2, 3, 4]) == 3\n    assert candidate([2, 3, 6]) == 8\n\ndef test_check():\n    check(big_sum)\n\ntest_check()\n", "sample_io": ["assert big_sum([1, 2, 3]) == 4"], "source_codes": ["\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) + min(nums)\n\n\n"], "responses": ["```python\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    return max(nums) + min(nums)\n```"], "prompt_tokens": [88], "completion_tokens": [53], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_476_big_sum"}
{"name": "mbpp_465_drop_empty", "language": "Python3", "prompt": "from typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to drop empty items from a given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "drop_empty", "test": "def check(candidate):\n    assert candidate({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }\n    assert candidate({ 'c1': 'Red', 'c2': None, 'c3': None }) == { 'c1': 'Red' }\n    assert candidate({ 'c1': None, 'c2': 'Green', 'c3': None }) == { 'c2': 'Green' }\n\ndef test_check():\n    check(drop_empty)\n\ntest_check()\n", "sample_io": ["assert drop_empty({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }"], "source_codes": ["\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n\n\n"], "responses": ["```python\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n```"], "prompt_tokens": [90], "completion_tokens": [59], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_465_drop_empty"}
{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Use regex to find a word containing 'z'\n    # \\b represents word boundaries\n    # \\w* means zero or more word characters\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n\n\n"], "responses": ["```python\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Use regex to find a word containing 'z'\n    # \\b represents word boundaries\n    # \\w* means zero or more word characters\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n```"], "prompt_tokens": [76], "completion_tokens": [90], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    # Check for divisibility from 2 to sqrt(num)\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases\n    if num < 2:\n        return False\n    \n    # Check for divisibility from 2 to sqrt(num)\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n```"], "prompt_tokens": [77], "completion_tokens": [100], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged = num1 + num2 + num3\n    \n    # Sort the combined list\n    merged.sort()\n    \n    return merged\n\n\n"], "responses": ["```python\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged = num1 + num2 + num3\n    \n    # Sort the combined list\n    merged.sort()\n    \n    return merged\n```"], "prompt_tokens": [97], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names \n    after removing the names that start with a lowercase letter.\n    \"\"\"\n    total_length = 0\n    for name in sample_names:\n        if name and name[0].isupper():\n            total_length += len(name)\n    return total_length\n\n\n"], "responses": ["```python\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n    Write a function to sum the length of the names of a given list of names \n    after removing the names that start with a lowercase letter.\n    \"\"\"\n    total_length = 0\n    for name in sample_names:\n        if name and name[0].isupper():\n            total_length += len(name)\n    return total_length\n```"], "prompt_tokens": [98], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n        list1: A list of tuples, where each tuple contains two integers\n        \n    Returns:\n        The minimum product value among all tuple pairs\n        \n    Examples:\n        >>> min_product_tuple([(2, 7), (3, 4), (8, 1)])\n        8\n        >>> min_product_tuple([(-1, 5), (2, 3), (4, -2)])\n        -8\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Calculate products of all tuples and find the minimum\n    products = [a * b for a, b in list1]\n    return min(products)\n\n\n"], "responses": ["```python\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n        list1: A list of tuples, where each tuple contains two integers\n        \n    Returns:\n        The minimum product value among all tuple pairs\n        \n    Examples:\n        >>> min_product_tuple([(2, 7), (3, 4), (8, 1)])\n        8\n        >>> min_product_tuple([(-1, 5), (2, 3), (4, -2)])\n        -8\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Calculate products of all tuples and find the minimum\n    products = [a * b for a, b in list1]\n    return min(products)\n```"], "prompt_tokens": [95], "completion_tokens": [179], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    def flatten_tuple(tup):\n        for item in tup:\n            if isinstance(item, tuple):\n                flatten_tuple(item)  # Recursively flatten nested tuples\n            else:\n                result.append(item)\n    \n    if isinstance(test_tup, tuple):\n        flatten_tuple(test_tup)\n    else:\n        result.append(test_tup)\n    \n    # Ensure we have exactly 4 integers\n    while len(result) < 4:\n        result.append(0)\n    \n    return tuple(result[:4])\n\n\n"], "responses": ["Looking at this problem, I need to write a function that removes nested tuples from a given tuple and returns a flat tuple of integers.\n\nLet me think through this step by step:\n1. I need to process the input tuple `test_tup`\n2. I need to identify and remove any nested tuples\n3. I should keep only the integer elements\n4. Return a tuple of integers\n\nBased on the function signature expecting exactly 4 integers in the return tuple, it seems like there's an expected format.\n\nLet me implement a solution that flattens the tuple and extracts integers:\n\n```python\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to remove tuples from the given tuple.\n    \"\"\"\n    result = []\n    \n    def flatten_tuple(tup):\n        for item in tup:\n            if isinstance(item, tuple):\n                flatten_tuple(item)  # Recursively flatten nested tuples\n            else:\n                result.append(item)\n    \n    if isinstance(test_tup, tuple):\n        flatten_tuple(test_tup)\n    else:\n        result.append(test_tup)\n    \n    # Ensure we have exactly 4 integers\n    while len(result) < 4:\n        result.append(0)\n    \n    return tuple(result[:4])\n```"], "prompt_tokens": [90], "completion_tokens": [265], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["```python\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last elements in a list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n```"], "prompt_tokens": [86], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    # Round each number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    return result\n\n\n"], "responses": ["```python\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n    Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n    \"\"\"\n    # Round each number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    return result\n```"], "prompt_tokens": [103], "completion_tokens": [122], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n - P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to build up the sequence\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i-1]] + dp[i - dp[i-1]]\n    \n    return dp[n]\n\n\n"], "responses": ["```python\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n - P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to build up the sequence\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i-1]] + dp[i - dp[i-1]]\n    \n    return dp[n]\n```"], "prompt_tokens": [78], "completion_tokens": [231], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman–shanks–williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": ["\ndef newman_prime(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate NSW sequence and find primes\n    nsw_primes = []\n    a, b = 1, 1  # NSW(0) = 1, NSW(1) = 1\n    \n    # Check if first two terms are prime\n    if is_prime(a):\n        nsw_primes.append(a)\n    \n    if len(nsw_primes) < n and is_prime(b):\n        nsw_primes.append(b)\n    \n    # Generate more NSW numbers and check for primes\n    index = 2\n    while len(nsw_primes) < n:\n        next_nsw = 2 * b + a\n        if is_prime(next_nsw):\n            nsw_primes.append(next_nsw)\n        a, b = b, next_nsw\n        index += 1\n    \n    return nsw_primes[n-1]\n\n\n"], "responses": ["Looking at this problem, I need to find the nth Newman-Shanks-Williams prime number.\n\nNewman-Shanks-Williams (NSW) primes are primes that appear in the NSW sequence, which is defined recursively:\n- NSW(0) = 1\n- NSW(1) = 1  \n- NSW(n) = 2 * NSW(n-1) + NSW(n-2) for n ≥ 2\n\nThe sequence starts: 1, 1, 3, 7, 17, 41, 99, 239, 577, 1393, ...\n\nNSW primes are the terms in this sequence that are actually prime numbers.\n\nLet me generate the NSW sequence, check for primes, and return the nth NSW prime.\n\n```python\ndef newman_prime(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Generate NSW sequence and find primes\n    nsw_primes = []\n    a, b = 1, 1  # NSW(0) = 1, NSW(1) = 1\n    \n    # Check if first two terms are prime\n    if is_prime(a):\n        nsw_primes.append(a)\n    \n    if len(nsw_primes) < n and is_prime(b):\n        nsw_primes.append(b)\n    \n    # Generate more NSW numbers and check for primes\n    index = 2\n    while len(nsw_primes) < n:\n        next_nsw = 2 * b + a\n        if is_prime(next_nsw):\n            nsw_primes.append(next_nsw)\n        a, b = b, next_nsw\n        index += 1\n    \n    return nsw_primes[n-1]\n```"], "prompt_tokens": [82], "completion_tokens": [440], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n\n\n"], "responses": ["```python\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    \n    return max_element\n```"], "prompt_tokens": [88], "completion_tokens": [82], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n\n\n"], "responses": ["```python\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n```"], "prompt_tokens": [79], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n\n\n"], "responses": ["```python\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            current_group.append(list1[i])\n        else:\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    result.append(current_group)\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [107], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the integer value in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first K elements (minimum K records)\n    return sorted_list[:K]\n\n\n"], "responses": ["```python\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list based on the integer value in each tuple.\n    \n    Args:\n        test_list: List of tuples where each tuple contains (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with the smallest integer values\n    \"\"\"\n    # Sort the list based on the second element (integer) of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first K elements (minimum K records)\n    return sorted_list[:K]\n```"], "prompt_tokens": [129], "completion_tokens": [147], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Check if empty string\n    if not text:\n        return False\n    \n    # Check for optional sign\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    # If we get here, it's a valid integer\n    return True\n\n\n"], "responses": ["```python\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Check if empty string\n    if not text:\n        return False\n    \n    # Check for optional sign\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not an integer\n        if len(text) == 1:\n            return False\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    # If we get here, it's a valid integer\n    return True\n```"], "prompt_tokens": [77], "completion_tokens": [173], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n\n\n"], "responses": ["```python\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \"\"\"\n    if not list:\n        return list\n    \n    n = len(list)\n    # Handle cases where m is larger than the list length\n    m = m % n\n    \n    # If m is 0, no rotation needed\n    if m == 0:\n        return list\n    \n    # Split the list and recombine\n    return list[-m:] + list[:-m]\n```"], "prompt_tokens": [108], "completion_tokens": [117], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    # Get the number of digits\n    num_digits = len(num_str)\n    # Calculate sum of each digit raised to the power of number of digits\n    total = sum(int(digit) ** num_digits for digit in num_str)\n    # Check if the total equals the original number\n    return total == number\n\n\n"], "responses": ["```python\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert number to string to get individual digits\n    num_str = str(number)\n    # Get the number of digits\n    num_digits = len(num_str)\n    # Calculate sum of each digit raised to the power of number of digits\n    total = sum(int(digit) ** num_digits for digit in num_str)\n    # Check if the total equals the original number\n    return total == number\n```"], "prompt_tokens": [79], "completion_tokens": [120], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total_sum = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total_sum += int(char)\n    \n    return total_sum\n\n\n"], "responses": ["```python\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Compute the sum of digits of each number of a given list.\n    \"\"\"\n    total_sum = 0\n    \n    for num in nums:\n        # Convert to string to handle both integers and floats\n        # Remove negative sign if present\n        num_str = str(abs(num))\n        \n        # Sum all digit characters in the string\n        for char in num_str:\n            if char.isdigit():\n                total_sum += int(char)\n    \n    return total_sum\n```"], "prompt_tokens": [89], "completion_tokens": [111], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n\n\n"], "responses": ["```python\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    # Extract the first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements while preserving order\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Combine negatives followed by positives\n    rearranged = negatives + positives\n    \n    # Return the rearranged first n elements followed by the rest of the array\n    return rearranged + arr[n:]\n```"], "prompt_tokens": [125], "completion_tokens": [124], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*t - 11.37*(v^0.16) + 0.3965*t*(v^0.16)\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return math.ceil(wci)\n\n\n"], "responses": ["```python\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer.\n    \n    Formula: WCI = 13.12 + 0.6215*t - 11.37*(v^0.16) + 0.3965*t*(v^0.16)\n    \n    Args:\n        v: wind velocity in km/h\n        t: temperature in celsius\n    \n    Returns:\n        wind chill index rounded to the next integer\n    \"\"\"\n    import math\n    \n    # Calculate wind chill using the standard formula\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the next integer (ceiling)\n    return math.ceil(wci)\n```"], "prompt_tokens": [96], "completion_tokens": [214], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": ["\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    The Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create a Bell triangle\n    # bell[i][j] will be the j-th element in i-th row\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions using the recurrence relation\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of the last row (which is the nth Bell number)\n    return bell[n][0]\n\n\n"], "responses": ["```python\ndef bell_Number(n: int) -> int:\n    \"\"\"\n    Find the nth Bell number using Bell triangle method.\n    \n    The Bell numbers count the number of ways to partition a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create a Bell triangle\n    # bell[i][j] will be the j-th element in i-th row\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Initialize first row\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # First element of each row is the last element of previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill remaining positions using the recurrence relation\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the first element of the last row (which is the nth Bell number)\n    return bell[n][0]\n```"], "prompt_tokens": [73], "completion_tokens": [251], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n\n\n"], "responses": ["```python\ndef sum_div(number: int) -> int:\n    \"\"\"\n    Write a function to return the sum of all divisors of a number.\n    \"\"\"\n    if number <= 0:\n        return 0\n    \n    divisor_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum\n```"], "prompt_tokens": [78], "completion_tokens": [86], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n\n\n"], "responses": ["```python\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    \"\"\"\n    x, y = test_tup\n    \n    # Generate all 8 adjacent coordinates (including diagonals)\n    adjacent_coords = []\n    \n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue  # Skip the original coordinate\n            adjacent_coords.append([x + dx, y + dy])\n    \n    return adjacent_coords\n```"], "prompt_tokens": [92], "completion_tokens": [136], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": ["\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple\n    return tuple(dissimilar_elements)\n\n\n"], "responses": ["Looking at this problem, I need to find elements that are in one tuple but not in the other tuple. This is essentially finding the symmetric difference between the two tuples.\n\nLet me think step by step:\n1. Convert tuples to sets to easily find differences\n2. Find elements in first tuple but not in second: set1 - set2\n3. Find elements in second tuple but not in first: set2 - set1\n4. Combine these differences (symmetric difference)\n5. Convert back to tuple and return\n\n```python\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Find symmetric difference (elements in either set but not in both)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert back to tuple\n    return tuple(dissimilar_elements)\n```"], "prompt_tokens": [116], "completion_tokens": [219], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["\ndef find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    # Convert to array: 0 becomes +1, 1 becomes -1\n    # This way, maximum subarray sum = max(count of 0s - count of 1s)\n    max_diff = 0\n    current_sum = 0\n    \n    for char in string:\n        if char == '0':\n            current_sum += 1\n        else:  # char == '1'\n            current_sum -= 1\n        \n        # Reset if current_sum becomes negative\n        if current_sum < 0:\n            current_sum = 0\n        else:\n            max_diff = max(max_diff, current_sum)\n    \n    return max_diff\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum difference between the number of 0s and 1s in any substring of a binary string.\n\nThis is essentially finding the maximum value of (count of 0s - count of 1s) across all possible substrings.\n\nI can transform this into a maximum subarray problem:\n- Convert each '0' to +1 (since we want to maximize 0s)\n- Convert each '1' to -1 (since we want to minimize 1s)\n- Find the maximum subarray sum using Kadane's algorithm\n\nLet me also consider the case where we might want negative differences (more 1s than 0s), but the problem asks for maximum difference, which would be positive when there are more 0s.\n\n```python\ndef find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    # Convert to array: 0 becomes +1, 1 becomes -1\n    # This way, maximum subarray sum = max(count of 0s - count of 1s)\n    max_diff = 0\n    current_sum = 0\n    \n    for char in string:\n        if char == '0':\n            current_sum += 1\n        else:  # char == '1'\n            current_sum -= 1\n        \n        # Reset if current_sum becomes negative\n        if current_sum < 0:\n            current_sum = 0\n        else:\n            max_diff = max(max_diff, current_sum)\n    \n    return max_diff\n```"], "prompt_tokens": [94], "completion_tokens": [323], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n\n\n"], "responses": ["```python\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n    Write a function that takes in a list and an integer L and splits the given list into two parts \n    where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n    \"\"\"\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n```"], "prompt_tokens": [119], "completion_tokens": [96], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    An expression is balanced if all opening brackets have corresponding closing brackets\n    in the correct order.\n    \"\"\"\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Set of opening brackets for quick lookup\n    opening_brackets = set(['(', '{', '['])\n    \n    # Iterate through each character in the expression\n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in opening_brackets:\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in bracket_map:\n            # If stack is empty or the top doesn't match, it's unbalanced\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n\n\n"], "responses": ["```python\ndef check_expression(exp: str) -> bool:\n    \"\"\"\n    Check if the given expression is balanced or not.\n    An expression is balanced if all opening brackets have corresponding closing brackets\n    in the correct order.\n    \"\"\"\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Set of opening brackets for quick lookup\n    opening_brackets = set(['(', '{', '['])\n    \n    # Iterate through each character in the expression\n    for char in exp:\n        # If it's an opening bracket, push to stack\n        if char in opening_brackets:\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in bracket_map:\n            # If stack is empty or the top doesn't match, it's unbalanced\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n```"], "prompt_tokens": [96], "completion_tokens": [230], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "responses": ["```python\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Write a python function to count the number of equal numbers from three given integers.\n    \"\"\"\n    # Count how many numbers are equal\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n```"], "prompt_tokens": [88], "completion_tokens": [94], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Lucas numbers\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    # Calculate Lucas numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "responses": ["```python\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Lucas numbers\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    # Calculate Lucas numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n```"], "prompt_tokens": [77], "completion_tokens": [138], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert a snake case string to camel case string.\n    \n    Args:\n        word (str): A snake case string\n        \n    Returns:\n        str: The camel case equivalent\n        \n    Examples:\n        >>> snake_to_camel('hello_world')\n        'helloWorld'\n        >>> snake_to_camel('this_is_a_test')\n        'thisIsATest'\n        >>> snake_to_camel('single')\n        'single'\n    \"\"\"\n    if not word:\n        return word\n    \n    # Split the string by underscore\n    parts = word.split('_')\n    \n    # Keep the first part as is, capitalize the first letter of subsequent parts\n    result = parts[0] + ''.join(part.capitalize() for part in parts[1:])\n    \n    return result\n\n\n"], "responses": ["```python\ndef snake_to_camel(word: str) -> str:\n    \"\"\"\n    Convert a snake case string to camel case string.\n    \n    Args:\n        word (str): A snake case string\n        \n    Returns:\n        str: The camel case equivalent\n        \n    Examples:\n        >>> snake_to_camel('hello_world')\n        'helloWorld'\n        >>> snake_to_camel('this_is_a_test')\n        'thisIsATest'\n        >>> snake_to_camel('single')\n        'single'\n    \"\"\"\n    if not word:\n        return word\n    \n    # Split the string by underscore\n    parts = word.split('_')\n    \n    # Keep the first part as is, capitalize the first letter of subsequent parts\n    result = parts[0] + ''.join(part.capitalize() for part in parts[1:])\n    \n    return result\n```"], "prompt_tokens": [79], "completion_tokens": [174], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join them back\n    return ' '.join(s.split()[::-1])\n\n\n"], "responses": ["```python\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Split the string into words, reverse the list of words, then join them back\n    return ' '.join(s.split()[::-1])\n```"], "prompt_tokens": [78], "completion_tokens": [64], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "responses": ["```python\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n```"], "prompt_tokens": [75], "completion_tokens": [36], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str_n1 = str(abs(n1))\n    str_n2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    total_distance = 0\n    for i in range(max_len):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_distance += digit_diff\n    \n    return total_distance\n\n\n"], "responses": ["```python\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings to easily access individual digits\n    str_n1 = str(abs(n1))\n    str_n2 = str(abs(n2))\n    \n    # Pad the shorter string with leading zeros to make them equal length\n    max_len = max(len(str_n1), len(str_n2))\n    str_n1 = str_n1.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences between corresponding digits\n    total_distance = 0\n    for i in range(max_len):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_distance += digit_diff\n    \n    return total_distance\n```"], "prompt_tokens": [87], "completion_tokens": [170], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n\n\n"], "responses": ["```python\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n```"], "prompt_tokens": [85], "completion_tokens": [63], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_143_find_lists"}
{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n\n\n"], "responses": ["```python\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n    Takes a list of lists and returns the average value for each sublist as a list.\n    \"\"\"\n    result = []\n    for sublist in nums:\n        if len(sublist) > 0:\n            avg = sum(sublist) / len(sublist)\n            result.append(avg)\n        else:\n            result.append(0.0)  # Handle empty sublists\n    return result\n```"], "prompt_tokens": [92], "completion_tokens": [99], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2 for each group\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n\n"], "responses": ["```python\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    For two numbers to XOR to an even number, they must have the same parity\n    (both even or both odd).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: C(n,2) = n*(n-1)/2 for each group\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n```"], "prompt_tokens": [91], "completion_tokens": [187], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n\n\n"], "responses": ["```python\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \"\"\"\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n```"], "prompt_tokens": [86], "completion_tokens": [63], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": ["\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n\n\n"], "responses": ["```python\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Write a function to sort each sublist of strings in a given list of lists.\n    \"\"\"\n    return [sorted(sublist) for sublist in list1]\n```"], "prompt_tokens": [90], "completion_tokens": [55], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["\nfrom typing import List\nfrom itertools import combinations_with_replacement\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    return [list(combo) for combo in combinations_with_replacement(l, n)]\n\n\n"], "responses": ["```python\nfrom typing import List\nfrom itertools import combinations_with_replacement\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    return [list(combo) for combo in combinations_with_replacement(l, n)]\n```"], "prompt_tokens": [112], "completion_tokens": [95], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters into non-digits and digits\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    # Concatenate non-digits first, then digits\n    return ''.join(non_digits + digits)\n\n\n"], "responses": ["```python\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    # Separate characters into non-digits and digits\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    # Concatenate non-digits first, then digits\n    return ''.join(non_digits + digits)\n```"], "prompt_tokens": [80], "completion_tokens": [105], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets and find intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Return the intersection as a list\n    return list(set1 & set2)\n\n\n"], "responses": ["```python\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n    Find the intersection of two arrays.\n    \n    Args:\n        array_nums1: First list of integers\n        array_nums2: Second list of integers\n    \n    Returns:\n        List of integers that appear in both arrays (no duplicates)\n    \"\"\"\n    # Convert both arrays to sets and find intersection\n    set1 = set(array_nums1)\n    set2 = set(array_nums2)\n    \n    # Return the intersection as a list\n    return list(set1 & set2)\n```"], "prompt_tokens": [90], "completion_tokens": [126], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n\n\n"], "responses": ["```python\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    return tup.count(x)\n```"], "prompt_tokens": [100], "completion_tokens": [58], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n\n\n"], "responses": ["```python\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while maintaining sorted order\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median of merged array\n    total_length = 2 * n\n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[total_length // 2 - 1] + merged[total_length // 2]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[total_length // 2])\n```"], "prompt_tokens": [95], "completion_tokens": [263], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    A tetrahedral number represents a pyramid with a triangular base.\n    The nth tetrahedral number is the sum of the first n triangular numbers.\n    Formula: T(n) = n(n+1)(n+2)/6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "responses": ["```python\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number.\n    \n    A tetrahedral number represents a pyramid with a triangular base.\n    The nth tetrahedral number is the sum of the first n triangular numbers.\n    Formula: T(n) = n(n+1)(n+2)/6\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6\n```"], "prompt_tokens": [77], "completion_tokens": [121], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": ["\nfrom typing import List, Tuple\nfrom itertools import product\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    if not test_list:\n        return []\n    \n    # Generate all possible combinations by taking one element from each tuple\n    combinations = list(product(*test_list))\n    \n    # Calculate sum for each combination and create (sum, original_combination) pairs\n    result = []\n    for combo in combinations:\n        total = sum(combo)\n        result.append((total, combo))\n    \n    # Sort by sum value\n    result.sort(key=lambda x: x[0])\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to find combinations of sums with tuples in the given tuple list. Based on the description and the reference link, this appears to be about finding all possible sums when combining elements from different tuples.\n\nLet me think through this step by step:\n\n1. For each tuple in the list, I can choose one element\n2. I need to find all possible sums of such combinations\n3. Each combination involves picking exactly one element from each tuple\n\nThis is essentially a Cartesian product problem where I'm finding all possible sums.\n\n```python\nfrom typing import List, Tuple\nfrom itertools import product\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    if not test_list:\n        return []\n    \n    # Generate all possible combinations by taking one element from each tuple\n    combinations = list(product(*test_list))\n    \n    # Calculate sum for each combination and create (sum, original_combination) pairs\n    result = []\n    for combo in combinations:\n        total = sum(combo)\n        result.append((total, combo))\n    \n    # Sort by sum value\n    result.sort(key=lambda x: x[0])\n    \n    return result\n```"], "prompt_tokens": [120], "completion_tokens": [250], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "responses": ["```python\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n    Uses binary search for O(log n) time complexity.\n    \"\"\"\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            result = mid\n            # Continue searching in the left half for the first occurrence\n            right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"], "prompt_tokens": [95], "completion_tokens": [158], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result has exactly one bit set (is a power of 2)\n    # A number is a power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n\n\n"], "responses": ["```python\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # If numbers are identical, xor_result will be 0\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result has exactly one bit set (is a power of 2)\n    # A number is a power of 2 if it has exactly one bit set\n    # This can be checked using the property: n & (n-1) == 0 for powers of 2\n    return (xor_result & (xor_result - 1)) == 0\n```"], "prompt_tokens": [90], "completion_tokens": [167], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = [4, 6, 9, 11]\n    \n    return monthnum3 in months_with_30_days\n\n\n"], "responses": ["```python\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. \n    Months are given as number from 1 to 12.\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = [4, 6, 9, 11]\n    \n    return monthnum3 in months_with_30_days\n```"], "prompt_tokens": [98], "completion_tokens": [118], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "responses": ["```python\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n```"], "prompt_tokens": [87], "completion_tokens": [83], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["\ndef rearrange_bigger(n: int) -> Any:\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, return None (no bigger permutation possible)\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n\n\n"], "responses": ["```python\ndef rearrange_bigger(n: int) -> Any:\n    # Convert number to list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first digit from right that is smaller than its next digit\n    i = length - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, return None (no bigger permutation possible)\n    if i == -1:\n        return None\n    \n    # Find the smallest digit on right side of i that is greater than digits[i]\n    j = length - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits after position i\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    # Convert back to integer\n    return int(''.join(digits))\n```"], "prompt_tokens": [89], "completion_tokens": [217], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["\ndef get_max_sum(n: int) -> int:\n    # Use memoization to store computed values\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num == 0:\n            return 0\n        \n        # Calculate the sum of recursive calls\n        recursive_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum of recursive sum and the number itself\n        result = max(recursive_sum, num)\n        memo[num] = result\n        return result\n    \n    return f(n)\n\n\n"], "responses": ["```python\ndef get_max_sum(n: int) -> int:\n    # Use memoization to store computed values\n    memo = {}\n    \n    def f(num):\n        if num in memo:\n            return memo[num]\n        \n        if num == 0:\n            return 0\n        \n        # Calculate the sum of recursive calls\n        recursive_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Return the maximum of recursive sum and the number itself\n        result = max(recursive_sum, num)\n        memo[num] = result\n        return result\n    \n    return f(n)\n```"], "prompt_tokens": [110], "completion_tokens": [139], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we don't have both even and odd numbers\n    return 0\n\n\n"], "responses": ["```python\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # If we found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we don't have both even and odd numbers\n    return 0\n```"], "prompt_tokens": [89], "completion_tokens": [149], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string \n    the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # For each rotation from 1 to n\n    for i in range(1, n + 1):\n        # After i left rotations, the last character is at index (i-1) % length\n        if s[(i - 1) % length] == '1':\n            count += 1\n    \n    return count\n\n\n"], "responses": ["Looking at this problem, I need to understand what \"rotating a binary string\" means and how it affects the decimal value.\n\nWhen we rotate a binary string left by 1 position, the first character moves to the end. For example, \"1011\" becomes \"0111\".\n\nLet me think about this step by step:\n1. Convert the binary string to decimal\n2. For each rotation, calculate the new decimal value\n3. Count how many of these values are odd\n\nHowever, there's a more efficient approach. In binary, a number is odd if and only if its last digit is '1'. So I need to count how many rotations result in the string ending with '1'.\n\nWhen rotating left, each character will eventually become the last character. So I need to count how many '1's are in the string, but I also need to consider that we're doing exactly `n` rotations.\n\nWait, let me re-read the problem. It says \"when rotating a binary string the given number of times\" - this could mean we do n different rotations (1, 2, ..., n) and count how many resulting numbers are odd, or it could mean we do n rotations total.\n\nLooking more carefully, I think it means we consider all possible rotations from 1 to n positions, and count how many resulting numbers are odd.\n\nBut actually, let me think of it differently. When we left-rotate a binary string, we're essentially looking at different suffixes becoming the end digit. The key insight is that a binary number is odd iff its last bit is 1.\n\nSo for each of the n rotations, I need to check if the last character is '1'.\n\n```python\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string \n    the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # For each rotation from 1 to n\n    for i in range(1, min(n + 1, length + 1)):\n        # After i left rotations, the character at position i (0-indexed) becomes the last character\n        # But we need to handle wrapping around\n        last_char_pos = (i - 1) % length\n        if s[length - 1 - last_char_pos] == '1':\n            count += 1\n    \n    # If n > length, we cycle through the same rotations\n    if n > length:\n        full_cycles = (n - length) // length\n        remaining = (n - length) % length\n        \n        # Count 1s in the string for full cycles\n        ones_count = s.count('1')\n        count += full_cycles * ones_count\n        \n        # Handle remaining rotations\n        for i in range(1, remaining + 1):\n            last_char_pos = (i - 1) % length\n            if s[length - 1 - last_char_pos] == '1':\n                count += 1\n    \n    return count\n```\n\nWait, I'm overcomplicating this. Let me reconsider what rotation means. Left rotation by k positions means taking the first k characters and moving them to the end.\n\nSo \"1011\" rotated left by 1 becomes \"0111\"\nRotated left by 2 becomes \"1110\"  \nRotated left by 3 becomes \"1101\"\n\nThe last character after k left rotations is the character at index (k-1) % length from the original string.\n\nActually, no. Let me be more careful:\n- Original: \"1011\" (indices 0,1,2,3)\n- Rotate left 1: \"0111\" - last char is s[0] = '1'\n- Rotate left 2: \"1110\" - last char is s[1] = '0'  \n- Rotate left 3: \"1101\" - last char is s[2] = '1'\n- Rotate left 4: \"1011\" - last char is s[3] = '1'\n\nSo after k left rotations, the last character is s[(k-1) % length].\n\n```python\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string \n    the given number of times.\n    \"\"\"\n    if not s or n <= 0:\n        return 0\n    \n    count = 0\n    length = len(s)\n    \n    # For each rotation from 1 to n\n    for i in range(1, n + 1):\n        # After i left rotations, the last character is at index (i-1) % length\n        if s[(i - 1) % length] == '1':\n            count += 1\n    \n    return count\n```"], "prompt_tokens": [94], "completion_tokens": [1055], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n\n\n"], "responses": ["```python\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_length = len(lst[0])\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    return min_length\n```"], "prompt_tokens": [89], "completion_tokens": [89], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n\n\n"], "responses": ["```python\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    return (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n```"], "prompt_tokens": [114], "completion_tokens": [134], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: (7n² - 5n) / 2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return (7 * n * n - 5 * n) // 2\n\n\n"], "responses": ["```python\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of \n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    \n    The formula for the nth nonagonal number is: (7n² - 5n) / 2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return (7 * n * n - 5 * n) // 2\n```"], "prompt_tokens": [75], "completion_tokens": [147], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": ["\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n² - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n\n\n"], "responses": ["```python\ndef is_octagonal(n: int) -> int:\n    \"\"\"\n    Find the nth octagonal number.\n    \n    The formula for the nth octagonal number is: 3n² - 2n\n    \"\"\"\n    return 3 * n * n - 2 * n\n```"], "prompt_tokens": [75], "completion_tokens": [62], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_59_is_octagonal"}
