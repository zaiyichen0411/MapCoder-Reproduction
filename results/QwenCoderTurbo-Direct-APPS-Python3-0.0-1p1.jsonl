{"name": "3554", "description": "Zonk is addictive dice game. In each round player rolls 6 dice. Then (s)he composes combinations from them. Each combination gives certain points. \n\nThen player can take one or more dice combinations to his hand and re-roll remaining dice or save his score. Dice in player's hand won't be taken into account in subsequent rolls.\n\nIf no combinations can be composed - situation is called \"zonk\". Player thrown zonk loses all points in this round and next player moves. So it's player decision when to reroll and when to stop and save his score.\n\nYour task is simple - just evaluate current roll and return maximum number of points can be scored from it. If no combinations can be made - function must return string ``\"Zonk\"`` (without quotes).\n\nThere are different variations of Zonk. In this kata, we will use most common table of combinations:\n\nCombinationExample rollPoints\nStraight (1,2,3,4,5 and 6)6 3 1 2 5 41000 points\nThree pairs of any dice2 2 4 4 1 1750 points\nThree of 11 4 1 11000 points\nThree of 22 3 4 2 2200 points\nThree of 33 4 3 6 3 2300 points\nThree of 44 4 4400 points\nThree of 52 5 5 5 4500 points\nThree of 66 6 2 6600 points\nFour of a kind1 1 1 1 4 62 \u00d7 Three-of-a-kind score (in example, 2000 pts)\nFive of a kind5 5 5 4 5 53 \u00d7 Three-of-a-kind score (in example, 1500 pts)\nSix of a kind4 4 4 4 4 44 \u00d7 Three-of-a-kind score (in example, 1600 pts)\nEvery 14 3 1 2 2100 points\nEvery 55 2 650 points\n\n\nEach die cannot be used in multiple combinations the same time, so three pairs of 2, 3 and 5 will worth you only ``750`` points (for three pairs), not 850 (for three pairs and two fives). But you can select multiple combinations, ``2 2 2 1 6`` will worth you ``300`` points (200 for three-of-kind '2' plus 100 for single '1' die)\n\nExamples:\n```python\n  get_score([1,2,3]) # returns 100 = points from one 1\n  get_score([3,4,1,1,5]) # returns 250 = points from two 1 and one 5\n  get_score([2,3,2,3,3,2]) # returns 500 = three of 2 + three of 3\n  get_score([1,1,1,1,1,5]) # returns 3050 = five 1 + one 5\n  get_score([2,3,4,3,6,6]) # returns \"Zonk\" = no combinations here\n  get_score([2,2,6,6,2,2]) # returns 400 = four 2, this cannot be scored as three pairs\n  get_score([1,3,4,3,4,1]) # returns 750 = three pairs\n  get_score([3,3,3,3]) # returns 600 = four of 3\n  get_score([1,2,3,4,5]) # returns 150 = it's not straight\n```\nOf course, in real Zonk game it's sometimes not worth to collect all combination from roll. Taking less dice and rerolling more remaining may be better, but task is just to calculate maximum possible score from current single roll.\n\nP.S. Inspired by this kata: http://www.codewars.com/kata/5270d0d18625160ada0000e4", "difficulty": "introductory", "id": 3554, "sample_io": [{"input": "[1, 2, 3]", "output": [100]}, {"input": "[3,4,1,1,5]", "output": [250]}, {"input": "[2,3,2,3,3,2]", "output": [500]}, {"input": "[1,1,1,1,1,5]", "output": [3050]}, {"input": "[2,3,4,3,6,6]", "output": ["Zonk"]}, {"input": "[2,2,6,6,2,2]", "output": [400]}, {"input": "[1,3,4,3,4,1]", "output": [750]}, {"input": "[3,3,3,3]", "output": [600]}, {"input": "[1,2,3,4,5]", "output": [150]}], "test_list": [{"input": "[1]", "output": [100]}, {"input": "[5]", "output": [50]}, {"input": "[1, 1]", "output": [200]}, {"input": "[5, 5]", "output": [100]}, {"input": "[5, 1]", "output": [150]}, {"input": "[5, 6]", "output": [50]}, {"input": "[1, 1, 1]", "output": [1000]}, {"input": "[2, 2, 2]", "output": [200]}, {"input": "[3, 3, 3]", "output": [300]}, {"input": "[4, 4, 4]", "output": [400]}, {"input": "[5, 5, 5]", "output": [500]}, {"input": "[6, 6, 6]", "output": [600]}, {"input": "[1, 2, 1]", "output": [200]}, {"input": "[1, 1, 5]", "output": [250]}, {"input": "[5, 5, 6]", "output": [100]}, {"input": "[1, 5, 5]", "output": [200]}, {"input": "[1, 1, 1, 1]", "output": [2000]}, {"input": "[2, 2, 2, 2]", "output": [400]}, {"input": "[3, 3, 3, 3]", "output": [600]}, {"input": "[4, 4, 4, 4]", "output": [800]}, {"input": "[5, 5, 5, 5]", "output": [1000]}, {"input": "[6, 6, 6, 6]", "output": [1200]}, {"input": "[1, 5, 5, 1]", "output": [300]}, {"input": "[2, 3, 4, 5]", "output": [50]}, {"input": "[3, 3, 5, 3]", "output": [350]}, {"input": "[1, 1, 1, 1, 1]", "output": [3000]}, {"input": "[2, 2, 2, 2, 2]", "output": [600]}, {"input": "[3, 3, 3, 3, 3]", "output": [900]}, {"input": "[4, 4, 4, 4, 4]", "output": [1200]}, {"input": "[5, 5, 5, 5, 5]", "output": [1500]}, {"input": "[6, 6, 6, 6, 6]", "output": [1800]}, {"input": "[1, 5, 1, 5, 1]", "output": [1100]}, {"input": "[1, 2, 3, 4, 5]", "output": [150]}, {"input": "[2, 3, 4, 5, 6]", "output": [50]}, {"input": "[1, 3, 4, 5, 2]", "output": [150]}, {"input": "[1, 1, 1, 1, 1, 1]", "output": [4000]}, {"input": "[2, 2, 2, 2, 2, 2]", "output": [800]}, {"input": "[3, 3, 3, 3, 3, 3]", "output": [1200]}, {"input": "[4, 4, 4, 4, 4, 4]", "output": [1600]}, {"input": "[5, 5, 5, 5, 5, 5]", "output": [2000]}, {"input": "[6, 6, 6, 6, 6, 6]", "output": [2400]}, {"input": "[2, 1, 3, 4, 6, 5]", "output": [1000]}, {"input": "[4, 4, 2, 2, 6, 6]", "output": [750]}, {"input": "[1, 2, 3, 4, 5, 5]", "output": [200]}, {"input": "[2, 2, 4, 2, 2, 4]", "output": [400]}, {"input": "[1, 3, 4, 5, 2, 2]", "output": [150]}, {"input": "[1, 5, 2, 1, 2, 5]", "output": [750]}, {"input": "[4, 1, 1, 1, 1, 5]", "output": [2050]}, {"input": "[3, 5, 2, 4, 2, 6]", "output": [50]}, {"input": "[1, 6, 6, 1, 1, 6]", "output": [1600]}], "starter_code": "\ndef get_score(dice):\n\t", "source_codes": ["\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    # Count occurrences of each die\n    counts = Counter(dice)\n    \n    # Check for special combinations first\n    # Straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Check for n-of-a-kind (where n >= 3)\n    score = 0\n    remaining_counts = counts.copy()\n    \n    # Handle six of a kind\n    for die, count in counts.items():\n        if count == 6:\n            if die == 1:\n                return 4 * 1000\n            else:\n                return 4 * (die * 100)\n    \n    # Handle five of a kind\n    for die, count in counts.items():\n        if count == 5:\n            if die == 1:\n                score += 3 * 1000\n                remaining_counts[die] -= 5\n            else:\n                score += 3 * (die * 100)\n                remaining_counts[die] -= 5\n    \n    # Handle four of a kind\n    for die, count in counts.items():\n        if count == 4:\n            if die == 1:\n                score += 2 * 1000\n                remaining_counts[die] -= 4\n            else:\n                score += 2 * (die * 100)\n                remaining_counts[die] -= 4\n    \n    # Handle three of a kind\n    for die, count in counts.items():\n        if remaining_counts[die] >= 3:\n            if die == 1:\n                score += 1000\n                remaining_counts[die] -= 3\n            else:\n                score += die * 100\n                remaining_counts[die] -= 3\n    \n    # Handle singles\n    for die, count in remaining_counts.items():\n        if die == 1:\n            score += count * 100\n        elif die == 5:\n            score += count * 50\n    \n    # If no scoring combinations found\n    if score == 0:\n        return \"Zonk\"\n    \n    return score\n\n# Read input and process\ndice = eval(input())\nresult = get_score(dice)\nprint(result)\n\n\n"], "responses": ["```python\nfrom collections import Counter\n\ndef get_score(dice):\n    if not dice:\n        return \"Zonk\"\n    \n    # Count occurrences of each die\n    counts = Counter(dice)\n    \n    # Check for special combinations first\n    # Straight (1,2,3,4,5,6)\n    if sorted(dice) == [1, 2, 3, 4, 5, 6]:\n        return 1000\n    \n    # Three pairs\n    if len(counts) == 3 and all(count == 2 for count in counts.values()):\n        return 750\n    \n    # Check for n-of-a-kind (where n >= 3)\n    score = 0\n    remaining_counts = counts.copy()\n    \n    # Handle six of a kind\n    for die, count in counts.items():\n        if count == 6:\n            if die == 1:\n                return 4 * 1000\n            else:\n                return 4 * (die * 100)\n    \n    # Handle five of a kind\n    for die, count in counts.items():\n        if count == 5:\n            if die == 1:\n                score += 3 * 1000\n                remaining_counts[die] -= 5\n            else:\n                score += 3 * (die * 100)\n                remaining_counts[die] -= 5\n    \n    # Handle four of a kind\n    for die, count in counts.items():\n        if count == 4:\n            if die == 1:\n                score += 2 * 1000\n                remaining_counts[die] -= 4\n            else:\n                score += 2 * (die * 100)\n                remaining_counts[die] -= 4\n    \n    # Handle three of a kind\n    for die, count in counts.items():\n        if remaining_counts[die] >= 3:\n            if die == 1:\n                score += 1000\n                remaining_counts[die] -= 3\n            else:\n                score += die * 100\n                remaining_counts[die] -= 3\n    \n    # Handle singles\n    for die, count in remaining_counts.items():\n        if die == 1:\n            score += count * 100\n        elif die == 5:\n            score += count * 50\n    \n    # If no scoring combinations found\n    if score == 0:\n        return \"Zonk\"\n    \n    return score\n\n# Read input and process\ndice = eval(input())\nresult = get_score(dice)\nprint(result)\n```"], "prompt_tokens": [1037], "completion_tokens": [556], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 3554}
{"name": "4724", "description": "DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.", "difficulty": "introductory", "id": 4724, "sample_io": [{"input": "apple of banana", "output": ["Apple of Banana"]}, {"input": "apple", "output": ["Apple"]}, {"input": "one   space", "output": ["One   Space"]}, {"input": "   space WALK   ", "output": ["   Space Walk   "]}], "test_list": [{"input": "Apple Banana", "output": ["Apple Banana"]}, {"input": "Apple", "output": ["Apple"]}, {"input": "", "output": [""]}, {"input": "of", "output": ["of"]}, {"input": "Revelation of the contents outraged American public opinion, and helped generate", "output": ["Revelation of The Contents Outraged American Public Opinion, And Helped Generate"]}, {"input": "more  than    one space between words", "output": ["More  Than    One Space Between Words"]}, {"input": "  leading spaces", "output": ["  Leading Spaces"]}, {"input": "trailing spaces   ", "output": ["Trailing Spaces   "]}, {"input": "ALL CAPS CRAZINESS", "output": ["All Caps Craziness"]}, {"input": "rAnDoM CaPs CrAzInEsS", "output": ["Random Caps Craziness"]}], "starter_code": "\ndef drop_cap(str_):\n\t", "source_codes": ["\ndef drop_cap(s):\n    words = s.split(' ')\n    result = []\n    \n    for word in words:\n        if len(word) > 2:\n            result.append(word.capitalize())\n        else:\n            result.append(word)\n    \n    return ' '.join(result)\n\n# Read input and process\ninput_string = input()\noutput_string = drop_cap(input_string)\nprint(output_string)\n\n\n"], "responses": ["```python\ndef drop_cap(s):\n    words = s.split(' ')\n    result = []\n    \n    for word in words:\n        if len(word) > 2:\n            result.append(word.capitalize())\n        else:\n            result.append(word)\n    \n    return ' '.join(result)\n\n# Read input and process\ninput_string = input()\noutput_string = drop_cap(input_string)\nprint(output_string)\n```"], "prompt_tokens": [266], "completion_tokens": [81], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 4724}
{"name": "4561", "description": "Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st):\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!", "difficulty": "introductory", "id": 4561, "sample_io": [{"input": "adfa", "output": [true]}, {"input": "bd", "output": [true]}], "test_list": [{"input": "abba", "output": [true]}, {"input": "abaazaba", "output": [false]}, {"input": "abccba", "output": [true]}, {"input": "adfa", "output": [true]}, {"input": "ae", "output": [false]}, {"input": "abzy", "output": [false]}, {"input": "ababbaba", "output": [true]}, {"input": "sq", "output": [true]}, {"input": "kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm", "output": [true]}], "starter_code": "\ndef solve(st):\n\t", "source_codes": ["\nfrom itertools import product\n\ndef get_possible_chars(c):\n    \"\"\"Get possible characters that c can be changed to\"\"\"\n    if c == 'a':\n        return ['b']\n    elif c == 'z':\n        return ['y']\n    else:\n        # For other characters, can go to previous or next\n        prev_char = chr(ord(c) - 1)\n        next_char = chr(ord(c) + 1)\n        return [prev_char, next_char]\n\ndef is_palindrome(s):\n    \"\"\"Check if string is palindrome\"\"\"\n    return s == s[::-1]\n\ndef solve(st):\n    # Get all possible characters for each position\n    possible_chars = [get_possible_chars(c) for c in st]\n    \n    # Generate all possible combinations\n    for combination in product(*possible_chars):\n        candidate = ''.join(combination)\n        if is_palindrome(candidate):\n            return True\n    \n    return False\n\n# Read input and solve\nst = input().strip()\nresult = solve(st)\nprint(result)\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Generate all possible strings by changing each character to either the one before or after it in the alphabet\n2. Check if any of these possibilities is a palindrome\n3. Return True if at least one is a palindrome, False otherwise\n\nLet me trace through the examples to understand the pattern:\n\nFor \"adfa\":\n- 'a' can become 'b' (only option since it's the first letter)\n- 'd' can become 'c' or 'e'\n- 'f' can become 'e' or 'g'\n- 'a' can become 'b' (only option)\n\nSo we get: [\"becb\", \"beeb\", \"bcgb\", \"bceb\"]\n\nThe issue with the provided code is that it's trying to check if the original string satisfies some condition, rather than generating all possibilities and checking each one.\n\nLet me write a correct solution:\n\n```python\nfrom itertools import product\n\ndef get_possible_chars(c):\n    \"\"\"Get possible characters that c can be changed to\"\"\"\n    if c == 'a':\n        return ['b']\n    elif c == 'z':\n        return ['y']\n    else:\n        # For other characters, can go to previous or next\n        prev_char = chr(ord(c) - 1)\n        next_char = chr(ord(c) + 1)\n        return [prev_char, next_char]\n\ndef is_palindrome(s):\n    \"\"\"Check if string is palindrome\"\"\"\n    return s == s[::-1]\n\ndef solve(st):\n    # Get all possible characters for each position\n    possible_chars = [get_possible_chars(c) for c in st]\n    \n    # Generate all possible combinations\n    for combination in product(*possible_chars):\n        candidate = ''.join(combination)\n        if is_palindrome(candidate):\n            return True\n    \n    return False\n\n# Read input and solve\nst = input().strip()\nresult = solve(st)\nprint(result)\n```\n\nLet me verify with the examples:\n\nFor \"adfa\":\n- Position 0 ('a'): ['b']\n- Position 1 ('d'): ['c', 'e']\n- Position 2 ('f'): ['e', 'g']\n- Position 3 ('a'): ['b']\n\nCombinations: \"bceb\", \"beeb\", \"bcgb\", \"begb\"\nChecking palindromes: \"beeb\" is a palindrome \u2192 True\n\nFor \"bd\":\n- Position 0 ('b'): ['a', 'c']\n- Position 1 ('d'): ['c', 'e']\n\nCombinations: \"ac\", \"ae\", \"cc\", \"ce\"\nChecking palindromes: \"cc\" is a palindrome \u2192 True\n\nThis matches the expected behavior!"], "prompt_tokens": [362], "completion_tokens": [561], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 4561}
{"name": "4468", "description": "## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`", "difficulty": "introductory", "id": 4468, "sample_io": [{"input": "0", "output": [""]}, {"input": "56", "output": ["5*10+6"]}, {"input": "60", "output": ["6*10"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "10004", "output": ["1*10000+4"]}], "test_list": [{"input": "8964631", "output": ["8*1000000+9*100000+6*10000+4*1000+6*100+3*10+1"]}, {"input": "56", "output": ["5*10+6"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "11", "output": ["1*10+1"]}, {"input": "991", "output": ["9*100+9*10+1"]}, {"input": "47", "output": ["4*10+7"]}, {"input": "234", "output": ["2*100+3*10+4"]}, {"input": "196587", "output": ["1*100000+9*10000+6*1000+5*100+8*10+7"]}, {"input": "660", "output": ["6*100+6*10"]}, {"input": "600", "output": ["6*100"]}, {"input": "9090", "output": ["9*1000+9*10"]}, {"input": "10104", "output": ["1*10000+1*100+4"]}, {"input": "80008", "output": ["8*10000+8"]}, {"input": "90000", "output": ["9*10000"]}, {"input": "0", "output": [""]}], "starter_code": "\ndef simplify(n):\n\t", "source_codes": ["\ndef solve(n):\n    if n == 0:\n        return \"\"\n    \n    # Convert to string to work with individual digits\n    s = str(n)\n    length = len(s)\n    result = []\n    \n    # Process each digit\n    for i, digit in enumerate(s):\n        if digit != '0':  # Skip zero digits\n            # Calculate power of 10 (position from right)\n            power = length - i - 1\n            if power == 0:\n                # For units place, just add the digit\n                result.append(digit)\n            else:\n                # For other places, show digit * 10^power\n                result.append(f\"{digit}*1{'0' * power}\")\n    \n    # Join with '+' sign\n    return \"+\".join(result)\n\n# Read input and solve\nn = int(input())\nprint(solve(n))\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. **Goal**: Decompose a number into its digits multiplied by appropriate powers of 10\n2. **Format**: Each digit \u00d7 power_of_10, joined by \"+\" signs\n3. **Special cases**: \n   - Input 0 \u2192 empty string\n   - Trailing zeros \u2192 no terms for zero digits (e.g., 60 \u2192 \"6*10\", not \"6*10+0\")\n\n## Step-by-Step Approach\n\n1. **Handle edge case**: If input is 0, return empty string\n2. **Convert number to string** to easily access individual digits\n3. **For each non-zero digit**:\n   - Calculate its position from right (determines power of 10)\n   - Format as \"digit*power_of_10\"\n4. **Join all terms** with \"+\" sign\n\n## Detailed Steps\n\nLet me trace through example 56:\n- Digits: 5, 6\n- Position 0 (from right): 6 \u00d7 10^0 = 6 \u00d7 1\n- Position 1 (from right): 5 \u00d7 10^1 = 5 \u00d7 10\n- Result: \"5*10+6\"\n\nFor 10004:\n- Digits: 1, 0, 0, 0, 4\n- Only non-zero: 1 (position 4) and 4 (position 0)\n- 1 \u00d7 10^4 = 1 \u00d7 10000\n- 4 \u00d7 10^0 = 4 \u00d7 1\n- Result: \"1*10000+4\"\n\n## Implementation\n\n```python\ndef solve(n):\n    if n == 0:\n        return \"\"\n    \n    # Convert to string to work with individual digits\n    s = str(n)\n    length = len(s)\n    result = []\n    \n    # Process each digit\n    for i, digit in enumerate(s):\n        if digit != '0':  # Skip zero digits\n            # Calculate power of 10 (position from right)\n            power = length - i - 1\n            if power == 0:\n                # For units place, just add the digit\n                result.append(digit)\n            else:\n                # For other places, show digit * 10^power\n                result.append(f\"{digit}*1{'0' * power}\")\n    \n    # Join with '+' sign\n    return \"+\".join(result)\n\n# Read input and solve\nn = int(input())\nprint(solve(n))\n```\n\nLet me verify with examples:\n\n- **0**: Returns \"\"\n- **56**: \"5*10+6\" \u2713\n- **60**: \"6*10\" \u2713 (no trailing +0)\n- **999**: \"9*100+9*10+9\" \u2713\n- **10004**: \"1*10000+4\" \u2713\n\nThe solution handles all the requirements including skipping zero digits and proper formatting."], "prompt_tokens": [239], "completion_tokens": [661], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 4468}
