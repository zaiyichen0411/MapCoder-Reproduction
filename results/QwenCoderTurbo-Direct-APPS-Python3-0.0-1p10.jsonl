{"name": "4262", "description": "Dee is lazy but she's kind and she likes to eat out at all the nice restaurants and gastropubs in town. To make paying quick and easy she uses a simple mental algorithm she's called The Fair %20 Rule. She's gotten so good she can do this in a few seconds and it always impresses her dates but she's perplexingly still single. Like you probably. \n\nThis is how she does it:\n\n - She rounds the price `P` at the tens place e.g:\n   - 25 becomes 30\n   - 24 becomes 20\n   - 5 becomes 10\n   - 4 becomes 0\n - She figures out the base tip `T` by dropping the singles place digit e.g:\n   - when `P = 24` she rounds to 20 drops 0 `T = 2`\n   - `P = 115` rounds to 120 drops 0 `T = 12`\n   - `P = 25` rounds to 30 drops 0 `T = 3`\n   - `P = 5` rounds to 10 drops 0 `T = 1`\n   - `P = 4` rounds to 0 `T = 0`\n - She then applies a 3 point satisfaction rating `R` to `T` i.e:\n   - When she's satisfied: `R = 1` and she'll add 1 to `T`\n   - Unsatisfied: `R = 0` and she'll subtract 1 from `T`\n   - Appalled: `R = -1` she'll divide `T` by 2, **rounds down** and subtracts 1\n \n## Your Task\n\nImplement a method `calc_tip` that takes two integer arguments for price `p` \n\nwhere `1 <= p <= 1000` and a rating `r` which is one of `-1, 0, 1`.\n\nThe return value `T` should be a non negative integer.\n\n*Note: each step should be done in the order listed.*\n\nDee always politely smiles and says \"Thank you\" on her way out. Dee is nice. Be like Dee.", "difficulty": "introductory", "id": 4262, "sample_io": [], "test_list": [{"input": "4\n1", "output": [1]}, {"input": "4\n0", "output": [0]}, {"input": "4\n-1", "output": [0]}, {"input": "5\n1", "output": [2]}, {"input": "5\n0", "output": [0]}, {"input": "5\n-1", "output": [0]}, {"input": "14\n1", "output": [2]}, {"input": "14\n0", "output": [0]}, {"input": "14\n-1", "output": [0]}, {"input": "15\n1", "output": [3]}, {"input": "15\n0", "output": [1]}, {"input": "15\n-1", "output": [0]}, {"input": "24\n1", "output": [3]}, {"input": "24\n0", "output": [1]}, {"input": "24\n-1", "output": [0]}, {"input": "25\n1", "output": [4]}, {"input": "25\n0", "output": [2]}, {"input": "25\n-1", "output": [0]}, {"input": "125\n1", "output": [14]}, {"input": "125\n0", "output": [12]}, {"input": "125\n-1", "output": [5]}, {"input": "144\n1", "output": [15]}, {"input": "144\n0", "output": [13]}, {"input": "144\n-1", "output": [6]}], "starter_code": "\ndef calc_tip(p, r):\n\t", "source_codes": ["\ndef calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    if p % 10 >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Figure out base tip T by dropping the singles place digit\n    # Since we've rounded to nearest 10, the singles digit is 0\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:  # Satisfied\n        T = T + 1\n    elif r == 0:  # Unsatisfied\n        T = T - 1\n    elif r == -1:  # Appalled\n        T = (T // 2) - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input\nline = input().split()\np = int(line[0])\nr = int(line[1])\n\n# Calculate and print result\nresult = calc_tip(p, r)\nprint(result)\n\n\n"], "responses": ["Here's the Python 3 code that implements Dee's \"Fair 20 Rule\" for calculating tips:\n\n```python\ndef calc_tip(p, r):\n    # Step 1: Round price P at the tens place\n    if p % 10 >= 5:\n        rounded_p = ((p // 10) + 1) * 10\n    else:\n        rounded_p = (p // 10) * 10\n    \n    # Step 2: Figure out base tip T by dropping the singles place digit\n    # Since we've rounded to nearest 10, the singles digit is 0\n    T = rounded_p // 10\n    \n    # Step 3: Apply satisfaction rating R to T\n    if r == 1:  # Satisfied\n        T = T + 1\n    elif r == 0:  # Unsatisfied\n        T = T - 1\n    elif r == -1:  # Appalled\n        T = (T // 2) - 1\n    \n    # Ensure T is non-negative\n    return max(0, T)\n\n# Read input\nline = input().split()\np = int(line[0])\nr = int(line[1])\n\n# Calculate and print result\nresult = calc_tip(p, r)\nprint(result)\n```\n\nThis implementation follows Dee's algorithm exactly:\n1. First, it rounds the price to the nearest 10 (rounding up on .5)\n2. Then it calculates the base tip by dividing the rounded price by 10\n3. Finally, it adjusts the tip based on the satisfaction rating:\n   - Adds 1 for satisfied (r=1)\n   - Subtracts 1 for unsatisfied (r=0)\n   - Divides by 2 (rounded down) and subtracts 1 for appalled (r=-1)\n4. It ensures the final tip is never negative\n\nThe input should be provided as two space-separated integers (price and rating), and the output will be the calculated tip amount."], "prompt_tokens": [555], "completion_tokens": [429], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 4262}
{"name": "2798", "description": "# altERnaTIng cAsE <=> ALTerNAtiNG CaSe\n\nDefine `String.prototype.toAlternatingCase` (or a similar function/method *such as* `to_alternating_case`/`toAlternatingCase`/`ToAlternatingCase` in your selected language; **see the initial solution for details**) such that each lowercase letter becomes uppercase and each uppercase letter becomes lowercase. For example:\n``` haskell\ntoAlternatingCase \"hello world\" `shouldBe` \"HELLO WORLD\"\ntoAlternatingCase \"HELLO WORLD\" `shouldBe` \"hello world\"\ntoAlternatingCase \"hello WORLD\" `shouldBe` \"HELLO world\"\ntoAlternatingCase \"HeLLo WoRLD\" `shouldBe` \"hEllO wOrld\"\ntoAlternatingCase \"12345\"       `shouldBe` \"12345\"\ntoAlternatingCase \"1a2b3c4d5e\"  `shouldBe` \"1A2B3C4D5E\"\n```\n```C++\nstring source = \"HeLLo WoRLD\";\nstring upperCase = to_alternating_case(source);\ncout << upperCase << endl; // outputs: hEllO wOrld\n```\nAs usual, your function/method should be pure, i.e. it should **not** mutate the original string.", "difficulty": "introductory", "id": 2798, "sample_io": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}], "test_list": [{"input": "hello world", "output": ["HELLO WORLD"]}, {"input": "HELLO WORLD", "output": ["hello world"]}, {"input": "hello WORLD", "output": ["HELLO world"]}, {"input": "HeLLo WoRLD", "output": ["hEllO wOrld"]}, {"input": "12345", "output": ["12345"]}, {"input": "1a2b3c4d5e", "output": ["1A2B3C4D5E"]}, {"input": "String.prototype.toAlternatingCase", "output": ["sTRING.PROTOTYPE.TOaLTERNATINGcASE"]}], "starter_code": "\ndef to_alternating_case(string):\n\t", "source_codes": ["\ndef to_alternating_case(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Take input from standard input\ninput_string = input()\n\n# Call the function and print the result\noutput_string = to_alternating_case(input_string)\nprint(output_string)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We need to create a function that converts each character in a string to alternating case\n2. Lowercase letters become uppercase\n3. Uppercase letters become lowercase\n4. Non-alphabetic characters remain unchanged\n5. The original string should not be mutated\n\n## Approach\n\n1. Iterate through each character in the string\n2. Check if the character is uppercase or lowercase\n3. Convert accordingly:\n   - If uppercase \u2192 convert to lowercase\n   - If lowercase \u2192 convert to uppercase\n   - If not alphabetic \u2192 keep as is\n4. Build and return the new string\n\n## Implementation Plan\n\nI'll use Python's built-in string methods:\n- `char.isupper()` to check if uppercase\n- `char.islower()` to check if lowercase\n- `char.upper()` to convert to uppercase\n- `char.lower()` to convert to lowercase\n\n## Code Implementation\n\n```python\ndef to_alternating_case(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n\n# Take input from standard input\ninput_string = input()\n\n# Call the function and print the result\noutput_string = to_alternating_case(input_string)\nprint(output_string)\n```\n\nLet me trace through the examples to verify:\n\n1. `\"hello world\"` \u2192 `\"HELLO WORLD\"` \u2713\n2. `\"HELLO WORLD\"` \u2192 `\"hello world\"` \u2713\n3. `\"hello WORLD\"` \u2192 `\"HELLO world\"` \u2713\n4. `\"HeLLo WoRLD\"` \u2192 `\"hEllO wOrld\"` \u2713\n5. `\"12345\"` \u2192 `\"12345\"` \u2713\n6. `\"1a2b3c4d5e\"` \u2192 `\"1A2B3C4D5E\"` \u2713\n\nThe solution correctly handles all cases including mixed alphanumeric strings and preserves non-alphabetic characters while converting the case of letters."], "prompt_tokens": [385], "completion_tokens": [434], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 2798}
{"name": "4411", "description": "# Background:\n\nYou're working in a number zoo, and it seems that one of the numbers has gone missing!\n\nZoo workers have no idea what number is missing, and are too incompetent to figure it out, so they're hiring you to do it for them.\n\nIn case the zoo loses another number, they want your program to work regardless of how many numbers there are in total.\n\n___\n\n## Task:\n\nWrite a function that takes a shuffled list of unique numbers from `1` to `n` with one element missing (which can be any number including `n`). Return this missing number.\n\n**Note**: huge lists will be tested.\n\n## Examples:\n\n```\n[1, 3, 4]  =>  2\n[1, 2, 3]  =>  4\n[4, 2, 3]  =>  1\n```", "difficulty": "introductory", "id": 4411, "sample_io": [{"input": "[1, 2, 3]", "output": [4]}, {"input": "[1, 3, 4]", "output": [2]}, {"input": "[4, 2, 3]", "output": [1]}], "test_list": [{"input": "[2, 3, 4]", "output": [1]}, {"input": "[1, 3, 4]", "output": [2]}, {"input": "[1, 2, 4]", "output": [3]}, {"input": "[1, 2, 3]", "output": [4]}, {"input": "[]", "output": [1]}, {"input": "[1]", "output": [2]}, {"input": "[2]", "output": [1]}], "starter_code": "\ndef find_missing_number(numbers):\n\t", "source_codes": ["\ndef find_missing_number(arr):\n    # Determine n (the maximum number in complete sequence)\n    n = len(arr) + 1\n    \n    # Calculate expected sum of numbers from 1 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate actual sum of array elements\n    actual_sum = sum(arr)\n    \n    # Missing number is the difference\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Read input and process\nif __name__ == \"__main__\":\n    # Read input\n    input_str = input().strip()\n    # Parse the list (removing brackets and splitting by comma)\n    if input_str.startswith('[') and input_str.endswith(']'):\n        input_str = input_str[1:-1]\n    \n    if input_str.strip() == '':\n        arr = []\n    else:\n        arr = [int(x.strip()) for x in input_str.split(',') if x.strip()]\n    \n    # Find and print the missing number\n    result = find_missing_number(arr)\n    print(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We have a list of unique numbers from 1 to n, but one number is missing\n2. The list is shuffled (not in order)\n3. We need to find which number is missing\n4. The missing number could be any number in the range 1 to n (including n itself)\n\n## Approach Analysis\n\nThere are several ways to solve this:\n\n### Method 1: Sum Formula\n- Calculate the expected sum of numbers 1 to n using formula: n\u00d7(n+1)/2\n- Calculate actual sum of given array\n- Missing number = expected sum - actual sum\n\n### Method 2: Set Difference\n- Create a set of expected numbers {1, 2, 3, ..., n}\n- Create a set from the given array\n- Find the difference\n\n### Method 3: XOR Operation\n- XOR all numbers from 1 to n\n- XOR all numbers in the array\n- XOR these two results to get the missing number\n\nFor large lists, **Method 1 (Sum Formula)** is most efficient as it's O(n) time and O(1) space.\n\n## Step-by-step Solution\n\n1. First, I need to determine what n should be\n   - If one number is missing from sequence 1 to n, and we have array of length len(arr)\n   - Then n = len(arr) + 1\n\n2. Calculate expected sum using formula: n\u00d7(n+1)/2\n\n3. Calculate actual sum of array elements\n\n4. Missing number = expected sum - actual sum\n\n## Implementation\n\n```python\ndef find_missing_number(arr):\n    # Determine n (the maximum number in complete sequence)\n    n = len(arr) + 1\n    \n    # Calculate expected sum of numbers from 1 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate actual sum of array elements\n    actual_sum = sum(arr)\n    \n    # Missing number is the difference\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Read input and process\nif __name__ == \"__main__\":\n    # Read input\n    input_str = input().strip()\n    # Parse the list (removing brackets and splitting by comma)\n    if input_str.startswith('[') and input_str.endswith(']'):\n        input_str = input_str[1:-1]\n    \n    if input_str.strip() == '':\n        arr = []\n    else:\n        arr = [int(x.strip()) for x in input_str.split(',') if x.strip()]\n    \n    # Find and print the missing number\n    result = find_missing_number(arr)\n    print(result)\n```\n\nLet me trace through the examples:\n\n**Example 1:** [1, 3, 4]\n- n = 3 + 1 = 4\n- Expected sum = 4 \u00d7 5 / 2 = 10\n- Actual sum = 1 + 3 + 4 = 8\n- Missing = 10 - 8 = 2 \u2713\n\n**Example 2:** [1, 2, 3]\n- n = 3 + 1 = 4\n- Expected sum = 4 \u00d7 5 / 2 = 10\n- Actual sum = 1 + 2 + 3 = 6\n- Missing = 10 - 6 = 4 \u2713\n\n**Example 3:** [4, 2, 3]\n- n = 3 + 1 = 4\n- Expected sum = 4 \u00d7 5 / 2 = 10\n- Actual sum = 4 + 2 + 3 = 9\n- Missing = 10 - 9 = 1 \u2713\n\nThe solution works correctly for all test cases and handles large inputs efficiently."], "prompt_tokens": [284], "completion_tokens": [805], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 4411}
{"name": "3741", "description": "Calculate the number of items in a vector that appear at the same index in each vector, with the same value. \n\n```python\n   vector_affinity([1, 2, 3, 4, 5], [1, 2, 2, 4, 3]) # => 0.6\n   vector_affinity([1, 2, 3], [1, 2, 3]) # => 1.0\n```\n\nAffinity value should be realized on a scale of 0.0 to 1.0, with 1.0 being absolutely identical. Two identical sets should always be evaulated as having an affinity or 1.0.\n\nHint: The last example test case holds a significant clue to calculating the affinity correctly.", "difficulty": "introductory", "id": 3741, "sample_io": [{"input": "[1, 2, 3, 4, 5]\n[1, 2, 2, 4, 3]", "output": [0.6]}, {"input": "[1, 2, 3]\n[1, 2, 3]", "output": [1.0]}], "test_list": [{"input": "[1, 2, 3]\n[1, 2, 3, 4, 5]", "output": [0.6]}, {"input": "[1, 2, 3, 4]\n[1, 2, 3, 5]", "output": [0.75]}, {"input": "[1, 2, 3, 4, 5]\n[]", "output": [0.0]}, {"input": "[1, 2, 3]\n[1, 2, 3]", "output": [1.0]}, {"input": "[6, 6, 6, 6, 6, 6]\n[6, None, None, 6, 6, None]", "output": [0.5]}, {"input": "[6]\n[6, 6, 6, 6, 6, 6]", "output": [0.16666666666666666]}, {"input": "[]\n[]", "output": [1.0]}, {"input": "[None]\n[None]", "output": [1.0]}], "starter_code": "\ndef vector_affinity(a, b):\n\t", "source_codes": ["\ndef vector_affinity(vector1, vector2):\n    # Handle edge case where vectors have different lengths\n    if len(vector1) != len(vector2):\n        return 0.0\n    \n    # If both vectors are empty, they are identical\n    if len(vector1) == 0:\n        return 1.0\n    \n    # Count matching elements at the same indices\n    matching_count = 0\n    for i in range(len(vector1)):\n        if vector1[i] == vector2[i]:\n            matching_count += 1\n    \n    # Calculate affinity as ratio of matching elements to total elements\n    affinity = matching_count / len(vector1)\n    return affinity\n\n# Read input\nvector1_str = input().strip()\nvector2_str = input().strip()\n\n# Parse the input strings to lists\nvector1 = eval(vector1_str)\nvector2 = eval(vector2_str)\n\n# Calculate and print the result\nresult = vector_affinity(vector1, vector2)\nprint(result)\n\n\n"], "responses": ["```python\ndef vector_affinity(vector1, vector2):\n    # Handle edge case where vectors have different lengths\n    if len(vector1) != len(vector2):\n        return 0.0\n    \n    # If both vectors are empty, they are identical\n    if len(vector1) == 0:\n        return 1.0\n    \n    # Count matching elements at the same indices\n    matching_count = 0\n    for i in range(len(vector1)):\n        if vector1[i] == vector2[i]:\n            matching_count += 1\n    \n    # Calculate affinity as ratio of matching elements to total elements\n    affinity = matching_count / len(vector1)\n    return affinity\n\n# Read input\nvector1_str = input().strip()\nvector2_str = input().strip()\n\n# Parse the input strings to lists\nvector1 = eval(vector1_str)\nvector2 = eval(vector2_str)\n\n# Calculate and print the result\nresult = vector_affinity(vector1, vector2)\nprint(result)\n```"], "prompt_tokens": [290], "completion_tokens": [209], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 3741}
