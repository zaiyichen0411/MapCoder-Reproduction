{"name": "2170", "description": "There are some rabbits in Singapore Zoo. To feed them, Zookeeper bought $n$ carrots with lengths $a_1, a_2, a_3, \\ldots, a_n$. However, rabbits are very fertile and multiply very quickly. Zookeeper now has $k$ rabbits and does not have enough carrots to feed all of them. To solve this problem, Zookeeper decided to cut the carrots into $k$ pieces. For some reason, all resulting carrot lengths must be positive integers.\n\nBig carrots are very difficult for rabbits to handle and eat, so the time needed to eat a carrot of size $x$ is $x^2$.\n\nHelp Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ $(1 \\leq n \\leq k \\leq 10^5)$: the initial number of carrots and the number of rabbits.\n\nThe next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ $(1 \\leq a_i \\leq 10^6)$: lengths of carrots.\n\nIt is guaranteed that the sum of $a_i$ is at least $k$.\n\n\n-----Output-----\n\nOutput one integer: the minimum sum of time taken for rabbits to eat carrots.\n\n\n-----Examples-----\nInput\n3 6\n5 3 1\n\nOutput\n15\n\nInput\n1 4\n19\n\nOutput\n91\n\n\n\n-----Note-----\n\nFor the first test, the optimal sizes of carrots are $\\{1,1,1,2,2,2\\}$. The time taken is $1^2+1^2+1^2+2^2+2^2+2^2=15$\n\nFor the second test, the optimal sizes of carrots are $\\{4,5,5,5\\}$. The time taken is $4^2+5^2+5^2+5^2=91$.", "difficulty": "competition", "id": 2170, "sample_io": [{"input": "3 6\n5 3 1\n", "output": ["15\n"]}, {"input": "1 4\n19\n", "output": ["91\n"]}], "test_list": [{"input": "3 6\n5 3 1\n", "output": ["15\n"]}, {"input": "1 4\n19\n", "output": ["91\n"]}, {"input": "1 3\n1000000\n", "output": ["333333333334\n"]}, {"input": "1 1\n1\n", "output": ["1\n"]}, {"input": "10 23\n343 984 238 758983 231 74 231 548 893 543\n", "output": ["41149446942\n"]}, {"input": "20 40\n2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n", "output": ["40\n"]}, {"input": "29 99047\n206580 305496 61753 908376 272137 803885 675070 665109 995787 667887 164508 634877 994427 270698 931765 721679 518973 65009 804367 608526 535640 117656 342804 398273 369209 298745 365459 942772 89584\n", "output": ["2192719703\n"]}, {"input": "54 42164\n810471 434523 262846 930807 148016 633714 247313 376546 142288 30094 599543 829013 182512 647950 512266 827248 452285 531124 257259 453752 114536 833190 737596 267349 598567 781294 390500 318098 354290 725051 978831 905185 849542 761886 55532 608148 631077 557070 355245 929381 280340 620004 285066 42159 82460 348896 446782 672690 364747 339938 715721 870099 357424 323761\n", "output": ["17049737221\n"]}, {"input": "12 21223\n992192 397069 263753 561788 903539 521894 818097 223467 511651 737418 975119 528954\n", "output": ["2604648091\n"]}], "starter_code": "", "source_codes": ["\nimport sys\nimport heapq\n\ndef min_eating_time():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    \n    # Use a max-heap, so we use negative values\n    max_heap = [-x for x in a]\n    heapq.heapify(max_heap)\n    \n    for _ in range(k - n):\n        largest = -heapq.heappop(max_heap)\n        half = largest // 2\n        heapq.heappush(max_heap, -half)\n        heapq.heappush(max_heap, -(largest - half))\n    \n    # Calculate the sum of squares\n    total = 0\n    while max_heap:\n        total += (-heapq.heappop(max_heap)) ** 2\n    \n    print(total)\n\n# Run the function\nmin_eating_time()\n\n\n"], "responses": ["To solve this problem efficiently, we need to minimize the sum of squares of the carrot pieces after cutting them into `k` pieces, with the constraint that all pieces must be positive integers.\n\n### Key Observations:\n\n1. **Cost Function**: The cost to eat a piece of size `x` is `x^2`. Therefore, we want to minimize the sum of squares of the pieces.\n2. **Optimal Cutting**: To minimize the sum of squares, we should make the pieces as equal as possible. For example, if we have a carrot of length `L` and we want to split it into `m` pieces, the optimal way is to split it into as many `floor(L/m)` as possible and the rest as `ceil(L/m)`.\n3. **Greedy Strategy**: We can use a **priority queue (max-heap)** to always split the largest carrot first, as splitting a larger carrot into smaller pieces gives a larger reduction in the total cost.\n\n### Approach:\n\n- Start with all carrots in a max-heap.\n- For each of the `k - n` cuts needed (since we start with `n` carrots and need `k` pieces), we:\n  - Pop the largest carrot.\n  - Split it into two parts: `x // 2` and `x - x // 2`.\n  - Push the two parts back into the heap.\n- After all cuts, sum the squares of all the carrot pieces.\n\nHere is the Python code:\n\n```python\nimport sys\nimport heapq\n\ndef min_eating_time():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    \n    # Use a max-heap, so we use negative values\n    max_heap = [-x for x in a]\n    heapq.heapify(max_heap)\n    \n    for _ in range(k - n):\n        largest = -heapq.heappop(max_heap)\n        half = largest // 2\n        heapq.heappush(max_heap, -half)\n        heapq.heappush(max_heap, -(largest - half))\n    \n    # Calculate the sum of squares\n    total = 0\n    while max_heap:\n        total += (-heapq.heappop(max_heap)) ** 2\n    \n    print(total)\n\n# Run the function\nmin_eating_time()\n```"], "prompt_tokens": [537], "completion_tokens": [505], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2170}
