{"name": "2070", "description": "Karen has just arrived at school, and she has a math test today! [Image] \n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 10^9 + 7.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is a_{i} (1 \u2264 a_{i} \u2264 10^9), the i-th number on the first row.\n\n\n-----Output-----\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 10^9 + 7.\n\n\n-----Examples-----\nInput\n5\n3 6 9 12 15\n\nOutput\n36\n\nInput\n4\n3 7 5 2\n\nOutput\n1000000006\n\n\n\n-----Note-----\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is 10^9 + 6, so this is the correct output.", "difficulty": "competition", "id": 2070, "sample_io": [{"input": "5\n3 6 9 12 15\n", "output": ["36\n"]}, {"input": "4\n3 7 5 2\n", "output": ["1000000006\n"]}], "test_list": [{"input": "5\n3 6 9 12 15\n", "output": ["36\n"]}, {"input": "4\n3 7 5 2\n", "output": ["1000000006\n"]}, {"input": "1\n1\n", "output": ["1\n"]}, {"input": "16\n985629174 189232688 48695377 692426437 952164554 243460498 173956955 210310239 237322183 96515847 678847559 682240199 498792552 208770488 736004147 176573082\n", "output": ["347261016\n"]}, {"input": "18\n341796022 486073481 86513380 593942288 60606166 627385348 778725113 896678215 384223198 661124212 882144246 60135494 374392733 408166459 179944793 331468916 401182818 69503967\n", "output": ["773499683\n"]}, {"input": "17\n458679894 912524637 347508634 863280107 226481104 787939275 48953130 553494227 458256339 673787326 353107999 298575751 436592642 233596921 957974470 254020999 707869688\n", "output": ["769845668\n"]}, {"input": "19\n519879446 764655030 680293934 914539062 744988123 317088317 653721289 239862203 605157354 943428394 261437390 821695238 312192823 432992892 547139308 408916833 829654733 223751525 672158759\n", "output": ["265109293\n"]}, {"input": "1\n1000000000\n", "output": ["1000000000\n"]}, {"input": "3\n524125987 923264237 374288891\n", "output": ["996365563\n"]}, {"input": "4\n702209411 496813081 673102149 561219907\n", "output": ["317278572\n"]}, {"input": "5\n585325539 365329221 412106895 291882089 564718673\n", "output": ["974257995\n"]}, {"input": "6\n58376259 643910770 5887448 757703054 544067926 902981667\n", "output": ["676517605\n"]}, {"input": "7\n941492387 72235422 449924898 783332532 378192988 592684636 147499872\n", "output": ["328894634\n"]}, {"input": "2\n500000004 500000003\n", "output": ["0\n"]}], "starter_code": "", "source_codes": ["\nimport sys\ninput = sys.stdin.read\n\nMOD = 10**9 + 7\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = n\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    # Fermat's little theorem: a^(MOD-2) mod MOD is the modular inverse of a\n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    result = 0\n    for i in range(n):\n        # C(n-1, i) = fact[n-1] * inv_fact[i] * inv_fact[n-1 - i] % MOD\n        c = fact[n - 1] * inv_fact[i] % MOD\n        c = c * inv_fact[n - 1 - i] % MOD\n        sign = -1 if (i % 2 == 1) else 1\n        term = c * a[i] % MOD\n        if sign == -1:\n            term = (MOD - term) % MOD\n        result = (result + term) % MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve this problem efficiently, we need to understand the pattern in the way the numbers are combined.\n\n### Key Insight:\nLet\u2019s think about the process:\n\n- For `n` numbers, we perform alternating addition and subtraction on adjacent pairs.\n- This process is repeated until only one number remains.\n\nBut instead of simulating the whole process (which would be O(n^2) and too slow for n up to 200,000), we can find a pattern in the final result.\n\nLet\u2019s look at the pattern of coefficients for the original numbers in the final result.\n\nFor example:\n- For `n = 1`: final result is `a1`\n- For `n = 2`: `a1 + a2`\n- For `n = 3`: `a1 - a2 + a3`\n- For `n = 4`: `a1 + a2 - a3 - a4`\n- For `n = 5`: `a1 - a2 + a3 - a4 + a5`\n\nWe can see a pattern in the signs:\n- The sign of the i-th number in the final result depends on the parity of the number of steps it goes through.\n\nThis leads to the following:\n- The coefficient of `a[i]` in the final result is `(-1)^(i-1) * C(n-1, i-1)`, where `C(n-1, i-1)` is the binomial coefficient.\n\nSo the final result is:\n\n```\nresult = sum( (-1)^(i-1) * C(n-1, i-1) * a[i] for i in range(n) )\n```\n\nBut computing binomial coefficients for large `n` (up to 200,000) is computationally expensive unless we precompute them.\n\n### Efficient Approach:\nWe can use **modular arithmetic** and **precompute factorials and inverse factorials** to compute binomial coefficients modulo `10^9 + 7`.\n\nHere's the Python code that implements this logic efficiently:\n\n```python\nimport sys\ninput = sys.stdin.read\n\nMOD = 10**9 + 7\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_n = n\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    # Fermat's little theorem: a^(MOD-2) mod MOD is the modular inverse of a\n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    result = 0\n    for i in range(n):\n        # C(n-1, i) = fact[n-1] * inv_fact[i] * inv_fact[n-1 - i] % MOD\n        c = fact[n - 1] * inv_fact[i] % MOD\n        c = c * inv_fact[n - 1 - i] % MOD\n        sign = -1 if (i % 2 == 1) else 1\n        term = c * a[i] % MOD\n        if sign == -1:\n            term = (MOD - term) % MOD\n        result = (result + term) % MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n- We precompute factorials and inverse factorials up to `n` using modular arithmetic.\n- For each element in the array, compute its binomial coefficient `C(n-1, i)` and apply the correct sign based on the position.\n- Sum all the terms modulo `10^9 + 7`.\n\nThis solution runs in **O(n)** time and is efficient even for `n = 200,000`."], "prompt_tokens": [711], "completion_tokens": [894], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2070}
