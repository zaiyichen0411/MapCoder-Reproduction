{"name": "2215", "description": "Jzzhu is the president of country A. There are n cities numbered from 1 to n in his country. City 1 is the capital of A. Also there are m roads connecting the cities. One can go from city u_{i} to v_{i} (and vise versa) using the i-th road, the length of this road is x_{i}. Finally, there are k train routes in the country. One can use the i-th train route to go from capital of the country to city s_{i} (and vise versa), the length of this route is y_{i}.\n\nJzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (2 \u2264 n \u2264 10^5;\u00a01 \u2264 m \u2264 3\u00b710^5;\u00a01 \u2264 k \u2264 10^5).\n\nEach of the next m lines contains three integers u_{i}, v_{i}, x_{i} (1 \u2264 u_{i}, v_{i} \u2264 n;\u00a0u_{i} \u2260 v_{i};\u00a01 \u2264 x_{i} \u2264 10^9).\n\nEach of the next k lines contains two integers s_{i} and y_{i} (2 \u2264 s_{i} \u2264 n;\u00a01 \u2264 y_{i} \u2264 10^9).\n\nIt is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.\n\n\n-----Output-----\n\nOutput a single integer representing the maximum number of the train routes which can be closed.\n\n\n-----Examples-----\nInput\n5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n\nOutput\n2\n\nInput\n2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n\nOutput\n2", "difficulty": "competition", "id": 2215, "sample_io": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}], "test_list": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}, {"input": "5 4 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "3 2 5\n1 2 2\n2 3 4\n3 5\n3 5\n3 5\n3 6\n3 7\n", "output": ["4\n"]}, {"input": "5 5 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 3 1000000000\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "2 1 5\n1 2 4\n2 3\n2 5\n2 4\n2 4\n2 5\n", "output": ["4\n"]}, {"input": "3 3 6\n1 2 499999999\n2 3 500000000\n1 3 999999999\n2 499999999\n2 500000000\n2 499999999\n3 999999999\n3 1000000000\n3 1000000000\n", "output": ["6\n"]}, {"input": "2 1 1\n1 2 1\n2 1000000000\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 4\n2 3 4\n2 2\n3 6\n", "output": ["1\n"]}, {"input": "5 5 2\n1 2 100\n2 3 100\n3 4 100\n4 5 20\n2 5 5\n5 50\n4 1\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 100\n2 3 1\n2 1\n3 3\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["\nimport sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    k = int(data[idx])\n    idx += 1\n\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        x = int(data[idx])\n        idx += 1\n        graph[u].append((v, x))\n        graph[v].append((u, x))\n\n    # Dijkstra's algorithm to find shortest distance from city 1\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    heap = [(0, 1)]\n    \n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heapq.heappush(heap, (dist[v], v))\n\n    # Process train routes\n    count = 0\n    for _ in range(k):\n        s = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        if y > dist[s]:\n            count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve this problem, we need to determine the maximum number of train routes that can be closed without increasing the shortest path from the capital (city 1) to any city.\n\n### Key Idea:\n- We can use **Dijkstra's algorithm** to compute the shortest distance from the capital (city 1) to all other cities using the roads.\n- For each train route (from capital to city `s_i` with length `y_i`), we check if `y_i` is **greater than** the shortest path from the capital to `s_i`. If it is, then this train route is **not necessary**, and we can close it.\n- If `y_i` is **equal to** the shortest path, then it's **possible** that this route is part of the shortest path, so we **cannot** close it.\n- If `y_i` is **less than** the shortest path, then it's **not possible** to close it as it would reduce the shortest path.\n\n### Steps:\n1. Use Dijkstra's algorithm to compute the shortest distance from the capital to all cities.\n2. For each train route, compare its length with the shortest distance to the city it connects.\n3. Count how many of these routes can be closed (i.e., where `y_i > shortest_distance[s_i]`).\n\n### Python Code:\n\n```python\nimport sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    k = int(data[idx])\n    idx += 1\n\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        x = int(data[idx])\n        idx += 1\n        graph[u].append((v, x))\n        graph[v].append((u, x))\n\n    # Dijkstra's algorithm to find shortest distance from city 1\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    heap = [(0, 1)]\n    \n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heapq.heappush(heap, (dist[v], v))\n\n    # Process train routes\n    count = 0\n    for _ in range(k):\n        s = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        if y > dist[s]:\n            count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```"], "prompt_tokens": [645], "completion_tokens": [617], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2215}
