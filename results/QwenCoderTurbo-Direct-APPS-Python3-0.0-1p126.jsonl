{"name": "2187", "description": "Jzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. \n\nJzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.\n\nJzzhu wonders how to get the maximum possible number of groups. Can you help him?\n\n\n-----Input-----\n\nA single integer n (1 \u2264 n \u2264 10^5), the number of the apples.\n\n\n-----Output-----\n\nThe first line must contain a single integer m, representing the maximum number of groups he can get. Each of the next m lines must contain two integers \u2014 the numbers of apples in the current group.\n\nIf there are several optimal answers you can print any of them.\n\n\n-----Examples-----\nInput\n6\n\nOutput\n2\n6 3\n2 4\n\nInput\n9\n\nOutput\n3\n9 3\n2 4\n6 8\n\nInput\n2\n\nOutput\n0", "difficulty": "competition", "id": 2187, "sample_io": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}], "test_list": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}, {"input": "10\n", "output": ["4\n2 4\n6 8\n10 5\n9 3\n"]}, {"input": "100\n", "output": ["44\n33 27\n22 11\n25 5\n64 66\n42 44\n31 62\n58 29\n43 86\n15 21\n6 99\n8 12\n85 65\n7 49\n23 46\n16 14\n20 18\n90 92\n48 50\n40 36\n74 37\n35 55\n10 95\n56 60\n47 94\n45 39\n93 87\n88 84\n72 76\n28 24\n75 81\n78 80\n54 52\n38 19\n3 9\n32 30\n91 77\n70 68\n63 69\n2 4\n57 51\n82 41\n17 34\n13 26\n96 98\n"]}, {"input": "1\n", "output": ["0\n"]}, {"input": "3\n", "output": ["0\n"]}, {"input": "5\n", "output": ["1\n2 4\n"]}], "starter_code": "", "source_codes": ["\nimport sys\nimport math\n\ndef max_apple_groups(n):\n    used = [False] * (n + 1)\n    groups = []\n\n    for i in range(2, n + 1):\n        if not used[i]:\n            for j in range(2 * i, n + 1, i):\n                if not used[j]:\n                    groups.append((i, j))\n                    used[i] = used[j] = True\n                    break\n\n    return groups\n\ndef main():\n    n = int(sys.stdin.readline())\n    groups = max_apple_groups(n)\n    print(len(groups))\n    for a, b in groups:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["Here's a Python3 solution to the problem. The approach is to pair up numbers such that each pair has a GCD greater than 1. The strategy is to iterate through the numbers and pair them with their multiples, ensuring that each number is used at most once.\n\n```python\nimport sys\nimport math\n\ndef max_apple_groups(n):\n    used = [False] * (n + 1)\n    groups = []\n\n    for i in range(2, n + 1):\n        if not used[i]:\n            for j in range(2 * i, n + 1, i):\n                if not used[j]:\n                    groups.append((i, j))\n                    used[i] = used[j] = True\n                    break\n\n    return groups\n\ndef main():\n    n = int(sys.stdin.readline())\n    groups = max_apple_groups(n)\n    print(len(groups))\n    for a, b in groups:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n```"], "prompt_tokens": [345], "completion_tokens": [207], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2187}
