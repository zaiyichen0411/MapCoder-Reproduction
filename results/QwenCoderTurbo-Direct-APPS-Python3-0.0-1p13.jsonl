{"name": "3836", "description": "Create a function that takes a number and finds the factors of it, listing them in **descending** order in an **array**.\n\nIf the parameter is not an integer or less than 1, return `-1`. In C# return an empty array.\n\nFor Example:\n`factors(54)` should return `[54, 27, 18, 9, 6, 3, 2, 1]`", "difficulty": "introductory", "id": 3836, "sample_io": [{"input": "54", "output": [[54, 27, 18, 9, 6, 3, 2, 1]]}], "test_list": [{"input": "-4", "output": [-1]}, {"input": "0", "output": [-1]}, {"input": "-12", "output": [-1]}, {"input": "a", "output": [-1]}, {"input": "4.5", "output": [-1]}, {"input": "hello world", "output": [-1]}, {"input": "54", "output": [[54, 27, 18, 9, 6, 3, 2, 1]]}, {"input": "49", "output": [[49, 7, 1]]}, {"input": "1", "output": [[1]]}], "starter_code": "\ndef factors(x):\n\t", "source_codes": ["\ndef factors(n):\n    # Check if input is valid (integer and >= 1)\n    if not isinstance(n, int) or n < 1:\n        return -1\n    \n    # Find all factors\n    factor_list = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            factor_list.append(i)\n            # Add the corresponding factor (n/i) if it's different from i\n            if i != n // i:\n                factor_list.append(n // i)\n    \n    # Sort in descending order\n    factor_list.sort(reverse=True)\n    return factor_list\n\n# Take input and process\nn = int(input())\nresult = factors(n)\nprint(result)\n\n\n"], "responses": ["```python\ndef factors(n):\n    # Check if input is valid (integer and >= 1)\n    if not isinstance(n, int) or n < 1:\n        return -1\n    \n    # Find all factors\n    factor_list = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            factor_list.append(i)\n            # Add the corresponding factor (n/i) if it's different from i\n            if i != n // i:\n                factor_list.append(n // i)\n    \n    # Sort in descending order\n    factor_list.sort(reverse=True)\n    return factor_list\n\n# Take input and process\nn = int(input())\nresult = factors(n)\nprint(result)\n```"], "prompt_tokens": [214], "completion_tokens": [159], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 3836}
{"name": "3531", "description": "A [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) is a prime number that can be represented as:\nMn = 2^(n) - 1. Therefore, every Mersenne prime is one less than a power of two. \n\nWrite a function that will return whether the given integer `n` will produce a Mersenne prime or not.\n\nThe tests will check random integers up to 2000.", "difficulty": "introductory", "id": 3531, "sample_io": [], "test_list": [{"input": "2", "output": [true]}, {"input": "3", "output": [true]}, {"input": "5", "output": [true]}, {"input": "7", "output": [true]}, {"input": "11", "output": [false]}, {"input": "13", "output": [true]}, {"input": "17", "output": [true]}, {"input": "19", "output": [true]}, {"input": "21", "output": [false]}, {"input": "23", "output": [false]}, {"input": "31", "output": [true]}, {"input": "49", "output": [false]}, {"input": "61", "output": [true]}, {"input": "89", "output": [true]}, {"input": "107", "output": [true]}, {"input": "127", "output": [true]}, {"input": "221", "output": [false]}, {"input": "521", "output": [true]}, {"input": "607", "output": [true]}, {"input": "1279", "output": [true]}], "starter_code": "\ndef valid_mersenne(n):\n\t", "source_codes": ["\ndef is_prime(num):\n    \"\"\"Check if a number is prime\"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    return True\n\ndef is_mersenne_prime(n):\n    \"\"\"Check if 2^n - 1 is a Mersenne prime\"\"\"\n    if n <= 0:\n        return False\n    \n    # Calculate 2^n - 1\n    mersenne_number = (2 ** n) - 1\n    \n    # Check if it's prime\n    return is_prime(mersenne_number)\n\n# Read input and process\nn = int(input())\nresult = is_mersenne_prime(n)\nprint(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\nFirst, let me understand what we need:\n1. Check if a given integer `n` produces a Mersenne prime Mn = 2^n - 1\n2. This means we need to check if 2^n - 1 is prime\n3. We need to handle input/output properly\n\nLet me break this down:\n- We need a function to check if a number is prime\n- We need to calculate 2^n - 1 \n- We need to check if that result is prime\n\nHere's my solution:\n\n```python\ndef is_prime(num):\n    \"\"\"Check if a number is prime\"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    return True\n\ndef is_mersenne_prime(n):\n    \"\"\"Check if 2^n - 1 is a Mersenne prime\"\"\"\n    if n <= 0:\n        return False\n    \n    # Calculate 2^n - 1\n    mersenne_number = (2 ** n) - 1\n    \n    # Check if it's prime\n    return is_prime(mersenne_number)\n\n# Read input and process\nn = int(input())\nresult = is_mersenne_prime(n)\nprint(result)\n```\n\nLet me trace through some examples:\n- For n=2: 2^2 - 1 = 4 - 1 = 3, which is prime \u2192 True\n- For n=3: 2^3 - 1 = 8 - 1 = 7, which is prime \u2192 True  \n- For n=4: 2^4 - 1 = 16 - 1 = 15, which is not prime (15 = 3\u00d75) \u2192 False\n\nThe solution efficiently checks primality by testing divisibility up to the square root of the number, and handles edge cases appropriately."], "prompt_tokens": [177], "completion_tokens": [453], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 3531}
{"name": "1643", "description": "You are given 2 numbers is `n` and `k`. You need to find the number of integers between 1 and n (inclusive) that contains exactly `k` non-zero digit.\n\nExample1 \n\n`\nalmost_everywhere_zero(100, 1) return 19`\n\nby following condition we have 19 numbers that have k = 1 digits( not count zero ) \n` [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100]`\n\n\nExample2  \n\n`\nalmost_everywhere_zero(11, 2) return 1`\n\nwe have only `11` that has 2 digits(ten not count because zero is not count) \n` 11`\n\n\n\n\n\nconstrains\n\n\n`1\u2264n<pow(10,100)`\n\n\n`1\u2264k\u2264100`", "difficulty": "interview", "id": 1643, "sample_io": [{"input": "100\n1", "output": [19]}, {"input": "11\n2", "output": [1]}], "test_list": [{"input": "100\n1", "output": [19]}, {"input": "11\n2", "output": [1]}, {"input": "20\n2", "output": [9]}, {"input": "101\n2", "output": [82]}, {"input": "10001\n2", "output": [487]}, {"input": "10001000\n2", "output": [1729]}, {"input": "500309160\n2", "output": [2604]}, {"input": "10000000000000000000000\n3", "output": [1122660]}, {"input": "10000000000000000000000\n21", "output": [2407217760893271902598]}, {"input": "1203\n4", "output": [81]}], "starter_code": "\ndef almost_everywhere_zero(n, k):\n\t", "source_codes": ["\ndef almost_everywhere_zero():\n    n = input().strip()\n    k = int(input().strip())\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, count, tight, started):\n        # Base case: reached end of digit string\n        if pos == len(n):\n            return 1 if count == k else 0\n        \n        # Check if already computed\n        if (pos, count, tight, started) in memo:\n            return memo[(pos, count, tight, started)]\n        \n        # Determine the maximum digit we can place at current position\n        limit = int(n[pos]) if tight else 9\n        \n        result = 0\n        for digit in range(0, limit + 1):\n            # Skip if we're not started and placing a zero (leading zero)\n            if not started and digit == 0:\n                result += dp(pos + 1, count, tight and (digit == limit), False)\n            else:\n                # We've started placing digits\n                new_count = count + (1 if digit != 0 else 0)\n                # If count exceeds k, no point in continuing\n                if new_count <= k:\n                    result += dp(pos + 1, new_count, tight and (digit == limit), True)\n        \n        memo[(pos, count, tight, started)] = result\n        return result\n    \n    return dp(0, 0, True, False)\n\n# Call the function and print result\nprint(almost_everywhere_zero())\n\n\n"], "responses": ["Looking at this problem, I need to count integers between 1 and n (inclusive) that have exactly k non-zero digits.\n\nThis is a digit DP (Dynamic Programming) problem where I need to:\n1. Process digits of n from left to right\n2. Keep track of how many non-zero digits I've placed so far\n3. Handle the constraint that the generated number should be \u2264 n\n\nLet me break down the approach:\n- Use digit DP with states: current position, count of non-zero digits placed, tight constraint flag\n- Handle leading zeros appropriately\n- Memoize results to avoid recomputation\n\n```python\ndef almost_everywhere_zero():\n    n = input().strip()\n    k = int(input().strip())\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, count, tight, started):\n        # Base case: reached end of digit string\n        if pos == len(n):\n            return 1 if count == k else 0\n        \n        # Check if already computed\n        if (pos, count, tight, started) in memo:\n            return memo[(pos, count, tight, started)]\n        \n        # Determine the maximum digit we can place at current position\n        limit = int(n[pos]) if tight else 9\n        \n        result = 0\n        for digit in range(0, limit + 1):\n            # Skip if we're not started and placing a zero (leading zero)\n            if not started and digit == 0:\n                result += dp(pos + 1, count, tight and (digit == limit), False)\n            else:\n                # We've started placing digits\n                new_count = count + (1 if digit != 0 else 0)\n                # If count exceeds k, no point in continuing\n                if new_count <= k:\n                    result += dp(pos + 1, new_count, tight and (digit == limit), True)\n        \n        memo[(pos, count, tight, started)] = result\n        return result\n    \n    return dp(0, 0, True, False)\n\n# Call the function and print result\nprint(almost_everywhere_zero())\n```\n\nThe algorithm works as follows:\n\n1. **State representation**: `dp(pos, count, tight, started)`\n   - `pos`: current digit position we're filling\n   - `count`: number of non-zero digits placed so far\n   - `tight`: whether we're constrained by the original number n\n   - `started`: whether we've placed a non-zero digit (to handle leading zeros)\n\n2. **Transition**: For each position, try all valid digits (0 to limit)\n   - If we haven't started and place 0, it's a leading zero\n   - Otherwise, update the count if we place a non-zero digit\n\n3. **Base case**: When we've processed all positions, return 1 if count equals k, otherwise 0\n\n4. **Memoization**: Store results to avoid recomputing same states\n\nTime complexity: O(len(n) \u00d7 k \u00d7 2 \u00d7 2 \u00d7 10) = O(len(n) \u00d7 k)\nSpace complexity: O(len(n) \u00d7 k)\n\nThis handles the large constraints efficiently since n can be up to 10^100."], "prompt_tokens": [313], "completion_tokens": [677], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 1643}
