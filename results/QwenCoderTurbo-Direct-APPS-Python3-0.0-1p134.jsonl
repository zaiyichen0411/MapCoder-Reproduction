{"name": "2075", "description": "It is known that there are k fish species in the polar ocean, numbered from 1 to k. They are sorted by non-decreasing order of their weight, which is a positive number. Let the weight of the i-th type of fish be w_{i}, then 0 < w_1 \u2264 w_2 \u2264 ... \u2264 w_{k} holds.\n\nPolar bears Alice and Bob each have caught some fish, and they are guessing who has the larger sum of weight of the fish he/she's caught. Given the type of the fish they've caught, determine whether it is possible that the fish caught by Alice has a strictly larger total weight than Bob's. In other words, does there exist a sequence of weights w_{i} (not necessary integers), such that the fish caught by Alice has a strictly larger total weight?\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (1 \u2264 n, m \u2264 10^5, 1 \u2264 k \u2264 10^9) \u2014 the number of fish caught by Alice and Bob respectively, and the number of fish species.\n\nThe second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.\n\nNote that one may have caught more than one fish for a same species.\n\n\n-----Output-----\n\nOutput \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n3 3 3\n2 2 2\n1 1 3\n\nOutput\nYES\n\nInput\n4 7 9\n5 2 7 3\n3 5 2 7 3 8 7\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample, if w_1 = 1, w_2 = 2, w_3 = 2.5,  then Alice has a total of 2 + 2 + 2 = 6 weight units, while Bob only has 1 + 1 + 2.5 = 4.5.\n\nIn the second sample, the fish that Alice caught is a subset of Bob's. Therefore, the total weight of Bob\u2019s fish is always not less than the total weight of Alice\u2019s fish.", "difficulty": "competition", "id": 2075, "sample_io": [{"input": "3 3 3\n2 2 2\n1 1 3\n", "output": ["YES\n"]}, {"input": "4 7 9\n5 2 7 3\n3 5 2 7 3 8 7\n", "output": ["NO\n"]}], "test_list": [{"input": "3 3 3\n2 2 2\n1 1 3\n", "output": ["YES\n"]}, {"input": "4 7 9\n5 2 7 3\n3 5 2 7 3 8 7\n", "output": ["NO\n"]}, {"input": "5 5 10\n8 2 8 5 9\n9 1 7 5 1\n", "output": ["YES\n"]}, {"input": "7 7 10\n8 2 8 10 6 9 10\n2 4 9 5 6 2 5\n", "output": ["YES\n"]}, {"input": "15 15 10\n4 5 9 1 4 6 4 1 4 3 7 9 9 2 6\n6 6 7 7 2 9 1 6 10 9 7 10 7 10 9\n", "output": ["NO\n"]}, {"input": "25 25 10\n10 6 2 1 9 7 2 5 6 9 2 3 2 8 5 8 2 9 10 8 9 7 7 4 8\n6 2 10 4 7 9 3 2 4 5 1 8 6 9 8 6 9 8 4 8 7 9 10 2 8\n", "output": ["NO\n"]}, {"input": "2 2 1000000000\n398981840 446967516\n477651114 577011341\n", "output": ["NO\n"]}, {"input": "1 1 1\n1\n1\n", "output": ["NO\n"]}, {"input": "1 1 1000000000\n502700350\n502700349\n", "output": ["YES\n"]}, {"input": "1 1 1000000000\n406009709\n406009709\n", "output": ["NO\n"]}, {"input": "2 1 1000000000\n699573624 308238132\n308238132\n", "output": ["YES\n"]}, {"input": "10 10 10\n2 10 8 1 10 4 6 1 3 7\n8 1 1 5 7 1 9 10 2 3\n", "output": ["YES\n"]}, {"input": "5 4 5\n1 2 2 3 4\n1 3 4 5\n", "output": ["YES\n"]}], "starter_code": "", "source_codes": ["\nimport sys\nfrom collections import Counter\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    \n    alice_fish = list(map(int, data[3:3+n]))\n    bob_fish = list(map(int, data[3+n:3+n+m]))\n    \n    alice_count = Counter(alice_fish)\n    bob_count = Counter(bob_fish)\n    \n    # We will simulate the weight assignment\n    # We need to check if there exists a way to assign weights such that sum(alice) > sum(bob)\n    \n    # We will process all species from 1 to k\n    # For each species, we can assign a weight such that:\n    # - If Alice has more of this species than Bob, we assign a higher weight\n    # - If Bob has more, we assign a lower weight\n    # - If they are equal, we can assign the same weight\n    \n    # We can simulate this by comparing the counts of each species\n    \n    # Create a set of all species that appear in either list\n    all_species = set(alice_fish + bob_fish)\n    \n    # Sort the species for consistent processing\n    all_species = sorted(all_species)\n    \n    # We will simulate the weight assignment\n    # We will keep track of the difference in counts between Alice and Bob\n    # For each species, if the difference is positive, it's better to assign higher weight\n    # If the difference is negative, assign lower weight\n    \n    # We can simulate this by keeping a running balance\n    balance = 0\n    \n    for species in all_species:\n        a = alice_count.get(species, 0)\n        b = bob_count.get(species, 0)\n        balance += a - b\n    \n    # If the final balance is positive, it's possible for Alice to have a higher total\n    if balance > 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve this problem, we need to determine if there exists a weight assignment to fish species such that the **total weight of Alice's fish is strictly greater** than the **total weight of Bob's fish**.\n\n### Key Observations:\n\n- Fish species are numbered from `1` to `k`, and their weights are in **non-decreasing order**:\n  $$\n  0 < w_1 \\le w_2 \\le \\ldots \\le w_k\n  $$\n\n- We are allowed to assign arbitrary positive real numbers to the weights as long as this order is maintained.\n\n- The goal is to **maximize the difference** between Alice's and Bob's total weight, **given their fish species**.\n\n### Strategy:\n\nTo make Alice's total weight as large as possible **relative to Bob's**, we want to:\n\n- Assign the **largest possible weights** to fish species that are in **Alice's list but not in Bob's**.\n- Assign the **smallest possible weights** to fish species that are in **Bob's list but not in Alice's**.\n- For fish species that are in **both**, we can assign the same weight.\n\nThis is equivalent to checking if **Alice's multiset of fish species dominates Bob's** in a way that allows her total to be strictly greater.\n\n### Efficient Approach:\n\nWe can use the **multiset (Counter)** of fish species for both Alice and Bob. Then, we:\n\n1. For each species, count how many times it appears in Alice's list and Bob's list.\n2. For species that are in **Alice's list more than Bob's**, we can assign a higher weight.\n3. For species that are in **Bob's list more than Alice's**, we can assign a lower weight.\n4. If there's a species that is in **Alice's list but not in Bob's**, and it's **not dominated by a higher species in Bob's list**, then it's possible for Alice to have a higher total.\n\n### Final Check:\n\nWe can **sort the species** and simulate the weight assignment by considering the **difference** between the counts in Alice and Bob's lists.\n\nHere's the Python code:\n\n```python\nimport sys\nfrom collections import Counter\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    \n    alice_fish = list(map(int, data[3:3+n]))\n    bob_fish = list(map(int, data[3+n:3+n+m]))\n    \n    alice_count = Counter(alice_fish)\n    bob_count = Counter(bob_fish)\n    \n    # We will simulate the weight assignment\n    # We need to check if there exists a way to assign weights such that sum(alice) > sum(bob)\n    \n    # We will process all species from 1 to k\n    # For each species, we can assign a weight such that:\n    # - If Alice has more of this species than Bob, we assign a higher weight\n    # - If Bob has more, we assign a lower weight\n    # - If they are equal, we can assign the same weight\n    \n    # We can simulate this by comparing the counts of each species\n    \n    # Create a set of all species that appear in either list\n    all_species = set(alice_fish + bob_fish)\n    \n    # Sort the species for consistent processing\n    all_species = sorted(all_species)\n    \n    # We will simulate the weight assignment\n    # We will keep track of the difference in counts between Alice and Bob\n    # For each species, if the difference is positive, it's better to assign higher weight\n    # If the difference is negative, assign lower weight\n    \n    # We can simulate this by keeping a running balance\n    balance = 0\n    \n    for species in all_species:\n        a = alice_count.get(species, 0)\n        b = bob_count.get(species, 0)\n        balance += a - b\n    \n    # If the final balance is positive, it's possible for Alice to have a higher total\n    if balance > 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n\n- We use `Counter` to count how many times each species appears in Alice's and Bob's lists.\n- We go through each unique species in sorted order.\n- For each species, we compute the **difference** in counts between Alice and Bob.\n- If the **total difference** is **positive**, it means Alice can have a higher total weight with a suitable weight assignment.\n\n### Time Complexity:\n\n- O(n + m + k) in the worst case, but since `k` can be up to 1e9, we only process the species that actually appear in the lists, which is O(n + m).\n\nThis solution is efficient and handles large inputs."], "prompt_tokens": [601], "completion_tokens": [1036], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2075}
