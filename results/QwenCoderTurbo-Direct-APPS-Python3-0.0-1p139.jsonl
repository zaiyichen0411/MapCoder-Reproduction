{"name": "2126", "description": "For the multiset of positive integers $s=\\{s_1,s_2,\\dots,s_k\\}$, define the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of $s$ as follow: $\\gcd(s)$ is the maximum positive integer $x$, such that all integers in $s$ are divisible on $x$. $\\textrm{lcm}(s)$ is the minimum positive integer $x$, that divisible on all integers from $s$.\n\nFor example, $\\gcd(\\{8,12\\})=4,\\gcd(\\{12,18,6\\})=6$ and $\\textrm{lcm}(\\{4,6\\})=12$. Note that for any positive integer $x$, $\\gcd(\\{x\\})=\\textrm{lcm}(\\{x\\})=x$.\n\nOrac has a sequence $a$ with length $n$. He come up with the multiset $t=\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\}$, and asked you to find the value of $\\gcd(t)$ for him. In other words, you need to calculate the GCD of LCMs of all pairs of elements in the given sequence.\n\n\n-----Input-----\n\nThe first line contains one integer $n\\ (2\\le n\\le 100\\,000)$.\n\nThe second line contains $n$ integers, $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 200\\,000$).\n\n\n-----Output-----\n\nPrint one integer: $\\gcd(\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\})$.\n\n\n-----Examples-----\nInput\n2\n1 1\n\nOutput\n1\n\nInput\n4\n10 24 40 80\n\nOutput\n40\n\nInput\n10\n540 648 810 648 720 540 594 864 972 648\n\nOutput\n54\n\n\n\n-----Note-----\n\nFor the first example, $t=\\{\\textrm{lcm}(\\{1,1\\})\\}=\\{1\\}$, so $\\gcd(t)=1$.\n\nFor the second example, $t=\\{120,40,80,120,240,80\\}$, and it's not hard to see that $\\gcd(t)=40$.", "difficulty": "competition", "id": 2126, "sample_io": [{"input": "2\n1 1\n", "output": ["1\n"]}, {"input": "4\n10 24 40 80\n", "output": ["40\n"]}, {"input": "10\n540 648 810 648 720 540 594 864 972 648\n", "output": ["54\n"]}], "test_list": [{"input": "2\n1 1\n", "output": ["1\n"]}, {"input": "4\n10 24 40 80\n", "output": ["40\n"]}, {"input": "10\n540 648 810 648 720 540 594 864 972 648\n", "output": ["54\n"]}, {"input": "2\n199999 200000\n", "output": ["39999800000\n"]}, {"input": "2\n198761 199999\n", "output": ["39752001239\n"]}, {"input": "10\n972 972 324 972 324 648 1944 243 324 474\n", "output": ["162\n"]}, {"input": "3\n166299 110866 86856\n", "output": ["332598\n"]}, {"input": "2\n10007 20014\n", "output": ["20014\n"]}, {"input": "2\n4 6\n", "output": ["12\n"]}, {"input": "5\n25 25 5 5 5\n", "output": ["5\n"]}, {"input": "2\n3 3\n", "output": ["3\n"]}], "starter_code": "", "source_codes": ["\nimport sys\nimport math\nfrom collections import defaultdict\nimport heapq\n\ndef factorize(n):\n    factors = {}\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n        i += 2\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    prime_exponents = defaultdict(list)\n\n    for num in a:\n        factors = factorize(num)\n        for p, exp in factors.items():\n            prime_exponents[p].append(exp)\n\n    result = 1\n\n    for p, exponents in prime_exponents.items():\n        if len(exponents) < 2:\n            continue\n        # Sort the exponents\n        exponents.sort()\n        # Take the second smallest exponent\n        result *= p ** exponents[1]\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve the problem of finding the **GCD of LCMs of all pairs** in a list, we need to understand the mathematical properties involved.\n\n### Key Observations:\n\nLet\u2019s denote the sequence as `a = [a_1, a_2, ..., a_n]`.\n\nWe are to compute:\n```\ngcd( { lcm(a_i, a_j) | 1 \u2264 i < j \u2264 n } )\n```\n\nLet\u2019s denote the final result as `G`.\n\n### Key Insight:\n\nLet\u2019s consider the prime factorization of all elements in the list.\n\nLet\u2019s define:\n- `f(p)` = the **maximum exponent** of prime `p` in the list.\n- `g(p)` = the **minimum exponent** of prime `p` in the list.\n\nFor each prime `p`, the **LCM** of any pair will have an exponent of at least `max(f(p), g(p))`, but the **GCD** of all LCMs will be the **minimum** of these maxima.\n\nSo for each prime `p`, the exponent in the final GCD is the **minimum** of `max(f(p), g(p))` over all pairs.\n\nBut a better way is to think in terms of **all elements**:\n\nLet\u2019s think about the **GCD of LCMs** of all pairs.\n\nLet\u2019s define:\n- `min_exponent(p)` = the **minimum exponent** of prime `p` in the list.\n- `max_exponent(p)` = the **maximum exponent** of prime `p` in the list.\n\nThen, the exponent of `p` in the GCD of all LCMs is:\n```\nmin( max_exponent(p), max_exponent(p) ) = max_exponent(p)\n```\nWait, that's not right.\n\nActually, the exponent of `p` in the **LCM** of any pair is `max(e_i, e_j)`.\n\nThe **GCD** of all such LCMs is the **minimum** of `max(e_i, e_j)` over all pairs.\n\nSo the exponent of `p` in the final GCD is:\n```\nmin( max(e_i, e_j) for all i < j )\n```\n\nThis is equivalent to:\n```\nmin( max(e_i, e_j) for all i < j )\n```\n\nBut what is the minimum of `max(e_i, e_j)` over all pairs?\n\nThat is equal to the **second smallest** value of `e_i`.\n\nSo, for each prime `p`, the exponent in the final result is:\n```\nthe second smallest exponent of `p` among all elements.\n```\n\n### Algorithm:\n\n1. For each number in the list, factorize it into primes.\n2. For each prime, maintain a list of exponents.\n3. For each prime, sort its list of exponents and take the second smallest one (if there are at least two elements).\n4. Multiply all such primes raised to their respective exponents.\n\n### Python Code:\n\n```python\nimport sys\nimport math\nfrom collections import defaultdict\nimport heapq\n\ndef factorize(n):\n    factors = {}\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n        i += 2\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    prime_exponents = defaultdict(list)\n\n    for num in a:\n        factors = factorize(num)\n        for p, exp in factors.items():\n            prime_exponents[p].append(exp)\n\n    result = 1\n\n    for p, exponents in prime_exponents.items():\n        if len(exponents) < 2:\n            continue\n        # Sort the exponents\n        exponents.sort()\n        # Take the second smallest exponent\n        result *= p ** exponents[1]\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n\n- `factorize(n)` returns the prime factorization of `n`.\n- We collect all exponents for each prime.\n- For each prime, we sort its exponents and take the second smallest one (since it's the minimum of `max(e_i, e_j)` over all pairs).\n- Finally, we compute the product of `p^second_smallest_exponent` for all primes.\n\n### Time Complexity:\n\n- Factorization of each number is O(sqrt(a_i)) = up to 450 for a_i \u2264 200,000.\n- Total time is O(n * sqrt(a_i)) which is acceptable for n \u2264 100,000.\n\nThis approach is efficient and correct."], "prompt_tokens": [657], "completion_tokens": [1072], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2126}
