{"name": "1646", "description": "This is a very simply formulated task. Let's call an integer number `N` 'green' if `N\u00b2` ends with all of the digits of `N`. Some examples:\n\n`5` is green, because `5\u00b2 = 25` and `25` ends with `5`.\n\n`11` is not green, because `11\u00b2 = 121` and `121` does not end with `11`.\n\n`376` is green, because `376\u00b2 = 141376` and `141376` ends with `376`.\n\nYour task is to write a function `green` that returns `n`th green number, starting with `1` - `green (1) == 1`\n\n---\n\n## Data range\n\n```if:haskell\n`n <= 4000` for Haskell\n```\n```if:java\n`n <= 5000` for Java\n```\n```if:python\n`n <= 5000` for Python\n```\n```if:javascript\n`n <= 3000` for JavaScript\n\nReturn values should be `String`s, and should be exact. A BigNum library is recommended.\n```", "difficulty": "interview", "id": 1646, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [6]}, {"input": "4", "output": [25]}, {"input": "12", "output": [2890625]}, {"input": "13", "output": [7109376]}, {"input": "100", "output": [6188999442576576769103890995893380022607743740081787109376]}, {"input": "110", "output": [9580863811000557423423230896109004106619977392256259918212890625]}], "starter_code": "\ndef green(n):\n\t", "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 1646}
{"name": "1656", "description": "With your birthday coming up soon, your eccentric friend sent you a message to say \"happy birthday\":\n\n    hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu\n    hhapppyyyy biirtttthdaaay too youuu\n    happy birrrthdayy to youuu\n    happpyyyy birrtthdaaay tooooo youu\n\nAt first it looks like a song, but upon closer investigation, you realize that your friend hid the phrase \"happy birthday\" thousands of times inside his message. In fact, it contains it more than 2 million times! To thank him, you'd like to reply with exactly how many times it occurs.\n\nTo count all the occurences, the procedure is as follows: look through the paragraph and find a `'h'`; then find an `'a'` later in the paragraph; then find an `'p'` after that, and so on. Now count the number of ways in which you can choose letters in this way to make the full phrase.\n\nMore precisely, given a text string, you are to determine how many times the search string appears as a sub-sequence of that string.\n\nWrite a function called `countSubsequences` that takes two arguments: `needle`, the string to be search for and `haystack`, the string to search in. In our example, `\"happy birthday\"` is the needle and the birthday message is the haystack. The function should return the number of times `needle` occurs as a sub-sequence of `haystack`.  Spaces are also considered part of the needle.\n\nSince the answers can be very large, return only the last 8 digits of the answer in case it exceeds 8 digits. The answers to the test cases will all be shorter than 8 digits.", "difficulty": "interview", "id": 1656, "sample_io": [], "test_list": [{"input": "happy birthday\nappyh appy birth day", "output": [1]}, {"input": "happy birthday\nhhaappyy bbiirrtthhddaayy", "output": [2048]}, {"input": "happy birthday\nhappy holidays", "output": [0]}, {"input": "happy birthday\nhappy birthday", "output": [1]}, {"input": "happy\nhhhappy", "output": [3]}, {"input": "happy birthday\nhhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu", "output": [7680]}], "starter_code": "\ndef count_subsequences(a, b):\n\t", "source_codes": ["\ndef countSubsequences(needle, haystack):\n    n = len(needle)\n    m = len(haystack)\n    \n    # dp[i][j] = number of ways to form needle[0:j] using haystack[0:i]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: empty needle can be formed in 1 way from any prefix of haystack\n    for i in range(m + 1):\n        dp[i][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # We can always skip the current character of haystack\n            dp[i][j] = dp[i-1][j]\n            \n            # If characters match, we can also use the current character\n            if haystack[i-1] == needle[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n] % 100000000\n\n# Read input\nneedle = input().strip()\nhaystack = input().strip()\n\n# Call function and print result\nresult = countSubsequences(needle, haystack)\nprint(result)\n\n\n"], "responses": ["Looking at this problem, I need to count the number of ways a needle string appears as a subsequence in a haystack string.\n\nThis is a classic dynamic programming problem. For each position in the haystack and each position in the needle, I need to count how many ways I can form the subsequence up to that point.\n\nLet me think about the approach:\n- I'll use dynamic programming where `dp[i][j]` represents the number of ways to form the first `j` characters of the needle using the first `i` characters of the haystack\n- If the current characters match, I can either include this character (add `dp[i-1][j-1]`) or not include it (add `dp[i-1][j]`)\n- If they don't match, I can only not include the current haystack character (take `dp[i-1][j]`)\n\nBase cases:\n- `dp[i][0] = 1` for all `i` (empty subsequence can be formed in 1 way)\n- `dp[0][j] = 0` for all `j > 0` (can't form non-empty subsequence from empty string)\n\n```python\ndef countSubsequences(needle, haystack):\n    n = len(needle)\n    m = len(haystack)\n    \n    # dp[i][j] = number of ways to form needle[0:j] using haystack[0:i]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: empty needle can be formed in 1 way from any prefix of haystack\n    for i in range(m + 1):\n        dp[i][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # We can always skip the current character of haystack\n            dp[i][j] = dp[i-1][j]\n            \n            # If characters match, we can also use the current character\n            if haystack[i-1] == needle[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n] % 100000000\n\n# Read input\nneedle = input().strip()\nhaystack = input().strip()\n\n# Call function and print result\nresult = countSubsequences(needle, haystack)\nprint(result)\n```"], "prompt_tokens": [453], "completion_tokens": [522], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 1656}
{"name": "1634", "description": "Let's define `increasing` numbers as the numbers whose digits, read from left to right, are never less than the previous ones: 234559 is an example of increasing number.\n\nConversely, `decreasing` numbers have all the digits read from left to right so that no digits is bigger than the previous one: 97732 is an example of decreasing number.\n\nYou do not need to be the next Gauss to figure that all numbers with 1 or 2 digits are either increasing or decreasing: 00, 01, 02, ..., 98, 99 are all belonging to one of this categories (if not both, like 22 or 55): 101 is indeed the first number which does NOT fall into either of the categories. Same goes for all the numbers up to 109, while 110 is again a decreasing number.\n\nNow your task is rather easy to declare (a bit less to perform): you have to build a function to return the total occurrences of all the increasing or decreasing numbers *below* 10 raised to the xth power (x will always be >= 0).\n\nTo give you a starting point, there are a grand total of increasing and decreasing numbers as shown in the table:\n\n|Total  | Below\n|---------------\n|1      | 1\n|10     | 10\n|100    | 100\n|475    | 1000\n|1675   | 10000\n|4954   | 100000\n|12952  | 1000000\n\nThis means that your function will have to behave like this:\n```python\ntotal_inc_dec(0)==1\ntotal_inc_dec(1)==10\ntotal_inc_dec(2)==100\ntotal_inc_dec(3)==475\ntotal_inc_dec(4)==1675\ntotal_inc_dec(5)==4954\ntotal_inc_dec(6)==12952\n```\n\n**Tips:** efficiency and trying to figure out how it works are essential: with a brute force approach, some tests with larger numbers may take more than the total computing power currently on Earth to be finished in the short allotted time.\n\nTo make it even clearer, the increasing or decreasing numbers between in the range 101-200 are: [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 122, 123, 124, 125, 126, 127, 128, 129, 133, 134, 135, 136, 137, 138, 139, 144, 145, 146, 147, 148, 149, 155, 156, 157, 158, 159, 166, 167, 168, 169, 177, 178, 179, 188, 189, 199, 200], that is 47 of them. In the following range, 201-300, there are 41 of them and so on, getting rarer and rarer.\n\n**Trivia:** just for the sake of your own curiosity, a number which is neither decreasing of increasing is called a `bouncy` number, like, say, 3848 or 37294; also, usually 0 is not considered being increasing, decreasing or bouncy, but it will be for the purpose of this kata", "difficulty": "interview", "id": 1634, "sample_io": [{"input": "0", "output": [1]}, {"input": "1", "output": [10]}, {"input": "2", "output": [100]}, {"input": "3", "output": [475]}, {"input": "4", "output": [1675]}, {"input": "5", "output": [4954]}, {"input": "6", "output": [12952]}], "test_list": [{"input": "0", "output": [1]}, {"input": "1", "output": [10]}, {"input": "2", "output": [100]}, {"input": "3", "output": [475]}, {"input": "4", "output": [1675]}, {"input": "5", "output": [4954]}, {"input": "6", "output": [12952]}, {"input": "10", "output": [277033]}, {"input": "20", "output": [40059819]}, {"input": "50", "output": [87959698326]}], "starter_code": "\ndef total_inc_dec(x):\n\t", "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 1634}
{"name": "1627", "description": "### Background\n\nI was reading a [book](http://www.amazon.co.uk/Things-Make-Do-Fourth-Dimension/dp/1846147646/) recently, \"Things to Make and Do in the Fourth Dimension\" by comedian and mathematician Matt Parker, and in the first chapter of the book Matt talks about problems he likes to solve in his head to take his mind off the fact that he is in his dentist's chair, we've all been there!\n\nThe problem he talks about relates to polydivisible numbers, and I thought a kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)\n\n### Polydivisib... huh what?\n\nSo what are they?\n\nA polydivisible number is divisible in an unusual way. The first digit is cleanly divisible by `1`, the first two digits are cleanly divisible by `2`, the first three by `3` and so on.\n\nThe interesting thing about polydivisiblity is that it relates to the underlying number, but not the base it is written in, so if aliens came to Earth and used base `23` (`11` fingers on one hand and `12` on the other), no matter what squiggles they use to write numbers, they would find the same numbers polydivisible!\n\n### Polydivisibilty Example:\n\nLet's do a worked example to clear up any questions ...\n\nStarting wih the number `1,232` in base `10` then:\n\n```\n 1232\n 1    /1 = 1    Yay!\n 12   /2 = 6    Yay!\n 123  /3 = 41   Yay!\n 1232 /4 = 308  Yay!\n```\n\nThus `1,232` is a polydivisible number in base `4` and above.\n\nHowever starting wih the number `123,220` and using base `10` then:\n\n```\n 123220\n 1      /1 = 1            Yay!\n 12     /2 = 6            Yay!\n 123    /3 = 41           Yay!\n 1232   /4 = 308          Yay!\n 12322  /5 = 2464.4       Oh no, that's not a round number!\n 123220 /6 = 220536.333r  Oh no, that's not a round number!\n```\n\nThus `123,220` is not a polydivisible base 10 number, but what about in another base?\n\nAgain starting wih the number `123,220` and using base `6` then:\n\n```\n base 6   base 10\n 1      = 1       -> 1     /1 = 1     Yay!\n 12     = 8       -> 8     /2 = 4     Yay!\n 123    = 51      -> 51    /3 = 17    Yay!\n 1232   = 308     -> 308   /4 = 77    Yay!\n 12322  = 1850    -> 1850  /5 = 370   Yay!\n 123220 = 11100   -> 11100 /6 = 1850  Yay!\n```\n\nThus `123,220` is a polydivisible base `6` number (and a polydivisible base `10` number when converted to `11100` in base `10`).\n\n### Kata\n\nIn this kata you must implement two methods: `is_polydivisible(n, b)` and `get_polydivisible(n, b)`.\n\nThe first `is_polydivisible(n, b)` will return `True` if `n` is polydivisible in base `b` or `False` if not.\n\nThe second `get_polydivisible(n, b)` will return the `n`th polydivisible number using base `b`, the first polydivisible number is of course always `0`.\n\nYou can assume that all inputs are valid.\n\n```if:haskell\nAll necessary arithmetic can be done in `Int` range.\n```\n\n### Kata Examples:\n\n```python\n    is_polydivisible(\"1232\", 10)   # => True\n    is_polydivisible(\"123220\", 10) # => False\n    is_polydivisible(\"123220\", 6)  # => True\n    get_polydivisible(22, 10)      # => \"32\"\n    get_polydivisible(22, 16)      # => \"1A\"\n    get_polydivisible(42, 16)      # => \"42\"\n```\n\n#### A Note on Bases\n\nThe maximum base used is base `62`, and uses characters in the following order `[0-9][A-Z][a-z]` to denote its digits, base `n` will use the first `n` characters of this sequence.\n```if-not:haskell\nA constant CHARS has been declared with this sequence for you.\n```", "difficulty": "interview", "id": 1627, "sample_io": [{"input": "1232\n10", "output": [true]}, {"input": "123220\n10", "output": [false]}, {"input": "123220\n6", "output": [true]}], "test_list": [{"input": "123\n10", "output": [true]}, {"input": "1234\n10", "output": [false]}, {"input": "12345\n10", "output": [false]}, {"input": "12365\n10", "output": [true]}, {"input": "123220\n10", "output": [false]}, {"input": "50041\n6", "output": [true]}, {"input": "140410\n6", "output": [true]}, {"input": "203230\n6", "output": [true]}, {"input": "30043052\n6", "output": [true]}], "starter_code": "\ndef is_polydivisible(s, b):\n\t", "source_codes": ["\nCHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef to_base_10(s, base):\n    \"\"\"Convert a number string from given base to base 10\"\"\"\n    result = 0\n    for char in s:\n        result = result * base + CHARS.index(char)\n    return result\n\ndef from_base_10(n, base):\n    \"\"\"Convert a base 10 number to given base as string\"\"\"\n    if n == 0:\n        return \"0\"\n    result = \"\"\n    while n > 0:\n        result = CHARS[n % base] + result\n        n //= base\n    return result\n\ndef is_polydivisible(n, b):\n    \"\"\"Check if number n in base b is polydivisible\"\"\"\n    # Convert n to base 10 for easier arithmetic\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        # Get first i digits\n        prefix = s[:i]\n        # Convert prefix to base 10\n        prefix_value = to_base_10(prefix, b)\n        # Check if divisible by i\n        if prefix_value % i != 0:\n            return False\n    return True\n\ndef get_polydivisible(n, b):\n    \"\"\"Get the nth polydivisible number in base b\"\"\"\n    if n == 1:\n        return \"0\"\n    \n    # BFS to generate polydivisible numbers\n    polydivisible_numbers = []\n    queue = [\"\"]\n    \n    # Add all single digit numbers (0 to b-1) as starting points\n    for i in range(b):\n        digit_char = CHARS[i]\n        if i == 0:\n            polydivisible_numbers.append(\"0\")\n            if len(polydivisible_numbers) == n:\n                return \"0\"\n        else:\n            queue.append(digit_char)\n    \n    # BFS to find polydivisible numbers\n    while queue and len(polydivisible_numbers) < n:\n        current = queue.pop(0)\n        polydivisible_numbers.append(current)\n        \n        if len(polydivisible_numbers) == n:\n            return current\n            \n        # Try appending each digit\n        for i in range(b):\n            digit_char = CHARS[i]\n            new_number = current + digit_char\n            # Check if this new number is polydivisible\n            if is_polydivisible(new_number, b):\n                queue.append(new_number)\n    \n    return polydivisible_numbers[n-1] if n <= len(polydivisible_numbers) else \"\"\n\n# Read input\nline1 = input().strip()\nline2 = input().strip()\n\n# Check if it's a number (for is_polydivisible) or an index (for get_polydivisible)\nif line1.isnumeric() and all(c in CHARS for c in line1):\n    # This is for is_polydivisible\n    result = is_polydivisible(line1, int(line2))\n    print(result)\nelse:\n    # This is for get_polydivisible\n    result = get_polydivisible(int(line1), int(line2))\n    print(result)\n\n\n"], "responses": ["```python\nCHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef to_base_10(s, base):\n    \"\"\"Convert a number string from given base to base 10\"\"\"\n    result = 0\n    for char in s:\n        result = result * base + CHARS.index(char)\n    return result\n\ndef from_base_10(n, base):\n    \"\"\"Convert a base 10 number to given base as string\"\"\"\n    if n == 0:\n        return \"0\"\n    result = \"\"\n    while n > 0:\n        result = CHARS[n % base] + result\n        n //= base\n    return result\n\ndef is_polydivisible(n, b):\n    \"\"\"Check if number n in base b is polydivisible\"\"\"\n    # Convert n to base 10 for easier arithmetic\n    s = str(n)\n    for i in range(1, len(s) + 1):\n        # Get first i digits\n        prefix = s[:i]\n        # Convert prefix to base 10\n        prefix_value = to_base_10(prefix, b)\n        # Check if divisible by i\n        if prefix_value % i != 0:\n            return False\n    return True\n\ndef get_polydivisible(n, b):\n    \"\"\"Get the nth polydivisible number in base b\"\"\"\n    if n == 1:\n        return \"0\"\n    \n    # BFS to generate polydivisible numbers\n    polydivisible_numbers = []\n    queue = [\"\"]\n    \n    # Add all single digit numbers (0 to b-1) as starting points\n    for i in range(b):\n        digit_char = CHARS[i]\n        if i == 0:\n            polydivisible_numbers.append(\"0\")\n            if len(polydivisible_numbers) == n:\n                return \"0\"\n        else:\n            queue.append(digit_char)\n    \n    # BFS to find polydivisible numbers\n    while queue and len(polydivisible_numbers) < n:\n        current = queue.pop(0)\n        polydivisible_numbers.append(current)\n        \n        if len(polydivisible_numbers) == n:\n            return current\n            \n        # Try appending each digit\n        for i in range(b):\n            digit_char = CHARS[i]\n            new_number = current + digit_char\n            # Check if this new number is polydivisible\n            if is_polydivisible(new_number, b):\n                queue.append(new_number)\n    \n    return polydivisible_numbers[n-1] if n <= len(polydivisible_numbers) else \"\"\n\n# Read input\nline1 = input().strip()\nline2 = input().strip()\n\n# Check if it's a number (for is_polydivisible) or an index (for get_polydivisible)\nif line1.isnumeric() and all(c in CHARS for c in line1):\n    # This is for is_polydivisible\n    result = is_polydivisible(line1, int(line2))\n    print(result)\nelse:\n    # This is for get_polydivisible\n    result = get_polydivisible(int(line1), int(line2))\n    print(result)\n```"], "prompt_tokens": [1270], "completion_tokens": [655], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 1627}
