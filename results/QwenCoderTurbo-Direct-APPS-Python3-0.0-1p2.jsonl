{"name": "3613", "description": "# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 \u2264 string1.length \u2264 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value", "difficulty": "introductory", "id": 3613, "sample_io": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}], "test_list": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}, {"input": "aaxxaaz\naazzaay", "output": [true]}, {"input": "aaxyaa\naazzaa", "output": [false]}, {"input": "aazzaa\naaxyaa", "output": [false]}, {"input": "jpeuizmi\nmxxcwriq", "output": [false]}], "starter_code": "\ndef is_substitution_cipher(s1, s2):\n\t", "source_codes": ["\ndef are_substitution_cipher_strings(string1, string2):\n    # Check if lengths are equal (given constraint)\n    if len(string1) != len(string2):\n        return False\n    \n    # Create mapping dictionaries\n    forward_map = {}  # string1 char -> string2 char\n    reverse_map = {}  # string2 char -> string1 char\n    \n    # Check each position\n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check forward mapping\n        if char1 in forward_map:\n            if forward_map[char1] != char2:\n                return False\n        else:\n            forward_map[char1] = char2\n        \n        # Check reverse mapping\n        if char2 in reverse_map:\n            if reverse_map[char2] != char1:\n                return False\n        else:\n            reverse_map[char2] = char1\n    \n    return True\n\n# Read input\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Solve and output\nresult = are_substitution_cipher_strings(string1, string2)\nprint(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We have two strings of equal length\n2. We need to check if they can be converted to each other using substitution ciphers\n3. A substitution cipher means each character maps to exactly one other character\n4. The mapping must be consistent - if 'a' maps to 'b', then every 'a' must map to 'b'\n\n## Key Insights\n\nFor two strings to be convertible to each other using substitution ciphers:\n1. They must have the same length (given)\n2. The pattern of character occurrences must be identical\n3. Each unique character in string1 must map to exactly one unique character in string2\n4. This mapping must be bijective (one-to-one and onto)\n\n## Approach\n\n1. Create a mapping from characters in string1 to string2\n2. Create a reverse mapping from characters in string2 to string1\n3. Check if both mappings are consistent throughout the strings\n\n## Step-by-step Solution\n\nLet me trace through the examples:\n\nExample 1: string1 = \"aacb\", string2 = \"aabc\"\n- Position 0: 'a' \u2192 'a'\n- Position 1: 'a' \u2192 'a' (consistent)\n- Position 2: 'c' \u2192 'b'\n- Position 3: 'b' \u2192 'c'\nThis works! 'a'\u2194'a', 'c'\u2194'b'\n\nExample 2: string1 = \"aa\", string2 = \"bc\"\n- Position 0: 'a' \u2192 'b'\n- Position 1: 'a' \u2192 'c'\nThis fails because 'a' cannot map to both 'b' and 'c'\n\n## Implementation Strategy\n\n1. Iterate through both strings simultaneously\n2. Maintain two dictionaries:\n   - forward_map: maps chars from string1 to string2\n   - reverse_map: maps chars from string2 to string1\n3. For each position, check if the mapping is consistent\n4. If any inconsistency is found, return False\n5. If we complete the iteration, return True\n\n```python\ndef are_substitution_cipher_strings(string1, string2):\n    # Check if lengths are equal (given constraint)\n    if len(string1) != len(string2):\n        return False\n    \n    # Create mapping dictionaries\n    forward_map = {}  # string1 char -> string2 char\n    reverse_map = {}  # string2 char -> string1 char\n    \n    # Check each position\n    for i in range(len(string1)):\n        char1 = string1[i]\n        char2 = string2[i]\n        \n        # Check forward mapping\n        if char1 in forward_map:\n            if forward_map[char1] != char2:\n                return False\n        else:\n            forward_map[char1] = char2\n        \n        # Check reverse mapping\n        if char2 in reverse_map:\n            if reverse_map[char2] != char1:\n                return False\n        else:\n            reverse_map[char2] = char1\n    \n    return True\n\n# Read input\nstring1 = input().strip()\nstring2 = input().strip()\n\n# Solve and output\nresult = are_substitution_cipher_strings(string1, string2)\nprint(result)\n```"], "prompt_tokens": [354], "completion_tokens": [677], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 3613}
{"name": "4465", "description": "Write a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.", "difficulty": "introductory", "id": 4465, "sample_io": [{"input": "123456", "output": [654321]}, {"input": "105", "output": [510]}, {"input": "12", "output": [21]}], "test_list": [{"input": "69", "output": [96]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [7210]}, {"input": "414", "output": [441]}, {"input": "608719", "output": [987610]}, {"input": "123456789", "output": [987654321]}, {"input": "700000000001", "output": [710000000000]}, {"input": "666666", "output": [666666]}, {"input": "2", "output": [2]}, {"input": "0", "output": [0]}], "starter_code": "\ndef super_size(n):\n\t", "source_codes": ["\ndef super_size(n):\n    # Convert the number to a string to work with individual digits\n    digits = str(n)\n    \n    # Sort the digits in descending order to get the largest possible arrangement\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Join the sorted digits and convert back to integer\n    result = int(''.join(sorted_digits))\n    \n    return result\n\n# Take input from standard input\nn = int(input())\n\n# Call the function and print the result\nprint(super_size(n))\n\n\n"], "responses": ["```python\ndef super_size(n):\n    # Convert the number to a string to work with individual digits\n    digits = str(n)\n    \n    # Sort the digits in descending order to get the largest possible arrangement\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Join the sorted digits and convert back to integer\n    result = int(''.join(sorted_digits))\n    \n    return result\n\n# Take input from standard input\nn = int(input())\n\n# Call the function and print the result\nprint(super_size(n))\n```"], "prompt_tokens": [251], "completion_tokens": [110], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 4465}
{"name": "3045", "description": "Given 2 elevators (named \"left\" and \"right\") in a building with 3 floors (numbered `0` to `2`), write a function `elevator` accepting 3 arguments (in order):\n\n- `left` - The current floor of the left elevator\n- `right` - The current floor of the right elevator\n- `call` -  The floor that called an elevator\n\nIt should return the name of the elevator closest to the called floor (`\"left\"`/`\"right\"`).\n\nIn the case where both elevators are equally distant from the called floor, choose the elevator to the right.\n\nYou can assume that the inputs will always be valid integers between 0-2.\n\nExamples:\n\n```python\nelevator(0, 1, 0) # => \"left\"\nelevator(0, 1, 1) # => \"right\"\nelevator(0, 1, 2) # => \"right\"\nelevator(0, 0, 0) # => \"right\"\nelevator(0, 2, 1) # => \"right\"\n```", "difficulty": "introductory", "id": 3045, "sample_io": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}], "test_list": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}, {"input": "0\n0\n1", "output": ["right"]}, {"input": "0\n0\n2", "output": ["right"]}, {"input": "0\n2\n0", "output": ["left"]}, {"input": "0\n2\n2", "output": ["right"]}, {"input": "1\n0\n0", "output": ["right"]}, {"input": "1\n0\n1", "output": ["left"]}, {"input": "1\n0\n2", "output": ["left"]}, {"input": "1\n1\n0", "output": ["right"]}, {"input": "1\n1\n1", "output": ["right"]}, {"input": "1\n1\n2", "output": ["right"]}, {"input": "1\n2\n0", "output": ["left"]}, {"input": "1\n2\n1", "output": ["left"]}, {"input": "1\n2\n2", "output": ["right"]}, {"input": "2\n0\n0", "output": ["right"]}, {"input": "2\n0\n1", "output": ["right"]}, {"input": "2\n0\n2", "output": ["left"]}, {"input": "2\n1\n0", "output": ["right"]}, {"input": "2\n1\n1", "output": ["right"]}, {"input": "2\n1\n2", "output": ["left"]}, {"input": "2\n2\n0", "output": ["right"]}, {"input": "2\n2\n1", "output": ["right"]}, {"input": "2\n2\n2", "output": ["right"]}], "starter_code": "\ndef elevator(left, right, call):\n\t", "source_codes": ["\ndef elevator(left, right, call):\n    # Calculate distances from each elevator to the called floor\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    # If right elevator is closer or equally close, return \"right\"\n    if right_distance <= left_distance:\n        return \"right\"\n    else:\n        return \"left\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call the function and print the result\nprint(elevator(left, right, call))\n\n\n"], "responses": ["```python\ndef elevator(left, right, call):\n    # Calculate distances from each elevator to the called floor\n    left_distance = abs(left - call)\n    right_distance = abs(right - call)\n    \n    # If right elevator is closer or equally close, return \"right\"\n    if right_distance <= left_distance:\n        return \"right\"\n    else:\n        return \"left\"\n\n# Read inputs\nleft = int(input())\nright = int(input())\ncall = int(input())\n\n# Call the function and print the result\nprint(elevator(left, right, call))\n```"], "prompt_tokens": [335], "completion_tokens": [117], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 3045}
{"name": "4276", "description": "Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```", "difficulty": "introductory", "id": 4276, "sample_io": [{"input": "4.2", "output": [4]}, {"input": "4.3", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.8", "output": [5]}, {"input": "4.75", "output": [5]}], "test_list": [{"input": "4.2", "output": [4]}, {"input": "4.25", "output": [4.5]}, {"input": "4.4", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.75", "output": [5]}, {"input": "4.8", "output": [5]}, {"input": "4.5", "output": [4.5]}, {"input": "4.55", "output": [4.5]}, {"input": "4.74", "output": [4.5]}, {"input": "4.74999999999", "output": [4.5]}, {"input": "4.74999999991", "output": [4.5]}], "starter_code": "\ndef solution(n):\n\t", "source_codes": ["\ndef solution(number):\n    # Multiply by 2 to convert 0.5 steps to integers\n    multiplied = number * 2\n    \n    # Round to nearest integer\n    rounded = round(multiplied)\n    \n    # Divide by 2 to get back to 0.5 steps\n    result = rounded / 2\n    \n    return result\n\n# Read input\nnumber = float(input())\n\n# Call function and print result\nprint(solution(number))\n\n\n"], "responses": ["```python\ndef solution(number):\n    # Multiply by 2 to convert 0.5 steps to integers\n    multiplied = number * 2\n    \n    # Round to nearest integer\n    rounded = round(multiplied)\n    \n    # Divide by 2 to get back to 0.5 steps\n    result = rounded / 2\n    \n    return result\n\n# Read input\nnumber = float(input())\n\n# Call function and print result\nprint(solution(number))\n```"], "prompt_tokens": [196], "completion_tokens": [96], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 4276}
