{"name": "2215", "description": "Jzzhu is the president of country A. There are n cities numbered from 1 to n in his country. City 1 is the capital of A. Also there are m roads connecting the cities. One can go from city u_{i} to v_{i} (and vise versa) using the i-th road, the length of this road is x_{i}. Finally, there are k train routes in the country. One can use the i-th train route to go from capital of the country to city s_{i} (and vise versa), the length of this route is y_{i}.\n\nJzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (2 \u2264 n \u2264 10^5;\u00a01 \u2264 m \u2264 3\u00b710^5;\u00a01 \u2264 k \u2264 10^5).\n\nEach of the next m lines contains three integers u_{i}, v_{i}, x_{i} (1 \u2264 u_{i}, v_{i} \u2264 n;\u00a0u_{i} \u2260 v_{i};\u00a01 \u2264 x_{i} \u2264 10^9).\n\nEach of the next k lines contains two integers s_{i} and y_{i} (2 \u2264 s_{i} \u2264 n;\u00a01 \u2264 y_{i} \u2264 10^9).\n\nIt is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.\n\n\n-----Output-----\n\nOutput a single integer representing the maximum number of the train routes which can be closed.\n\n\n-----Examples-----\nInput\n5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n\nOutput\n2\n\nInput\n2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n\nOutput\n2", "difficulty": "competition", "id": 2215, "sample_io": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}], "test_list": [{"input": "5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n", "output": ["2\n"]}, {"input": "2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n", "output": ["2\n"]}, {"input": "5 4 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "3 2 5\n1 2 2\n2 3 4\n3 5\n3 5\n3 5\n3 6\n3 7\n", "output": ["4\n"]}, {"input": "5 5 3\n1 2 999999999\n2 3 1000000000\n3 4 529529529\n5 1 524524524\n5 3 1000000000\n5 524444444\n5 529999999\n2 1000000000\n", "output": ["2\n"]}, {"input": "2 1 5\n1 2 4\n2 3\n2 5\n2 4\n2 4\n2 5\n", "output": ["4\n"]}, {"input": "3 3 6\n1 2 499999999\n2 3 500000000\n1 3 999999999\n2 499999999\n2 500000000\n2 499999999\n3 999999999\n3 1000000000\n3 1000000000\n", "output": ["6\n"]}, {"input": "2 1 1\n1 2 1\n2 1000000000\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 4\n2 3 4\n2 2\n3 6\n", "output": ["1\n"]}, {"input": "5 5 2\n1 2 100\n2 3 100\n3 4 100\n4 5 20\n2 5 5\n5 50\n4 1\n", "output": ["1\n"]}, {"input": "3 2 2\n1 2 100\n2 3 1\n2 1\n3 3\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["\nimport heapq\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    k = int(data[idx])\n    idx += 1\n\n    # Build adjacency list for roads\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        w = int(data[idx])\n        idx += 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n\n    # Read train routes\n    trains = []\n    train_map = defaultdict(list)\n    for _ in range(k):\n        s = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        trains.append((s, y))\n        train_map[s].append(y)\n\n    # Run Dijkstra from city 1 using only roads\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n\n    # Count useful trains\n    useful_trains = 0\n    used = [False] * (n + 1)  # Track whether a node uses a train to achieve its shortest distance\n\n    # Check which train routes provide strictly better access to nodes\n    for s, y in trains:\n        if y < dist[s]:  # This train offers a faster way to reach 's'\n            if not used[s]:\n                useful_trains += 1\n                used[s] = True\n                # Update distances for neighbors via this new shorter path\n                dist[s] = y\n                heapq.heappush(pq, (y, s))\n\n    # Re-run Dijkstra now including useful trains\n    dist_final = [float('inf')] * (n + 1)\n    dist_final[1] = 0\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist_final[u]:\n            continue\n        for v, w in adj[u]:\n            if dist_final[u] + w < dist_final[v]:\n                dist_final[v] = dist_final[u] + w\n                heapq.heappush(pq, (dist_final[v], v))\n        # Apply useful train routes\n        for y in train_map[u]:\n            if used[u] and dist_final[u] + y < dist_final[u]:\n                pass  # Not relevant since we apply them from capital\n        # But actually all useful trains start from node 1\n        # So let's correct our approach here\n    \n    # Let's simplify:\n    # We have initial distances from roads-only Dijkstra: dist[]\n    # Now for every train route (1 -> s, y), check if y < dist[s]\n    # If yes, then this train improves shortest path to s.\n    # Among such improving trains, only keep one per destination with best (minimum) value.\n    # Others are redundant.\n\n    min_train_cost = {}\n    for s, y in trains:\n        if y < dist[s]:\n            if s not in min_train_cost:\n                min_train_cost[s] = y\n            else:\n                min_train_cost[s] = min(min_train_cost[s], y)\n\n    # Total useful trains is len(min_train_cost)\n    # Hence, max closable = total trains - useful trains\n    print(k - len(min_train_cost))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve this problem, we need to determine the maximum number of train routes that can be closed without increasing the shortest distance from any city to the capital (city 1). Here's how we approach it:\n\n### Approach:\n1. **Graph Representation**:\n   - The cities and roads form an undirected graph with weighted edges.\n   - Train routes connect the capital (city 1) directly to certain cities with specific weights.\n\n2. **Shortest Distance Calculation**:\n   - First, compute the shortest distances from the capital to all other cities considering only the road network using Dijkstra\u2019s algorithm.\n   - Then, for each city, compare these shortest distances with those achievable via train routes.\n\n3. **Redundant Trains**:\n   - A train route to city `s_i` with cost `y_i` is redundant if there already exists a shorter or equal path from city 1 to `s_i` through the roads.\n   - Additionally, even if the direct train is better than current known paths, we might not need it if another train or combination gives the same minimum distance.\n\n4. **Optimization Strategy**:\n   - After computing the true shortest distances (`dist[]`) using Dijkstra on the road graph, we process all train routes.\n   - For each city, keep track of the minimum train distance available to it.\n   - Only count a train as necessary if it contributes to achieving the actual shortest distance for at least one node \u2014 and no road-based path achieves that distance.\n\nLet's implement this logic step-by-step in Python:\n\n```python\nimport heapq\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    k = int(data[idx])\n    idx += 1\n\n    # Build adjacency list for roads\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        w = int(data[idx])\n        idx += 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n\n    # Read train routes\n    trains = []\n    train_map = defaultdict(list)\n    for _ in range(k):\n        s = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        trains.append((s, y))\n        train_map[s].append(y)\n\n    # Run Dijkstra from city 1 using only roads\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n\n    # Count useful trains\n    useful_trains = 0\n    used = [False] * (n + 1)  # Track whether a node uses a train to achieve its shortest distance\n\n    # Check which train routes provide strictly better access to nodes\n    for s, y in trains:\n        if y < dist[s]:  # This train offers a faster way to reach 's'\n            if not used[s]:\n                useful_trains += 1\n                used[s] = True\n                # Update distances for neighbors via this new shorter path\n                dist[s] = y\n                heapq.heappush(pq, (y, s))\n\n    # Re-run Dijkstra now including useful trains\n    dist_final = [float('inf')] * (n + 1)\n    dist_final[1] = 0\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist_final[u]:\n            continue\n        for v, w in adj[u]:\n            if dist_final[u] + w < dist_final[v]:\n                dist_final[v] = dist_final[u] + w\n                heapq.heappush(pq, (dist_final[v], v))\n        # Apply useful train routes\n        for y in train_map[u]:\n            if used[u] and dist_final[u] + y < dist_final[u]:\n                pass  # Not relevant since we apply them from capital\n        # But actually all useful trains start from node 1\n        # So let's correct our approach here\n    \n    # Let's simplify:\n    # We have initial distances from roads-only Dijkstra: dist[]\n    # Now for every train route (1 -> s, y), check if y < dist[s]\n    # If yes, then this train improves shortest path to s.\n    # Among such improving trains, only keep one per destination with best (minimum) value.\n    # Others are redundant.\n\n    min_train_cost = {}\n    for s, y in trains:\n        if y < dist[s]:\n            if s not in min_train_cost:\n                min_train_cost[s] = y\n            else:\n                min_train_cost[s] = min(min_train_cost[s], y)\n\n    # Total useful trains is len(min_train_cost)\n    # Hence, max closable = total trains - useful trains\n    print(k - len(min_train_cost))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution does the following:\n- Runs Dijkstra once to find shortest paths using roads only.\n- Identifies which train routes improve upon those distances.\n- Keeps only the best (cheapest) train per city among beneficial ones.\n- Outputs the difference between total trains and the number of uniquely beneficial trains.\n\nTime complexity: O((V + E) log V) due to Dijkstra. Space complexity: O(V + E)."], "prompt_tokens": [641], "completion_tokens": [1267], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2215}
{"name": "2187", "description": "Jzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. \n\nJzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.\n\nJzzhu wonders how to get the maximum possible number of groups. Can you help him?\n\n\n-----Input-----\n\nA single integer n (1 \u2264 n \u2264 10^5), the number of the apples.\n\n\n-----Output-----\n\nThe first line must contain a single integer m, representing the maximum number of groups he can get. Each of the next m lines must contain two integers \u2014 the numbers of apples in the current group.\n\nIf there are several optimal answers you can print any of them.\n\n\n-----Examples-----\nInput\n6\n\nOutput\n2\n6 3\n2 4\n\nInput\n9\n\nOutput\n3\n9 3\n2 4\n6 8\n\nInput\n2\n\nOutput\n0", "difficulty": "competition", "id": 2187, "sample_io": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}], "test_list": [{"input": "6\n", "output": ["2\n6 3\n2 4\n"]}, {"input": "9\n", "output": ["3\n9 3\n2 4\n6 8\n"]}, {"input": "2\n", "output": ["0\n"]}, {"input": "10\n", "output": ["4\n2 4\n6 8\n10 5\n9 3\n"]}, {"input": "100\n", "output": ["44\n33 27\n22 11\n25 5\n64 66\n42 44\n31 62\n58 29\n43 86\n15 21\n6 99\n8 12\n85 65\n7 49\n23 46\n16 14\n20 18\n90 92\n48 50\n40 36\n74 37\n35 55\n10 95\n56 60\n47 94\n45 39\n93 87\n88 84\n72 76\n28 24\n75 81\n78 80\n54 52\n38 19\n3 9\n32 30\n91 77\n70 68\n63 69\n2 4\n57 51\n82 41\n17 34\n13 26\n96 98\n"]}, {"input": "1\n", "output": ["0\n"]}, {"input": "3\n", "output": ["0\n"]}, {"input": "5\n", "output": ["1\n2 4\n"]}], "starter_code": "", "source_codes": ["\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nn = int(input())\n\nif n < 2:\n    print(0)\nelse:\n    # Available numbers\n    available = [False] + [True] * n  # index 0 unused, 1 to n are available\n    pairs = []\n    \n    # Try to pair numbers greedily\n    for i in range(1, n + 1):\n        if not available[i]:\n            continue\n        for j in range(i + 1, n + 1):\n            if not available[j]:\n                continue\n            if gcd(i, j) > 1:\n                pairs.append((i, j))\n                available[i] = False\n                available[j] = False\n                break\n    \n    # Output\n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We have n apples numbered from 1 to n\n2. We need to group them into pairs where GCD of the two numbers > 1\n3. Each apple can be used at most once\n4. We want to maximize the number of such groups\n\n## Key Insights\n\n1. Two numbers have GCD > 1 if they share a common factor > 1\n2. Even numbers (except 1) can always pair with other even numbers (GCD \u2265 2)\n3. Odd numbers need to share common factors with other numbers\n4. Prime numbers can only pair with their multiples\n5. The number 1 cannot pair with anyone (GCD(1,x) = 1 for all x)\n\n## Strategy\n\n1. **Greedy approach**: Pair numbers that can be paired, prioritizing easy cases\n2. **Even numbers**: Pair consecutive even numbers (2,4), (6,8), etc.\n3. **Multiples**: For remaining numbers, try to pair them with their multiples or numbers sharing common factors\n\n## Detailed Approach\n\nLet me think of a better strategy:\n\n1. **Special case**: Number 1 cannot pair with anyone, so ignore it\n2. **Even numbers**: All even numbers can pair with each other (GCD \u2265 2)\n3. **Odd numbers**: Need to find pairs among themselves\n4. **Optimal pairing**: \n   - Pair consecutive even numbers first: (2,4), (6,8), (10,12), ...\n   - For odd numbers, pair multiples of 3: (3,9), (15,21), ...\n   - Continue with other patterns\n\nWait, let me reconsider. A better approach:\n\n1. Create a graph where nodes are numbers 1 to n\n2. Connect two nodes if their GCD > 1\n3. Find maximum matching in this graph\n\nBut that's complex. Let me think of a simpler greedy approach:\n\n## Simpler Approach\n\n1. Skip number 1 (can't pair with anyone)\n2. Pair consecutive even numbers: (2,4), (6,8), (10,12), ...\n3. For remaining numbers, try to pair them greedily\n\nActually, let me think even more systematically:\n\n## Better Greedy Strategy\n\n1. **Key insight**: Most numbers can be paired except 1 and possibly some primes\n2. **Even numbers**: Easy to pair (all have factor 2)\n3. **Strategy**: Go through numbers and try to pair each unpaired number with another unpaired number\n\n## Simple Greedy Implementation\n\n1. Keep track of available numbers\n2. For each number, try to find a partner with GCD > 1\n3. Use a greedy approach\n\nLet me implement a clean solution:\n\n```python\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n):\n    if n < 2:\n        return 0, []\n    \n    # Available numbers\n    available = [True] * (n + 1)  # index 0 to n, we'll use 1 to n\n    pairs = []\n    \n    # First, pair consecutive even numbers\n    for i in range(2, n, 2):\n        if available[i] and available[i + 1] and i + 1 <= n:\n            if gcd(i, i + 1) > 1:\n                pairs.append((i, i + 1))\n                available[i] = False\n                available[i + 1] = False\n    \n    # Try to pair remaining numbers\n    for i in range(1, n + 1):\n        if not available[i]:\n            continue\n        for j in range(i + 1, n + 1):\n            if not available[j]:\n                continue\n            if gcd(i, j) > 1:\n                pairs.append((i, j))\n                available[i] = False\n                available[j] = False\n                break\n    \n    return len(pairs), pairs\n\n# Read input\nn = int(input())\n\n# Solve\ncount, pairs = solve(n)\n\n# Output\nprint(count)\nfor pair in pairs:\n    print(pair[0], pair[1])\n```\n\nWait, let me check this logic again. Consecutive numbers have GCD = 1, so (2,3), (4,5), etc. won't work.\n\nLet me revise:\n\n```python\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nn = int(input())\n\nif n < 2:\n    print(0)\nelse:\n    # Available numbers\n    available = [False] + [True] * n  # index 0 unused, 1 to n are available\n    pairs = []\n    \n    # Try to pair numbers greedily\n    for i in range(1, n + 1):\n        if not available[i]:\n            continue\n        for j in range(i + 1, n + 1):\n            if not available[j]:\n                continue\n            if gcd(i, j) > 1:\n                pairs.append((i, j))\n                available[i] = False\n                available[j] = False\n                break\n    \n    # Output\n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])\n```"], "prompt_tokens": [341], "completion_tokens": [1153], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2187}
{"name": "2047", "description": "Allen dreams of one day owning a enormous fleet of electric cars, the car of the future! He knows that this will give him a big status boost. As Allen is planning out all of the different types of cars he will own and how he will arrange them, he realizes that he has a problem. \n\nAllen's future parking lot can be represented as a rectangle with $4$ rows and $n$ ($n \\le 50$) columns of rectangular spaces, each of which can contain at most one car at any time. He imagines having $k$ ($k \\le 2n$) cars in the grid, and all the cars are initially in the second and third rows. Each of the cars also has a different designated parking space in the first or fourth row. Allen has to put the cars into corresponding parking places.\n\n [Image] Illustration to the first example. \n\nHowever, since Allen would never entrust his cars to anyone else, only one car can be moved at a time. He can drive a car from a space in any of the four cardinal directions to a neighboring empty space. Furthermore, Allen can only move one of his cars into a space on the first or fourth rows if it is the car's designated parking space. \n\nAllen knows he will be a very busy man, and will only have time to move cars at most $20000$ times before he realizes that moving cars is not worth his time. Help Allen determine if he should bother parking his cars or leave it to someone less important.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 2n$), representing the number of columns and the number of cars, respectively.\n\nThe next four lines will contain $n$ integers each between $0$ and $k$ inclusive, representing the initial state of the parking lot. The rows are numbered $1$ to $4$ from top to bottom and the columns are numbered $1$ to $n$ from left to right.\n\nIn the first and last line, an integer $1 \\le x \\le k$ represents a parking spot assigned to car $x$ (you can only move this car to this place), while the integer $0$ represents a empty space (you can't move any car to this place).\n\nIn the second and third line, an integer $1 \\le x \\le k$ represents initial position of car $x$, while the integer $0$ represents an empty space (you can move any car to this place).\n\nEach $x$ between $1$ and $k$ appears exactly once in the second and third line, and exactly once in the first and fourth line.\n\n\n-----Output-----\n\nIf there is a sequence of moves that brings all of the cars to their parking spaces, with at most $20000$ car moves, then print $m$, the number of moves, on the first line. On the following $m$ lines, print the moves (one move per line) in the format $i$ $r$ $c$, which corresponds to Allen moving car $i$ to the neighboring space at row $r$ and column $c$.\n\nIf it is not possible for Allen to move all the cars to the correct spaces with at most $20000$ car moves, print a single line with the integer $-1$.\n\n\n-----Examples-----\nInput\n4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n\nOutput\n6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n\nInput\n1 2\n1\n2\n1\n2\n\nOutput\n-1\n\nInput\n1 2\n1\n1\n2\n2\n\nOutput\n2\n1 1 1\n2 4 1\n\n\n\n-----Note-----\n\nIn the first sample test case, all cars are in front of their spots except car $5$, which is in front of the parking spot adjacent. The example shows the shortest possible sequence of moves, but any sequence of length at most $20000$ will be accepted.\n\nIn the second sample test case, there is only one column, and the cars are in the wrong order, so no cars can move and the task is impossible.", "difficulty": "competition", "id": 2047, "sample_io": [{"input": "4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n", "output": ["6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n"]}, {"input": "1 2\n1\n2\n1\n2\n", "output": ["-1\n"]}, {"input": "1 2\n1\n1\n2\n2\n", "output": ["2\n1 1 1\n2 4 1\n"]}], "test_list": [{"input": "4 5\n1 2 0 4\n1 2 0 4\n5 0 0 3\n0 5 0 3\n", "output": ["6\n1 1 1\n2 1 2\n4 1 4\n3 4 4\n5 3 2\n5 4 2\n"]}, {"input": "1 2\n1\n2\n1\n2\n", "output": ["-1\n"]}, {"input": "1 2\n1\n1\n2\n2\n", "output": ["2\n1 1 1\n2 4 1\n"]}, {"input": "2 2\n1 0\n0 2\n0 1\n0 2\n", "output": ["7\n2 2 1\n1 2 2\n2 3 1\n1 2 1\n2 3 2\n1 1 1\n2 4 2\n"]}, {"input": "7 14\n2 11 1 14 9 8 5\n12 6 7 1 10 2 3\n14 13 9 8 5 4 11\n13 6 4 3 12 7 10\n", "output": ["-1\n"]}, {"input": "2 1\n0 0\n0 0\n0 1\n0 1\n", "output": ["1\n1 4 2\n"]}, {"input": "2 3\n0 2\n0 1\n3 2\n3 1\n", "output": ["7\n1 2 1\n2 2 2\n3 4 1\n1 3 1\n2 1 2\n1 3 2\n1 4 2\n"]}, {"input": "1 1\n0\n1\n0\n1\n", "output": ["2\n1 3 1\n1 4 1\n"]}, {"input": "2 4\n3 4\n2 1\n3 4\n2 1\n", "output": ["-1\n"]}, {"input": "3 5\n2 1 5\n5 3 2\n4 0 1\n0 4 3\n", "output": ["18\n4 3 2\n5 3 1\n3 2 1\n2 2 2\n1 2 3\n4 4 2\n5 3 2\n3 3 1\n2 2 1\n1 2 2\n5 3 3\n3 3 2\n2 1 1\n1 1 2\n5 2 3\n3 3 3\n5 1 3\n3 4 3\n"]}, {"input": "10 1\n0 0 1 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n", "output": ["1\n1 1 3\n"]}, {"input": "50 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": ["34\n1 3 27\n1 3 28\n1 3 29\n1 3 30\n1 3 31\n1 3 32\n1 3 33\n1 3 34\n1 3 35\n1 3 36\n1 3 37\n1 3 38\n1 3 39\n1 3 40\n1 3 41\n1 3 42\n1 3 43\n1 3 44\n1 3 45\n1 3 46\n1 3 47\n1 3 48\n1 3 49\n1 3 50\n1 2 50\n1 2 49\n1 2 48\n1 2 47\n1 2 46\n1 2 45\n1 2 44\n1 2 43\n1 2 42\n1 1 42\n"]}, {"input": "22 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0\n", "output": ["65\n2 2 13\n1 3 21\n2 2 12\n1 3 22\n2 2 11\n1 2 22\n2 2 10\n1 2 21\n2 2 9\n1 2 20\n2 2 8\n1 2 19\n2 2 7\n1 2 18\n2 2 6\n1 2 17\n2 2 5\n1 2 16\n2 2 4\n1 2 15\n2 2 3\n1 2 14\n2 2 2\n1 2 13\n2 2 1\n1 2 12\n2 3 1\n1 2 11\n2 3 2\n1 2 10\n2 3 3\n1 2 9\n2 3 4\n1 2 8\n2 3 5\n1 2 7\n2 3 6\n1 2 6\n2 3 7\n1 2 5\n2 3 8\n1 2 4\n2 3 9\n1 2 3\n2 3 10\n1 2 2\n2 3 11\n1 2 1\n2 3 12\n1 3 1\n2 3 13\n1 3 2\n2 3 14\n1 3 3\n2 3 15\n1 3 4\n2 3 16\n1 3 5\n2 3 17\n1 3 6\n2 3 18\n1 3 7\n2 4 18\n1 3 8\n1 4 8\n"]}, {"input": "12 3\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n2 0 0 0 0 3 0 0 0 1 0 0\n0 0 0 0 0 0 0 1 3 0 2 0\n", "output": ["38\n1 3 11\n3 3 7\n2 3 2\n1 3 12\n3 3 8\n2 3 3\n1 2 12\n3 3 9\n2 3 4\n1 2 11\n3 4 9\n2 3 5\n1 2 10\n2 3 6\n1 2 9\n2 3 7\n1 2 8\n2 3 8\n1 2 7\n2 3 9\n1 2 6\n2 3 10\n1 2 5\n2 3 11\n1 2 4\n2 4 11\n1 2 3\n1 2 2\n1 2 1\n1 3 1\n1 3 2\n1 3 3\n1 3 4\n1 3 5\n1 3 6\n1 3 7\n1 3 8\n1 4 8\n"]}, {"input": "10 20\n18 9 4 5 12 14 16 1 15 20\n11 13 16 6 18 5 20 17 4 3\n12 9 15 14 8 10 2 19 1 7\n6 11 13 2 7 19 10 3 8 17\n", "output": ["-1\n"]}, {"input": "15 30\n20 24 17 13 26 8 5 6 27 14 18 22 25 2 15\n4 12 6 25 3 5 28 11 15 21 9 26 7 17 13\n19 20 24 16 2 23 8 29 22 30 1 27 10 14 18\n9 29 3 7 12 28 10 16 23 19 21 1 30 11 4\n", "output": ["-1\n"]}], "starter_code": "", "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2047}
{"name": "2026", "description": "Yaroslav is playing a game called \"Time\". The game has a timer showing the lifespan he's got left. As soon as the timer shows 0, Yaroslav's character dies and the game ends. Also, the game has n clock stations, station number i is at point (x_{i}, y_{i}) of the plane. As the player visits station number i, he increases the current time on his timer by a_{i}. The stations are for one-time use only, so if the player visits some station another time, the time on his timer won't grow.\n\nA player spends d\u00b7dist time units to move between stations, where dist is the distance the player has covered and d is some constant. The distance between stations i and j is determined as |x_{i} - x_{j}| + |y_{i} - y_{j}|.\n\nInitially, the player is at station number 1, and the player has strictly more than zero and strictly less than one units of time. At station number 1 one unit of money can increase the time on the timer by one time unit (you can buy only integer number of time units).\n\nNow Yaroslav is wondering, how much money he needs to get to station n. Help Yaroslav. Consider the time to buy and to increase the timer value negligibly small.\n\n\n-----Input-----\n\nThe first line contains integers n and d (3 \u2264 n \u2264 100, 10^3 \u2264 d \u2264 10^5) \u2014 the number of stations and the constant from the statement.\n\nThe second line contains n - 2 integers: a_2, a_3, ..., a_{n} - 1 (1 \u2264 a_{i} \u2264 10^3). The next n lines contain the coordinates of the stations. The i-th of them contains two integers x_{i}, y_{i} (-100 \u2264 x_{i}, y_{i} \u2264 100).\n\nIt is guaranteed that no two stations are located at the same point.\n\n\n-----Output-----\n\nIn a single line print an integer \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n3 1000\n1000\n0 0\n0 1\n0 3\n\nOutput\n2000\n\nInput\n3 1000\n1000\n1 0\n1 1\n1 2\n\nOutput\n1000", "difficulty": "competition", "id": 2026, "sample_io": [{"input": "3 1000\n1000\n0 0\n0 1\n0 3\n", "output": ["2000\n"]}, {"input": "3 1000\n1000\n1 0\n1 1\n1 2\n", "output": ["1000\n"]}], "test_list": [{"input": "3 1000\n1000\n0 0\n0 1\n0 3\n", "output": ["2000\n"]}, {"input": "3 1000\n1000\n1 0\n1 1\n1 2\n", "output": ["1000\n"]}, {"input": "5 1421\n896 448 727\n-19 -40\n-87 40\n69 51\n-55 61\n-7 67\n", "output": ["169099\n"]}, {"input": "6 1000\n142 712 254 869\n7 0\n95 38\n96 -20\n-7 93\n75 -45\n-80 -20\n", "output": ["107000\n"]}, {"input": "7 1288\n943 265 649 447 806\n-4 -51\n-26 32\n47 -28\n31 32\n61 65\n-45 -37\n82 42\n", "output": ["229903\n"]}, {"input": "8 1931\n440 627 324 538 539 119\n-85 -41\n-91 61\n-84 11\n92 -19\n8 -5\n16 -25\n97 -98\n91 78\n", "output": ["569018\n"]}, {"input": "9 1829\n98 513 987 291 162 637 356\n38 -3\n-89 93\n-86 45\n-43 -84\n-3 -87\n53 -59\n18 -19\n81 -74\n-85 32\n", "output": ["288982\n"]}, {"input": "10 1000\n759 222 589 423 947 507 31 414\n-4 -71\n-31 -53\n24 28\n-13 -65\n-59 -49\n-42 -79\n85 -71\n-60 -17\n28 66\n74 2\n", "output": ["151000\n"]}, {"input": "11 1199\n282 735 54 1000 419 939 901 789 128\n10 -81\n26 72\n19 -91\n-61 85\n0 -33\n-62 79\n-59 65\n-2 -77\n-63 100\n-15 53\n94 54\n", "output": ["262581\n"]}, {"input": "12 1609\n196 486 94 344 524 588 315 504 449 201\n86 -22\n-2 25\n-95 -8\n-5 -30\n-78 71\n5 -54\n-69 -92\n-41 0\n10 19\n61 17\n75 -39\n-46 22\n", "output": ["282231\n"]}, {"input": "3 97325\n40\n43 43\n45 -95\n-93 63\n", "output": ["15182700\n"]}, {"input": "11 1615\n137 681 199 33 388 585 241 518 7\n-60 89\n24 6\n-100 -55\n-26 -90\n-40 -33\n-100 28\n12 34\n-60 -13\n38 -89\n62 81\n-35 54\n", "output": ["96900\n"]}, {"input": "4 62071\n706 480\n6 96\n51 -12\n99 66\n-69 -61\n", "output": ["14400472\n"]}, {"input": "12 1542\n389 356 290 648 182 94 585 988 762 494\n-46 96\n1 88\n0 95\n-91 -100\n-42 -29\n45 -27\n-52 -34\n-62 27\n-19 46\n-100 95\n5 -55\n-36 -65\n", "output": ["263034\n"]}, {"input": "3 100000\n1\n-100 -100\n-100 -99\n100 100\n", "output": ["39999999\n"]}, {"input": "12 1211\n1 5 7 1000 1000 1000 1000 1000 1000 1000\n1 1\n5 5\n3 4\n4 3\n0 1\n0 2\n0 5\n0 7\n1 0\n3 0\n8 0\n10 10\n", "output": ["20220\n"]}, {"input": "6 1000\n1000 1000 1000 1000\n0 0\n0 -1\n1 -1\n2 -1\n2 0\n2 1\n", "output": ["1000\n"]}], "starter_code": "", "source_codes": ["\nimport heapq\nfrom itertools import permutations\n\ndef manhattan(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    d = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(2, n):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    points = []\n    for _ in range(n):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        points.append((x, y))\n    \n    # Precompute distance matrix\n    dist = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist[i][j] = manhattan(points[i], points[j]) * d\n    \n    # Since order matters and stations are one-time-use,\n    # We want to visit subset of stations including 1 and n\n    # This becomes Traveling Salesman like, but small enough to brute-force?\n    # Actually, better to do bitmask DP or greedy heuristic?\n\n    # Let's use TSP-like approach with pruning if needed\n    # But since n <= 100, full permutation impossible.\n    \n    # Instead, let's think differently:\n    # Try to build a path greedily with best gains per cost ratio?\n    \n    # Or better yet: Use dynamic programming with bitmasks.\n    # dp[mask][u] = min_money to reach station u having visited set of stations represented by mask\n    \n    INF = float('inf')\n    dp = {}\n    # Start from station 0 (index 0 corresponds to station 1)\n    # Initial time is ~0, so any movement requires paying upfront\n    dp[(1 << 0, 0)] = 0  # (mask, last_station) -> money_spent\n    \n    pq = [(0, 0, 1 << 0)]  # (money_spent, last_node, mask)\n\n    while pq:\n        money, u, mask = heapq.heappop(pq)\n        if money > dp.get((mask, u), INF):\n            continue\n        if u == n - 1:\n            print(money)\n            return\n        \n        for v in range(n):\n            if mask & (1 << v): \n                continue\n            new_mask = mask | (1 << v)\n            cost = dist[u][v]\n            gain = a[v + 1] if 2 <= v + 1 <= n - 1 else 0\n            \n            net_cost = cost - gain\n            required_money = max(0, net_cost)\n            \n            new_money = money + required_money\n            key = (new_mask, v)\n            if new_money < dp.get(key, INF):\n                dp[key] = new_money\n                heapq.heappush(pq, (new_money, v, new_mask))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["To solve this problem, we need to determine the minimum amount of money Yaroslav needs to reach station `n` from station `1`, considering:\n\n- He starts at station `1` with some initial time `t` where `0 < t < 1`.\n- Each station `i` (except station `1` and `n`) gives a bonus time `a_i` when visited.\n- Moving between stations costs time equal to `d * Manhattan distance`.\n- Station `1` allows buying time: 1 money = 1 extra time unit.\n- All stations can only be visited once.\n\n### Approach:\nThis is essentially a shortest path problem with a twist: we track not just the time but also how much money we may need to spend to survive the journey.\n\nWe will use **Dijkstra's algorithm**, where each state in our priority queue will be:\n```\n(current_time, current_station, money_spent)\n```\n\nSince time can become negative during traversal, we must ensure that it never drops to zero or below. So, we simulate all paths and whenever the time goes below the required movement cost, we calculate how much money is needed to bring it back up to at least that threshold.\n\nHowever, since there are only up to `n=100` nodes, and we're allowed multiple visits via Dijkstra tracking different states, this approach works efficiently.\n\nBut given the constraints (`d` can be as high as `1e5`, and distances could make move costs very large), we must realize that buying enough time initially might be necessary because moving even one step can consume huge amounts of time due to `d`.\n\nSo instead of complex DP, let\u2019s simplify:\n\nWe compute the minimal total time deficit along any valid Hamiltonian path from `1` to `n`. Then we calculate the minimum money required to cover deficits.\n\nLet\u2019s try all permutations? No \u2013 too slow.\n\nInstead, since `n <= 100`, we'll model the problem as finding a path through all stations such that cumulative time never falls below zero. To do that optimally:\n\nUse **Dijkstra** on a graph where:\n- Nodes are `(station_index)`\n- We keep track of maximum money spent to reach that node alive\n- For every transition, calculate new time = old_time + gain - cost\n    - If time < 0 \u2192 add `-time` money to compensate\n\nWe start with `initial_time \u2248 0.5` (since 0 < t < 1)\n\nWe can treat initial time as negligible because we don\u2019t know its exact value. So to be safe, we assume worst-case scenario: starting time is infinitesimally small.\n\nThus, we precompute pairwise distances and bonuses.\n\nThen run modified Dijkstra to find min money to survive from 1 to n visiting each station once.\n\n---\n\nHere's the implementation in Python:\n\n```python\nimport heapq\nfrom itertools import permutations\n\ndef manhattan(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    d = int(data[idx])\n    idx += 1\n    \n    a = [0] * (n + 1)\n    for i in range(2, n):\n        a[i] = int(data[idx])\n        idx += 1\n    \n    points = []\n    for _ in range(n):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        points.append((x, y))\n    \n    # Precompute distance matrix\n    dist = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist[i][j] = manhattan(points[i], points[j]) * d\n    \n    # Since order matters and stations are one-time-use,\n    # We want to visit subset of stations including 1 and n\n    # This becomes Traveling Salesman like, but small enough to brute-force?\n    # Actually, better to do bitmask DP or greedy heuristic?\n\n    # Let's use TSP-like approach with pruning if needed\n    # But since n <= 100, full permutation impossible.\n    \n    # Instead, let's think differently:\n    # Try to build a path greedily with best gains per cost ratio?\n    \n    # Or better yet: Use dynamic programming with bitmasks.\n    # dp[mask][u] = min_money to reach station u having visited set of stations represented by mask\n    \n    INF = float('inf')\n    dp = {}\n    # Start from station 0 (index 0 corresponds to station 1)\n    # Initial time is ~0, so any movement requires paying upfront\n    dp[(1 << 0, 0)] = 0  # (mask, last_station) -> money_spent\n    \n    pq = [(0, 0, 1 << 0)]  # (money_spent, last_node, mask)\n\n    while pq:\n        money, u, mask = heapq.heappop(pq)\n        if money > dp.get((mask, u), INF):\n            continue\n        if u == n - 1:\n            print(money)\n            return\n        \n        for v in range(n):\n            if mask & (1 << v): \n                continue\n            new_mask = mask | (1 << v)\n            cost = dist[u][v]\n            gain = a[v + 1] if 2 <= v + 1 <= n - 1 else 0\n            \n            net_cost = cost - gain\n            required_money = max(0, net_cost)\n            \n            new_money = money + required_money\n            key = (new_mask, v)\n            if new_money < dp.get(key, INF):\n                dp[key] = new_money\n                heapq.heappush(pq, (new_money, v, new_mask))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n\n- Uses Dijkstra-style search over combinations of visited stations.\n- Tracks minimum money spent to stay alive while traveling.\n- At each step, computes the net cost (distance cost minus reward).\n- If net cost is positive, it means extra time is needed, hence pay money.\n- Stops when reaching station `n`.\n\n> Note: The input format assumes standard input reading; this script reads all input at once and parses accordingly. Ensure it runs correctly in your environment (like redirecting file to stdin)."], "prompt_tokens": [636], "completion_tokens": [1386], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 2026}
