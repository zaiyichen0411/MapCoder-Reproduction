{"name": "2198", "description": "There are some ambiguities when one writes Berland names with the letters of the Latin alphabet.\n\nFor example, the Berland sound u can be written in the Latin alphabet as \"u\", and can be written as \"oo\". For this reason, two words \"ulyana\" and \"oolyana\" denote the same name.\n\nThe second ambiguity is about the Berland sound h: one can use both \"h\" and \"kh\" to write it. For example, the words \"mihail\" and \"mikhail\" denote the same name.\n\nThere are n users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?\n\nFormally, we assume that two words denote the same name, if using the replacements \"u\"\u00a0[Image]\u00a0\"oo\" and \"h\"\u00a0[Image]\u00a0\"kh\", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.\n\nFor example, the following pairs of words denote the same name:  \"koouper\" and \"kuooper\". Making the replacements described above, you can make both words to be equal: \"koouper\" $\\rightarrow$ \"kuuper\" and \"kuooper\" $\\rightarrow$ \"kuuper\".  \"khun\" and \"kkkhoon\". With the replacements described above you can make both words to be equal: \"khun\" $\\rightarrow$ \"khoon\" and \"kkkhoon\" $\\rightarrow$ \"kkhoon\" $\\rightarrow$ \"khoon\". \n\nFor a given list of words, find the minimal number of groups where the words in each group denote the same name.\n\n\n-----Input-----\n\nThe first line contains integer number n (2 \u2264 n \u2264 400) \u2014 number of the words in the list.\n\nThe following n lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.\n\n\n-----Output-----\n\nPrint the minimal number of groups where the words in each group denote the same name.\n\n\n-----Examples-----\nInput\n10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n\nOutput\n4\n\nInput\n9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n\nOutput\n5\n\nInput\n2\nalex\nalex\n\nOutput\n1\n\n\n\n-----Note-----\n\nThere are four groups of words in the first example. Words in each group denote same name:  \"mihail\", \"mikhail\"  \"oolyana\", \"ulyana\"  \"kooooper\", \"koouper\"  \"hoon\", \"khun\", \"kkkhoon\" \n\nThere are five groups of words in the second example. Words in each group denote same name:  \"hariton\", \"kkkhariton\", \"khariton\"  \"hkariton\"  \"buoi\", \"boooi\", \"boui\"  \"bui\"  \"boi\" \n\nIn the third example the words are equal, so they denote the same name.", "difficulty": "competition", "id": 2198, "sample_io": [{"input": "10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n", "output": ["4\n"]}, {"input": "9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n", "output": ["5\n"]}, {"input": "2\nalex\nalex\n", "output": ["1\n"]}], "test_list": [{"input": "10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n", "output": ["4\n"]}, {"input": "9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n", "output": ["5\n"]}, {"input": "2\nalex\nalex\n", "output": ["1\n"]}, {"input": "40\nuok\nkuu\nku\no\nkku\nuh\nu\nu\nhh\nk\nkh\nh\nh\nou\nokh\nukk\nou\nuhk\nuo\nuko\nu\nuu\nh\nh\nhk\nuhu\nuoh\nooo\nk\nh\nuk\nk\nkku\nh\nku\nok\nk\nkuu\nou\nhh\n", "output": ["21\n"]}, {"input": "40\noooo\nhu\no\nhoh\nkhk\nuuh\nhu\nou\nuuoh\no\nkouk\nuouo\nu\nok\nuu\nuuuo\nhoh\nuu\nkuu\nh\nu\nkkoh\nkhh\nuoh\nouuk\nkuo\nk\nu\nuku\nh\nu\nk\nhuho\nku\nh\noo\nuh\nk\nuo\nou\n", "output": ["25\n"]}, {"input": "100\nuh\nu\nou\nhk\nokh\nuou\nk\no\nuhh\nk\noku\nk\nou\nhuh\nkoo\nuo\nkk\nkok\nhhu\nuu\noou\nk\nk\noh\nhk\nk\nu\no\nuo\no\no\no\nhoh\nkuo\nhuh\nkhu\nuu\nk\noku\nk\nh\nuu\nuo\nhuo\noo\nhu\nukk\nok\no\noh\nuo\nkko\nok\nouh\nkoh\nhhu\nku\nko\nhho\nkho\nkho\nkhk\nho\nhk\nuko\nukh\nh\nkh\nkk\nuku\nkkk\no\nuo\no\nouh\nou\nuhk\nou\nk\nh\nkko\nuko\no\nu\nho\nu\nooo\nuo\no\nko\noh\nkh\nuk\nohk\noko\nuko\nh\nh\noo\no\n", "output": ["36\n"]}, {"input": "2\nkkkhkkh\nhh\n", "output": ["1\n"]}], "starter_code": "", "source_codes": ["\ndef normalize_name(name):\n    # Normalize the name by applying replacements until no more changes occur\n    prev_name = \"\"\n    current_name = name\n    while prev_name != current_name:\n        prev_name = current_name\n        # Replace \"kh\" with \"h\" and \"oo\" with \"u\" \n        current_name = current_name.replace(\"kh\", \"h\")\n        current_name = current_name.replace(\"oo\", \"u\")\n    return current_name\n\nn = int(input())\nnames = []\nfor _ in range(n):\n    names.append(input().strip())\n\n# Normalize all names\nnormalized_names = [normalize_name(name) for name in names]\n\n# Count unique normalized names\nunique_names = set(normalized_names)\n\nprint(len(unique_names))\n\n\n"], "responses": ["Here's a Python solution for the problem:\n\n```python\ndef normalize_name(name):\n    # Normalize the name by applying replacements until no more changes occur\n    prev_name = \"\"\n    current_name = name\n    while prev_name != current_name:\n        prev_name = current_name\n        # Replace \"kh\" with \"h\" and \"oo\" with \"u\" \n        current_name = current_name.replace(\"kh\", \"h\")\n        current_name = current_name.replace(\"oo\", \"u\")\n    return current_name\n\nn = int(input())\nnames = []\nfor _ in range(n):\n    names.append(input().strip())\n\n# Normalize all names\nnormalized_names = [normalize_name(name) for name in names]\n\n# Count unique normalized names\nunique_names = set(normalized_names)\n\nprint(len(unique_names))\n```\n\n### Explanation:\n- The core idea is to **normalize** each name by repeatedly applying the allowed transformations until no further changes are possible.\n- Transformations:\n  - Replace `\"oo\"` with `\"u\"`\n  - Replace `\"kh\"` with `\"h\"`\n- We keep doing these replacements until the string stops changing.\n- Then, we count how many unique normalized strings there are using a `set`.\n\n### Examples:\nFor the first sample input:\n- \"mihail\" \u2192 \"mihail\"\n- \"mikhail\" \u2192 \"mihail\"\nThese will normalize to the same string.\n\nSimilarly,\n- \"oolyana\" \u2192 \"ulyana\"\n- \"ulyana\" \u2192 \"ulyana\"\n\nSo they also match.\n\nThis approach correctly groups all equivalent names and counts the distinct ones."], "prompt_tokens": [863], "completion_tokens": [329], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2198}
{"name": "2073", "description": "Bike loves looking for the second maximum element in the sequence. The second maximum element in the sequence of distinct numbers x_1, x_2, ..., x_{k} (k > 1) is such maximum element x_{j}, that the following inequality holds: $x_{j} \\neq \\operatorname{max}_{i = 1}^{k} x_{i}$.\n\nThe lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence.\n\nYou've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1 \u2264 l < r \u2264 n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r].\n\nNote that as all numbers in sequence s are distinct, all the given definitions make sence.\n\n\n-----Input-----\n\nThe first line contains integer n (1 < n \u2264 10^5). The second line contains n distinct integers s_1, s_2, ..., s_{n} (1 \u2264 s_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum lucky number among all lucky numbers of sequences s[l..r].\n\n\n-----Examples-----\nInput\n5\n5 2 1 4 3\n\nOutput\n7\n\nInput\n5\n9 8 3 5 7\n\nOutput\n15\n\n\n\n-----Note-----\n\nFor the first sample you can choose s[4..5] = {4, 3} and its lucky number is (4\u00a0xor\u00a03) = 7. You can also choose s[1..2].\n\nFor the second sample you must choose s[2..5] = {8, 3, 5, 7}.", "difficulty": "competition", "id": 2073, "sample_io": [{"input": "5\n5 2 1 4 3\n", "output": ["7\n"]}, {"input": "5\n9 8 3 5 7\n", "output": ["15\n"]}], "test_list": [{"input": "5\n5 2 1 4 3\n", "output": ["7\n"]}, {"input": "5\n9 8 3 5 7\n", "output": ["15\n"]}, {"input": "10\n76969694 71698884 32888447 31877010 65564584 87864180 7850891 1505323 17879621 15722446\n", "output": ["128869996\n"]}, {"input": "10\n4547989 39261040 94929326 38131456 26174500 7152864 71295827 77784626 89898294 68006331\n", "output": ["134189790\n"]}, {"input": "10\n30301275 19973434 63004643 54007648 93722492 91677384 58694045 41546981 15552151 5811338\n", "output": ["112066588\n"]}, {"input": "10\n47606126 65484553 142643 35352821 26622058 5603080 7296801 53938188 34750256 97196502\n", "output": ["131671782\n"]}, {"input": "10\n82942694 74816699 72957520 1634864 60842992 60103606 61079517 41624114 13932450 24035648\n", "output": ["133874061\n"]}, {"input": "10\n73622246 45316865 2066146 61168230 1258786 69603039 64470479 72811017 72683016 97992629\n", "output": ["133280528\n"]}, {"input": "10\n29272229 8752316 10025994 52398694 57994948 49609605 28150935 66061676 44865054 87041483\n", "output": ["127710165\n"]}, {"input": "10\n3106954 3413954 3854371 85952704 17834583 20954227 58810981 7460648 97908613 97965110\n", "output": ["111078053\n"]}, {"input": "3\n11 10 8\n", "output": ["2\n"]}, {"input": "2\n5 6\n", "output": ["3\n"]}, {"input": "2\n16 17\n", "output": ["1\n"]}, {"input": "3\n8 9 10\n", "output": ["3\n"]}], "starter_code": "", "source_codes": ["\ndef solve():\n    n = int(input())\n    s = list(map(int, input().split()))\n    \n    max_lucky = 0\n    \n    # For each possible subarray s[l..r] where l < r\n    for l in range(n):\n        max_val = s[l]\n        second_max = -1\n        \n        for r in range(l + 1, n):\n            # Update max and second max when extending the subarray\n            if s[r] > max_val:\n                second_max = max_val\n                max_val = s[r]\n            elif s[r] > second_max:\n                second_max = s[r]\n            \n            # Calculate lucky number if we have valid second_max\n            if second_max != -1:\n                lucky = max_val ^ second_max\n                max_lucky = max(max_lucky, lucky)\n    \n    print(max_lucky)\n\nsolve()\n\n\n"], "responses": ["Here's the Python code to solve the problem:\n\n```python\ndef solve():\n    n = int(input())\n    s = list(map(int, input().split()))\n    \n    max_lucky = 0\n    \n    # For each possible subarray s[l..r] where l < r\n    for l in range(n):\n        max_val = s[l]\n        second_max = -1\n        \n        for r in range(l + 1, n):\n            # Update max and second max when extending the subarray\n            if s[r] > max_val:\n                second_max = max_val\n                max_val = s[r]\n            elif s[r] > second_max:\n                second_max = s[r]\n            \n            # Calculate lucky number if we have valid second_max\n            if second_max != -1:\n                lucky = max_val ^ second_max\n                max_lucky = max(max_lucky, lucky)\n    \n    print(max_lucky)\n\nsolve()\n```\n\nExplanation:\n1. For each possible subarray `s[l..r]` where `l < r`:\n   - We maintain the maximum and second maximum elements in the current subarray.\n   - As we extend the subarray from left to right, we update these values accordingly.\n   - When we have a valid pair of max and second max, we calculate their XOR (lucky number).\n   - We keep track of the maximum lucky number found so far.\n\n2. Time complexity: O(n\u00b2) where n is the length of the sequence.\n3. Space complexity: O(1) excluding the input storage.\n\nThe algorithm efficiently finds the maximum element and second maximum element for each subarray by maintaining them as we extend the subarray, rather than recalculating from scratch each time."], "prompt_tokens": [541], "completion_tokens": [360], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 2073}
{"name": "2126", "description": "For the multiset of positive integers $s=\\{s_1,s_2,\\dots,s_k\\}$, define the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of $s$ as follow: $\\gcd(s)$ is the maximum positive integer $x$, such that all integers in $s$ are divisible on $x$. $\\textrm{lcm}(s)$ is the minimum positive integer $x$, that divisible on all integers from $s$.\n\nFor example, $\\gcd(\\{8,12\\})=4,\\gcd(\\{12,18,6\\})=6$ and $\\textrm{lcm}(\\{4,6\\})=12$. Note that for any positive integer $x$, $\\gcd(\\{x\\})=\\textrm{lcm}(\\{x\\})=x$.\n\nOrac has a sequence $a$ with length $n$. He come up with the multiset $t=\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\}$, and asked you to find the value of $\\gcd(t)$ for him. In other words, you need to calculate the GCD of LCMs of all pairs of elements in the given sequence.\n\n\n-----Input-----\n\nThe first line contains one integer $n\\ (2\\le n\\le 100\\,000)$.\n\nThe second line contains $n$ integers, $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 200\\,000$).\n\n\n-----Output-----\n\nPrint one integer: $\\gcd(\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\})$.\n\n\n-----Examples-----\nInput\n2\n1 1\n\nOutput\n1\n\nInput\n4\n10 24 40 80\n\nOutput\n40\n\nInput\n10\n540 648 810 648 720 540 594 864 972 648\n\nOutput\n54\n\n\n\n-----Note-----\n\nFor the first example, $t=\\{\\textrm{lcm}(\\{1,1\\})\\}=\\{1\\}$, so $\\gcd(t)=1$.\n\nFor the second example, $t=\\{120,40,80,120,240,80\\}$, and it's not hard to see that $\\gcd(t)=40$.", "difficulty": "competition", "id": 2126, "sample_io": [{"input": "2\n1 1\n", "output": ["1\n"]}, {"input": "4\n10 24 40 80\n", "output": ["40\n"]}, {"input": "10\n540 648 810 648 720 540 594 864 972 648\n", "output": ["54\n"]}], "test_list": [{"input": "2\n1 1\n", "output": ["1\n"]}, {"input": "4\n10 24 40 80\n", "output": ["40\n"]}, {"input": "10\n540 648 810 648 720 540 594 864 972 648\n", "output": ["54\n"]}, {"input": "2\n199999 200000\n", "output": ["39999800000\n"]}, {"input": "2\n198761 199999\n", "output": ["39752001239\n"]}, {"input": "10\n972 972 324 972 324 648 1944 243 324 474\n", "output": ["162\n"]}, {"input": "3\n166299 110866 86856\n", "output": ["332598\n"]}, {"input": "2\n10007 20014\n", "output": ["20014\n"]}, {"input": "2\n4 6\n", "output": ["12\n"]}, {"input": "5\n25 25 5 5 5\n", "output": ["5\n"]}, {"input": "2\n3 3\n", "output": ["3\n"]}], "starter_code": "", "source_codes": ["\ndef gcd_of_lcm_pairs():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Find all primes up to max(a)\n    max_val = max(a)\n    \n    # Sieve to find smallest prime factor for each number\n    spf = list(range(max_val + 1))\n    for i in range(2, int(max_val**0.5) + 1):\n        if spf[i] == i:\n            for j in range(i * i, max_val + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    \n    # Function to get prime factorization\n    def factorize(x):\n        factors = {}\n        while x > 1:\n            p = spf[x]\n            factors[p] = factors.get(p, 0) + 1\n            x //= p\n        return factors\n    \n    # Collect all prime factors and their exponents from all numbers\n    prime_exponents = {}\n    for num in a:\n        factors = factorize(num)\n        for p, e in factors.items():\n            if p not in prime_exponents:\n                prime_exponents[p] = []\n            prime_exponents[p].append(e)\n    \n    # For each prime, find the second smallest exponent\n    result = 1\n    for p, exponents in prime_exponents.items():\n        exponents.sort()\n        # Second smallest exponent (index 1 since we have at least 2 elements)\n        second_min_exp = exponents[1] if len(exponents) >= 2 else 0\n        result *= pow(p, second_min_exp)\n    \n    return result\n\nprint(gcd_of_lcm_pairs())\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\nWe need to:\n1. Take all pairs of elements from the sequence `a`\n2. Compute LCM for each pair\n3. Find the GCD of all these LCMs\n\nLet me think about this mathematically.\n\n## Mathematical Insight\n\nLet's think about what `gcd(lcm(a_i, a_j) for all i < j)` means.\n\nFor any prime `p` with exponent `e` in the final answer, we need `p^e` to divide all LCMs, and `p^(e+1)` should not divide at least one LCM.\n\nFor `p^e` to divide `lcm(a_i, a_j)`, it must be that `p^e` divides `a_i` OR `p^e` divides `a_j`.\n\nSo `p^e` divides ALL LCMs if and only if for every pair `(a_i, a_j)`, either `a_i` or `a_j` is divisible by `p^e`.\n\nThis is equivalent to saying that at most one element in the sequence is NOT divisible by `p^e`.\n\nIf there are two or more elements not divisible by `p^e`, then their LCM won't be divisible by `p^e`.\n\nTherefore, for each prime `p`, we want the largest `e` such that at most one element in the sequence is not divisible by `p^e`.\n\nThis means we can:\n1. For each prime `p`, find how many elements are divisible by `p^e` for each relevant power `e`\n2. Find the maximum `e` such that at least `n-1` elements are divisible by `p^e`\n3. Multiply all such `p^e` together\n\nActually, let me think even more carefully.\n\nThe answer is the product over all primes `p` of `p^(min(max_v_p(a_i), max_v_p(a_i) where v_p(a_i) is minimized))`.\n\nWait, let me reframe:\n\nFor each prime `p`, let `v_p(x)` denote the exponent of `p` in the prime factorization of `x`.\n\nThen the exponent of `p` in our answer is the minimum over all pairs `i,j` of `v_p(lcm(a_i,a_j))`, which equals the minimum over all pairs of `max(v_p(a_i), v_p(a_j))`.\n\nTo find this minimum, sort the values `v_p(a_1), v_p(a_2), ..., v_p(a_n)` in ascending order.\nThe minimum of `max(v_p(a_i), v_p(a_j))` over all pairs is achieved when we take the pair that gives the smallest maximum - this happens when we take adjacent elements in the sorted list, specifically the smallest two values will give us the minimum maximum among all pairs.\n\nNo wait, that's wrong. We want the minimum of all the maxima. The minimum of `max(v_p(a_i), v_p(a_j))` over all pairs is simply the second smallest value in `v_p(a_1), ..., v_p(a_n)`.\n\nBecause if we sort them as `e_1 \u2264 e_2 \u2264 ... \u2264 e_n`, then:\n- `max(e_1, e_2) = e_2`\n- `max(e_1, e_3) = e_3 \u2265 e_2`\n- ...\n- `max(e_2, e_3) = e_3 \u2265 e_2`\n\nSo the minimum of all these maxima is `e_2`, the second smallest.\n\n## Algorithm\n\n1. For each prime `p` that appears in any element's factorization:\n   - Find the exponents of `p` in all numbers\n   - Sort these exponents\n   - Take the second smallest (if there are at least 2 elements)\n2. Multiply `p^(second_smallest_exponent)` for all such primes\n\nSpecial case: if `n = 1`, there are no pairs, but the constraint says `n \u2265 2`.\n\nActually wait, let me double-check with the examples:\n\nExample 1: `[1, 1]`\n- Pairs: `lcm(1,1) = 1`\n- Answer: `gcd({1}) = 1` \u2713\n\nExample 2: `[10, 24, 40, 80]`\n- `10 = 2\u00b9 \u00d7 5\u00b9`\n- `24 = 2\u00b3 \u00d7 3\u00b9`  \n- `40 = 2\u00b3 \u00d7 5\u00b9`\n- `80 = 2\u2074 \u00d7 5\u00b9`\n\nFor prime 2: exponents [1, 3, 3, 4], sorted = [1, 3, 3, 4], second smallest = 3\nFor prime 3: exponents [0, 1, 0, 0], sorted = [0, 0, 0, 1], second smallest = 0  \nFor prime 5: exponents [1, 0, 1, 1], sorted = [0, 1, 1, 1], second smallest = 1\n\nAnswer = 2\u00b3 \u00d7 3\u2070 \u00d7 5\u00b9 = 8 \u00d7 1 \u00d7 5 = 40 \u2713\n\nThis confirms my approach!\n\n```python\ndef gcd_of_lcm_pairs():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Find all primes up to max(a)\n    max_val = max(a)\n    \n    # Sieve to find smallest prime factor for each number\n    spf = list(range(max_val + 1))\n    for i in range(2, int(max_val**0.5) + 1):\n        if spf[i] == i:\n            for j in range(i * i, max_val + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    \n    # Function to get prime factorization\n    def factorize(x):\n        factors = {}\n        while x > 1:\n            p = spf[x]\n            factors[p] = factors.get(p, 0) + 1\n            x //= p\n        return factors\n    \n    # Collect all prime factors and their exponents from all numbers\n    prime_exponents = {}\n    for num in a:\n        factors = factorize(num)\n        for p, e in factors.items():\n            if p not in prime_exponents:\n                prime_exponents[p] = []\n            prime_exponents[p].append(e)\n    \n    # For each prime, find the second smallest exponent\n    result = 1\n    for p, exponents in prime_exponents.items():\n        exponents.sort()\n        # Second smallest exponent (index 1 since we have at least 2 elements)\n        second_min_exp = exponents[1] if len(exponents) >= 2 else 0\n        result *= pow(p, second_min_exp)\n    \n    return result\n\nprint(gcd_of_lcm_pairs())\n```"], "prompt_tokens": [653], "completion_tokens": [1493], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2126}
{"name": "2012", "description": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n).\n\nA lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.\n\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4", "difficulty": "competition", "id": 2012, "sample_io": [{"input": "1\n", "output": ["1 \n"]}, {"input": "2\n", "output": ["-1\n"]}, {"input": "4\n", "output": ["2 4 1 3 \n"]}, {"input": "5\n", "output": ["2 5 3 1 4 \n"]}], "test_list": [{"input": "1\n", "output": ["1 \n"]}, {"input": "2\n", "output": ["-1\n"]}, {"input": "4\n", "output": ["2 4 1 3 \n"]}, {"input": "5\n", "output": ["2 5 3 1 4 \n"]}, {"input": "3\n", "output": ["-1\n"]}, {"input": "6\n", "output": ["-1\n"]}, {"input": "7\n", "output": ["-1\n"]}, {"input": "8\n", "output": ["2 8 4 6 3 5 1 7 \n"]}, {"input": "9\n", "output": ["2 9 4 7 5 3 6 1 8 \n"]}, {"input": "10002\n", "output": ["-1\n"]}, {"input": "10003\n", "output": ["-1\n"]}, {"input": "25\n", "output": ["2 25 4 23 6 21 8 19 10 17 12 15 13 11 14 9 16 7 18 5 20 3 22 1 24 \n"]}, {"input": "29\n", "output": ["2 29 4 27 6 25 8 23 10 21 12 19 14 17 15 13 16 11 18 9 20 7 22 5 24 3 26 1 28 \n"]}, {"input": "33\n", "output": ["2 33 4 31 6 29 8 27 10 25 12 23 14 21 16 19 17 15 18 13 20 11 22 9 24 7 26 5 28 3 30 1 32 \n"]}, {"input": "9\n", "output": ["2 9 4 7 5 3 6 1 8 \n"]}, {"input": "13\n", "output": ["2 13 4 11 6 9 7 5 8 3 10 1 12 \n"]}, {"input": "17\n", "output": ["2 17 4 15 6 13 8 11 9 7 10 5 12 3 14 1 16 \n"]}, {"input": "99999\n", "output": ["-1\n"]}], "starter_code": "", "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 2012}
