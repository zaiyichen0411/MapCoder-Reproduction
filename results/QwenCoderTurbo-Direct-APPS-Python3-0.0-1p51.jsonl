{"name": "1643", "description": "You are given 2 numbers is `n` and `k`. You need to find the number of integers between 1 and n (inclusive) that contains exactly `k` non-zero digit.\n\nExample1 \n\n`\nalmost_everywhere_zero(100, 1) return 19`\n\nby following condition we have 19 numbers that have k = 1 digits( not count zero ) \n` [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100]`\n\n\nExample2  \n\n`\nalmost_everywhere_zero(11, 2) return 1`\n\nwe have only `11` that has 2 digits(ten not count because zero is not count) \n` 11`\n\n\n\n\n\nconstrains\n\n\n`1\u2264n<pow(10,100)`\n\n\n`1\u2264k\u2264100`", "difficulty": "interview", "id": 1643, "sample_io": [{"input": "100\n1", "output": [19]}, {"input": "11\n2", "output": [1]}], "test_list": [{"input": "100\n1", "output": [19]}, {"input": "11\n2", "output": [1]}, {"input": "20\n2", "output": [9]}, {"input": "101\n2", "output": [82]}, {"input": "10001\n2", "output": [487]}, {"input": "10001000\n2", "output": [1729]}, {"input": "500309160\n2", "output": [2604]}, {"input": "10000000000000000000000\n3", "output": [1122660]}, {"input": "10000000000000000000000\n21", "output": [2407217760893271902598]}, {"input": "1203\n4", "output": [81]}], "starter_code": "\ndef almost_everywhere_zero(n, k):\n\t", "source_codes": ["\nimport sys\nsys.setrecursionlimit(10000)\n\ndef almost_everywhere_zero(n_str, k):\n    from functools import lru_cache\n\n    n = len(n_str)\n    digits = [int(c) for c in n_str]\n\n    @lru_cache(None)\n    def dp(pos, count, tight, leading_zero):\n        if pos == n:\n            return 1 if (count == k and not leading_zero) else 0\n\n        limit = digits[pos] if tight else 9\n        total = 0\n\n        for d in range(0, limit + 1):\n            new_tight = tight and (d == limit)\n            new_leading_zero = leading_zero and (d == 0)\n            new_count = count\n\n            if not new_leading_zero:\n                if d != 0:\n                    new_count += 1\n\n            if new_count > k:\n                continue\n\n            total += dp(pos + 1, new_count, new_tight, new_leading_zero)\n\n        return total\n\n    return dp(0, 0, True, True)\n\ndef main():\n    n = input().strip()\n    k = int(input().strip())\n    print(almost_everywhere_zero(n, k))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["Here's a Python3 solution to the problem. The function `almost_everywhere_zero(n, k)` computes how many numbers from 1 to `n` (inclusive) have exactly `k` non-zero digits. The input is read from standard input, and the output is printed to standard output.\n\nThe approach uses **digit dynamic programming (digit DP)** to handle the large constraint `n < 10^100` efficiently.\n\n```python\nimport sys\nsys.setrecursionlimit(10000)\n\ndef almost_everywhere_zero(n_str, k):\n    from functools import lru_cache\n\n    n = len(n_str)\n    digits = [int(c) for c in n_str]\n\n    @lru_cache(None)\n    def dp(pos, count, tight, leading_zero):\n        if pos == n:\n            return 1 if (count == k and not leading_zero) else 0\n\n        limit = digits[pos] if tight else 9\n        total = 0\n\n        for d in range(0, limit + 1):\n            new_tight = tight and (d == limit)\n            new_leading_zero = leading_zero and (d == 0)\n            new_count = count\n\n            if not new_leading_zero:\n                if d != 0:\n                    new_count += 1\n\n            if new_count > k:\n                continue\n\n            total += dp(pos + 1, new_count, new_tight, new_leading_zero)\n\n        return total\n\n    return dp(0, 0, True, True)\n\ndef main():\n    n = input().strip()\n    k = int(input().strip())\n    print(almost_everywhere_zero(n, k))\n\nif __name__ == \"__main__\":\n    main()\n``` \n\n### Explanation:\n\n- `dp(pos, count, tight, leading_zero)` is a recursive function that:\n  - `pos`: current position in the number\n  - `count`: number of non-zero digits so far\n  - `tight`: whether the current number is still tight to the original number\n  - `leading_zero`: whether we are still in the leading zero phase\n- The function uses memoization (`lru_cache`) to avoid recomputation.\n- It iterates over all possible digits at the current position and updates the count and tight state accordingly.\n- At the end of the recursion, it checks if the number of non-zero digits is exactly `k`.\n\n### Sample Input:\n\n```\n100\n1\n```\n\n### Sample Output:\n\n```\n19\n```\n\nThis solution works efficiently even for very large values of `n` (up to 10^100) due to the use of digit DP."], "prompt_tokens": [317], "completion_tokens": [559], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 1643}
