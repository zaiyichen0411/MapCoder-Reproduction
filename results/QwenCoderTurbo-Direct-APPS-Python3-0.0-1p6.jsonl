{"name": "4515", "description": "Your task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.", "difficulty": "introductory", "id": 4515, "sample_io": [{"input": "['56-23','1-100']", "output": ["1-100"]}, {"input": "['1-3', '5-7', '2-3']", "output": ["1-3"]}, {"input": "['11-11', '344-344']", "output": [false]}], "test_list": [{"input": "['43-45', '1021-55', '000-18888', '92-34', '76-32', '99-1', '1020-54']", "output": ["000-18888"]}, {"input": "['1-2', '2-4', '5-7', '8-9', '44-45']", "output": ["2-4"]}, {"input": "['1-1000', '2-1000', '100-67', '98-45', '8-9']", "output": ["1-1000"]}, {"input": "['33-33', '77-77']", "output": [false]}, {"input": "['23-67', '67-23', '88-88', '45-46']", "output": ["23-67"]}, {"input": "['45896-2354', '4654-556767', '2455-423522', '3455-355', '34-34', '2524522-0']", "output": ["2524522-0"]}, {"input": "['1-1', '2-2', '1-0', '77-77']", "output": ["1-0"]}, {"input": "['0-0']", "output": [false]}, {"input": "[]", "output": [false]}], "starter_code": "\ndef diff(arr):\n\t", "source_codes": ["\ndef find_greatest_difference(couples):\n    max_diff = 0\n    result = None\n    \n    for couple in couples:\n        # Split the string to get the two numbers\n        num1, num2 = map(int, couple.split('-'))\n        \n        # Calculate the absolute difference\n        diff = abs(num1 - num2)\n        \n        # Update result if this difference is greater than max_diff\n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    # If max_diff is still 0, it means all differences are 0\n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input\ninput_str = input().strip()\n# Parse the input string to extract the array\ncouples = eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)\n\n\n"], "responses": ["```python\ndef find_greatest_difference(couples):\n    max_diff = 0\n    result = None\n    \n    for couple in couples:\n        # Split the string to get the two numbers\n        num1, num2 = map(int, couple.split('-'))\n        \n        # Calculate the absolute difference\n        diff = abs(num1 - num2)\n        \n        # Update result if this difference is greater than max_diff\n        if diff > max_diff:\n            max_diff = diff\n            result = couple\n    \n    # If max_diff is still 0, it means all differences are 0\n    if max_diff == 0:\n        return False\n    \n    return result\n\n# Read input\ninput_str = input().strip()\n# Parse the input string to extract the array\ncouples = eval(input_str)\n\n# Call the function and print the result\nresult = find_greatest_difference(couples)\nprint(result)\n```"], "prompt_tokens": [262], "completion_tokens": [189], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 4515}
{"name": "3068", "description": "You need to play around with the provided string (s).\n\nMove consonants forward 9 places through the alphabet.\nIf they pass 'z', start again at 'a'.\n\nMove vowels back 5 places through the alphabet.\nIf they pass 'a', start again at 'z'.\nFor our Polish friends this kata does not count 'y' as a vowel.\n\nExceptions:\n\nIf the character is 'c' or 'o', move it back 1 place.\nFor 'd' move it back 3, and for 'e', move it back 4.\n\nIf a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.\n\nProvided string will always be lower case, won't be empty and will have no special characters.", "difficulty": "introductory", "id": 3068, "sample_io": [], "test_list": [{"input": "testcase", "output": ["tabtbvba"]}, {"input": "codewars", "output": ["bnaafvab"]}, {"input": "exampletesthere", "output": ["agvvyuatabtqaaa"]}, {"input": "returnofthespacecamel", "output": ["aatpawnftqabyvbabvvau"]}, {"input": "bringonthebootcamp", "output": ["kaiwpnwtqaknntbvvy"]}, {"input": "weneedanofficedog", "output": ["fawaaavwnffibaanp"]}], "starter_code": "\ndef vowel_back(st):\n\t", "source_codes": ["\ndef solve(s):\n    vowels = set('aeiou')\n    exceptions = set('code')\n    result = []\n    \n    for char in s:\n        original_char = char\n        new_char = char\n        \n        # Handle exceptions first\n        if char == 'c' or char == 'o':\n            # Move back 1\n            new_char = chr(ord(char) - 1)\n        elif char == 'd':\n            # Move back 3\n            new_char = chr(ord(char) - 3)\n        elif char == 'e':\n            # Move back 4\n            new_char = chr(ord(char) - 4)\n        elif char in vowels:\n            # Vowel: move back 5 places\n            new_ord = ord(char) - 5\n            if new_ord < ord('a'):\n                new_ord = ord('z') - (ord('a') - new_ord - 1)\n            new_char = chr(new_ord)\n        else:\n            # Consonant: move forward 9 places\n            new_ord = ord(char) + 9\n            if new_ord > ord('z'):\n                new_ord = ord('a') + (new_ord - ord('z') - 1)\n            new_char = chr(new_ord)\n        \n        # Check if new character is one of the exception targets\n        if new_char in exceptions:\n            new_char = original_char\n            \n        result.append(new_char)\n    \n    return ''.join(result)\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))\n\n\n"], "responses": ["I'll solve this step by step.\n\nFirst, let me understand the rules:\n1. Move consonants forward 9 places (wrap around from z to a)\n2. Move vowels back 5 places (wrap around from a to z)\n3. Exceptions for specific letters: c, o (back 1), d (back 3), e (back 4)\n4. If a moved letter becomes c, o, d, or e, revert to original\n5. Vowels are a, e, i, o, u (not y)\n\nLet me trace through some examples:\n- 'b' (consonant) \u2192 forward 9 \u2192 'k'\n- 'a' (vowel) \u2192 back 5 \u2192 'v'\n- 'c' (exception) \u2192 back 1 \u2192 'b'\n\nHere's my solution:\n\n```python\ndef solve(s):\n    vowels = set('aeiou')\n    exceptions = set('code')\n    result = []\n    \n    for char in s:\n        original_char = char\n        new_char = char\n        \n        # Handle exceptions first\n        if char == 'c' or char == 'o':\n            # Move back 1\n            new_char = chr(ord(char) - 1)\n        elif char == 'd':\n            # Move back 3\n            new_char = chr(ord(char) - 3)\n        elif char == 'e':\n            # Move back 4\n            new_char = chr(ord(char) - 4)\n        elif char in vowels:\n            # Vowel: move back 5 places\n            new_ord = ord(char) - 5\n            if new_ord < ord('a'):\n                new_ord = ord('z') - (ord('a') - new_ord - 1)\n            new_char = chr(new_ord)\n        else:\n            # Consonant: move forward 9 places\n            new_ord = ord(char) + 9\n            if new_ord > ord('z'):\n                new_ord = ord('a') + (new_ord - ord('z') - 1)\n            new_char = chr(new_ord)\n        \n        # Check if new character is one of the exception targets\n        if new_char in exceptions:\n            new_char = original_char\n            \n        result.append(new_char)\n    \n    return ''.join(result)\n\n# Read input and solve\ns = input().strip()\nprint(solve(s))\n```"], "prompt_tokens": [244], "completion_tokens": [500], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 3068}
{"name": "4214", "description": "In this kata you will have to modify a sentence so it meets the following rules:\n\nconvert every word backwards that is:\n\n    longer than 6 characters\n\n  OR\n\n    has 2 or more 'T' or 't' in it\n\nconvert every word uppercase that is:\n\n    exactly 2 characters long\n\n  OR\n\n    before a comma\n\nconvert every word to a \"0\" that is:\n\n    exactly one character long\n \n\n NOTES: \n\n      Punctuation must not be touched. if a word is 6 characters long, and a \".\" is behind it,\n      it counts as 6 characters so it must not be flipped, but if a word is 7 characters long,\n      it must be flipped but the \".\" must stay at the end of the word.\n      -----------------------------------------------------------------------------------------\n      Only the first transformation applies to a given word, for example 'companions,'\n      will be 'snoinapmoc,' and not 'SNOINAPMOC,'.\n      -----------------------------------------------------------------------------------------\n      As for special characters like apostrophes or dashes, they count as normal characters, \n      so e.g 'sand-colored' must be transformed to 'deroloc-dnas'.", "difficulty": "introductory", "id": 4214, "sample_io": [{"input": "companions,", "output": ["snoinapmoc,"]}, {"input": "sand-colored", "output": ["deroloc-dnas"]}], "test_list": [{"input": "Welcome.", "output": ["emocleW."]}, {"input": "If a man does not keep pace with his companions, perhaps it is because he hears a different drummer.", "output": ["IF 0 man does not keep pace with his snoinapmoc, spahrep IT IS esuaceb HE hears 0 tnereffid remmurd."]}, {"input": "As Grainier drove along in the wagon behind a wide, slow, sand-colored mare, clusters of orange butterflies exploded off the purple blackish piles of bear sign and winked and winked and fluttered magically like leaves without trees.", "output": ["AS reiniarG drove along IN the wagon behind 0 WIDE, SLOW, deroloc-dnas MARE, sretsulc OF orange seilfrettub dedolpxe off the purple hsikcalb piles OF bear sign and winked and winked and derettulf yllacigam like leaves tuohtiw trees."]}, {"input": "You should check the mileage on your car since you've been driving it so much, and because it's starting to make weird noises.", "output": ["You should check the egaelim ON your car since you've been gnivird IT SO MUCH, and esuaceb it's gnitrats TO make weird noises."]}, {"input": "Wherever you go, you can always find beauty.", "output": ["reverehW you GO, you can always find beauty."]}, {"input": "Action is indeed, commmmmmmming.", "output": ["Action IS INDEED, gnimmmmmmmmoc."]}, {"input": "Mother, please, help, me.", "output": ["MOTHER, PLEASE, HELP, ME."]}, {"input": "Jojojo, jojo, tata man kata.", "output": ["JOJOJO, JOJO, atat man kata."]}], "starter_code": "\ndef spin_solve(sentence):\n\t", "source_codes": ["\nimport re\n\ndef transform_sentence(sentence):\n    # Split into tokens (words with their punctuation)\n    tokens = sentence.split()\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Separate word from punctuation\n        word_part = \"\"\n        punct_part = \"\"\n        \n        # Extract alphabetic part from the beginning\n        j = 0\n        while j < len(token) and (token[j].isalpha() or token[j].isdigit() or token[j] in \"'-\"):\n            word_part += token[j]\n            j += 1\n        \n        punct_part = token[j:] if j < len(token) else \"\"\n        \n        # Apply transformations in order of precedence\n        if len(word_part) == 1:\n            # Rule 3: exactly one character long -> \"0\"\n            result_tokens.append(\"0\" + punct_part)\n        elif len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            # Rule 1: longer than 6 chars OR 2+ 'T'/'t' -> backwards\n            result_tokens.append(word_part[::-1] + punct_part)\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and tokens[i + 1].startswith(',')):\n            # Rule 2: exactly 2 chars OR before a comma -> uppercase\n            result_tokens.append(word_part.upper() + punct_part)\n        else:\n            # No transformation\n            result_tokens.append(word_part + punct_part)\n    \n    return ' '.join(result_tokens)\n\n# Read input and process\nsentence = input().strip()\nresult = transform_sentence(sentence)\nprint(result)\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Process each word in a sentence according to specific rules\n2. Handle punctuation correctly (keep it attached to the word)\n3. Apply transformations in order of precedence\n4. Output the modified sentence\n\nLet me break down the approach:\n- Extract words with their punctuation\n- Apply transformations based on the rules\n- Reconstruct the sentence\n\n```python\nimport re\nimport sys\n\ndef transform_sentence(sentence):\n    # Split sentence into words while keeping punctuation\n    # This regex finds sequences of word characters and punctuation separately\n    words = re.findall(r'\\S+', sentence)\n    \n    result_words = []\n    \n    for word in words:\n        # Separate the actual word from trailing punctuation\n        # Find where the alphabetic characters end\n        clean_word = \"\"\n        punctuation = \"\"\n        \n        # Extract the actual word part (letters, numbers, apostrophes, dashes)\n        i = len(word) - 1\n        while i >= 0 and not word[i].isalpha() and not word[i].isdigit():\n            i -= 1\n        \n        if i >= 0:\n            clean_word = word[:i+1]\n            punctuation = word[i+1:]\n        else:\n            clean_word = \"\"\n            punctuation = word\n        \n        # Apply transformations in order\n        if len(clean_word) == 1:\n            # Rule 3: convert to \"0\" if exactly one character long\n            result_words.append(\"0\" + punctuation)\n        elif len(clean_word) > 6 or clean_word.lower().count('t') >= 2:\n            # Rule 1: convert backwards if longer than 6 chars OR has 2+ 'T'/'t'\n            result_words.append(clean_word[::-1] + punctuation)\n        elif len(clean_word) == 2 or (len(result_words) < len(words) - 1 and word.endswith(',')):\n            # Rule 2: convert uppercase if exactly 2 chars OR before a comma\n            # For \"before a comma\" check, we need to look ahead\n            result_words.append(clean_word.upper() + punctuation)\n        else:\n            # No transformation\n            result_words.append(clean_word + punctuation)\n    \n    return ' '.join(result_words)\n\ndef process_text():\n    # Read input\n    sentence = input().strip()\n    \n    # Transform and output\n    result = transform_sentence(sentence)\n    print(result)\n\n# Run the function\nprocess_text()\n```\n\nWait, let me re-read the problem more carefully. I need to handle the \"before a comma\" rule correctly. Let me revise:\n\n```python\nimport re\n\ndef transform_sentence(sentence):\n    # Split into tokens (words with their punctuation)\n    tokens = sentence.split()\n    \n    result_tokens = []\n    \n    for i, token in enumerate(tokens):\n        # Separate word from punctuation\n        word_part = \"\"\n        punct_part = \"\"\n        \n        # Extract alphabetic part from the beginning\n        j = 0\n        while j < len(token) and (token[j].isalpha() or token[j].isdigit() or token[j] in \"'-\"):\n            word_part += token[j]\n            j += 1\n        \n        punct_part = token[j:] if j < len(token) else \"\"\n        \n        # Apply transformations in order of precedence\n        if len(word_part) == 1:\n            # Rule 3: exactly one character long -> \"0\"\n            result_tokens.append(\"0\" + punct_part)\n        elif len(word_part) > 6 or word_part.lower().count('t') >= 2:\n            # Rule 1: longer than 6 chars OR 2+ 'T'/'t' -> backwards\n            result_tokens.append(word_part[::-1] + punct_part)\n        elif len(word_part) == 2 or (i < len(tokens) - 1 and tokens[i + 1].startswith(',')):\n            # Rule 2: exactly 2 chars OR before a comma -> uppercase\n            result_tokens.append(word_part.upper() + punct_part)\n        else:\n            # No transformation\n            result_tokens.append(word_part + punct_part)\n    \n    return ' '.join(result_tokens)\n\n# Read input and process\nsentence = input().strip()\nresult = transform_sentence(sentence)\nprint(result)\n```"], "prompt_tokens": [342], "completion_tokens": [883], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": 4214}
{"name": "3884", "description": "# RegExp Fun #1 - When I miss few days of gym\n\n## Disclaimer\n\nThe background story of this Kata is 100% fiction.  Any resemblance to real people or real events is **nothing more than a coincidence** and should be regarded as such.\n\n## Background Story\n\nYou are a person who loves to go to the gym everyday with the squad of people that you've known since early childhood.  However, you recently contracted a sickness that forced you to stay at home for over a week.  As you see your body getting weaker and weaker every day and as you see your biceps and triceps disappearing, you can't help but lay in bed and cry.  You're usually an optimistic person but this time negative thoughts come to your head ... \n\n![When I miss few days of gym](https://pics.onsizzle.com/Instagram-faf8c9.png)\n\n\n## Task\n\nAs can be seen from the funny image above (or am I the only person to find the picture above hilarious?) there is lots of slang.  Your task is to define a function ```gymSlang``` which accepts a string argument and does the following:\n\n1. Replace *all* instances of ```\"probably\"``` to ```\"prolly\"```\n2. Replace *all* instances of ```\"i am\"``` to ```\"i'm\"```\n3. Replace *all* instances of ```\"instagram\"``` to ```\"insta\"```\n4. Replace *all* instances of ```\"do not\"``` to ```\"don't\"```\n5. Replace *all* instances of ```\"going to\"``` to ```\"gonna\"```\n6. Replace *all* instances of ```\"combination\"``` to ```\"combo\"```\n\nYour replacement regexes **should be case-sensitive**, only replacing the words above with slang if the detected pattern is in **lowercase**.  However, please note that apart from 100% lowercase matches, you will **also have to replace matches that are correctly capitalized** (e.g. ```\"Probably\" => \"Prolly\"``` or ```\"Instagram\" => \"Insta\"```).\n\nFinally, your code will be tested to make sure that you have used **RegExp** replace in your code.\n\nEnjoy :D", "difficulty": "introductory", "id": 3884, "sample_io": [{"input": "Probably", "output": ["Prolly"]}, {"input": "Instagram", "output": ["Insta"]}], "test_list": [{"input": "When I miss few days of gym", "output": ["When I miss few days of gym"]}, {"input": "Squad probably think I am fake", "output": ["Squad prolly think I'm fake"]}, {"input": "Whole squad probably bigger than me now", "output": ["Whole squad prolly bigger than me now"]}, {"input": "No selfie to post on Instagram either", "output": ["No selfie to post on Insta either"]}, {"input": "Gym crush probably found someone else", "output": ["Gym crush prolly found someone else"]}, {"input": "What if I die fat", "output": ["What if I die fat"]}, {"input": "What if I do not fit in my clothes now", "output": ["What if I don't fit in my clothes now"]}, {"input": "Going to feel like a new gym member", "output": ["Gonna feel like a new gym member"]}, {"input": "wait what was my lock combination", "output": ["wait what was my lock combo"]}, {"input": "that skinny girl can probably outlift me now", "output": ["that skinny girl can prolly outlift me now"]}, {"input": "probably Probably", "output": ["prolly Prolly"]}, {"input": "i am I am", "output": ["i'm I'm"]}, {"input": "instagram Instagram", "output": ["insta Insta"]}, {"input": "do not Do not", "output": ["don't Don't"]}, {"input": "going to Going to", "output": ["gonna Gonna"]}, {"input": "combination Combination", "output": ["combo Combo"]}, {"input": "probably Probably probably Probably probably Probably probably Probably probably Probably", "output": ["prolly Prolly prolly Prolly prolly Prolly prolly Prolly prolly Prolly"]}, {"input": "i am I am i am I am i am I am i am I am i am I am i am I am", "output": ["i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm i'm I'm"]}, {"input": "instagram Instagram instagram Instagram instagram Instagram instagram Instagram instagram Instagram", "output": ["insta Insta insta Insta insta Insta insta Insta insta Insta"]}, {"input": "do not Do not do not Do not do not Do not do not Do not", "output": ["don't Don't don't Don't don't Don't don't Don't"]}, {"input": "Going to going to Going to Going to going to Going to Going to going to Going to", "output": ["Gonna gonna Gonna Gonna gonna Gonna Gonna gonna Gonna"]}, {"input": "combination combination Combination combination Combination", "output": ["combo combo Combo combo Combo"]}], "starter_code": "\ndef gym_slang(phrase):\n\t", "source_codes": ["\nimport re\n\ndef gymSlang(phrase):\n    # Replace \"probably\" to \"prolly\" \n    phrase = re.sub(r'\\b[Pp]robably\\b', lambda m: \"Prolly\" if m.group()[0].isupper() else \"prolly\", phrase)\n    \n    # Replace \"i am\" to \"i'm\"\n    phrase = re.sub(r'\\b[Ii] am\\b', lambda m: \"I'm\" if m.group()[0].isupper() else \"i'm\", phrase)\n    \n    # Replace \"instagram\" to \"insta\"\n    phrase = re.sub(r'\\b[Ii]nstagram\\b', lambda m: \"Insta\" if m.group()[0].isupper() else \"insta\", phrase)\n    \n    # Replace \"do not\" to \"don't\"\n    phrase = re.sub(r'\\b[Dd]o not\\b', lambda m: \"Don't\" if m.group()[0].isupper() else \"don't\", phrase)\n    \n    # Replace \"going to\" to \"gonna\"\n    phrase = re.sub(r'\\b[Gg]oing to\\b', lambda m: \"Gonna\" if m.group()[0].isupper() else \"gonna\", phrase)\n    \n    # Replace \"combination\" to \"combo\"\n    phrase = re.sub(r'\\b[Cc]ombination\\b', lambda m: \"Combo\" if m.group()[0].isupper() else \"combo\", phrase)\n    \n    return phrase\n\n# Read input and process\ninput_phrase = input()\nresult = gymSlang(input_phrase)\nprint(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. Create a function `gymSlang` that takes a string and replaces specific words with slang versions\n2. The replacements should be case-sensitive for the original patterns (only lowercase)\n3. But we also need to handle correctly capitalized versions (first letter uppercase)\n4. Must use RegExp replace operations\n5. The replacements are:\n   - \"probably\" \u2192 \"prolly\" \n   - \"i am\" \u2192 \"i'm\"\n   - \"instagram\" \u2192 \"insta\"\n   - \"do not\" \u2192 \"don't\"\n   - \"going to\" \u2192 \"gonna\"\n   - \"combination\" \u2192 \"combo\"\n\n## Approach\n\n1. Use regular expressions with word boundaries to match exact words\n2. Handle both lowercase and capitalized versions\n3. For each replacement, I'll create a pattern that matches both cases and replace appropriately\n\n## Step-by-step Solution\n\n### Step 1: Import required modules\nWe'll need the `re` module for regular expressions.\n\n### Step 2: Define the gymSlang function\n- Take a string input\n- Apply regex replacements in sequence\n\n### Step 3: Handle capitalization\n- Match both lowercase and capitalized versions\n- Preserve the capitalization in the replacement\n\n### Step 4: Use word boundaries\n- Use `\\b` to ensure we match whole words only\n\nLet me implement this:\n\n```python\nimport re\n\ndef gymSlang(phrase):\n    # Replace \"probably\" to \"prolly\" (and \"Probably\" to \"Prolly\")\n    phrase = re.sub(r'\\b[Pp]robably\\b', lambda m: \"Prolly\" if m.group()[0].isupper() else \"prolly\", phrase)\n    \n    # Replace \"i am\" to \"i'm\" (and \"I am\" to \"I'm\")\n    phrase = re.sub(r'\\b[Ii] am\\b', lambda m: \"I'm\" if m.group()[0].isupper() else \"i'm\", phrase)\n    \n    # Replace \"instagram\" to \"insta\" (and \"Instagram\" to \"Insta\")\n    phrase = re.sub(r'\\b[Ii]nstagram\\b', lambda m: \"Insta\" if m.group()[0].isupper() else \"insta\", phrase)\n    \n    # Replace \"do not\" to \"don't\" (and \"Do not\" to \"Don't\")\n    phrase = re.sub(r'\\b[Dd]o not\\b', lambda m: \"Don't\" if m.group()[0].isupper() else \"don't\", phrase)\n    \n    # Replace \"going to\" to \"gonna\" (and \"Going to\" to \"Gonna\")\n    phrase = re.sub(r'\\b[Gg]oing to\\b', lambda m: \"Gonna\" if m.group()[0].isupper() else \"gonna\", phrase)\n    \n    # Replace \"combination\" to \"combo\" (and \"Combination\" to \"Combo\")\n    phrase = re.sub(r'\\b[Cc]ombination\\b', lambda m: \"Combo\" if m.group()[0].isupper() else \"combo\", phrase)\n    \n    return phrase\n\n# Read input and process\nif __name__ == \"__main__\":\n    input_phrase = input()\n    result = gymSlang(input_phrase)\n    print(result)\n```\n\nWait, let me reconsider the approach. Looking at the sample more carefully:\n\nFor \"Probably\" \u2192 \"Prolly\", it's not just about the first letter - we need to preserve the capitalization pattern properly.\n\nActually, let me check the examples again:\n- \"Probably\" should become \"Prolly\" \n- \"probably\" should become \"prolly\"\n\nSo I need to check if the matched word starts with uppercase, and if so, the replacement should also start with uppercase.\n\nMy approach looks correct. Let me finalize the solution:\n\n```python\nimport re\n\ndef gymSlang(phrase):\n    # Replace \"probably\" to \"prolly\" \n    phrase = re.sub(r'\\b[Pp]robably\\b', lambda m: \"Prolly\" if m.group()[0].isupper() else \"prolly\", phrase)\n    \n    # Replace \"i am\" to \"i'm\"\n    phrase = re.sub(r'\\b[Ii] am\\b', lambda m: \"I'm\" if m.group()[0].isupper() else \"i'm\", phrase)\n    \n    # Replace \"instagram\" to \"insta\"\n    phrase = re.sub(r'\\b[Ii]nstagram\\b', lambda m: \"Insta\" if m.group()[0].isupper() else \"insta\", phrase)\n    \n    # Replace \"do not\" to \"don't\"\n    phrase = re.sub(r'\\b[Dd]o not\\b', lambda m: \"Don't\" if m.group()[0].isupper() else \"don't\", phrase)\n    \n    # Replace \"going to\" to \"gonna\"\n    phrase = re.sub(r'\\b[Gg]oing to\\b', lambda m: \"Gonna\" if m.group()[0].isupper() else \"gonna\", phrase)\n    \n    # Replace \"combination\" to \"combo\"\n    phrase = re.sub(r'\\b[Cc]ombination\\b', lambda m: \"Combo\" if m.group()[0].isupper() else \"combo\", phrase)\n    \n    return phrase\n\n# Read input and process\ninput_phrase = input()\nresult = gymSlang(input_phrase)\nprint(result)\n```"], "prompt_tokens": [575], "completion_tokens": [1170], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": 3884}
