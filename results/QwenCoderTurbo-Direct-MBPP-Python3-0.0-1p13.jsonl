{"name": "mbpp_568_empty_list", "language": "Python3", "prompt": "from typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n\tWrite a function to create a list of N empty dictionaries.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "empty_list", "test": "def check(candidate):\n    assert candidate(5) == [{  }, {  }, {  }, {  }, {  }]\n    assert candidate(6) == [{  }, {  }, {  }, {  }, {  }, {  }]\n    assert candidate(7) == [{  }, {  }, {  }, {  }, {  }, {  }, {  }]\n\ndef test_check():\n    check(empty_list)\n\ntest_check()\n", "sample_io": ["assert empty_list(5) == [{  }, {  }, {  }, {  }, {  }]"], "source_codes": ["\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n\n\n"], "responses": ["Looking at this problem, I need to create a function that returns a list of N empty dictionaries.\n\nLet me analyze the type hint:\n- `List[Dict[None, None]]` - This suggests a list where each element is a dictionary with keys of type `None` and values of type `None`\n\nHowever, this type hint seems unusual. Typically, we'd want empty dictionaries that can hold any key-value pairs, which would be `List[Dict[Any, Any]]` or simply `List[dict]`.\n\nGiven the function description \"create a list of N empty dictionaries\", I'll implement it to create N completely empty dictionaries:\n\n```python\nfrom typing import List, Dict\n\ndef empty_list(length: int) -> List[Dict[None, None]]:\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(length)]\n```\n\nThis solution:\n1. Uses a list comprehension to create `length` number of empty dictionaries\n2. Each `{}` is an empty dictionary\n3. Returns the list of these empty dictionaries\n\nThe function will work correctly even with the somewhat restrictive type hint `Dict[None, None]` since empty dictionaries are compatible with any dictionary type annotation."], "prompt_tokens": [59], "completion_tokens": [256], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_568_empty_list"}
{"name": "mbpp_285_text_match_two_three", "language": "Python3", "prompt": "def text_match_two_three(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_two_three", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n\ndef test_check():\n    check(text_match_two_three)\n\ntest_check()\n", "sample_io": ["assert text_match_two_three('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    # Pattern: 'a' followed by exactly 2 or 3 'b' characters\n    # Using {2,3} quantifier to match 2 to 3 occurrences of 'b'\n    pattern = r'ab{2,3}'\n    \n    # Check if the pattern exists anywhere in the text\n    return bool(re.search(pattern, text))\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(text_match_two_three(\"ab\"))        # False - only 1 'b'\n    print(text_match_two_three(\"abb\"))       # True - 'a' + 2 'b'\n    print(text_match_two_three(\"abbb\"))      # True - 'a' + 3 'b'\n    print(text_match_two_three(\"abbbb\"))     # True - contains 'a' + 3 'b' (first 3 b's)\n    print(text_match_two_three(\"aabbb\"))     # True - contains 'a' + 3 'b'\n    print(text_match_two_three(\"xyzabb123\")) # True - contains 'a' + 2 'b'\n    print(text_match_two_three(\"ac\"))        # False - no 'b' after 'a'\n    print(text_match_two_three(\"bb\"))        # False - no 'a'\n\n\n"], "responses": ["Looking at this problem, I need to check if a string contains the pattern 'a' followed by exactly 2 or 3 'b' characters.\n\nLet me break down the requirements:\n- Find 'a' character\n- Followed by exactly 2 or 3 'b' characters (not more, not less)\n- This should be checked anywhere in the string\n\nI'll use regular expressions for this pattern matching:\n\n```python\nimport re\n\ndef text_match_two_three(text: str) -> bool:\n    \"\"\"\n    Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \"\"\"\n    # Pattern: 'a' followed by exactly 2 or 3 'b' characters\n    # Using {2,3} quantifier to match 2 to 3 occurrences of 'b'\n    pattern = r'ab{2,3}'\n    \n    # Check if the pattern exists anywhere in the text\n    return bool(re.search(pattern, text))\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(text_match_two_three(\"ab\"))        # False - only 1 'b'\n    print(text_match_two_three(\"abb\"))       # True - 'a' + 2 'b'\n    print(text_match_two_three(\"abbb\"))      # True - 'a' + 3 'b'\n    print(text_match_two_three(\"abbbb\"))     # True - contains 'a' + 3 'b' (first 3 b's)\n    print(text_match_two_three(\"aabbb\"))     # True - contains 'a' + 3 'b'\n    print(text_match_two_three(\"xyzabb123\")) # True - contains 'a' + 2 'b'\n    print(text_match_two_three(\"ac\"))        # False - no 'b' after 'a'\n    print(text_match_two_three(\"bb\"))        # False - no 'a'\n```\n\nThe solution uses:\n- `r'ab{2,3}'` pattern where:\n  - `a` matches the literal character 'a'\n  - `b{2,3}` matches exactly 2 to 3 occurrences of 'b'\n- `re.search()` to find the pattern anywhere in the string\n- Returns `True` if pattern is found, `False` otherwise\n\nThis correctly identifies strings containing 'a' followed by exactly 2 or 3 'b' characters."], "prompt_tokens": [60], "completion_tokens": [511], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_285_text_match_two_three"}
{"name": "mbpp_721_maxAverageOfPath", "language": "Python3", "prompt": "from typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "maxAverageOfPath", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n    assert candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2\n    assert candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8\n\ndef test_check():\n    check(maxAverageOfPath)\n\ntest_check()\n", "sample_io": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"], "source_codes": ["\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. \n    A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down \n    and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. \n    Average is computed as total cost divided by the number of cells visited in the path.\n    \"\"\"\n    if not cost or not cost[0]:\n        return 0.0\n    \n    n = len(cost)\n    \n    # Create DP table to store maximum sum to reach each cell\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize starting point\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the table\n    for i in range(1, n):\n        for j in range(1, n):\n            # Take maximum of coming from above or from left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Maximum sum path is in dp[n-1][n-1]\n    max_sum = dp[n-1][n-1]\n    \n    # Number of cells in any path from top-left to bottom-right\n    path_length = 2 * n - 1\n    \n    # Return maximum average\n    return max_sum / path_length\n\n\n"], "responses": ["Looking at this problem, I need to find the path from top-left to bottom-right (moving only right or down) that maximizes the average cost per cell.\n\nSince all paths from top-left to bottom-right in an N\u00d7N matrix have exactly the same length (2N-1 cells), maximizing the average is equivalent to maximizing the total sum. This is because:\n- Average = Total Sum / Number of Cells\n- Number of cells is constant (= 2N-1) for all paths\n\nSo I can use dynamic programming to find the maximum sum path, then divide by the path length.\n\n```python\nfrom typing import List\n\ndef maxAverageOfPath(cost: List[List[int]]) -> float:\n    \"\"\"\n    Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. \n    A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down \n    and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. \n    Average is computed as total cost divided by the number of cells visited in the path.\n    \"\"\"\n    if not cost or not cost[0]:\n        return 0.0\n    \n    n = len(cost)\n    \n    # Create DP table to store maximum sum to reach each cell\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize starting point\n    dp[0][0] = cost[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    # Fill the rest of the table\n    for i in range(1, n):\n        for j in range(1, n):\n            # Take maximum of coming from above or from left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    # Maximum sum path is in dp[n-1][n-1]\n    max_sum = dp[n-1][n-1]\n    \n    # Number of cells in any path from top-left to bottom-right\n    path_length = 2 * n - 1\n    \n    # Return maximum average\n    return max_sum / path_length\n```\n\nThe algorithm works as follows:\n\n1. **Dynamic Programming Approach**: Use a 2D DP table where `dp[i][j]` represents the maximum sum to reach cell `(i,j)` from `(0,0)`.\n\n2. **Base Case**: `dp[0][0] = cost[0][0]`\n\n3. **Fill First Row**: Each cell can only be reached from the left neighbor.\n\n4. **Fill First Column**: Each cell can only be reached from the above neighbor.\n\n5. **Fill Remaining Cells**: For each cell `(i,j)`, we can come either from `(i-1,j)` or `(i,j-1)`, so we take the maximum of these two options plus the current cell's cost.\n\n6. **Calculate Average**: The maximum sum is `dp[n-1][n-1]`, and since all paths have the same length (2N-1), we divide by this constant.\n\n**Time Complexity**: O(N\u00b2)  \n**Space Complexity**: O(N\u00b2)\n\n**Key Insight**: Since all valid paths have exactly the same number of cells (2N-1), maximizing the average is equivalent to maximizing the total sum, which allows us to use standard maximum path sum dynamic programming."], "prompt_tokens": [130], "completion_tokens": [802], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_721_maxAverageOfPath"}
{"name": "mbpp_797_sum_in_range", "language": "Python3", "prompt": "def sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of all odd natural numbers within the range l and r.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_in_range", "test": "def check(candidate):\n    assert candidate(2, 5) == 8\n    assert candidate(5, 7) == 12\n    assert candidate(7, 13) == 40\n\ndef test_check():\n    check(sum_in_range)\n\ntest_check()\n", "sample_io": ["assert sum_in_range(2, 5) == 8"], "source_codes": ["\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of all odd natural numbers within the range l and r.\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:  # Check if the number is odd\n            total += i\n    return total\n\n\n"], "responses": ["```python\ndef sum_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Write a python function to find the sum of all odd natural numbers within the range l and r.\n    \"\"\"\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 1:  # Check if the number is odd\n            total += i\n    return total\n```\n\nThis function works by:\n1. Initializing a variable `total` to store the sum\n2. Iterating through all numbers from `l` to `r` (inclusive)\n3. Checking if each number is odd using the modulo operator (`% 2 == 1`)\n4. Adding odd numbers to the running total\n5. Returning the final sum\n\nExample usage:\n- `sum_in_range(1, 10)` would return `25` (1 + 3 + 5 + 7 + 9 = 25)\n- `sum_in_range(2, 8)` would return `15` (3 + 5 + 7 = 15)"], "prompt_tokens": [59], "completion_tokens": [234], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_797_sum_in_range"}
{"name": "mbpp_4_heap_queue_largest", "language": "Python3", "prompt": "from typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_queue_largest", "test": "def check(candidate):\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n\ndef test_check():\n    check(heap_queue_largest)\n\ntest_check()\n", "sample_io": ["assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"], "source_codes": ["\n# Example 1\nnums = [3, 1, 4, 1, 5, 9, 2, 6]\nn = 3\nresult = heap_queue_largest(nums, n)\nprint(result)  # Output: [9, 6, 5]\n\n# Example 2\nnums = [10, 20, 30, 40, 50]\nn = 2\nresult = heap_queue_largest(nums, n)\nprint(result)  # Output: [50, 40]\n\n\n"], "responses": ["Looking at this problem, I need to find the n largest integers from a list and return them in descending order. I'll use Python's `heapq` module which provides efficient heap operations.\n\n```python\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    # Handle edge cases\n    if not nums or n <= 0:\n        return []\n    \n    # If n is greater than the length of nums, return all elements sorted in descending order\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to get the n largest elements in descending order\n    return heapq.nlargest(n, nums)\n```\n\nThe solution works as follows:\n\n1. **Edge case handling**: Check for empty lists or invalid n values\n2. **Boundary condition**: If n is larger than the list size, return all elements sorted in descending order\n3. **Main logic**: Use `heapq.nlargest(n, nums)` which efficiently finds the n largest elements and returns them in descending order\n\n**Time Complexity**: O(n log k) where k is the number of elements we want (n parameter), but since we're using `nlargest`, it's actually O(len(nums) log n)\n**Space Complexity**: O(n) for the result list\n\n**Example usage**:\n```python\n# Example 1\nnums = [3, 1, 4, 1, 5, 9, 2, 6]\nn = 3\nresult = heap_queue_largest(nums, n)\nprint(result)  # Output: [9, 6, 5]\n\n# Example 2\nnums = [10, 20, 30, 40, 50]\nn = 2\nresult = heap_queue_largest(nums, n)\nprint(result)  # Output: [50, 40]\n```"], "prompt_tokens": [68], "completion_tokens": [432], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_4_heap_queue_largest"}
{"name": "mbpp_120_max_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 200\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 484\n\ndef test_check():\n    check(max_product_tuple)\n\ntest_check()\n", "sample_io": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"], "source_codes": ["\n# Test cases\nprint(max_product_tuple([(2, 3), (-4, 5), (6, -7)]))  # Output: 42 (|6 * -7| = 42)\nprint(max_product_tuple([(-1, -2), (3, 4), (-5, 6)])) # Output: 30 (|-5 * 6| = 30)\nprint(max_product_tuple([(0, 5), (2, 3)]))            # Output: 6 (|2 * 3| = 6)\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Find the absolute product of each tuple pair\n2. Return the maximum of these products\n\nLet me trace through what this means:\n- For each tuple like (a, b), calculate |a * b|\n- Find the maximum among all these absolute products\n\nHere's my solution:\n\n```python\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    max_product = float('-inf')\n    \n    for tuple_pair in list1:\n        # Calculate absolute product of the two numbers in the tuple\n        product = abs(tuple_pair[0] * tuple_pair[1])\n        max_product = max(max_product, product)\n    \n    return max_product\n```\n\nLet me also provide a more concise version using built-in functions:\n\n```python\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    return max(abs(a * b) for a, b in list1)\n```\n\nExample usage:\n```python\n# Test cases\nprint(max_product_tuple([(2, 3), (-4, 5), (6, -7)]))  # Output: 42 (|6 * -7| = 42)\nprint(max_product_tuple([(-1, -2), (3, 4), (-5, 6)])) # Output: 30 (|-5 * 6| = 30)\nprint(max_product_tuple([(0, 5), (2, 3)]))            # Output: 6 (|2 * 3| = 6)\n```\n\nThe second version is more Pythonic and concise, using a generator expression with `max()` to find the maximum absolute product directly."], "prompt_tokens": [68], "completion_tokens": [454], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_120_max_product_tuple"}
{"name": "mbpp_230_replace_blank", "language": "Python3", "prompt": "def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n\tWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_blank", "test": "def check(candidate):\n    assert candidate('hello people', '@') == 'hello@people'\n    assert candidate('python program language', '$') == 'python$program$language'\n    assert candidate('blank space', '-') == 'blank-space'\n\ndef test_check():\n    check(replace_blank)\n\ntest_check()\n", "sample_io": ["assert replace_blank('hello people', '@') == 'hello@people'"], "source_codes": ["\n# Example 1\nresult1 = replace_blank(\"hello world\", \"*\")\nprint(result1)  # Output: \"hello*world\"\n\n# Example 2\nresult2 = replace_blank(\"The quick brown fox\", \"_\")\nprint(result2)  # Output: \"The_quick_brown_fox\"\n\n# Example 3\nresult3 = replace_blank(\"no spaces here\", \"-\")\nprint(result3)  # Output: \"no-spaces-here\"\n\n\n"], "responses": ["```python\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n```\n\nThis function works by using Python's built-in `replace()` method, which replaces all occurrences of the first argument (in this case, a space character `' '`) with the second argument (the replacement character `char`).\n\nExample usage:\n```python\n# Example 1\nresult1 = replace_blank(\"hello world\", \"*\")\nprint(result1)  # Output: \"hello*world\"\n\n# Example 2\nresult2 = replace_blank(\"The quick brown fox\", \"_\")\nprint(result2)  # Output: \"The_quick_brown_fox\"\n\n# Example 3\nresult3 = replace_blank(\"no spaces here\", \"-\")\nprint(result3)  # Output: \"no-spaces-here\"\n```"], "prompt_tokens": [65], "completion_tokens": [207], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_230_replace_blank"}
{"name": "mbpp_600_is_Even", "language": "Python3", "prompt": "def is_Even(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Even", "test": "def check(candidate):\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(3) == False\n\ndef test_check():\n    check(is_Even)\n\ntest_check()\n", "sample_io": ["assert is_Even(1) == False"], "source_codes": ["\nprint(is_Even(4))   # True\nprint(is_Even(7))   # False\nprint(is_Even(0))   # True\nprint(is_Even(-2))  # True\nprint(is_Even(-3))  # False\n\n\n"], "responses": ["```python\ndef is_Even(n: int) -> bool:\n    \"\"\"\n    Write a python function to check whether the given number is even or not.\n    \"\"\"\n    return n % 2 == 0\n```\n\nThis function works by using the modulo operator (`%`) to check if the remainder when dividing by 2 is equal to 0. If the remainder is 0, the number is even and the function returns `True`. Otherwise, it returns `False`.\n\nExample usage:\n```python\nprint(is_Even(4))   # True\nprint(is_Even(7))   # False\nprint(is_Even(0))   # True\nprint(is_Even(-2))  # True\nprint(is_Even(-3))  # False\n```"], "prompt_tokens": [50], "completion_tokens": [160], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_600_is_Even"}
