{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n\n\n"], "responses": ["Looking at this problem, I need to remove all words that have exactly length K from the given string.\n\nHere's my solution:\n\n```python\ndef remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n    Write a function to remove all the words with k length in the given string.\n    \"\"\"\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n```\n\nLet me trace through an example to show how it works:\n- If `test_str = \"hello world python code\"` and `K = 5`\n- `words = [\"hello\", \"world\", \"python\", \"code\"]`\n- Words with length 5: \"hello\", \"world\", \"code\"\n- Remaining words: [\"python\"]\n- Result: \"python\"\n\nThe function handles edge cases like:\n- Empty strings (returns empty string)\n- No words of length K (returns original string)\n- All words have length K (returns empty string)\n- Multiple spaces between words (preserves single spaces in output)"], "prompt_tokens": [55], "completion_tokens": [257], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth jacobsthal number. \n    https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ \n    0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use the recurrence relation: J(n) = J(n-1) + 2*J(n-2)\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test the first few Jacobsthal numbers\n    expected = [0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731]\n    for i, exp in enumerate(expected):\n        result = jacobsthal_num(i)\n        print(f\"J({i}) = {result} {'\u2713' if result == exp else '\u2717'}\")\n\n\n"], "responses": ["Looking at the Jacobsthal sequence: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\nI can see the pattern:\n- J(0) = 0\n- J(1) = 1\n- J(n) = J(n-1) + 2\u00d7J(n-2) for n \u2265 2\n\nLet me verify this with a few examples:\n- J(2) = J(1) + 2\u00d7J(0) = 1 + 2\u00d70 = 1 \u2713\n- J(3) = J(2) + 2\u00d7J(1) = 1 + 2\u00d71 = 3 \u2713\n- J(4) = J(3) + 2\u00d7J(2) = 3 + 2\u00d71 = 5 \u2713\n\nHere's the implementation:\n\n```python\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Write a function to find the nth jacobsthal number. \n    https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ \n    0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # For n >= 2, use the recurrence relation: J(n) = J(n-1) + 2*J(n-2)\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test the first few Jacobsthal numbers\n    expected = [0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731]\n    for i, exp in enumerate(expected):\n        result = jacobsthal_num(i)\n        print(f\"J({i}) = {result} {'\u2713' if result == exp else '\u2717'}\")\n```\n\nThis implementation uses an iterative approach with O(n) time complexity and O(1) space complexity, which is efficient for computing Jacobsthal numbers."], "prompt_tokens": [131], "completion_tokens": [624], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum difference between any two elements in a given array.\n    \"\"\"\n    # Handle edge case of empty array or single element\n    if len(arr) <= 1:\n        return 0\n    \n    # Find the maximum and minimum elements\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the absolute difference\n    return max_val - min_val\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum absolute difference between any two elements in an array. The most efficient approach is to find the maximum and minimum values in the array and return their difference.\n\n```python\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the maximum difference between any two elements in a given array.\n    \"\"\"\n    # Handle edge case of empty array or single element\n    if len(arr) <= 1:\n        return 0\n    \n    # Find the maximum and minimum elements\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the absolute difference\n    return max_val - min_val\n```\n\nThis solution works by:\n\n1. First checking edge cases where the array has 0 or 1 elements (return 0 in these cases)\n2. Finding the maximum value in the array using `max()`\n3. Finding the minimum value in the array using `min()`\n4. Returning the difference between max and min values\n\nThe time complexity is O(n) where n is the length of the array, since we need to scan through all elements to find the max and min values. The space complexity is O(1) as we only use a constant amount of extra space.\n\nExample usage:\n- `max_Abs_Diff([1, 2, 3, 4, 5])` returns `4` (5 - 1)\n- `max_Abs_Diff([10, -5, 3, 8])` returns `15` (10 - (-5))\n- `max_Abs_Diff([7])` returns `0` (only one element)"], "prompt_tokens": [61], "completion_tokens": [361], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Find two numbers that appear exactly once in a list where all other numbers appear twice.\n    \n    Args:\n        nums: List of integers where exactly two numbers appear once and others appear twice\n        \n    Returns:\n        List containing the two unique numbers (in any order)\n    \"\"\"\n    # XOR all numbers to get XOR of the two unique numbers\n    xor_result = 0\n    for num in nums:\n        xor_result ^= num\n    \n    # Find a bit that is set in xor_result (this bit differs between the two unique numbers)\n    diff_bit = xor_result & (-xor_result)  # Get the rightmost set bit\n    \n    # Partition numbers into two groups based on the diff_bit\n    num1 = 0\n    num2 = 0\n    \n    for num in nums:\n        if num & diff_bit:\n            num1 ^= num  # XOR of first group\n        else:\n            num2 ^= num  # XOR of second group\n    \n    return [num1, num2]\n\n\n"], "responses": ["Looking at the problem description and function name, I need to create a function that finds two unique numbers from a list. However, the description mentions \"remove duplicate numbers from a given number of lists\" which seems inconsistent with the function name \"two_unique_nums\".\n\nBased on the function name and typical coding problems, I believe this is asking to find two numbers that appear exactly once in a list where all other numbers appear twice.\n\nHere's my solution:\n\n```python\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Find two numbers that appear exactly once in a list where all other numbers appear twice.\n    \n    Args:\n        nums: List of integers where exactly two numbers appear once and others appear twice\n        \n    Returns:\n        List containing the two unique numbers (in any order)\n    \"\"\"\n    # XOR all numbers to get XOR of the two unique numbers\n    xor_result = 0\n    for num in nums:\n        xor_result ^= num\n    \n    # Find a bit that is set in xor_result (this bit differs between the two unique numbers)\n    diff_bit = xor_result & (-xor_result)  # Get the rightmost set bit\n    \n    # Partition numbers into two groups based on the diff_bit\n    num1 = 0\n    num2 = 0\n    \n    for num in nums:\n        if num & diff_bit:\n            num1 ^= num  # XOR of first group\n        else:\n            num2 ^= num  # XOR of second group\n    \n    return [num1, num2]\n```\n\nThis solution works by:\n1. XORing all numbers to get the XOR of the two unique numbers (since pairs cancel out)\n2. Finding a bit position where the two unique numbers differ\n3. Partitioning all numbers into two groups based on that bit\n4. XORing each group separately to isolate the two unique numbers\n\nTime complexity: O(n), Space complexity: O(1)"], "prompt_tokens": [57], "completion_tokens": [401], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Write a python function to count the number of pairs whose xor value is odd.\n    \"\"\"\n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Pairs with odd XOR are those where one is even and other is odd\n    return even_count * odd_count\n\n\n"], "responses": ["Looking at this problem, I need to count pairs whose XOR value is odd.\n\nLet me think about when XOR of two numbers is odd:\n- XOR is odd when one number is even and the other is odd\n- XOR is even when both numbers are even or both are odd\n\nSo I need to count pairs where one element is even and the other is odd.\n\nHere's my approach:\n1. Count the number of even and odd numbers in the array\n2. The number of pairs with odd XOR = (count of even numbers) \u00d7 (count of odd numbers)\n\n```python\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n    Write a python function to count the number of pairs whose xor value is odd.\n    \"\"\"\n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Pairs with odd XOR are those where one is even and other is odd\n    return even_count * odd_count\n```\n\nThe logic is:\n- For each even number, it can pair with any odd number to produce an odd XOR\n- For each odd number, it can pair with any even number to produce an odd XOR\n- So total pairs = (number of even elements) \u00d7 (number of odd elements)\n\nTime complexity: O(N)\nSpace complexity: O(1)"], "prompt_tokens": [63], "completion_tokens": [319], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": ["\n# arr = [1, 101, 2, 3, 100, 4, 5], index = 3, k = 5\n# Prefix: [1, 101, 2, 3], must include a[5] = 4\n# Valid subsequences: [1], [1,2], [1,2,3], [2], [3]\n# Best that can extend to 4: [1,2,3] with sum 6\n# Final result: 6 + 4 = 10\n\n\n"], "responses": ["Looking at this problem, I need to find the maximum sum of an increasing subsequence that:\n1. Comes from the prefix up to index `i`\n2. Must include the kth element (where k > i)\n\nLet me break this down:\n- I need to find the best increasing subsequence in `a[0:i+1]` \n- This subsequence must be able to extend to include `a[k]`\n- Since it's an increasing subsequence, the last element must be \u2264 `a[k]`\n\nHere's my approach:\n1. Use dynamic programming to find the maximum sum increasing subsequence ending at each position in the prefix\n2. Only consider subsequences that can be extended to include `a[k]` (last element \u2264 `a[k]`)\n3. Return the maximum among valid subsequences plus `a[k]`\n\n```python\nfrom typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n    Find the maximum sum of increasing subsequence from prefix until ith index \n    and also including a given kth element which is after i, i.e., k > i.\n    \n    Args:\n        a: List of integers\n        n: Length of the array\n        index: The ith index (prefix boundary)\n        k: The kth element that must be included\n    \n    Returns:\n        Maximum sum of valid increasing subsequence including a[k]\n    \"\"\"\n    # Handle edge cases\n    if k >= n or index >= k or index < 0:\n        return 0\n    \n    # If kth element is negative and we can't form a valid subsequence, return just a[k]\n    target_value = a[k]\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at position i\n    dp = [0] * (index + 1)\n    \n    # Initialize dp array\n    for i in range(index + 1):\n        dp[i] = a[i]\n    \n    # Fill dp array using dynamic programming\n    for i in range(1, index + 1):\n        for j in range(i):\n            # If we can extend the subsequence ending at j to include element at i\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find the maximum sum subsequence that can be extended to include a[k]\n    max_prefix_sum = 0\n    for i in range(index + 1):\n        # Check if the subsequence ending at position i can be extended to include a[k]\n        if a[i] <= target_value:\n            max_prefix_sum = max(max_prefix_sum, dp[i])\n    \n    # Return the maximum sum including the kth element\n    return max_prefix_sum + target_value\n```\n\nThe algorithm works as follows:\n\n1. **Initialize**: Create a DP array where `dp[i]` represents the maximum sum of increasing subsequence ending at position `i` within the prefix.\n\n2. **Base case**: Each element by itself forms a subsequence with sum equal to its value.\n\n3. **Fill DP table**: For each position, check all previous positions and extend subsequences if they maintain the increasing property.\n\n4. **Find valid prefix**: Among all possible subsequences in the prefix, select those whose last element is \u2264 `a[k]` (so they can be extended).\n\n5. **Return result**: Add the value of `a[k]` to the best valid prefix sum.\n\n**Time Complexity**: O(index\u00b2)  \n**Space Complexity**: O(index)\n\n**Example usage**:\n```python\n# arr = [1, 101, 2, 3, 100, 4, 5], index = 3, k = 5\n# Prefix: [1, 101, 2, 3], must include a[5] = 4\n# Valid subsequences: [1], [1,2], [1,2,3], [2], [3]\n# Best that can extend to 4: [1,2,3] with sum 6\n# Final result: 6 + 4 = 10\n```"], "prompt_tokens": [93], "completion_tokens": [887], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Find the highest power of 2 <= n\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n\n\n"], "responses": ["Looking at this problem, I need to find the highest power of 2 that is less than or equal to n.\n\nFor example:\n- If n = 10, the powers of 2 are: 1, 2, 4, 8, 16, ... The highest one \u2264 10 is 8\n- If n = 16, the answer would be 16 itself\n\nHere are a few approaches to solve this:\n\n```python\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Method 1: Using bit manipulation (most efficient)\n    # Find the position of the most significant bit\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    return 1 << power\n\n# Alternative implementation using bit operations\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Method 2: More concise bit manipulation\n    # Keep shifting right until we get 1, count the shifts\n    n_copy = n\n    result = 1\n    while n_copy > 1:\n        result <<= 1  # Multiply by 2\n        n_copy >>= 1  # Divide by 2\n    return result\n\n# Another clean approach\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Method 3: Using logarithms (conceptual)\n    # power = int(math.log2(n))\n    # return 2 ** power\n    \n    # Method 4: Bit manipulation - find the MSB\n    power = 0\n    temp = n\n    while temp > 1:\n        temp >>= 1\n        power += 1\n    return 1 << power\n\n# Simple and clean final solution\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Find the highest power of 2 <= n\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n```\n\nThe last implementation is the most straightforward:\n\n```python\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Write a python function to find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Find the highest power of 2 <= n\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n```\n\nThis works by:\n1. Starting with `power = 1` (which is 2^0)\n2. Keep doubling it as long as the next power of 2 is still \u2264 n\n3. Return the last valid power of 2\n\nTime complexity: O(log n)\nSpace complexity: O(1)"], "prompt_tokens": [59], "completion_tokens": [777], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    return [[a + b for a, b in zip(sublist1, sublist2)] \n            for sublist1, sublist2 in zip(test_tup1, test_tup2)]\n\n\n"], "responses": ["Looking at this problem, I need to perform element-wise addition of two nested lists (which are being treated like tuples based on the function name).\n\nHere's my solution:\n\n```python\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    result = []\n    \n    # Iterate through corresponding sublists\n    for i in range(len(test_tup1)):\n        sublist = []\n        # Iterate through corresponding elements in each sublist\n        for j in range(len(test_tup1[i])):\n            sublist.append(test_tup1[i][j] + test_tup2[i][j])\n        result.append(sublist)\n    \n    return result\n```\n\nAlternatively, here's a more concise version using list comprehension:\n\n```python\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    return [[test_tup1[i][j] + test_tup2[i][j] for j in range(len(test_tup1[i]))] \n            for i in range(len(test_tup1))]\n```\n\nOr using `zip` for even cleaner code:\n\n```python\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Write a function to perform index wise addition of list elements in the given two nested lists.\n    \"\"\"\n    return [[a + b for a, b in zip(sublist1, sublist2)] \n            for sublist1, sublist2 in zip(test_tup1, test_tup2)]\n```\n\nThe third version using `zip` is the most Pythonic and handles the indexing automatically. It assumes both input lists have the same structure (same number of sublists and same length for corresponding sublists)."], "prompt_tokens": [74], "completion_tokens": [442], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_401_add_nested_tuples"}
