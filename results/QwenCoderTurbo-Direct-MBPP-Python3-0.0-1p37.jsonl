{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["\n# Test the function\ntest_data = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nresult = cummulative_sum(test_data)\nprint(result)  # Output: 45\n\n\n"], "responses": ["Looking at this problem, I need to find the cumulative sum of all values in a list of lists.\n\nLet me break down what's needed:\n1. Iterate through each sublist in the main list\n2. Iterate through each element in each sublist\n3. Sum all the elements together\n4. Return the cumulative sum\n\nHere's the solution:\n\n```python\nfrom typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    total = 0\n    for sublist in test_list:\n        for element in sublist:\n            total += element\n    return total\n```\n\nAlternatively, here's a more concise version using nested comprehensions:\n\n```python\nfrom typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    return sum(sum(sublist) for sublist in test_list)\n```\n\nOr even more concise using itertools.chain:\n\n```python\nfrom typing import List\nimport itertools\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n    \"\"\"\n    return sum(itertools.chain.from_iterable(test_list))\n```\n\nThe first version is the most readable and straightforward. It iterates through each sublist and then each element, accumulating the total sum which is then returned.\n\nExample usage:\n```python\n# Test the function\ntest_data = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nresult = cummulative_sum(test_data)\nprint(result)  # Output: 45\n```"], "prompt_tokens": [66], "completion_tokens": [396], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["\n# Example 1: Square each number\nprint(nth_nums([1, 2, 3, 4], 2))  # Output: [1, 4, 9, 16]\n\n# Example 2: Cube each number\nprint(nth_nums([2, 3, 4], 3))     # Output: [8, 27, 64]\n\n# Example 3: Fourth power\nprint(nth_nums([1, -2, 3], 4))    # Output: [1, 16, 81]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function to compute the n-th power of each number in a list.\n    \"\"\"\n    return [num ** n for num in nums]\n```\n\nThis function takes a list of integers `nums` and an integer `n`, then returns a new list where each element is the n-th power of the corresponding element in the input list. It uses a list comprehension to efficiently compute the result.\n\nExample usage:\n```python\n# Example 1: Square each number\nprint(nth_nums([1, 2, 3, 4], 2))  # Output: [1, 4, 9, 16]\n\n# Example 2: Cube each number\nprint(nth_nums([2, 3, 4], 3))     # Output: [8, 27, 64]\n\n# Example 3: Fourth power\nprint(nth_nums([1, -2, 3], 4))    # Output: [1, 16, 81]\n```"], "prompt_tokens": [61], "completion_tokens": [238], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \n    Args:\n        n: The 32-bit number to rotate\n        d: Number of bits to rotate left\n        \n    Returns:\n        The result after left rotation\n    \"\"\"\n    # Handle cases where d is larger than 32\n    d = d % 32\n    \n    # If d is 0, no rotation needed\n    if d == 0:\n        return n\n    \n    # Create a mask for 32-bit number\n    mask = 0xFFFFFFFF\n    \n    # Take the leftmost d bits that will be rotated out\n    rotated_bits = (n >> (32 - d)) & ((1 << d) - 1)\n    \n    # Shift the number left by d bits and apply 32-bit mask\n    shifted = (n << d) & mask\n    \n    # Combine the shifted bits with the rotated bits\n    result = shifted | rotated_bits\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to perform a left bitwise rotation on a 32-bit number by `d` bits.\n\nIn a left rotation:\n- Bits that are shifted out from the left end wrap around to the right end\n- For example, if we have 8 bits `11001010` and rotate left by 2, we get `00101011`\n\nHere's my approach:\n1. Take the leftmost `d` bits that will be rotated out\n2. Shift the entire number left by `d` positions\n3. Move those saved bits to the rightmost positions\n\nHowever, since we're working with 32-bit numbers, I also need to handle cases where `d` is greater than 32 by using modulo operation.\n\n```python\ndef left_rotate(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left bits by d bits a given number. We assume that the number is 32 bit.\n    \n    Args:\n        n: The 32-bit number to rotate\n        d: Number of bits to rotate left\n        \n    Returns:\n        The result after left rotation\n    \"\"\"\n    # Handle cases where d is larger than 32\n    d = d % 32\n    \n    # If d is 0, no rotation needed\n    if d == 0:\n        return n\n    \n    # Create a mask for 32-bit number\n    mask = 0xFFFFFFFF\n    \n    # Take the leftmost d bits that will be rotated out\n    rotated_bits = (n >> (32 - d)) & ((1 << d) - 1)\n    \n    # Shift the number left by d bits and apply 32-bit mask\n    shifted = (n << d) & mask\n    \n    # Combine the shifted bits with the rotated bits\n    result = shifted | rotated_bits\n    \n    return result\n```\n\nLet me trace through an example:\n- If `n = 0b11000000000000000000000000000001` (32 bits) and `d = 2`\n- `rotated_bits = (n >> 30) & 0b11 = 0b11` (the two leftmost bits)\n- `shifted = (n << 2) & 0xFFFFFFFF = 0b00000000000000000000000000000100`\n- `result = shifted | rotated_bits = 0b00000000000000000000000000000111`\n\nThis performs the left rotation correctly by moving the leftmost bits to the rightmost positions."], "prompt_tokens": [64], "completion_tokens": [609], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": ["\ndef lps(str: str) -> int:\n    \"\"\"\n    Find the length of the longest palindromic subsequence in the given string.\n    \n    Args:\n        str: Input string\n        \n    Returns:\n        int: Length of the longest palindromic subsequence\n        \n    Examples:\n        >>> lps(\"bbbab\")\n        4\n        >>> lps(\"cbbd\")\n        2\n        >>> lps(\"a\")\n        1\n        >>> lps(\"abcdef\")\n        1\n    \"\"\"\n    n = len(str)\n    \n    # Handle edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Create a 2D DP table\n    # dp[i][j] represents the length of longest palindromic subsequence \n    # in substring from index i to j\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2 to n\n    for length in range(2, n + 1):  # length of substring\n        for i in range(n - length + 1):  # starting index\n            j = i + length - 1  # ending index\n            \n            if str[i] == str[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # Return the result for the entire string\n    return dp[0][n - 1]\n\n\n"], "responses": ["Looking at this problem, I need to find the length of the longest palindromic subsequence in a given string. This is a classic dynamic programming problem.\n\nA palindromic subsequence reads the same forwards and backwards, and a subsequence maintains the relative order of characters but doesn't need to be contiguous.\n\nI'll use dynamic programming where `dp[i][j]` represents the length of the longest palindromic subsequence in the substring from index `i` to `j`.\n\nHere's my approach:\n- If `i == j` (single character), the length is 1\n- If `str[i] == str[j]`, then `dp[i][j] = dp[i+1][j-1] + 2`\n- If `str[i] != str[j]`, then `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`\n\n```python\ndef lps(str: str) -> int:\n    \"\"\"\n    Find the length of the longest palindromic subsequence in the given string.\n    \n    Args:\n        str: Input string\n        \n    Returns:\n        int: Length of the longest palindromic subsequence\n        \n    Examples:\n        >>> lps(\"bbbab\")\n        4\n        >>> lps(\"cbbd\")\n        2\n        >>> lps(\"a\")\n        1\n        >>> lps(\"abcdef\")\n        1\n    \"\"\"\n    n = len(str)\n    \n    # Handle edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Create a 2D DP table\n    # dp[i][j] represents the length of longest palindromic subsequence \n    # in substring from index i to j\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table for substrings of length 2 to n\n    for length in range(2, n + 1):  # length of substring\n        for i in range(n - length + 1):  # starting index\n            j = i + length - 1  # ending index\n            \n            if str[i] == str[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # Return the result for the entire string\n    return dp[0][n - 1]\n```\n\nThe algorithm works as follows:\n\n1. **Base case**: Each single character forms a palindrome of length 1\n2. **Two characters**: If they're equal, length is 2; otherwise 1\n3. **Longer substrings**: \n   - If first and last characters match, add 2 to the result of the inner substring\n   - If they don't match, take the maximum of excluding either the first or last character\n\n**Time Complexity**: O(n\u00b2) where n is the length of the string\n**Space Complexity**: O(n\u00b2) for the DP table\n\nThe solution handles all edge cases including empty strings and single characters, and correctly computes the longest palindromic subsequence by considering all possible subsequences through dynamic programming."], "prompt_tokens": [55], "completion_tokens": [747], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_247_lps"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["\ndef toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits\n    bit_length = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if bit_length <= 2:\n        return n\n    \n    # Create mask with 1s for middle bits only\n    mask = ((1 << (bit_length - 2)) - 1) << 1\n    \n    # XOR to toggle middle bits\n    return n ^ mask\n\n\n"], "responses": ["Looking at this problem, I need to toggle all bits except the first (most significant) and last (least significant) bits.\n\nLet me break down the approach:\n1. Find the position of the most significant bit (MSB)\n2. Create a mask that has 1s for all middle positions and 0s for first and last positions\n3. XOR the number with this mask to toggle only the middle bits\n\nHere's my solution:\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n    \n    Args:\n        n: Integer whose middle bits need to be toggled\n        \n    Returns:\n        Integer with middle bits toggled\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the position of the most significant bit (0-indexed from right)\n    msb_pos = n.bit_length() - 1\n    \n    # If there are no middle bits (only first and last), return as is\n    if msb_pos <= 1:\n        return n\n    \n    # Create a mask with all 1s from bit 1 to bit (msb_pos - 1)\n    # This will have 1s in positions we want to toggle\n    mask = ((1 << (msb_pos - 1)) - 1) << 1\n    \n    # XOR with mask to toggle the middle bits\n    return n ^ mask\n\n# Alternative cleaner implementation:\ndef toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits\n    bit_length = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if bit_length <= 2:\n        return n\n    \n    # Create mask: all 1s except first and last bits\n    # For example, for 6 bits: 011110\n    mask = ((1 << (bit_length - 2)) - 1) << 1\n    \n    # XOR to toggle middle bits\n    return n ^ mask\n```\n\nLet me trace through an example:\n- For n = 10 (binary: 1010)\n- bit_length = 4\n- MSB position = 3\n- We want to toggle bits at positions 1 and 2 (0-indexed)\n- mask = ((1 << (4-2)) - 1) << 1 = ((1 << 2) - 1) << 1 = (4-1) << 1 = 3 << 1 = 6 (binary: 0110)\n- result = 1010 ^ 0110 = 1100 = 12\n\nThe final clean solution:\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n    \"\"\"\n    # Handle edge cases\n    if n <= 1:\n        return n\n    \n    # Find the number of bits\n    bit_length = n.bit_length()\n    \n    # If less than 3 bits, no middle bits to toggle\n    if bit_length <= 2:\n        return n\n    \n    # Create mask with 1s for middle bits only\n    mask = ((1 << (bit_length - 2)) - 1) << 1\n    \n    # XOR to toggle middle bits\n    return n ^ mask\n```"], "prompt_tokens": [73], "completion_tokens": [759], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["\n# With spaces between elements\nreturn ' '.join(tup1)\n\n# With commas between elements  \nreturn ','.join(tup1)\n\n\n"], "responses": ["Looking at the problem, I need to write a function that converts a list of strings to a single string. Based on the function name `tup_string` and the parameter name `tup1`, it seems like this might be intended to work with tuples, but the type hint shows `List[str]`.\n\nHere's the Python code to convert a list of strings to a single string:\n\n```python\nfrom typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return ''.join(tup1)\n```\n\nThis solution uses the `join()` method to concatenate all strings in the list into a single string. If you want spaces or other separators between the elements, you could modify it like this:\n\n```python\n# With spaces between elements\nreturn ' '.join(tup1)\n\n# With commas between elements  \nreturn ','.join(tup1)\n```\n\nBut based on the simple requirement to \"convert a list to a string\", the first version with no separator is the most straightforward interpretation."], "prompt_tokens": [53], "completion_tokens": [223], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["\n# Example 1\nresult = Extract([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(result)  # Output: [1, 4, 7]\n\n# Example 2\nresult = Extract([[10], [20, 30], [40, 50, 60]])\nprint(result)  # Output: [10, 20, 40]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]\n```\n\nThis function uses a list comprehension to:\n1. Iterate through each sublist in the input list\n2. Extract the first element (`sublist[0]`) from each sublist\n3. Include a safety check `if sublist` to handle empty sublists (though based on the type hint, we expect non-empty sublists)\n\nExample usage:\n```python\n# Example 1\nresult = Extract([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(result)  # Output: [1, 4, 7]\n\n# Example 2\nresult = Extract([[10], [20, 30], [40, 50, 60]])\nprint(result)  # Output: [10, 20, 40]\n```"], "prompt_tokens": [54], "completion_tokens": [230], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n# Example usage:\n# print(radian_degree(90))   # Output: 1.5707963267948966\n# print(radian_degree(180))  # Output: 3.141592653589793\n# print(radian_degree(360))  # Output: 6.283185307179586\n\n\n"], "responses": ["```python\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Write a function to convert degrees to radians.\n    \"\"\"\n    return degree * (math.pi / 180)\n\n# Example usage:\n# print(radian_degree(90))   # Output: 1.5707963267948966\n# print(radian_degree(180))  # Output: 3.141592653589793\n# print(radian_degree(360))  # Output: 6.283185307179586\n```\n\nThe function converts degrees to radians using the formula:\n**radians = degrees \u00d7 (\u03c0 / 180)**\n\nThis is the standard mathematical conversion formula where \u03c0 radians equals 180 degrees."], "prompt_tokens": [45], "completion_tokens": [192], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
