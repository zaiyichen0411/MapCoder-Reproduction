{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurrence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n\n\n"], "responses": ["Here's the Python3 code to solve the problem:\n\n```python\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurrence of the string 'std' in a given string.\n    \"\"\"\n    return s.count('std')\n```\n\nThis solution uses Python's built-in `count()` method which efficiently counts the number of non-overlapping occurrences of the substring 'std' in the given string `s`.\n\n**Alternative implementation without using built-in count():**\n\n```python\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurrence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n```\n\nBoth implementations will work correctly. The first one is more concise and efficient, while the second one shows the manual approach by checking each possible substring of length 3."], "prompt_tokens": [57], "completion_tokens": [220], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(text_match_one(\"ab\"))        # True\n    print(text_match_one(\"abb\"))       # True\n    print(text_match_one(\"abbb\"))      # True\n    print(text_match_one(\"ac\"))        # False\n    print(text_match_one(\"ba\"))        # False\n    print(text_match_one(\"abc\"))       # True\n    print(text_match_one(\"aab\"))       # True\n    print(text_match_one(\"\"))          # False\n    print(text_match_one(\"xyz\"))       # False\n\n\n"], "responses": ["Looking at this problem, I need to create a function that checks if a string contains an 'a' followed by one or more 'b's.\n\nHere's the solution using regular expressions:\n\n```python\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(text_match_one(\"ab\"))        # True\n    print(text_match_one(\"abb\"))       # True\n    print(text_match_one(\"abbb\"))      # True\n    print(text_match_one(\"ac\"))        # False\n    print(text_match_one(\"ba\"))        # False\n    print(text_match_one(\"abc\"))       # True\n    print(text_match_one(\"aab\"))       # True\n    print(text_match_one(\"\"))          # False\n    print(text_match_one(\"xyz\"))       # False\n```\n\n**Explanation:**\n- The regular expression `r'ab+'` means:\n  - `a` - matches the literal character 'a'\n  - `b+` - matches one or more 'b' characters (the `+` quantifier means \"one or more\")\n- `re.search()` looks for the pattern anywhere in the string\n- The function returns `True` if the pattern is found, `False` otherwise\n\nThe function will return `True` for strings like \"ab\", \"abb\", \"abbb\", \"abc\", \"aab\", etc., and `False` for strings that don't contain an 'a' followed by at least one 'b'."], "prompt_tokens": [54], "completion_tokens": [361], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find out the number of ways of painting the fence \n    such that at most 2 adjacent posts have the same color for the given \n    fence with n posts and k colors.\n    \"\"\"\n    # Edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 0:\n        return 0\n    \n    # For n = 1, we have k ways\n    # For n = 2, we have k * k ways (each post can be any of k colors)\n    if n == 2:\n        return k * k\n    \n    # dp_same: number of ways where last two posts have same color\n    # dp_diff: number of ways where last two posts have different colors\n    dp_same = k  # For n=2, same colors: k ways\n    dp_diff = k * (k - 1)  # For n=2, different colors: k*(k-1) ways\n    \n    # For each additional post from 3 to n\n    for i in range(3, n + 1):\n        # New dp_same: previous must be diff (to avoid 3 consecutive same), \n        # and we choose same color as previous post\n        new_dp_same = dp_diff\n        \n        # New dp_diff: previous can be same or diff, and we choose different color\n        new_dp_diff = (dp_same + dp_diff) * (k - 1)\n        \n        dp_same = new_dp_same\n        dp_diff = new_dp_diff\n    \n    return dp_same + dp_diff\n\n\n"], "responses": ["Looking at this problem, I need to find the number of ways to paint a fence with n posts using k colors, where at most 2 adjacent posts can have the same color.\n\nLet me think about this step by step:\n\n1. This is a dynamic programming problem\n2. I need to track states based on how many consecutive posts have the same color\n3. Let me define:\n   - `same`: number of ways where the last two posts have the same color\n   - `diff`: number of ways where the last two posts have different colors\n\nHere's my approach:\n- For n=1: We can paint it in k ways\n- For n=2: \n  - Same color: k ways (k choices for first post, 1 choice for second)\n  - Different colors: k*(k-1) ways\n- For n>2:\n  - If last two posts are same, the previous post must be different (to avoid 3 consecutive same)\n  - If last two posts are different, previous can be either same or different\n\n```python\ndef count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    Write a function to find out the number of ways of painting the fence \n    such that at most 2 adjacent posts have the same color for the given \n    fence with n posts and k colors.\n    \"\"\"\n    # Edge cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 0:\n        return 0\n    \n    # For n = 1, we have k ways\n    # For n = 2, we have k * k ways (each post can be any of k colors)\n    if n == 2:\n        return k * k\n    \n    # dp_same: number of ways where last two posts have same color\n    # dp_diff: number of ways where last two posts have different colors\n    dp_same = k  # For n=2, same colors: k ways\n    dp_diff = k * (k - 1)  # For n=2, different colors: k*(k-1) ways\n    \n    # For each additional post from 3 to n\n    for i in range(3, n + 1):\n        # New dp_same: previous must be diff (to avoid 3 consecutive same), \n        # and we choose same color as previous post\n        new_dp_same = dp_diff\n        \n        # New dp_diff: previous can be same or diff, and we choose different color\n        new_dp_diff = (dp_same + dp_diff) * (k - 1)\n        \n        dp_same = new_dp_same\n        dp_diff = new_dp_diff\n    \n    return dp_same + dp_diff\n```\n\nThe logic works as follows:\n\n1. **Base cases**: Handle n=0, n=1, n=2 separately\n2. **State definition**: \n   - `dp_same`: ways where the last two posts have the same color\n   - `dp_diff`: ways where the last two posts have different colors\n3. **Transitions**:\n   - To make last two posts same: previous two must be different (to avoid 3 consecutive), so `new_dp_same = dp_diff`\n   - To make last two posts different: previous can be either same or different, and we have (k-1) choices for a different color, so `new_dp_diff = (dp_same + dp_diff) * (k-1)`\n4. **Result**: Sum of both states gives total valid ways\n\nTime complexity: O(n)\nSpace complexity: O(1)"], "prompt_tokens": [78], "completion_tokens": [763], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["\n# Example 1: [2, 3, 4] with n=5\n# Product = 2 * 3 * 4 = 24\n# 24 % 5 = 4\nprint(find_remainder([2, 3, 4], 5))  # Output: 4\n\n# Example 2: [1, 2, 3] with n=6\n# Product = 1 * 2 * 3 = 6\n# 6 % 6 = 0\nprint(find_remainder([1, 2, 3], 6))  # Output: 0\n\n\n"], "responses": ["Looking at this problem, I need to find the product of all elements in the array and then take that product modulo n.\n\nHere's my solution:\n\n```python\nfrom typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        Remainder when product of array elements is divided by n\n    \"\"\"\n    # Handle edge cases\n    if not arr:\n        return 0\n    \n    if n == 1:\n        return 0\n    \n    # Calculate product modulo n\n    result = 1\n    for num in arr:\n        result = (result * num) % n\n    \n    return result\n```\n\nThe key insights in this solution are:\n\n1. **Edge case handling**: \n   - Empty array returns 0\n   - If n=1, any number mod 1 is 0\n\n2. **Modular arithmetic optimization**: Instead of calculating the entire product first (which could cause integer overflow), I apply the modulo operation at each step using the property: `(a * b) % n = ((a % n) * (b % n)) % n`\n\n3. **Efficient computation**: By taking modulo at each multiplication step, I keep the intermediate results small and avoid potential overflow issues.\n\n**Example usage:**\n```python\n# Example 1: [2, 3, 4] with n=5\n# Product = 2 * 3 * 4 = 24\n# 24 % 5 = 4\nprint(find_remainder([2, 3, 4], 5))  # Output: 4\n\n# Example 2: [1, 2, 3] with n=6\n# Product = 1 * 2 * 3 = 6\n# 6 % 6 = 0\nprint(find_remainder([1, 2, 3], 6))  # Output: 0\n```"], "prompt_tokens": [60], "completion_tokens": [435], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["\n# Test cases\nprint(check_K([1, 2, 3, 4, 5], 3))  # True\nprint(check_K([1, 2, 3, 4, 5], 6))  # False\nprint(check_K([], 1))               # False\nprint(check_K([10, 20, 30], 20))    # True\n\n\n"], "responses": ["Looking at the problem, I need to write a function that checks if a list of integers contains a specific value K.\n\nHere's the solution:\n\n```python\nfrom typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n```\n\nThis function:\n1. Takes a list of integers (`test_tup`) and an integer `K` as parameters\n2. Returns `True` if `K` is found in the list, `False` otherwise\n3. Uses Python's `in` operator which efficiently checks for membership\n\nExample usage:\n```python\n# Test cases\nprint(check_K([1, 2, 3, 4, 5], 3))  # True\nprint(check_K([1, 2, 3, 4, 5], 6))  # False\nprint(check_K([], 1))               # False\nprint(check_K([10, 20, 30], 20))    # True\n```"], "prompt_tokens": [61], "completion_tokens": [239], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given array is monotonic or not.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    increasing = all(A[i] >= A[i-1] for i in range(1, len(A)))\n    decreasing = all(A[i] <= A[i-1] for i in range(1, len(A)))\n    \n    return increasing or decreasing\n\n\n"], "responses": ["Looking at this problem, I need to check if an array is monotonic, which means it's either entirely non-decreasing or entirely non-increasing.\n\nHere's my solution:\n\n```python\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given array is monotonic or not.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is monotonic increasing\n    is_increasing = True\n    for i in range(1, len(A)):\n        if A[i] < A[i-1]:\n            is_increasing = False\n            break\n    \n    # Check if array is monotonic decreasing\n    is_decreasing = True\n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            is_decreasing = False\n            break\n    \n    return is_increasing or is_decreasing\n```\n\nAlternative more concise solution:\n\n```python\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether the given array is monotonic or not.\n    \"\"\"\n    if len(A) <= 1:\n        return True\n    \n    increasing = all(A[i] >= A[i-1] for i in range(1, len(A)))\n    decreasing = all(A[i] <= A[i-1] for i in range(1, len(A)))\n    \n    return increasing or decreasing\n```\n\nThe function works by:\n1. Handling edge cases where array has 0 or 1 elements (always monotonic)\n2. Checking if the array is monotonic increasing (each element >= previous)\n3. Checking if the array is monotonic decreasing (each element <= previous)\n4. Returning True if either condition is met\n\nTime complexity: O(n)\nSpace complexity: O(1)"], "prompt_tokens": [59], "completion_tokens": [397], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": ["\ndef parabola_directrix(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the directrix of a parabola given by y = ax\u00b2 + bx + c.\n    \n    For a parabola in the form y = ax\u00b2 + bx + c, the directrix is the line\n    y = c - (b\u00b2 + 1)/(4a).\n    \n    Args:\n        a: Coefficient of x\u00b2 (non-zero)\n        b: Coefficient of x\n        c: Constant term\n    \n    Returns:\n        The y-coordinate of the directrix line\n    \n    Example:\n        >>> parabola_directrix(1, 0, 0)  # y = x\u00b2\n        -0.25\n        >>> parabola_directrix(-1, 0, 0)  # y = -x\u00b2\n        0.25\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero for a parabola\")\n    \n    # Directrix formula: y = c - (b\u00b2 + 1)/(4a)\n    return c - (b**2 + 1) / (4 * a)\n\n\n"], "responses": ["Looking at this problem, I need to find the directrix of a parabola given in the standard form y = ax\u00b2 + bx + c.\n\nFor a parabola in the form y = ax\u00b2 + bx + c, I need to:\n1. Convert it to vertex form to identify the vertex and focus\n2. Use the relationship between the vertex, focus, and directrix\n\nLet me work through the mathematics:\n\nFor y = ax\u00b2 + bx + c:\n- The vertex is at (h, k) where h = -b/(2a) and k = c - b\u00b2/(4a)\n- For a parabola opening vertically, the distance from vertex to focus equals the distance from vertex to directrix\n- This distance is 1/(4|a|)\n- Since the parabola opens upward when a > 0 and downward when a < 0, the directrix is located accordingly\n\nThe directrix is a horizontal line y = k - 1/(4a) when a > 0, or y = k + 1/(4a) when a < 0.\nThis can be written as: y = k - 1/(4a) for all non-zero values of a.\n\nSubstituting k = c - b\u00b2/(4a):\ny = c - b\u00b2/(4a) - 1/(4a) = c - (b\u00b2 + 1)/(4a)\n\nWait, let me reconsider this more carefully.\n\nFor a parabola y = ax\u00b2 + bx + c:\n- Vertex form: y = a(x - h)\u00b2 + k\n- Where h = -b/(2a) and k = a(h)\u00b2 + bh + c = ah\u00b2 + bh + c\n- But k = c - ah\u00b2 = c - a(b\u00b2/(4a\u00b2)) = c - b\u00b2/(4a)\n\nFor a parabola with vertex (h, k) and parameter 4p (where p is the distance from vertex to focus/directrix):\n- If it's (x - h)\u00b2 = 4p(y - k), then the directrix is y = k - p\n- Our equation: y = a(x - h)\u00b2 + k, which means (x - h)\u00b2 = (1/a)(y - k)\n- So 4p = 1/a, therefore p = 1/(4a)\n- Directrix: y = k - 1/(4a) = c - b\u00b2/(4a) - 1/(4a) = c - (b\u00b2 + 1)/(4a)\n\nActually, let me double-check the standard form relationship:\nFor y = ax\u00b2, the focus is at (0, 1/(4a)) and directrix is y = -1/(4a).\n\nSo for y = ax\u00b2 + bx + c:\nAfter completing the square: y = a(x + b/(2a))\u00b2 + (c - b\u00b2/(4a))\nThe vertex is at (-b/(2a), c - b\u00b2/(4a))\nThe directrix is at y = (c - b\u00b2/(4a)) - 1/(4a) = c - (b\u00b2 + 1)/(4a)\n\n```python\ndef parabola_directrix(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the directrix of a parabola given by y = ax\u00b2 + bx + c.\n    \n    For a parabola in the form y = ax\u00b2 + bx + c, the directrix is the line\n    y = c - (b\u00b2 + 1)/(4a).\n    \n    Args:\n        a: Coefficient of x\u00b2 (non-zero)\n        b: Coefficient of x\n        c: Constant term\n    \n    Returns:\n        The y-coordinate of the directrix line\n    \n    Example:\n        >>> parabola_directrix(1, 0, 0)  # y = x\u00b2\n        -0.25\n        >>> parabola_directrix(-1, 0, 0)  # y = -x\u00b2\n        0.25\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must be non-zero for a parabola\")\n    \n    # Directrix formula: y = c - (b\u00b2 + 1)/(4a)\n    return c - (b**2 + 1) / (4 * a)\n```"], "prompt_tokens": [59], "completion_tokens": [942], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": ["\n# Example 1\nnums1 = [10, 20, 30]\nnums2 = [2, 4, 5]\nresult = div_list(nums1, nums2)  # [5.0, 5.0, 6.0]\n\n# Example 2\nnums1 = [15, 50, 100]\nnums2 = [3, 10, 20]\nresult = div_list(nums1, nums2)  # [5.0, 5.0, 5.0]\n\n\n"], "responses": ["```python\nfrom typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n    Write a function to divide two lists element wise.\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    result = []\n    for i in range(len(nums1)):\n        if nums2[i] == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        result.append(nums1[i] / nums2[i])\n    \n    return result\n```\n\nThis function:\n1. Takes two lists of integers as input\n2. Checks if both lists have the same length\n3. Iterates through both lists simultaneously\n4. Divides corresponding elements and adds the result to a new list\n5. Handles division by zero errors\n6. Returns a list of floats (since division in Python returns float)\n\nExample usage:\n```python\n# Example 1\nnums1 = [10, 20, 30]\nnums2 = [2, 4, 5]\nresult = div_list(nums1, nums2)  # [5.0, 5.0, 6.0]\n\n# Example 2\nnums1 = [15, 50, 100]\nnums2 = [3, 10, 20]\nresult = div_list(nums1, nums2)  # [5.0, 5.0, 5.0]\n```"], "prompt_tokens": [58], "completion_tokens": [317], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_618_div_list"}
