{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n    Pack consecutive duplicates of a given list elements into sublists.\n    \n    Args:\n        list1: A list of elements\n        \n    Returns:\n        A list of lists where consecutive duplicates are grouped together\n        \n    Examples:\n        >>> pack_consecutive_duplicates([1, 1, 2, 3, 3, 3, 4])\n        [[1, 1], [2], [3, 3, 3], [4]]\n        >>> pack_consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        [['a', 'a'], ['b', 'b'], ['c']]\n        >>> pack_consecutive_duplicates([])\n        []\n    \"\"\"\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            # Same as previous element, add to current group\n            current_group.append(list1[i])\n        else:\n            # Different from previous element, start new group\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    # Don't forget to add the last group\n    result.append(current_group)\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to group consecutive duplicate elements into sublists. Let me break down what's needed:\n\n1. Iterate through the list\n2. Group consecutive elements that are the same\n3. Put each group into a separate sublist\n\nHere's my solution:\n\n```python\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n    Pack consecutive duplicates of a given list elements into sublists.\n    \n    Args:\n        list1: A list of elements\n        \n    Returns:\n        A list of lists where consecutive duplicates are grouped together\n        \n    Examples:\n        >>> pack_consecutive_duplicates([1, 1, 2, 3, 3, 3, 4])\n        [[1, 1], [2], [3, 3, 3], [4]]\n        >>> pack_consecutive_duplicates(['a', 'a', 'b', 'b', 'c'])\n        [['a', 'a'], ['b', 'b'], ['c']]\n        >>> pack_consecutive_duplicates([])\n        []\n    \"\"\"\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]\n    \n    for i in range(1, len(list1)):\n        if list1[i] == list1[i-1]:\n            # Same as previous element, add to current group\n            current_group.append(list1[i])\n        else:\n            # Different from previous element, start new group\n            result.append(current_group)\n            current_group = [list1[i]]\n    \n    # Don't forget to add the last group\n    result.append(current_group)\n    \n    return result\n```\n\nThe algorithm works as follows:\n\n1. **Handle empty list**: Return empty list if input is empty\n2. **Initialize**: Start with the first element in a current group\n3. **Iterate**: For each subsequent element:\n   - If it's the same as the previous element, add it to the current group\n   - If it's different, save the current group to results and start a new group\n4. **Finalize**: Add the last group to the results\n\n**Time Complexity**: O(n) - single pass through the list\n**Space Complexity**: O(n) - for storing the result\n\nThe function handles various edge cases:\n- Empty lists\n- Single elements\n- No duplicates\n- All duplicates\n- Mixed data types"], "prompt_tokens": [63], "completion_tokens": [503], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list.\n    \n    Args:\n        test_list: List of tuples containing (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with smallest integer values, sorted by integer values\n    \"\"\"\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort by the integer value (second element of tuple)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return first K elements\n    return sorted_list[:K]\n\n\n"], "responses": ["Looking at this problem, I need to find the K records with the smallest integer values from a list of tuples.\n\nLet me analyze what's needed:\n- Input: List of tuples (str, int) and integer K\n- Output: List of K tuples with the smallest integer values\n- The tuples should be returned in ascending order by their integer values\n\nHere's my solution:\n\n```python\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list.\n    \n    Args:\n        test_list: List of tuples containing (string, integer)\n        K: Number of minimum records to return\n        \n    Returns:\n        List of K tuples with smallest integer values, sorted by integer values\n    \"\"\"\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort by the integer value (second element of tuple)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return first K elements\n    return sorted_list[:K]\n```\n\nThe approach is straightforward:\n1. Handle edge cases where the list is empty or K is non-positive\n2. Sort the list of tuples based on the second element (integer value) using a lambda function as the key\n3. Return the first K elements from the sorted list\n\nThis ensures we get the K records with the smallest integer values in ascending order."], "prompt_tokens": [100], "completion_tokens": [310], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check for optional sign at the beginning\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not a valid integer\n        if len(text) == 1:\n            return False\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n\n\n"], "responses": ["```python\ndef check_integer(text: str) -> bool:\n    \"\"\"\n    Write a function to check if a string represents an integer or not.\n    \"\"\"\n    # Handle empty string\n    if not text:\n        return False\n    \n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Handle empty string after stripping\n    if not text:\n        return False\n    \n    # Check for optional sign at the beginning\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not a valid integer\n        if len(text) == 1:\n            return False\n    \n    # Check if all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    return True\n```\n\nThis function works by:\n\n1. First checking if the string is empty or contains only whitespace\n2. Handling optional plus (+) or minus (-) signs at the beginning\n3. Ensuring that all remaining characters are digits (0-9)\n4. Returning `True` only if all checks pass\n\nThe function will correctly identify strings like:\n- \"123\" \u2192 True\n- \"-456\" \u2192 True\n- \"+789\" \u2192 True\n- \"0\" \u2192 True\n- \"  123  \" \u2192 True (ignores leading/trailing whitespace)\n\nAnd will return `False` for:\n- \"12.3\" \u2192 False (contains decimal point)\n- \"abc\" \u2192 False (contains letters)\n- \"\" \u2192 False (empty string)\n- \"+\" \u2192 False (only sign, no digits)\n- \"12a3\" \u2192 False (contains non-digit character)"], "prompt_tokens": [48], "completion_tokens": [370], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["\nfrom typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \n    Args:\n        list: List of integers to rotate\n        m: Number of positions to rotate right\n        \n    Returns:\n        New list rotated m positions to the right\n    \"\"\"\n    # Handle empty list or no rotation needed\n    if not list or m == 0:\n        return list[:]\n    \n    # Handle cases where m is larger than list length\n    m = m % len(list)\n    \n    # If m is 0 after modulo, no rotation needed\n    if m == 0:\n        return list[:]\n    \n    # Split the list and rearrange\n    # Take last m elements and put them at the beginning\n    return list[-m:] + list[:-m]\n\n\n"], "responses": ["Looking at this problem, I need to rotate a list to the right by `m` positions. Let me think through this:\n\n- Rotating right means elements move towards the end of the list\n- Elements that \"fall off\" the end wrap around to the beginning\n- For example: [1,2,3,4,5] rotated right by 2 becomes [4,5,1,2,3]\n\nHere's my solution:\n\n```python\nfrom typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n    \n    Args:\n        list: List of integers to rotate\n        m: Number of positions to rotate right\n        \n    Returns:\n        New list rotated m positions to the right\n    \"\"\"\n    # Handle empty list or no rotation needed\n    if not list or m == 0:\n        return list[:]\n    \n    # Handle cases where m is larger than list length\n    m = m % len(list)\n    \n    # If m is 0 after modulo, no rotation needed\n    if m == 0:\n        return list[:]\n    \n    # Split the list and rearrange\n    # Take last m elements and put them at the beginning\n    return list[-m:] + list[:-m]\n```\n\nThe approach works as follows:\n1. Handle edge cases (empty list, no rotation)\n2. Use modulo operation to handle cases where `m` is larger than the list length\n3. Split the list into two parts:\n   - `list[-m:]` - the last `m` elements that will move to the front\n   - `list[:-m]` - the remaining elements that stay at the back\n4. Concatenate them in the new order\n\nExample:\n- `[1,2,3,4,5]` with `m=2`\n- `list[-2:]` = `[4,5]`\n- `list[:-2]` = `[1,2,3]`\n- Result: `[4,5,1,2,3]`"], "prompt_tokens": [79], "completion_tokens": [440], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \n    An Armstrong number is a number that is equal to the sum of its own digits \n    each raised to the power of the number of digits.\n    \n    Args:\n        number (int): The number to check\n        \n    Returns:\n        bool: True if the number is an Armstrong number, False otherwise\n        \n    Examples:\n        >>> armstrong_number(153)\n        True\n        >>> armstrong_number(9474)\n        True\n        >>> armstrong_number(123)\n        False\n    \"\"\"\n    # Convert number to string to easily access individual digits\n    num_str = str(abs(number))  # Use abs() to handle negative numbers\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if the sum equals the original number\n    return sum_of_powers == abs(number)\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test with known Armstrong numbers\n    print(armstrong_number(153))    # True (1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153)\n    print(armstrong_number(9474))   # True (9^4 + 4^4 + 7^4 + 4^4 = 6561 + 256 + 2401 + 256 = 9474)\n    print(armstrong_number(123))    # False (1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36 \u2260 123)\n    print(armstrong_number(1))      # True (1^1 = 1)\n    print(armstrong_number(0))      # True (0^1 = 0)\n\n\n"], "responses": ["```python\ndef armstrong_number(number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n    \n    An Armstrong number is a number that is equal to the sum of its own digits \n    each raised to the power of the number of digits.\n    \n    Args:\n        number (int): The number to check\n        \n    Returns:\n        bool: True if the number is an Armstrong number, False otherwise\n        \n    Examples:\n        >>> armstrong_number(153)\n        True\n        >>> armstrong_number(9474)\n        True\n        >>> armstrong_number(123)\n        False\n    \"\"\"\n    # Convert number to string to easily access individual digits\n    num_str = str(abs(number))  # Use abs() to handle negative numbers\n    num_digits = len(num_str)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if the sum equals the original number\n    return sum_of_powers == abs(number)\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test with known Armstrong numbers\n    print(armstrong_number(153))    # True (1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153)\n    print(armstrong_number(9474))   # True (9^4 + 4^4 + 7^4 + 4^4 = 6561 + 256 + 2401 + 256 = 9474)\n    print(armstrong_number(123))    # False (1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36 \u2260 123)\n    print(armstrong_number(1))      # True (1^1 = 1)\n    print(armstrong_number(0))      # True (0^1 = 0)\n```\n\nThis function works by:\n\n1. Converting the number to a string to easily access individual digits\n2. Counting the number of digits\n3. Calculating the sum of each digit raised to the power of the total number of digits\n4. Comparing this sum with the original number\n\nThe function handles edge cases like:\n- Single digit numbers (which are all Armstrong numbers)\n- Negative numbers (uses absolute value)\n- Zero"], "prompt_tokens": [50], "completion_tokens": [544], "no_of_try": 1, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["\n# Test cases\nprint(sum_of_digits([123, 456, 789]))  # Output: 45 (1+2+3+4+5+6+7+8+9)\nprint(sum_of_digits([12.5, -34, \"hello\", 7]))  # Output: 22 (1+2+5+3+4+7)\nprint(sum_of_digits([]))  # Output: 0\n\n\n"], "responses": ["Looking at this problem, I need to:\n\n1. Take a list that may contain numbers and other types\n2. For each number in the list, calculate the sum of its digits\n3. Return the total sum of all digits from all numbers\n\nHere's my solution:\n\n```python\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n    Write a function to compute the sum of digits of each number of a given list.\n    \"\"\"\n    total_sum = 0\n    \n    for item in nums:\n        # Check if the item is a number (int or float)\n        if isinstance(item, (int, float)):\n            # Convert to string and remove decimal point and negative sign\n            num_str = str(abs(item)).replace('.', '')\n            \n            # Sum the digits\n            for digit_char in num_str:\n                if digit_char.isdigit():\n                    total_sum += int(digit_char)\n    \n    return total_sum\n```\n\nThis solution:\n\n1. Iterates through each item in the input list\n2. Checks if the item is a number (int or float) using `isinstance()`\n3. Converts the absolute value to a string to handle negative numbers\n4. Removes the decimal point for floats\n5. Sums up each digit character, converting back to integer\n6. Returns the total sum\n\nExample usage:\n```python\n# Test cases\nprint(sum_of_digits([123, 456, 789]))  # Output: 45 (1+2+3+4+5+6+7+8+9)\nprint(sum_of_digits([12.5, -34, \"hello\", 7]))  # Output: 22 (1+2+5+3+4+7)\nprint(sum_of_digits([]))  # Output: 0\n```"], "prompt_tokens": [60], "completion_tokens": [387], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n    \"\"\"\n    if n <= 0 or n > len(arr):\n        return arr\n    \n    # Separate negative and positive elements from first n elements\n    negatives = []\n    positives = []\n    \n    # First pass: collect negatives and positives while preserving order\n    for i in range(n):\n        if arr[i] < 0:\n            negatives.append(arr[i])\n        else:\n            positives.append(arr[i])\n    \n    # Second pass: place them back in the correct order\n    result = arr[:]  # Create a copy of the original array\n    \n    # Place negatives first, then positives\n    index = 0\n    for neg in negatives:\n        result[index] = neg\n        index += 1\n    \n    for pos in positives:\n        result[index] = pos\n        index += 1\n    \n    return result\n\n\n"], "responses": ["Looking at this problem, I need to rearrange the first `n` elements of an array so that:\n1. All negative elements come before positive elements\n2. The relative order within negative elements is preserved\n3. The relative order within positive elements is preserved\n4. Elements after index `n-1` remain unchanged\n\nThis is essentially a stable partitioning problem. I'll use a two-pass approach to collect negatives and positives separately while preserving their order.\n\n```python\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n    \"\"\"\n    if n <= 0 or n > len(arr):\n        return arr\n    \n    # Separate negative and positive elements from first n elements\n    negatives = []\n    positives = []\n    \n    # First pass: collect negatives and positives while preserving order\n    for i in range(n):\n        if arr[i] < 0:\n            negatives.append(arr[i])\n        else:\n            positives.append(arr[i])\n    \n    # Second pass: place them back in the correct order\n    result = arr[:]  # Create a copy of the original array\n    \n    # Place negatives first, then positives\n    index = 0\n    for neg in negatives:\n        result[index] = neg\n        index += 1\n    \n    for pos in positives:\n        result[index] = pos\n        index += 1\n    \n    return result\n```\n\nLet me trace through an example:\n- Input: `arr = [1, -2, 3, -4, 5]`, `n = 4`\n- First 4 elements: `[1, -2, 3, -4]`\n- Negatives: `[-2, -4]`, Positives: `[1, 3]`\n- After rearrangement: `[-2, -4, 1, 3, 5]`\n- The last element `5` remains unchanged since it's beyond the first `n` elements\n\nThe time complexity is O(n) and space complexity is O(n), where n is the input parameter (not the array length)."], "prompt_tokens": [96], "completion_tokens": [487], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Wind chill formula: 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16\n    # Where T is temperature in Celsius and V is wind speed in km/h\n    \n    import math\n    \n    # Calculate V^0.16\n    v_power = v ** 0.16\n    \n    # Apply the wind chill formula\n    wc = 13.12 + 0.6215 * t - 11.37 * v_power + 0.3965 * t * v_power\n    \n    # Round to the next integer (ceiling)\n    return math.ceil(wc)\n\n\n"], "responses": ["Looking at this problem, I need to implement a wind chill calculation function. The wind chill index is typically calculated using a specific formula that relates wind speed and temperature.\n\nThe standard wind chill formula (used by meteorological services) is:\nWind Chill = 13.12 + 0.6215\u00d7T - 11.37\u00d7V^0.16 + 0.3965\u00d7T\u00d7V^0.16\n\nWhere:\n- T is temperature in Celsius\n- V is wind speed in km/h\n\nHere's the implementation:\n\n```python\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Wind chill formula: 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16\n    # Where T is temperature in Celsius and V is wind speed in km/h\n    \n    import math\n    \n    # Calculate V^0.16\n    v_power = v ** 0.16\n    \n    # Apply the wind chill formula\n    wc = 13.12 + 0.6215 * t - 11.37 * v_power + 0.3965 * t * v_power\n    \n    # Round to the next integer (ceiling)\n    return math.ceil(wc)\n```\n\nThis function:\n1. Takes wind velocity `v` (km/h) and temperature `t` (Celsius) as integer inputs\n2. Applies the standard wind chill formula\n3. Uses `math.ceil()` to round up to the next integer as requested\n4. Returns the result as an integer\n\nNote: This formula is typically valid for temperatures at or below 10\u00b0C and wind speeds above 4.8 km/h. For edge cases outside these ranges, you might want to add validation, but the problem doesn't specify such requirements."], "prompt_tokens": [67], "completion_tokens": [447], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_638_wind_chill"}
