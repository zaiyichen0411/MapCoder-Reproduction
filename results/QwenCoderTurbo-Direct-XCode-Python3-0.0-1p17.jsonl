{"description": "The numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.Lucky number is a number that consists of digits 7 and 8 only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than n digits.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u200955) \u2014 the maximum length of a number that a door-plate can hold.", "output_spec": "Output one integer \u2014 the maximum number of offices, than can have unique lucky numbers not longer than n digits.", "notes": null, "sample_inputs": ["2"], "sample_outputs": ["6"], "tags": ["combinatorics", "math"], "src_uid": "f1b43baa14d4c262ba616d892525dfde", "difficulty": 1100, "source_codes": ["\ndef solve(n):\n    # Calculate sum of geometric series: 2^1 + 2^2 + ... + 2^n\n    # Using formula: 2^(n+1) - 2\n    return (2 ** (n + 1)) - 2\n\n# Read input\nn = int(input())\n\n# Solve and output\nresult = solve(n)\nprint(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. **Lucky numbers** are numbers that contain only digits 7 and 8\n2. We need to find how many unique lucky numbers can be formed with at most `n` digits\n3. Each office needs a unique lucky number for its door plate\n\n## Analysis\n\nLet's think about how many lucky numbers we can form:\n- For 1-digit lucky numbers: 7, 8 \u2192 2 numbers\n- For 2-digit lucky numbers: 77, 78, 87, 88 \u2192 4 numbers\n- For 3-digit lucky numbers: 777, 778, 787, 788, 877, 878, 887, 888 \u2192 8 numbers\n\nI can see a pattern here:\n- For k-digit lucky numbers, there are 2^k possibilities\n- This is because each position can be filled with either 7 or 8 (2 choices)\n\nSo for numbers with at most n digits:\n- 1-digit: 2^1 = 2\n- 2-digit: 2^2 = 4\n- 3-digit: 2^3 = 8\n- ...\n- n-digit: 2^n\n\nTotal = 2^1 + 2^2 + 2^3 + ... + 2^n\n\nThis is a geometric series with:\n- First term a = 2\n- Common ratio r = 2\n- Number of terms = n\n\nSum = a \u00d7 (r^n - 1) / (r - 1) = 2 \u00d7 (2^n - 1) / (2 - 1) = 2 \u00d7 (2^n - 1) = 2^(n+1) - 2\n\nLet me verify with the sample:\n- n = 2\n- Total = 2^1 + 2^2 = 2 + 4 = 6 \u2713\n\n## Implementation\n\n```python\ndef solve(n):\n    # Calculate sum of geometric series: 2^1 + 2^2 + ... + 2^n\n    # Using formula: 2^(n+1) - 2\n    return (2 ** (n + 1)) - 2\n\n# Read input\nn = int(input())\n\n# Solve and output\nresult = solve(n)\nprint(result)\n```\n\nLet me trace through the sample:\n- Input: n = 2\n- Lucky numbers: 7, 8, 77, 78, 87, 88\n- Count: 6\n- Using formula: 2^(2+1) - 2 = 2^3 - 2 = 8 - 2 = 6 \u2713\n\nThe solution works correctly!"], "prompt_tokens": [243], "completion_tokens": [603], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "f1b43baa14d4c262ba616d892525dfde"}
{"description": "Vasya started working in a machine vision company of IT City. Vasya's team creates software and hardware for identification of people by their face.One of the project's know-how is a camera rotating around its optical axis on shooting. People see an eye-catching gadget \u2014 a rotating camera \u2014 come up to it to see it better, look into it. And the camera takes their photo at that time. What could be better for high quality identification?But not everything is so simple. The pictures from camera appear rotated too (on clockwise camera rotation frame the content becomes rotated counter-clockwise). But the identification algorithm can work only with faces that are just slightly deviated from vertical.Vasya was entrusted to correct the situation \u2014 to rotate a captured image so that image would be minimally deviated from vertical. Requirements were severe. Firstly, the picture should be rotated only on angle divisible by 90 degrees to not lose a bit of information about the image. Secondly, the frames from the camera are so huge and FPS is so big that adequate rotation speed is provided by hardware FPGA solution only. And this solution can rotate only by 90 degrees clockwise. Of course, one can apply 90 degrees turn several times but for the sake of performance the number of turns should be minimized.Help Vasya implement the program that by the given rotation angle of the camera can determine the minimum number of 90 degrees clockwise turns necessary to get a picture in which up direction deviation from vertical is minimum.The next figure contains frames taken from an unrotated camera, then from rotated 90 degrees clockwise, then from rotated 90 degrees counter-clockwise. Arrows show direction to \"true up\".  The next figure shows 90 degrees clockwise turn by FPGA hardware.  ", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of the input contains one integer x (\u2009-\u20091018\u2009\u2264\u2009x\u2009\u2264\u20091018) \u2014 camera angle in degrees. Positive value denotes clockwise camera rotation, negative \u2014 counter-clockwise.", "output_spec": "Output one integer \u2014 the minimum required number of 90 degrees clockwise turns.", "notes": "NoteWhen the camera is rotated 60 degrees counter-clockwise (the second example), an image from it is rotated 60 degrees clockwise. One 90 degrees clockwise turn of the image result in 150 degrees clockwise total rotation and deviation from \"true up\" for one turn is 150 degrees. Two 90 degrees clockwise turns of the image result in 240 degrees clockwise total rotation and deviation from \"true up\" for two turns is 120 degrees because 240 degrees clockwise equal to 120 degrees counter-clockwise. Three 90 degrees clockwise turns of the image result in 330 degrees clockwise total rotation and deviation from \"true up\" for three turns is 30 degrees because 330 degrees clockwise equal to 30 degrees counter-clockwise.From 60, 150, 120 and 30 degrees deviations the smallest is 30, and it it achieved in three 90 degrees clockwise turns.", "sample_inputs": ["60", "-60"], "sample_outputs": ["1", "3"], "tags": ["geometry", "math"], "src_uid": "509db9cb6156b692557ba874a09f150e", "difficulty": 1800, "source_codes": ["\ndef min_clockwise_turns(x):\n    # Normalize x to avoid huge numbers\n    x = x % 360\n    img_angle = (-x) % 360  # Effective image angle due to camera rotation\n    \n    best_k = 0\n    min_deviation = float('inf')\n    \n    for k in range(4):\n        new_angle = (img_angle + 90 * k) % 360\n        deviation = min(new_angle, 360 - new_angle)\n        if deviation < min_deviation:\n            min_deviation = deviation\n            best_k = k\n            \n    return best_k\n\n# Read input\nx = int(input())\n\n# Output result\nprint(min_clockwise_turns(x))\n\n\n"], "responses": ["Let's break down the problem step by step before implementing the solution:\n\n---\n\n### **Understanding the Problem**\n\n1. **Camera Rotation:**\n   - The camera rotates by an angle `x` degrees.\n   - Positive `x`: clockwise rotation.\n   - Negative `x`: counter-clockwise rotation.\n\n2. **Image Rotation Effect:**\n   - When the camera rotates clockwise, the image appears **counter-clockwise**.\n   - So if the camera rotates by `x` degrees, the image effectively rotates by `-x` degrees.\n\n3. **Goal:**\n   - We want to rotate the image back so that it is as close to upright (vertical) as possible.\n   - We can only perform **90-degree clockwise rotations**.\n   - We must minimize the number of such operations.\n\n4. **How Image Rotation Works:**\n   - Let\u2019s say effective image angle = `-x`.\n   - Each 90-degree clockwise turn adds 90 degrees to the current image orientation.\n   - We try applying 0, 1, 2, or 3 such turns and find the one that brings the final angle closest to a multiple of 360 (i.e., upright).\n\n5. **Deviation Measurement:**\n   - For any resulting total angle \u03b8, deviation from vertical is the minimal angular distance to 0\u00b0 modulo 360\u00b0.\n     - That is, min(|\u03b8 % 360|, |(\u03b8 % 360) - 360|)\n\n---\n\n### **Approach**\n\nWe simulate applying 0 to 3 clockwise 90-degree turns on the initial image orientation (`-x`) and compute the absolute angular deviation for each case. Then choose the number of turns that gives minimum deviation.\n\nBecause we're dealing with large numbers (up to \u00b110^18), all calculations involving angles must use modular arithmetic properly.\n\nAlso note:\n- A full circle is 360 degrees.\n- Modulo operation behaves differently in Python for negative numbers \u2013 `a % b` always returns a non-negative result when `b > 0`.\n\n---\n\n### **Implementation Plan**\n\n1. Normalize input angle `x` mod 360 to reduce computation scale.\n2. Compute effective image angle = `-x`.\n3. Try 0 to 3 clockwise 90-degree turns:\n   - New angle = `(effective_angle + 90 * k) % 360`\n   - Compute deviation from 0\u00b0: `min(abs(angle), 360 - abs(angle))`\n4. Return the `k` corresponding to minimum deviation.\n\n---\n\n### \u2705 Final Python Code\n\n```python\ndef min_clockwise_turns(x):\n    # Normalize x to avoid huge numbers\n    x = x % 360\n    img_angle = (-x) % 360  # Effective image angle due to camera rotation\n    \n    best_k = 0\n    min_deviation = float('inf')\n    \n    for k in range(4):\n        new_angle = (img_angle + 90 * k) % 360\n        deviation = min(new_angle, 360 - new_angle)\n        if deviation < min_deviation:\n            min_deviation = deviation\n            best_k = k\n            \n    return best_k\n\n# Read input\nx = int(input())\n\n# Output result\nprint(min_clockwise_turns(x))\n```\n\n---\n\n### \ud83e\uddea Sample Test Cases Explained\n\n#### Input: `60`\n- Camera rotated 60\u00b0 clockwise \u2192 Image rotated -60\u00b0\n- Trying:\n  - 0 turns \u2192 -60\u00b0 \u2192 Deviation = 60\u00b0\n  - 1 turn (+90\u00b0) \u2192 30\u00b0 \u2192 Deviation = 30\u00b0 \u2705\n  - 2 turns \u2192 120\u00b0 \u2192 Deviation = 120\u00b0\n  - 3 turns \u2192 210\u00b0 \u2192 Deviation = 150\u00b0\n- Minimum deviation: 30\u00b0 at 1 turn\n\n\u2705 Output: `1`\n\n#### Input: `-60`\n- Camera rotated -60\u00b0 \u2192 Image rotated +60\u00b0\n- Trying:\n  - 0 turns \u2192 60\u00b0 \u2192 Deviation = 60\u00b0\n  - 1 turn \u2192 150\u00b0 \u2192 Deviation = 150\u00b0\n  - 2 turns \u2192 240\u00b0 \u2192 Deviation = 120\u00b0\n  - 3 turns \u2192 330\u00b0 \u2192 Deviation = 30\u00b0 \u2705\n- Minimum deviation: 30\u00b0 at 3 turns\n\n\u2705 Output: `3`\n\n---\n\nThis approach handles all edge cases including very large values of `x` efficiently thanks to `% 360`. Time complexity is constant O(1), space is also O(1)."], "prompt_tokens": [763], "completion_tokens": [1020], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "509db9cb6156b692557ba874a09f150e"}
{"description": "There are n people, sitting in a line at the table. For each person we know that he always tells either the truth or lies.Little Serge asked them: how many of you always tell the truth? Each of the people at the table knows everything (who is an honest person and who is a liar) about all the people at the table. The honest people are going to say the correct answer, the liars are going to say any integer from 1 to n, which is not the correct answer. Every liar chooses his answer, regardless of the other liars, so two distinct liars may give distinct answer.Serge does not know any information about the people besides their answers to his question. He took a piece of paper and wrote n integers a1,\u2009a2,\u2009...,\u2009an, where ai is the answer of the i-th person in the row. Given this sequence, Serge determined that exactly k people sitting at the table apparently lie.Serge wonders, how many variants of people's answers (sequences of answers a of length n) there are where one can say that exactly k people sitting at the table apparently lie. As there can be rather many described variants of answers, count the remainder of dividing the number of the variants by 777777777.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n, k, (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200928). It is guaranteed that n \u2014 is the power of number 2.", "output_spec": "Print a single integer \u2014 the answer to the problem modulo 777777777.", "notes": null, "sample_inputs": ["1 1", "2 1"], "sample_outputs": ["0", "2"], "tags": ["dp"], "src_uid": "cfe19131644e5925e32084a581e23286", "difficulty": 2700, "source_codes": ["\ndef solve():\n    MOD = 777777777\n    \n    def mod_pow(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp & 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp >>= 1\n        return result\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        num = 1\n        den = 1\n        for i in range(k):\n            num = (num * (n - i)) % MOD\n            den = (den * (i + 1)) % MOD\n        \n        return (num * mod_pow(den, MOD - 2, MOD)) % MOD\n    \n    n, k = map(int, input().split())\n    \n    # For exactly k people to apparently lie,\n    # we need exactly (n-k) truth-tellers\n    t = n - k\n    \n    if t < 0:\n        print(0)\n        return\n    \n    # Answer is C(n, k) * (n-1)^k\n    result = comb(n, k)\n    result = (result * mod_pow(n - 1, k, MOD)) % MOD\n    \n    print(result)\n\nsolve()\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. **Setup**: n people sitting in a line, each either always tells truth or always lies\n2. **Question**: \"How many of you always tell the truth?\"\n3. **Responses**:\n   - Truth-tellers will give the correct answer (actual count of truth-tellers)\n   - Liars will give any integer from 1 to n, except the correct answer\n4. **Goal**: Count sequences of length n where exactly k people \"apparently lie\"\n\n## Key Insights\n\nLet's think about what it means for someone to \"apparently lie\":\n- If there are actually t truth-tellers, then:\n  - Truth-tellers will say t\n  - Liars will say anything except t\n- Someone \"apparently lies\" if their answer doesn't match what we'd expect from the actual configuration\n\nWait, let me re-read... \"exactly k people sitting at the table apparently lie\" - this seems to mean k people gave wrong answers according to Serge's analysis.\n\nActually, looking more carefully at the sample:\n- For n=1, k=1: output is 0\n- For n=2, k=1: output is 2\n\nLet me think differently. \"Apparently lie\" likely means their answer doesn't match what it should be given the actual number of truth-tellers.\n\n## Refined Understanding\n\nLet's say there are t actual truth-tellers:\n- Each truth-teller says t (correct answer)\n- Each liar says something \u2260 t (any value from 1 to n except t)\n\nFor a given sequence, we want exactly k people whose answers don't match what they should say if there were t truth-tellers.\n\nBut we don't know t. We need to consider all possible values of t (from 0 to n).\n\n## Approach\n\nFor each possible number of actual truth-tellers t (0 to n):\n1. Count sequences where exactly k people \"apparently lie\"\n2. A person apparently lies if:\n   - They are a truth-teller but don't say t, OR\n   - They are a liar but say t\n3. But wait, truth-tellers MUST say t, so they never apparently lie\n4. Liars apparently lie unless they happen to say t (but they can't say t by definition)\n\nHmm, let me reconsider the problem statement...\n\nRe-reading: \"the liars are going to say any integer from 1 to n, which is not the correct answer\"\n\nSo liars NEVER say the correct answer. Therefore:\n- Truth-tellers always say the correct answer t\n- Liars never say t\n\nSo someone \"apparently lies\" if their answer is not t.\n- Truth-tellers never apparently lie (they say t)\n- Liars always apparently lie (they don't say t)\n\nTherefore, if there are t truth-tellers, exactly (n-t) people apparently lie.\n\nWe want exactly k people to apparently lie, so we need n-t = k, which means t = n-k.\n\n## Solution Approach\n\nWe want sequences where exactly k people apparently lie.\nThis means there are exactly (n-k) truth-tellers.\n\nFor a fixed number of truth-tellers t = n-k:\n1. Choose which t positions have truth-tellers: C(n,t) ways\n2. Each truth-teller says t: 1 way each\n3. Each liar says something other than t: (n-1) choices each\n4. Number of liars = k\n\nTotal for this case = C(n, n-k) \u00d7 1^(n-k) \u00d7 (n-1)^k = C(n, k) \u00d7 (n-1)^k\n\nWait, let me check with samples:\n\nFor n=1, k=1:\n- t = n-k = 0 truth-tellers\n- C(1,1) \u00d7 (1-1)^1 = 1 \u00d7 0^1 = 0 \u2713\n\nFor n=2, k=1:\n- t = 2-1 = 1 truth-teller  \n- C(2,1) \u00d7 (2-1)^1 = 2 \u00d7 1^1 = 2 \u2713\n\nGreat! This matches.\n\n## Implementation\n\n```python\ndef solve():\n    MOD = 777777777\n    \n    def mod_pow(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp & 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp >>= 1\n        return result\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        num = 1\n        den = 1\n        for i in range(k):\n            num = (num * (n - i)) % MOD\n            den = (den * (i + 1)) % MOD\n        \n        return (num * mod_pow(den, MOD - 2, MOD)) % MOD\n    \n    n, k = map(int, input().split())\n    \n    # Number of truth-tellers\n    t = n - k\n    \n    if t < 0:\n        print(0)\n        return\n    \n    # C(n, k) * (n-1)^k\n    result = comb(n, k)\n    result = (result * mod_pow(n - 1, k, MOD)) % MOD\n    \n    print(result)\n\nsolve()\n```\n\nLet me verify once more:\n- n=1, k=1: t=0, C(1,1) \u00d7 0^1 = 1 \u00d7 0 = 0 \u2713\n- n=2, k=1: t=1, C(2,1) \u00d7 1^1 = 2 \u00d7 1 = 2 \u2713\n\nThe logic is sound. Here's the final code:\n\n```python\ndef solve():\n    MOD = 777777777\n    \n    def mod_pow(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp & 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp >>= 1\n        return result\n    \n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        \n        num = 1\n        den = 1\n        for i in range(k):\n            num = (num * (n - i)) % MOD\n            den = (den * (i + 1)) % MOD\n        \n        return (num * mod_pow(den, MOD - 2, MOD)) % MOD\n    \n    n, k = map(int, input().split())\n    \n    # For exactly k people to apparently lie,\n    # we need exactly (n-k) truth-tellers\n    t = n - k\n    \n    if t < 0:\n        print(0)\n        return\n    \n    # Answer is C(n, k) * (n-1)^k\n    result = comb(n, k)\n    result = (result * mod_pow(n - 1, k, MOD)) % MOD\n    \n    print(result)\n\nsolve()\n```"], "prompt_tokens": [459], "completion_tokens": [1563], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "cfe19131644e5925e32084a581e23286"}
{"description": "There have recently been elections in the zoo. Overall there were 7 main political parties: one of them is the Little Elephant Political Party, 6 other parties have less catchy names.Political parties find their number in the ballot highly important. Overall there are m possible numbers: 1,\u20092,\u2009...,\u2009m. Each of these 7 parties is going to be assigned in some way to exactly one number, at that, two distinct parties cannot receive the same number.The Little Elephant Political Party members believe in the lucky digits 4 and 7. They want to evaluate their chances in the elections. For that, they need to find out, how many correct assignments are there, such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties. Help the Little Elephant Political Party, calculate this number. As the answer can be rather large, print the remainder from dividing it by 1000000007 (109\u2009+\u20097).", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "A single line contains a single positive integer m (7\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 the number of possible numbers in the ballot.", "output_spec": "In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["7", "8"], "sample_outputs": ["0", "1440"], "tags": ["brute force", "math", "combinatorics", "dp"], "src_uid": "656ed7b1b80de84d65a253e5d14d62a9", "difficulty": 1900, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "656ed7b1b80de84d65a253e5d14d62a9"}
