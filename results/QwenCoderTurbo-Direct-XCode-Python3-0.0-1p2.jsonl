{"description": "Little Johnny Bubbles enjoys spending hours in front of his computer playing video games. His favorite game is Bubble Strike, fast-paced bubble shooting online game for two players.Each game is set in one of the N maps, each having different terrain configuration. First phase of each game decides on which map the game will be played. The game system randomly selects three maps and shows them to the players. Each player must pick one of those three maps to be discarded. The game system then randomly selects one of the maps that were not picked by any of the players and starts the game.Johnny is deeply enthusiastic about the game and wants to spend some time studying maps, thus increasing chances to win games played on those maps. However, he also needs to do his homework, so he does not have time to study all the maps. That is why he asked himself the following question: \"What is the minimum number of maps I have to study, so that the probability to play one of those maps is at least $$$P$$$\"?Can you help Johnny find the answer for this question? You can assume Johnny's opponents do not know him, and they will randomly pick maps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers $$$N$$$ ($$$3$$$ $$$\\leq$$$ $$$N$$$ $$$\\leq$$$ $$$10^{3}$$$) and $$$P$$$ ($$$0$$$ $$$\\leq$$$ $$$P$$$ $$$\\leq$$$ $$$1$$$) \u2013 total number of maps in the game and probability to play map Johnny has studied. $$$P$$$ will have at most four digits after the decimal point.", "output_spec": "Output contains one integer number \u2013 minimum number of maps Johnny has to study.", "notes": null, "sample_inputs": ["7 1.0000"], "sample_outputs": ["6"], "tags": ["combinatorics", "binary search", "ternary search", "probabilities", "math"], "src_uid": "788ed59a964264bd0e755e155a37e14d", "difficulty": 2000, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "788ed59a964264bd0e755e155a37e14d"}
{"description": "You are given an undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. Initially there is a single integer written on every vertex: the vertex $$$i$$$ has $$$p_i$$$ written on it. All $$$p_i$$$ are distinct integers from $$$1$$$ to $$$n$$$.You have to process $$$q$$$ queries of two types:  $$$1$$$ $$$v$$$ \u2014 among all vertices reachable from the vertex $$$v$$$ using the edges of the graph (including the vertex $$$v$$$ itself), find a vertex $$$u$$$ with the largest number $$$p_u$$$ written on it, print $$$p_u$$$ and replace $$$p_u$$$ with $$$0$$$;  $$$2$$$ $$$i$$$ \u2014 delete the $$$i$$$-th edge from the graph.  Note that, in a query of the first type, it is possible that all vertices reachable from $$$v$$$ have $$$0$$$ written on them. In this case, $$$u$$$ is not explicitly defined, but since the selection of $$$u$$$ does not affect anything, you can choose any vertex reachable from $$$v$$$ and print its value (which is $$$0$$$). ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1.5 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$q$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le m \\le 3 \\cdot 10^5$$$; $$$1 \\le q \\le 5 \\cdot 10^5$$$). The second line contains $$$n$$$ distinct integers $$$p_1$$$, $$$p_2$$$, ..., $$$p_n$$$, where $$$p_i$$$ is the number initially written on vertex $$$i$$$ ($$$1 \\le p_i \\le n$$$). Then $$$m$$$ lines follow, the $$$i$$$-th of them contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$, $$$a_i \\ne b_i$$$) and means that the $$$i$$$-th edge connects vertices $$$a_i$$$ and $$$b_i$$$. It is guaranteed that the graph does not contain multi-edges. Then $$$q$$$ lines follow, which describe the queries. Each line is given by one of the following formats:   $$$1$$$ $$$v$$$ \u2014 denotes a query of the first type with a vertex $$$v$$$ ($$$1 \\le v \\le n$$$).  $$$2$$$ $$$i$$$ \u2014 denotes a query of the second type with an edge $$$i$$$ ($$$1 \\le i \\le m$$$). For each query of the second type, it is guaranteed that the corresponding edge is not deleted from the graph yet. ", "output_spec": "For every query of the first type, print the value of $$$p_u$$$ written on the chosen vertex $$$u$$$.", "notes": null, "sample_inputs": ["5 4 6\n1 2 5 4 3\n1 2\n2 3\n1 3\n4 5\n1 1\n2 1\n2 3\n1 1\n1 2\n1 2"], "sample_outputs": ["5\n1\n2\n0"], "tags": ["trees", "data structures", "graphs", "dsu", "implementation"], "src_uid": "ad014bde729222db14f38caa521e4167", "difficulty": 2600, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "ad014bde729222db14f38caa521e4167"}
{"description": "Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $$$x$$$ in an array. For an array $$$a$$$ indexed from zero, and an integer $$$x$$$ the pseudocode of the algorithm is as follows:  Note that the elements of the array are indexed from zero, and the division is done in integers (rounding down).Andrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $$$x$$$!Andrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $$$n$$$ such that the algorithm finds $$$x$$$ in them. A permutation of size $$$n$$$ is an array consisting of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ in arbitrary order.Help Andrey and find the number of permutations of size $$$n$$$ which contain $$$x$$$ at position $$$pos$$$ and for which the given implementation of the binary search algorithm finds $$$x$$$ (returns true). As the result may be extremely large, print the remainder of its division by $$$10^9+7$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line of input contains integers $$$n$$$, $$$x$$$ and $$$pos$$$ ($$$1 \\le x \\le n \\le 1000$$$, $$$0 \\le pos \\le n - 1$$$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.", "output_spec": "Print a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $$$10^9+7$$$.", "notes": "NoteAll possible permutations in the first test case: $$$(2, 3, 1, 4)$$$, $$$(2, 4, 1, 3)$$$, $$$(3, 2, 1, 4)$$$, $$$(3, 4, 1, 2)$$$, $$$(4, 2, 1, 3)$$$, $$$(4, 3, 1, 2)$$$.", "sample_inputs": ["4 1 2", "123 42 24"], "sample_outputs": ["6", "824071958"], "tags": ["combinatorics", "binary search"], "src_uid": "24e2f10463f440affccc2755f4462d8a", "difficulty": 1500, "source_codes": ["\ndef solve():\n    MOD = 1000000007\n    \n    # Precompute factorials\n    def precompute_factorials(max_n):\n        fact = [1] * (max_n + 1)\n        for i in range(1, max_n + 1):\n            fact[i] = (fact[i-1] * i) % MOD\n        return fact\n    \n    n, x, pos = map(int, input().split())\n    \n    # Simulate binary search to find which positions are accessed\n    l, r = 0, n\n    smaller_count = 0  # positions < pos that are accessed\n    larger_count = 0   # positions > pos that are accessed\n    \n    while l < r:\n        mid = (l + r) // 2\n        if mid < pos:\n            smaller_count += 1\n            l = mid + 1\n        elif mid > pos:\n            larger_count += 1\n            r = mid\n        else:  # mid == pos\n            l = mid + 1\n    \n    # Available numbers\n    smaller_numbers = x - 1  # numbers 1, 2, ..., x-1\n    larger_numbers = n - x   # numbers x+1, x+2, ..., n\n    \n    # Check if we have enough numbers\n    if smaller_count > smaller_numbers or larger_count > larger_numbers:\n        print(0)\n        return\n    \n    # Precompute factorials\n    fact = precompute_factorials(n)\n    \n    # Calculate permutations\n    # Choose and arrange smaller_count numbers from smaller_numbers\n    if smaller_count == 0:\n        smaller_ways = 1\n    else:\n        smaller_ways = (fact[smaller_numbers] * pow(fact[smaller_numbers - smaller_count], MOD - 2, MOD)) % MOD\n    \n    # Choose and arrange larger_count numbers from larger_numbers  \n    if larger_count == 0:\n        larger_ways = 1\n    else:\n        larger_ways = (fact[larger_numbers] * pow(fact[larger_numbers - larger_count], MOD - 2, MOD)) % MOD\n    \n    # Arrange remaining numbers in remaining positions\n    remaining_positions = (n - 1) - smaller_count - larger_count\n    remaining_ways = fact[remaining_positions] if remaining_positions >= 0 else 1\n    \n    result = (smaller_ways * larger_ways) % MOD\n    result = (result * remaining_ways) % MOD\n    \n    print(result)\n\nsolve()\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We need to count permutations of size `n` where:\n   - Element `x` is at position `pos`\n   - Binary search algorithm successfully finds `x` at position `pos`\n\n2. The binary search algorithm given:\n   - Starts with `l = 0`, `r = n`\n   - While `l < r`: \n     - `mid = (l + r) // 2`\n     - If `mid <= pos`: set `l = mid + 1` (we want element at `pos`)\n     - If `mid > pos`: set `r = mid` (we don't want elements after `pos`)\n\n3. For the algorithm to work correctly:\n   - When `mid < pos`: we need `a[mid] < x` (so we move left pointer forward)\n   - When `mid > pos`: we need `a[mid] > x` (so we move right pointer backward)\n   - When `mid = pos`: we found our target\n\n## Key Insights\n\n1. During binary search, we visit certain positions in the array\n2. For positions visited where `mid < pos`: those elements must be `< x`\n3. For positions visited where `mid > pos`: those elements must be `> x`\n4. The position `pos` itself must contain `x`\n\n## Approach\n\n1. Simulate the binary search to find which positions are visited\n2. Count how many positions are visited with `mid < pos` (let's call it `smaller_count`)\n3. Count how many positions are visited with `mid > pos` (let's call it `larger_count`)\n4. The remaining numbers are `1, 2, ..., x-1, x+1, ..., n` (excluding `x`)\n5. We need to choose `smaller_count` numbers from `{1, 2, ..., x-1}` and arrange them\n6. We need to choose `larger_count` numbers from `{x+1, x+2, ..., n}` and arrange them\n7. Answer = `P(x-1, smaller_count) \u00d7 P(n-x, larger_count)` where P is permutations\n\nLet me trace through the first example:\n- n=4, x=1, pos=2\n- Binary search simulation:\n  - l=0, r=4, mid=2 \u2192 mid==pos \u2192 l=3\n  - l=3, r=4, mid=3 \u2192 mid>pos \u2192 r=3\n  - l=3, r=3 \u2192 stop\n- Visited positions: 2, 3\n- Position 3 has mid>pos, so needs element > x=1\n- Available numbers > 1: {2, 3, 4} (3 numbers)\n- Available numbers < 1: {} (0 numbers)\n- We need 1 number > 1 for position 3: C(3,1) \u00d7 1! = 3 ways\n- We need 0 numbers < 1 for positions < 2: C(0,0) \u00d7 0! = 1 way\n- Numbers to arrange in remaining positions: 1 way each\n- Actually, let me retrace...\n\nWait, I think I misunderstood. Let me re-read carefully.\n\nWe fix `x` at position `pos`. Then we simulate binary search and see what other positions get accessed, and what constraints they have.\n\n## Detailed Solution\n\n```python\ndef solve():\n    MOD = 1000000007\n    \n    # Precompute factorials\n    def precompute_factorials(max_n):\n        fact = [1] * (max_n + 1)\n        for i in range(1, max_n + 1):\n            fact[i] = (fact[i-1] * i) % MOD\n        return fact\n    \n    n, x, pos = map(int, input().split())\n    \n    # Simulate binary search to find which positions are accessed\n    l, r = 0, n\n    smaller_count = 0  # positions < pos that are accessed\n    larger_count = 0   # positions > pos that are accessed\n    \n    while l < r:\n        mid = (l + r) // 2\n        if mid < pos:\n            smaller_count += 1\n            l = mid + 1\n        elif mid > pos:\n            larger_count += 1\n            r = mid\n        else:  # mid == pos\n            l = mid + 1\n    \n    # Available numbers\n    smaller_numbers = x - 1  # numbers 1, 2, ..., x-1\n    larger_numbers = n - x   # numbers x+1, x+2, ..., n\n    \n    # Check if we have enough numbers\n    if smaller_count > smaller_numbers or larger_count > larger_numbers:\n        print(0)\n        return\n    \n    # Precompute factorials\n    fact = precompute_factorials(n)\n    \n    # Calculate permutations\n    # Choose and arrange smaller_count numbers from smaller_numbers\n    if smaller_count == 0:\n        smaller_ways = 1\n    else:\n        smaller_ways = (fact[smaller_numbers] * pow(fact[smaller_numbers - smaller_count], MOD - 2, MOD)) % MOD\n    \n    # Choose and arrange larger_count numbers from larger_numbers  \n    if larger_count == 0:\n        larger_ways = 1\n    else:\n        larger_ways = (fact[larger_numbers] * pow(fact[larger_numbers - larger_count], MOD - 2, MOD)) % MOD\n    \n    # Arrange remaining numbers in remaining positions\n    remaining_positions = (n - 1) - smaller_count - larger_count\n    remaining_numbers = (smaller_numbers - smaller_count) + (larger_numbers - larger_count)\n    \n    remaining_ways = fact[remaining_positions] if remaining_positions >= 0 else 1\n    \n    result = (smaller_ways * larger_ways) % MOD\n    result = (result * remaining_ways) % MOD\n    \n    print(result)\n\nsolve()\n```\n\nLet me verify with the first example:\n- n=4, x=1, pos=2\n- Binary search:\n  - l=0, r=4, mid=2 \u2192 mid==pos \u2192 l=3\n  - l=3, r=4, mid=3 \u2192 mid>pos \u2192 r=3  \n  - l=3, r=3 \u2192 stop\n- Accessed positions: 2(index), 3\n- smaller_count = 0 (no positions < 2 accessed in search path except the starting l=0,r=4 which gives mid=2)\n- Wait, let me retrace more carefully:\n\nActually l=0,r=4,mid=2. Since mid=pos=2, we set l=3.\nNow l=3,r=4,mid=3. Since mid>pos, we set r=3.\nNow l=3,r=3, loop ends.\n\nSo only position 3 was accessed with mid>pos.\n- smaller_count = 0\n- larger_count = 1\n- smaller_numbers = 1-1 = 0\n- larger_numbers = 4-1 = 3\n\nSo we need to choose 0 numbers from 0 available numbers for smaller: 1 way\nWe need to choose 1 number from 3 available numbers for larger: P(3,1) = 3 ways\nRemaining positions: (4-1) - 0 - 1 = 2 positions\nRemaining numbers: (0-0) + (3-1) = 2 numbers\nArrange 2 numbers in 2 positions: 2! = 2 ways\n\nTotal: 1 \u00d7 3 \u00d7 2 = 6 \u2713\n\nThis matches!\n\n```python\ndef solve():\n    MOD = 1000000007\n    \n    # Precompute factorials\n    def precompute_factorials(max_n):\n        fact = [1] * (max_n + 1)\n        for i in range(1, max_n + 1):\n            fact[i] = (fact[i-1] * i) % MOD\n        return fact\n    \n    n, x, pos = map(int, input().split())\n    \n    # Simulate binary search to find which positions are accessed\n    l, r = 0, n\n    smaller_count = 0  # positions < pos that are accessed\n    larger_count = 0   # positions > pos that are accessed\n    \n    while l < r:\n        mid = (l + r) // 2\n        if mid < pos:\n            smaller_count += 1\n            l = mid + 1\n        elif mid > pos:\n            larger_count += 1\n            r = mid\n        else:  # mid == pos\n            l = mid + 1\n    \n    # Available numbers\n    smaller_numbers = x - 1  # numbers 1, 2, ..., x-1\n    larger_numbers = n - x   # numbers x+1, x+2, ..., n\n    \n    # Check if we have enough numbers\n    if smaller_count > smaller_numbers or larger_count > larger_numbers:\n        print(0)\n        return\n    \n    # Precompute factorials\n    fact = precompute_factorials(n)\n    \n    # Calculate permutations\n    # Choose and arrange smaller_count numbers from smaller_numbers\n    if smaller_count == 0:\n        smaller_ways = 1\n    else:\n        smaller_ways = (fact[smaller_numbers] * pow(fact[smaller_numbers - smaller_count], MOD - 2, MOD)) % MOD\n    \n    # Choose and arrange larger_count numbers from larger_numbers  \n    if larger_count == 0:\n        larger_ways = 1\n    else:\n        larger_ways = (fact[larger_numbers] * pow(fact[larger_numbers - larger_count], MOD - 2, MOD)) % MOD\n    \n    # Arrange remaining numbers in remaining positions\n    remaining_positions = (n - 1) - smaller_count - larger_count\n    remaining_ways = fact[remaining_positions] if remaining_positions >= 0 else 1\n    \n    result = (smaller_ways * larger_ways) % MOD\n    result = (result * remaining_ways) % MOD\n    \n    print(result)\n\nsolve()\n```"], "prompt_tokens": [606], "completion_tokens": [2194], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "24e2f10463f440affccc2755f4462d8a"}
{"description": "Today is the final contest of INOI (Iranian National Olympiad in Informatics). The contest room is a row with $$$n$$$ computers. All computers are numbered with integers from $$$1$$$ to $$$n$$$ from left to right. There are $$$m$$$ participants, numbered with integers from $$$1$$$ to $$$m$$$.We have an array $$$a$$$ of length $$$m$$$ where $$$a_{i}$$$ ($$$1 \\leq a_i \\leq n$$$) is the computer behind which the $$$i$$$-th participant wants to sit.Also, we have another array $$$b$$$ of length $$$m$$$ consisting of characters 'L' and 'R'. $$$b_i$$$ is the side from which the $$$i$$$-th participant enters the room. 'L' means the participant enters from the left of computer $$$1$$$ and goes from left to right, and 'R' means the participant enters from the right of computer $$$n$$$ and goes from right to left.The participants in the order from $$$1$$$ to $$$m$$$ enter the room one by one. The $$$i$$$-th of them enters the contest room in the direction $$$b_i$$$ and goes to sit behind the $$$a_i$$$-th computer. If it is occupied he keeps walking in his direction until he reaches the first unoccupied computer. After that, he sits behind it. If he doesn't find any computer he gets upset and gives up on the contest.The madness of the $$$i$$$-th participant is the distance between his assigned computer ($$$a_i$$$) and the computer he ends up sitting behind. The distance between computers $$$i$$$ and $$$j$$$ is equal to $$$|i - j|$$$.The values in the array $$$a$$$ can be equal. There exist $$$n^m \\cdot 2^m$$$ possible pairs of arrays $$$(a, b)$$$.Consider all pairs of arrays $$$(a, b)$$$ such that no person becomes upset. For each of them let's calculate the sum of participants madnesses. Find the sum of all these values.You will be given some prime modulo $$$p$$$. Find this sum by modulo $$$p$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains three integers $$$n$$$, $$$m$$$, $$$p$$$ ($$$1 \\leq m \\leq n \\leq 500, 10^8 \\leq p \\leq 10 ^ 9 + 9$$$). It is guaranteed, that the number $$$p$$$ is prime.", "output_spec": "Print only one integer\u00a0\u2014 the required sum by modulo $$$p$$$.", "notes": "NoteIn the first test, there are three possible arrays $$$a$$$: $$$\\{1\\}$$$, $$$\\{2\\}$$$, and $$$ \\{3\\}$$$ and two possible arrays $$$b$$$: $$$\\{\\mathtt{L}\\}$$$ and $$$\\{\\mathtt{R}\\}$$$. For all six pairs of arrays $$$(a, b)$$$, the only participant will sit behind the computer $$$a_1$$$, so his madness will be $$$0$$$. So the total sum of madnesses will be $$$0$$$.In the second test, all possible pairs of arrays $$$(a, b)$$$, such that no person becomes upset are:  $$$(\\{1, 1\\}, \\{\\mathtt{L}, \\mathtt{L}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{1, 1\\}, \\{\\mathtt{R}, \\mathtt{L}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{2, 2\\}, \\{\\mathtt{R}, \\mathtt{R}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{2, 2\\}, \\{\\mathtt{L}, \\mathtt{R}\\})$$$, the sum of madnesses is $$$1$$$;  all possible pairs of $$$a \\in \\{\\{1, 2\\}, \\{2, 1\\}\\}$$$ and $$$b \\in \\{\\{\\mathtt{L}, \\mathtt{L}\\}, \\{\\mathtt{R}, \\mathtt{L}\\}, \\{\\mathtt{L}, \\mathtt{R}\\}, \\{\\mathtt{R}, \\mathtt{R}\\}\\}$$$, the sum of madnesses is $$$0$$$. So, the answer is $$$1 + 1 + 1 + 1 + 0 \\ldots = 4$$$.", "sample_inputs": ["3 1 1000000007", "2 2 1000000009", "3 2 998244353", "20 10 1000000009"], "sample_outputs": ["0", "4", "8", "352081045"], "tags": ["fft", "dp", "combinatorics"], "src_uid": "9812de5f2d272511a63ead8765b23190", "difficulty": 3100, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "9812de5f2d272511a63ead8765b23190"}
