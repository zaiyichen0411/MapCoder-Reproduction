{"description": "The Little Elephant is playing with the Cartesian coordinates' system. Most of all he likes playing with integer points. The Little Elephant defines an integer point as a pair of integers (x;\u00a0y), such that 0\u2009\u2264\u2009x\u2009\u2264\u2009w and 0\u2009\u2264\u2009y\u2009\u2264\u2009h. Thus, the Little Elephant knows only (w\u2009+\u20091)\u00b7(h\u2009+\u20091) distinct integer points.The Little Elephant wants to paint a triangle with vertexes at integer points, the triangle's area must be a positive integer. For that, he needs to find the number of groups of three points that form such triangle. At that, the order of points in a group matters, that is, the group of three points (0;0), (0;2), (2;2) isn't equal to the group (0;2), (0;0), (2;2).Help the Little Elephant to find the number of groups of three integer points that form a nondegenerate triangle with integer area.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "A single line contains two integers w and h (1\u2009\u2264\u2009w,\u2009h\u2009\u2264\u20094000).", "output_spec": "In a single output line print an integer \u2014 the remainder of dividing the answer to the problem by 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["2 1", "2 2"], "sample_outputs": ["36", "240"], "tags": ["geometry", "math"], "src_uid": "984788e4b4925c15c9c6f31e42f2f8fa", "difficulty": 2500, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "984788e4b4925c15c9c6f31e42f2f8fa"}
{"description": "Polycarpus loves lucky numbers. Everybody knows that lucky numbers are positive integers, whose decimal representation (without leading zeroes) contain only the lucky digits x and y. For example, if x\u2009=\u20094, and y\u2009=\u20097, then numbers 47, 744, 4 are lucky.Let's call a positive integer a undoubtedly lucky, if there are such digits x and y (0\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20099), that the decimal representation of number a (without leading zeroes) contains only digits x and y.Polycarpus has integer n. He wants to know how many positive integers that do not exceed n, are undoubtedly lucky. Help him, count this number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 Polycarpus's number.", "output_spec": "Print a single integer that says, how many positive integers that do not exceed n are undoubtedly lucky.", "notes": "NoteIn the first test sample all numbers that do not exceed 10 are undoubtedly lucky.In the second sample numbers 102, 103, 104, 105, 106, 107, 108, 109, 120, 123 are not undoubtedly lucky.", "sample_inputs": ["10", "123"], "sample_outputs": ["10", "113"], "tags": ["brute force", "bitmasks", "dfs and similar"], "src_uid": "0f7f10557602c8c2f2eb80762709ffc4", "difficulty": 1600, "source_codes": ["\nfrom collections import deque\n\ndef count_undoubtedly_lucky(n):\n    visited = set()\n    \n    # For each pair of digits (including same digits)\n    for digit1 in range(10):\n        for digit2 in range(digit1, 10):\n            # Generate all numbers using only digit1 and digit2\n            queue = deque()\n            # Start with valid single digits (no leading zero)\n            if digit1 != 0:\n                queue.append(digit1)\n            if digit2 != 0 and digit2 != digit1:\n                queue.append(digit2)\n            if digit1 == 0 and digit2 == 0:\n                continue\n            \n            generated = set()\n            if digit1 != 0:\n                generated.add(digit1)\n            if digit2 != 0 and digit2 != digit1:\n                generated.add(digit2)\n                \n            while queue:\n                num = queue.popleft()\n                if num > n:\n                    continue\n                    \n                # Try both extensions\n                next1 = num * 10 + digit1\n                next2 = num * 10 + digit2\n                \n                if next1 <= n and next1 not in generated:\n                    queue.append(next1)\n                    generated.add(next1)\n                if next2 <= n and next2 not in generated:\n                    queue.append(next2)\n                    generated.add(next2)\n            \n            # Add all generated numbers to global visited set\n            visited.update(generated)\n    \n    return len(visited)\n\n# Read input and solve\nn = int(input())\nprint(count_undoubtedly_lucky(n))\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. **Lucky numbers**: Numbers that contain only two specific digits x and y\n2. **Undoubtedly lucky numbers**: Numbers that can be represented using only 2 distinct digits (any pair from 0-9)\n3. **Goal**: Count how many numbers \u2264 n are undoubtedly lucky\n\n## Key Insights\n\nLet me think about what numbers are **NOT** undoubtedly lucky:\n- Numbers that use 3 or more distinct digits\n\nSo I need to count numbers that use at most 2 distinct digits.\n\n## Approach\n\nIt's easier to use complementary counting:\n- Total numbers from 1 to n = n\n- Subtract numbers that use 3 or more distinct digits\n\nBut actually, let's think differently:\n- Count all numbers that use exactly 1 distinct digit\n- Count all numbers that use exactly 2 distinct digits\n\n## Better Approach\n\nLet's generate all possible undoubtedly lucky numbers:\n1. For each pair of digits (x,y) where 0\u2264x,y\u22649 and x\u2260y\n2. Generate all numbers \u2264 n that contain only digits x and y\n3. Use BFS/DFS to generate these numbers systematically\n\nWait, that might be inefficient for large n.\n\n## Mathematical Approach\n\nLet's think combinatorially:\n- Numbers with exactly 1 distinct digit: 1, 2, 3, ..., 9, 11, 22, 33, ..., 99, 111, 222, ...\n- Numbers with exactly 2 distinct digits: all combinations\n\nActually, let me re-read... \"undoubtedly lucky\" means there EXISTS some x,y such that the number contains only x and y. This is true for ALL numbers except those that use 3 or more different digits.\n\nWait, no. Let me re-read carefully...\n\n\"undoubtedly lucky\" - there exist digits x,y such that decimal representation contains ONLY x and y.\n\nSo a number is undoubtedly lucky if it uses at most 2 distinct digits.\n\n## Refined Approach\n\nCount numbers from 1 to n that have at most 2 distinct digits.\n\nUse complementary counting:\n- Answer = n - (count of numbers with 3 or more distinct digits)\n\nBut generating all numbers up to n and checking is too slow for n=10^9.\n\n## Correct Approach\n\nGenerate all undoubtedly lucky numbers up to n:\n1. For each valid pair of digits (including same digits), generate all numbers \u2264 n\n2. Use BFS to generate numbers systematically\n\nLet me think of pairs:\n- (0,1), (0,2), ..., (0,9) \n- (1,2), (1,3), ..., (1,9)\n- ...\n- (8,9)\n- Also (0,0), (1,1), ..., (9,9) for single digit numbers\n\nBut we need to be careful with leading zeros.\n\n## Implementation Plan\n\n1. Use BFS/queue to generate all valid numbers\n2. For each pair of digits, start BFS to generate all numbers \u2264 n\n3. Keep track of visited numbers to avoid duplicates\n4. Count all generated numbers\n\nLet me trace through examples:\n\nFor n=10: All numbers 1-10 have at most 2 distinct digits, so answer is 10.\n\nFor n=123: We need to exclude numbers like 102, 103, etc. that have 3 distinct digits.\n\nActually, let me think of a cleaner approach:\n\nGenerate all numbers with at most 2 distinct digits that are \u2264 n.\n\n## Cleaner Solution\n\nUse BFS with state space pruning:\n- Start with single digits 1-9 (they're all valid)\n- For each number, try appending each of the digits that are already used, or one new digit\n- But this is complex.\n\n## Simpler Approach\n\nSince n \u2264 10^9, there aren't too many numbers with at most 2 distinct digits.\n\nStrategy:\n1. Generate all numbers with exactly 1 distinct digit (1-9, 11-99, 111-999, ...)\n2. Generate all numbers with exactly 2 distinct digits\n3. Count those \u2264 n\n\nFor 2-digit combinations: we can enumerate all pairs and use BFS.\n\n```python\nfrom collections import deque\n\ndef solve(n):\n    if n <= 0:\n        return 0\n    \n    visited = set()\n    queue = deque()\n    count = 0\n    \n    # Generate all numbers with at most 2 distinct digits\n    # Try all pairs of digits\n    for d1 in range(10):\n        for d2 in range(d1, 10):  # d2 >= d1 to avoid duplicates\n            # BFS to generate all numbers using only d1 and d2\n            local_queue = deque()\n            local_visited = set()\n            \n            # Add starting numbers (avoiding leading zeros)\n            if d1 != 0:\n                local_queue.append(d1)\n                local_visited.add(d1)\n            if d2 != 0 and d2 != d1:\n                local_queue.append(d2)\n                local_visited.add(d2)\n            if d1 == d2 == 0:\n                continue\n                \n            while local_queue:\n                current = local_queue.popleft()\n                if current > n:\n                    continue\n                    \n                if current not in visited:\n                    visited.add(current)\n                    count += 1\n                \n                # Try appending d1 or d2\n                next1 = current * 10 + d1\n                next2 = current * 10 + d2\n                \n                if next1 <= n and next1 not in local_visited:\n                    local_queue.append(next1)\n                    local_visited.add(next1)\n                if next2 <= n and next2 not in local_visited:\n                    local_queue.append(next2)\n                    local_visited.add(next2)\n    \n    return count\n\n# Read input\nn = int(input())\nprint(solve(n))\n```\n\nWait, this approach has issues with duplicate counting. Let me fix it:\n\n```python\nfrom collections import deque\n\ndef count_undoubtedly_lucky(n):\n    visited = set()\n    \n    # For each pair of digits (including same digits)\n    for digit1 in range(10):\n        for digit2 in range(digit1, 10):\n            # Generate all numbers using only digit1 and digit2\n            queue = deque()\n            # Start with valid single digits (no leading zero)\n            if digit1 != 0:\n                queue.append(digit1)\n            if digit2 != 0 and digit2 != digit1:\n                queue.append(digit2)\n            if digit1 == 0 and digit2 == 0:\n                continue\n            \n            generated = set()\n            if digit1 != 0:\n                generated.add(digit1)\n            if digit2 != 0 and digit2 != digit1:\n                generated.add(digit2)\n                \n            while queue:\n                num = queue.popleft()\n                if num > n:\n                    continue\n                    \n                # Try both extensions\n                next1 = num * 10 + digit1\n                next2 = num * 10 + digit2\n                \n                if next1 <= n and next1 not in generated:\n                    queue.append(next1)\n                    generated.add(next1)\n                if next2 <= n and next2 not in generated:\n                    queue.append(next2)\n                    generated.add(next2)\n            \n            # Add all generated numbers to global visited set\n            visited.update(generated)\n    \n    return len(visited)\n\n# Read input and solve\nn = int(input())\nprint(count_undoubtedly_lucky(n))\n```"], "prompt_tokens": [413], "completion_tokens": [1597], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "0f7f10557602c8c2f2eb80762709ffc4"}
{"description": "One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "64 megabytes", "input_spec": "The first (and the only) input line contains integer number w (1\u2009\u2264\u2009w\u2009\u2264\u2009100) \u2014 the weight of the watermelon bought by the boys.", "output_spec": "Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.", "notes": "NoteFor example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).", "sample_inputs": ["8"], "sample_outputs": ["YES"], "tags": ["brute force", "math"], "src_uid": "230a3c4d7090401e5fa3c6b9d994cdf2", "difficulty": 800, "source_codes": ["\ndef can_divide_watermelon(w):\n    # Check if w is even and greater than 2\n    if w % 2 == 0 and w > 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nw = int(input())\n\n# Solve and print result\nresult = can_divide_watermelon(w)\nprint(result)\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\n1. We have a watermelon of weight `w` kilos\n2. We need to divide it into **two parts** such that:\n   - Each part has an **even** number of kilos\n   - Each part has **positive** weight (greater than 0)\n3. The two parts don't need to be equal\n\n## Analysis\n\nLet's think about when this is possible:\n- We need to split `w` into two even numbers: `a + b = w` where both `a` and `b` are even and positive\n- Even numbers are: 2, 4, 6, 8, 10, ...\n- Sum of two even numbers is always even\n- So if `w` is odd, it's impossible (since sum of two even numbers can't be odd)\n- If `w` is even, we need to check if we can split it into two positive even numbers\n\nLet's consider even values of `w`:\n- `w = 2`: Only split is 1+1 (both odd) \u2192 NO\n- `w = 4`: Split is 2+2 (both even) \u2192 YES  \n- `w = 6`: Split is 2+4 (both even) \u2192 YES\n- `w = 8`: Split is 2+6 or 4+4 (both even) \u2192 YES\n\nPattern: For even `w > 2`, we can always write it as `2 + (w-2)` where both are even and positive.\n\n## Solution Logic\n\n1. If `w` is odd \u2192 impossible \u2192 NO\n2. If `w` is even:\n   - If `w = 2` \u2192 only split is 1+1 \u2192 NO\n   - If `w > 2` \u2192 can split as 2+(w-2) \u2192 YES\n\nSo the condition is: `w` is even AND `w > 2`\n\n## Implementation\n\n```python\ndef can_divide_watermelon(w):\n    # Check if w is even and greater than 2\n    if w % 2 == 0 and w > 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nw = int(input())\n\n# Solve and print result\nresult = can_divide_watermelon(w)\nprint(result)\n```\n\nLet me verify with the sample:\n- Input: 8\n- 8 is even and 8 > 2\n- Output: YES \u2713\n\nLet me check edge cases:\n- w = 1: odd \u2192 NO\n- w = 2: even but not > 2 \u2192 NO  \n- w = 3: odd \u2192 NO\n- w = 4: even and > 2 \u2192 YES (2+2)\n\nThis matches our expected behavior."], "prompt_tokens": [395], "completion_tokens": [602], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "230a3c4d7090401e5fa3c6b9d994cdf2"}
{"description": "Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,\u2009y1), (x2,\u2009y2), ..., (xn,\u2009yn). The first vertex has a coordinate x1\u2009=\u20091, the second \u2014 x2\u2009=\u20092, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&lt;\u2009yj\u2009&gt;\u2009yj\u2009+\u20091,  there should be precisely t\u2009-\u20091 such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&gt;\u2009yj\u2009&lt;\u2009yj\u2009+\u20091,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "64 megabytes", "input_spec": "The first line contains a pair of integers n and t (3\u2009\u2264\u2009n\u2009\u2264\u200920, 1\u2009\u2264\u2009t\u2009\u2264\u200910).", "output_spec": "Output the required amount of camels with t humps.", "notes": "NoteIn the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).", "sample_inputs": ["6 1", "4 2"], "sample_outputs": ["6", "0"], "tags": ["dp"], "src_uid": "6d67559744583229455c5eafe68f7952", "difficulty": 1900, "source_codes": ["\ndef solve():\n    n, t = map(int, input().split())\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, prev_y, curr_y, humps, valleys):\n        # Base case: reached the end\n        if pos == n:\n            return 1 if (humps == t and valleys == t - 1) else 0\n        \n        # Memoization\n        if (pos, prev_y, curr_y, humps, valleys) in memo:\n            return memo[(pos, prev_y, curr_y, humps, valleys)]\n        \n        result = 0\n        \n        # Try all possible next y values (1 to 4, not equal to current)\n        for next_y in range(1, 5):\n            if next_y == curr_y:  # No horizontal segments\n                continue\n                \n            new_humps = humps\n            new_valleys = valleys\n            \n            # Check if current position (pos-1, curr_y) is a hump or valley\n            if pos >= 2:  # We have enough points to check\n                if prev_y < curr_y > next_y:  # Hump\n                    new_humps += 1\n                elif prev_y > curr_y < next_y:  # Valley\n                    new_valleys += 1\n            \n            # Continue only if we haven't exceeded limits\n            if new_humps <= t and new_valleys <= t - 1:\n                result += dp(pos + 1, curr_y, next_y, new_humps, new_valleys)\n        \n        memo[(pos, prev_y, curr_y, humps, valleys)] = result\n        return result\n    \n    total = 0\n    \n    # Try all starting combinations for first two positions\n    for y1 in range(1, 5):\n        for y2 in range(1, 5):\n            if y1 != y2:  # No horizontal segments\n                total += dp(2, y1, y2, 0, 0)\n    \n    print(total)\n\nsolve()\n\n\n"], "responses": ["I'll solve this step by step.\n\n## Problem Understanding\n\nWe need to count the number of valid polylines with:\n- `n` vertices at x-coordinates 1, 2, ..., n\n- y-coordinates between 1 and 4 (inclusive)\n- Exactly `t` humps (local maxima): where y[j-1] < y[j] > y[j+1]\n- Exactly `t-1` valleys (local minima): where y[j-1] > y[j] < y[j+1]\n- No horizontal segments (consecutive y-values must be different)\n\n## Approach\n\nThis is a dynamic programming problem. I'll use DP with states tracking:\n- Current position\n- Current y-coordinate\n- Previous y-coordinate\n- Number of humps found so far\n- Number of valleys found so far\n\n## Solution Steps\n\n1. **State Definition**: `dp[pos][prev][curr][humps][valleys]`\n2. **Transitions**: For each position, try all valid y-values (1-4, different from previous)\n3. **Count humps/valleys**: Check if current position forms a hump or valley\n4. **Base case**: Start at position 2 (need previous values)\n5. **Final answer**: Sum all valid complete sequences\n\nLet me trace through the first example (n=6, t=1):\n- We need exactly 1 hump and 0 valleys\n- Valid sequences like 123421: increasing then decreasing with one peak\n\n## Implementation\n\n```python\ndef solve():\n    n, t = map(int, input().split())\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, prev_y, curr_y, humps, valleys):\n        # Base case: reached the end\n        if pos == n:\n            return 1 if (humps == t and valleys == t - 1) else 0\n        \n        # Memoization\n        if (pos, prev_y, curr_y, humps, valleys) in memo:\n            return memo[(pos, prev_y, curr_y, humps, valleys)]\n        \n        result = 0\n        \n        # Try all possible next y values (1 to 4, not equal to current)\n        for next_y in range(1, 5):\n            if next_y == curr_y:  # No horizontal segments\n                continue\n                \n            new_humps = humps\n            new_valleys = valleys\n            \n            # Check if current position (pos-1, curr_y) is a hump or valley\n            if pos >= 2:  # We have enough points to check\n                if prev_y < curr_y > next_y:  # Hump\n                    new_humps += 1\n                elif prev_y > curr_y < next_y:  # Valley\n                    new_valleys += 1\n            \n            # Continue only if we haven't exceeded limits\n            if new_humps <= t and new_valleys <= t - 1:\n                result += dp(pos + 1, curr_y, next_y, new_humps, new_valleys)\n        \n        memo[(pos, prev_y, curr_y, humps, valleys)] = result\n        return result\n    \n    total = 0\n    \n    # Try all starting combinations for first two positions\n    for y1 in range(1, 5):\n        for y2 in range(1, 5):\n            if y1 != y2:  # No horizontal segments\n                total += dp(2, y1, y2, 0, 0)\n    \n    print(total)\n\nsolve()\n```\n\nLet me verify with the examples:\n\nFor n=6, t=1:\n- We want exactly 1 hump and 0 valleys\n- This means we want one peak and no troughs in the middle\n- The sequences given (123421, 123431, etc.) make sense\n\nFor n=4, t=2:\n- We want exactly 2 humps and 1 valley\n- But with only 4 points, we have only positions 2 and 3 for checking extrema\n- So we can have at most 1 hump and 1 valley, but we need exactly 2 humps\n- Therefore result is 0\n\nThe solution looks correct!\n\n```python\ndef solve():\n    n, t = map(int, input().split())\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, prev_y, curr_y, humps, valleys):\n        # Base case: reached the end\n        if pos == n:\n            return 1 if (humps == t and valleys == t - 1) else 0\n        \n        # Memoization\n        if (pos, prev_y, curr_y, humps, valleys) in memo:\n            return memo[(pos, prev_y, curr_y, humps, valleys)]\n        \n        result = 0\n        \n        # Try all possible next y values (1 to 4, not equal to current)\n        for next_y in range(1, 5):\n            if next_y == curr_y:  # No horizontal segments\n                continue\n                \n            new_humps = humps\n            new_valleys = valleys\n            \n            # Check if current position (pos-1, curr_y) is a hump or valley\n            if pos >= 2:  # We have enough points to check\n                if prev_y < curr_y > next_y:  # Hump\n                    new_humps += 1\n                elif prev_y > curr_y < next_y:  # Valley\n                    new_valleys += 1\n            \n            # Continue only if we haven't exceeded limits\n            if new_humps <= t and new_valleys <= t - 1:\n                result += dp(pos + 1, curr_y, next_y, new_humps, new_valleys)\n        \n        memo[(pos, prev_y, curr_y, humps, valleys)] = result\n        return result\n    \n    total = 0\n    \n    # Try all starting combinations for first two positions\n    for y1 in range(1, 5):\n        for y2 in range(1, 5):\n            if y1 != y2:  # No horizontal segments\n                total += dp(2, y1, y2, 0, 0)\n    \n    print(total)\n\nsolve()\n```"], "prompt_tokens": [603], "completion_tokens": [1346], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "6d67559744583229455c5eafe68f7952"}
