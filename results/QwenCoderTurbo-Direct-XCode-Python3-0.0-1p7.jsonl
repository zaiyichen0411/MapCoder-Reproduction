{"description": "You are given a binary string $$$s$$$.Find the number of distinct cyclical binary strings of length $$$n$$$ which contain $$$s$$$ as a substring.The cyclical string $$$t$$$ contains $$$s$$$ as a substring if there is some cyclical shift of string $$$t$$$, such that $$$s$$$ is a substring of this cyclical shift of $$$t$$$.For example, the cyclical string \"000111\" contains substrings \"001\", \"01110\" and \"10\", but doesn't contain \"0110\" and \"10110\".Two cyclical strings are called different if they differ from each other as strings. For example, two different strings, which differ from each other by a cyclical shift, are still considered different cyclical strings.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 40$$$)\u00a0\u2014 the length of the target string $$$t$$$. The next line contains the string $$$s$$$ ($$$1 \\le |s| \\le n$$$)\u00a0\u2014 the string which must be a substring of cyclical string $$$t$$$. String $$$s$$$ contains only characters '0' and '1'.", "output_spec": "Print the only integer\u00a0\u2014 the number of distinct cyclical binary strings $$$t$$$, which contain $$$s$$$ as a substring.", "notes": "NoteIn the first example, there are three cyclical strings, which contain \"0\"\u00a0\u2014 \"00\", \"01\" and \"10\".In the second example, there are only two such strings\u00a0\u2014 \"1010\", \"0101\".", "sample_inputs": ["2\n0", "4\n1010", "20\n10101010101010"], "sample_outputs": ["3", "2", "962"], "tags": ["dp", "strings"], "src_uid": "0034806908c9794086736a2d07fc654c", "difficulty": 2900, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "0034806908c9794086736a2d07fc654c"}
{"description": "Masha has three sticks of length $$$a$$$, $$$b$$$ and $$$c$$$ centimeters respectively. In one minute Masha can pick one arbitrary stick and increase its length by one centimeter. She is not allowed to break sticks.What is the minimum number of minutes she needs to spend increasing the stick's length in order to be able to assemble a triangle of positive area. Sticks should be used as triangle's sides (one stick for one side) and their endpoints should be located at triangle's vertices.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains tree integers $$$a$$$, $$$b$$$ and $$$c$$$ ($$$1 \\leq a, b, c \\leq 100$$$)\u00a0\u2014 the lengths of sticks Masha possesses.", "output_spec": "Print a single integer\u00a0\u2014 the minimum number of minutes that Masha needs to spend in order to be able to make the triangle of positive area from her sticks.", "notes": "NoteIn the first example, Masha can make a triangle from the sticks without increasing the length of any of them.In the second example, Masha can't make a triangle of positive area from the sticks she has at the beginning, but she can spend one minute to increase the length $$$2$$$ centimeter stick by one and after that form a triangle with sides $$$3$$$, $$$3$$$ and $$$5$$$ centimeters.In the third example, Masha can take $$$33$$$ minutes to increase one of the $$$10$$$ centimeters sticks by $$$33$$$ centimeters, and after that take $$$48$$$ minutes to increase another $$$10$$$ centimeters stick by $$$48$$$ centimeters. This way she can form a triangle with lengths $$$43$$$, $$$58$$$ and $$$100$$$ centimeters in $$$81$$$ minutes. One can show that it is impossible to get a valid triangle faster.", "sample_inputs": ["3 4 5", "2 5 3", "100 10 10"], "sample_outputs": ["0", "1", "81"], "tags": ["geometry", "brute force", "math"], "src_uid": "3dc56bc08606a39dd9ca40a43c452f09", "difficulty": 800, "source_codes": ["\ndef min_minutes_to_triangle(a, b, c):\n    # Sort the sides to make it easier to work with\n    sides = sorted([a, b, c])\n    x, y, z = sides[0], sides[1], sides[2]\n    \n    # Check if already forms a triangle\n    # For a valid triangle: sum of two smaller sides > largest side\n    if x + y > z:\n        return 0\n    \n    # We need to increase the sides so that x + y > z\n    # The minimum increase needed is when x + y becomes just greater than z\n    # So we need x + y >= z + 1, which means we need to increase total by (z + 1 - (x + y))\n    # But we can only increase sides, so we need to find the optimal way\n    \n    # The amount we need to make up\n    needed = z + 1 - (x + y)\n    \n    return needed\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print result\nresult = min_minutes_to_triangle(a, b, c)\nprint(result)\n\n\n"], "responses": ["```python\ndef min_minutes_to_triangle(a, b, c):\n    # Sort the sides to make it easier to work with\n    sides = sorted([a, b, c])\n    x, y, z = sides[0], sides[1], sides[2]\n    \n    # Check if already forms a triangle\n    # For a valid triangle: sum of two smaller sides > largest side\n    if x + y > z:\n        return 0\n    \n    # We need to increase the sides so that x + y > z\n    # The minimum increase needed is when x + y becomes just greater than z\n    # So we need x + y >= z + 1, which means we need to increase total by (z + 1 - (x + y))\n    # But we can only increase sides, so we need to find the optimal way\n    \n    # The amount we need to make up\n    needed = z + 1 - (x + y)\n    \n    return needed\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print result\nresult = min_minutes_to_triangle(a, b, c)\nprint(result)\n```"], "prompt_tokens": [518], "completion_tokens": [248], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "3dc56bc08606a39dd9ca40a43c452f09"}
{"description": "Hasan loves playing games and has recently discovered a game called TopScore. In this soccer-like game there are $$$p$$$ players doing penalty shoot-outs. Winner is the one who scores the most. In case of ties, one of the top-scorers will be declared as the winner randomly with equal probability.They have just finished the game and now are waiting for the result. But there's a tiny problem! The judges have lost the paper of scores! Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored. However, the information about the bounds is private, so Hasan only got to know his bound.According to the available data, he knows that his score is at least $$$r$$$ and sum of the scores is $$$s$$$.Thus the final state of the game can be represented in form of sequence of $$$p$$$ integers $$$a_1, a_2, \\dots, a_p$$$ ($$$0 \\le a_i$$$) \u2014 player's scores. Hasan is player number $$$1$$$, so $$$a_1 \\ge r$$$. Also $$$a_1 + a_2 + \\dots + a_p = s$$$. Two states are considered different if there exists some position $$$i$$$ such that the value of $$$a_i$$$ differs in these states. Once again, Hasan doesn't know the exact scores (he doesn't know his exact score as well). So he considers each of the final states to be equally probable to achieve.Help Hasan find the probability of him winning.It can be shown that it is in the form of $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \\ne 0$$$, $$$P \\le Q$$$. Report the value of $$$P \\cdot Q^{-1} \\pmod {998244353}$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains three integers $$$p$$$, $$$s$$$ and $$$r$$$ ($$$1 \\le p \\le 100$$$, $$$0 \\le r \\le s \\le 5000$$$) \u2014 the number of players, the sum of scores of all players and Hasan's score, respectively.", "output_spec": "Print a single integer \u2014 the probability of Hasan winning. It can be shown that it is in the form of $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \\ne 0$$$, $$$P \\le Q$$$. Report the value of $$$P \\cdot Q^{-1} \\pmod {998244353}$$$.", "notes": "NoteIn the first example Hasan can score $$$3$$$, $$$4$$$, $$$5$$$ or $$$6$$$ goals. If he scores $$$4$$$ goals or more than he scores strictly more than his only opponent. If he scores $$$3$$$ then his opponent also scores $$$3$$$ and Hasan has a probability of $$$\\frac 1 2$$$ to win the game. Thus, overall he has the probability of $$$\\frac 7 8$$$ to win.In the second example even Hasan's lower bound on goal implies him scoring more than any of his opponents. Thus, the resulting probability is $$$1$$$.", "sample_inputs": ["2 6 3", "5 20 11", "10 30 10"], "sample_outputs": ["124780545", "1", "85932500"], "tags": ["math", "probabilities", "combinatorics", "dp"], "src_uid": "609195ef4a970c62a8210dafe118580e", "difficulty": 2500, "source_codes": [""], "responses": ["Request timed out."], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "609195ef4a970c62a8210dafe118580e"}
{"description": "Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word \"abracadabra\" Hongcow will get words \"aabracadabr\", \"raabracadab\" and so on.Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of input will be a single string s (1\u2009\u2264\u2009|s|\u2009\u2264\u200950), the word Hongcow initially learns how to spell. The string s consists only of lowercase English letters ('a'\u2013'z').", "output_spec": "Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.", "notes": "NoteFor the first sample, the strings Hongcow can generate are \"abcd\", \"dabc\", \"cdab\", and \"bcda\".For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate \"bbb\".For the third sample, the two strings Hongcow can generate are \"yzyz\" and \"zyzy\".", "sample_inputs": ["abcd", "bbb", "yzyz"], "sample_outputs": ["4", "1", "2"], "tags": ["strings", "implementation"], "src_uid": "8909ac99ed4ab2ee4d681ec864c7831e", "difficulty": 900, "source_codes": ["\ndef count_distinct_cyclic_shifts(s):\n    if not s:\n        return 0\n    \n    distinct_strings = set()\n    current = s\n    \n    while current not in distinct_strings:\n        distinct_strings.add(current)\n        # Move last character to the beginning\n        current = current[-1] + current[:-1]\n    \n    return len(distinct_strings)\n\n# Read input and solve\ns = input().strip()\nresult = count_distinct_cyclic_shifts(s)\nprint(result)\n\n\n"], "responses": ["Looking at this problem, I need to find how many distinct strings can be generated by repeatedly moving the last character to the front (cyclic shifts).\n\nLet me think through the approach:\n1. Start with the original string\n2. Keep applying cyclic shifts and track all unique strings\n3. Stop when we get back to a string we've seen before (since it will cycle)\n4. Return the count of unique strings\n\nLet me trace through the examples:\n- \"abcd\": abcd \u2192 dabc \u2192 cdab \u2192 bcda \u2192 abcd (back to start) = 4 distinct strings\n- \"bbb\": bbb \u2192 bbb \u2192 ... = 1 distinct string  \n- \"yzyz\": yzyz \u2192 zyzy \u2192 yzyz \u2192 ... = 2 distinct strings\n\nHere's my solution:\n\n```python\ndef count_distinct_cyclic_shifts(s):\n    if not s:\n        return 0\n    \n    distinct_strings = set()\n    current = s\n    \n    while current not in distinct_strings:\n        distinct_strings.add(current)\n        # Move last character to the beginning\n        current = current[-1] + current[:-1]\n    \n    return len(distinct_strings)\n\n# Read input and solve\ns = input().strip()\nresult = count_distinct_cyclic_shifts(s)\nprint(result)\n```\n\nLet me verify with the examples:\n1. \"abcd\": \n   - Add \"abcd\", current becomes \"dabc\"\n   - Add \"dabc\", current becomes \"cdab\" \n   - Add \"cdab\", current becomes \"bcda\"\n   - Add \"bcda\", current becomes \"abcd\"\n   - \"abcd\" already in set, stop. Count = 4 \u2713\n\n2. \"bbb\":\n   - Add \"bbb\", current becomes \"bbb\"\n   - \"bbb\" already in set, stop. Count = 1 \u2713\n\n3. \"yzyz\":\n   - Add \"yzyz\", current becomes \"zyzy\"\n   - Add \"zyzy\", current becomes \"yzyz\" \n   - \"yzyz\" already in set, stop. Count = 2 \u2713\n\nThe solution works by generating each cyclic shift until we detect a cycle, using a set to automatically handle uniqueness."], "prompt_tokens": [451], "completion_tokens": [466], "no_of_try": 1, "is_solved": true, "language": "Python3", "task_id": "8909ac99ed4ab2ee4d681ec864c7831e"}
