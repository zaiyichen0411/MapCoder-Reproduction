{"name": "3554", "description": "Zonk is addictive dice game. In each round player rolls 6 dice. Then (s)he composes combinations from them. Each combination gives certain points. \n\nThen player can take one or more dice combinations to his hand and re-roll remaining dice or save his score. Dice in player's hand won't be taken into account in subsequent rolls.\n\nIf no combinations can be composed - situation is called \"zonk\". Player thrown zonk loses all points in this round and next player moves. So it's player decision when to reroll and when to stop and save his score.\n\nYour task is simple - just evaluate current roll and return maximum number of points can be scored from it. If no combinations can be made - function must return string ``\"Zonk\"`` (without quotes).\n\nThere are different variations of Zonk. In this kata, we will use most common table of combinations:\n\nCombinationExample rollPoints\nStraight (1,2,3,4,5 and 6)6 3 1 2 5 41000 points\nThree pairs of any dice2 2 4 4 1 1750 points\nThree of 11 4 1 11000 points\nThree of 22 3 4 2 2200 points\nThree of 33 4 3 6 3 2300 points\nThree of 44 4 4400 points\nThree of 52 5 5 5 4500 points\nThree of 66 6 2 6600 points\nFour of a kind1 1 1 1 4 62 \u00d7 Three-of-a-kind score (in example, 2000 pts)\nFive of a kind5 5 5 4 5 53 \u00d7 Three-of-a-kind score (in example, 1500 pts)\nSix of a kind4 4 4 4 4 44 \u00d7 Three-of-a-kind score (in example, 1600 pts)\nEvery 14 3 1 2 2100 points\nEvery 55 2 650 points\n\n\nEach die cannot be used in multiple combinations the same time, so three pairs of 2, 3 and 5 will worth you only ``750`` points (for three pairs), not 850 (for three pairs and two fives). But you can select multiple combinations, ``2 2 2 1 6`` will worth you ``300`` points (200 for three-of-kind '2' plus 100 for single '1' die)\n\nExamples:\n```python\n  get_score([1,2,3]) # returns 100 = points from one 1\n  get_score([3,4,1,1,5]) # returns 250 = points from two 1 and one 5\n  get_score([2,3,2,3,3,2]) # returns 500 = three of 2 + three of 3\n  get_score([1,1,1,1,1,5]) # returns 3050 = five 1 + one 5\n  get_score([2,3,4,3,6,6]) # returns \"Zonk\" = no combinations here\n  get_score([2,2,6,6,2,2]) # returns 400 = four 2, this cannot be scored as three pairs\n  get_score([1,3,4,3,4,1]) # returns 750 = three pairs\n  get_score([3,3,3,3]) # returns 600 = four of 3\n  get_score([1,2,3,4,5]) # returns 150 = it's not straight\n```\nOf course, in real Zonk game it's sometimes not worth to collect all combination from roll. Taking less dice and rerolling more remaining may be better, but task is just to calculate maximum possible score from current single roll.\n\nP.S. Inspired by this kata: http://www.codewars.com/kata/5270d0d18625160ada0000e4", "difficulty": "introductory", "id": 3554, "sample_io": [{"input": "[1, 2, 3]", "output": [100]}, {"input": "[3,4,1,1,5]", "output": [250]}, {"input": "[2,3,2,3,3,2]", "output": [500]}, {"input": "[1,1,1,1,1,5]", "output": [3050]}, {"input": "[2,3,4,3,6,6]", "output": ["Zonk"]}, {"input": "[2,2,6,6,2,2]", "output": [400]}, {"input": "[1,3,4,3,4,1]", "output": [750]}, {"input": "[3,3,3,3]", "output": [600]}, {"input": "[1,2,3,4,5]", "output": [150]}], "test_list": [{"input": "[1]", "output": [100]}, {"input": "[5]", "output": [50]}, {"input": "[1, 1]", "output": [200]}, {"input": "[5, 5]", "output": [100]}, {"input": "[5, 1]", "output": [150]}, {"input": "[5, 6]", "output": [50]}, {"input": "[1, 1, 1]", "output": [1000]}, {"input": "[2, 2, 2]", "output": [200]}, {"input": "[3, 3, 3]", "output": [300]}, {"input": "[4, 4, 4]", "output": [400]}, {"input": "[5, 5, 5]", "output": [500]}, {"input": "[6, 6, 6]", "output": [600]}, {"input": "[1, 2, 1]", "output": [200]}, {"input": "[1, 1, 5]", "output": [250]}, {"input": "[5, 5, 6]", "output": [100]}, {"input": "[1, 5, 5]", "output": [200]}, {"input": "[1, 1, 1, 1]", "output": [2000]}, {"input": "[2, 2, 2, 2]", "output": [400]}, {"input": "[3, 3, 3, 3]", "output": [600]}, {"input": "[4, 4, 4, 4]", "output": [800]}, {"input": "[5, 5, 5, 5]", "output": [1000]}, {"input": "[6, 6, 6, 6]", "output": [1200]}, {"input": "[1, 5, 5, 1]", "output": [300]}, {"input": "[2, 3, 4, 5]", "output": [50]}, {"input": "[3, 3, 5, 3]", "output": [350]}, {"input": "[1, 1, 1, 1, 1]", "output": [3000]}, {"input": "[2, 2, 2, 2, 2]", "output": [600]}, {"input": "[3, 3, 3, 3, 3]", "output": [900]}, {"input": "[4, 4, 4, 4, 4]", "output": [1200]}, {"input": "[5, 5, 5, 5, 5]", "output": [1500]}, {"input": "[6, 6, 6, 6, 6]", "output": [1800]}, {"input": "[1, 5, 1, 5, 1]", "output": [1100]}, {"input": "[1, 2, 3, 4, 5]", "output": [150]}, {"input": "[2, 3, 4, 5, 6]", "output": [50]}, {"input": "[1, 3, 4, 5, 2]", "output": [150]}, {"input": "[1, 1, 1, 1, 1, 1]", "output": [4000]}, {"input": "[2, 2, 2, 2, 2, 2]", "output": [800]}, {"input": "[3, 3, 3, 3, 3, 3]", "output": [1200]}, {"input": "[4, 4, 4, 4, 4, 4]", "output": [1600]}, {"input": "[5, 5, 5, 5, 5, 5]", "output": [2000]}, {"input": "[6, 6, 6, 6, 6, 6]", "output": [2400]}, {"input": "[2, 1, 3, 4, 6, 5]", "output": [1000]}, {"input": "[4, 4, 2, 2, 6, 6]", "output": [750]}, {"input": "[1, 2, 3, 4, 5, 5]", "output": [200]}, {"input": "[2, 2, 4, 2, 2, 4]", "output": [400]}, {"input": "[1, 3, 4, 5, 2, 2]", "output": [150]}, {"input": "[1, 5, 2, 1, 2, 5]", "output": [750]}, {"input": "[4, 1, 1, 1, 1, 5]", "output": [2050]}, {"input": "[3, 5, 2, 4, 2, 6]", "output": [50]}, {"input": "[1, 6, 6, 1, 1, 6]", "output": [1600]}], "starter_code": "\ndef get_score(dice):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 3554}
{"name": "4724", "description": "DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.", "difficulty": "introductory", "id": 4724, "sample_io": [{"input": "apple of banana", "output": ["Apple of Banana"]}, {"input": "apple", "output": ["Apple"]}, {"input": "one   space", "output": ["One   Space"]}, {"input": "   space WALK   ", "output": ["   Space Walk   "]}], "test_list": [{"input": "Apple Banana", "output": ["Apple Banana"]}, {"input": "Apple", "output": ["Apple"]}, {"input": "", "output": [""]}, {"input": "of", "output": ["of"]}, {"input": "Revelation of the contents outraged American public opinion, and helped generate", "output": ["Revelation of The Contents Outraged American Public Opinion, And Helped Generate"]}, {"input": "more  than    one space between words", "output": ["More  Than    One Space Between Words"]}, {"input": "  leading spaces", "output": ["  Leading Spaces"]}, {"input": "trailing spaces   ", "output": ["Trailing Spaces   "]}, {"input": "ALL CAPS CRAZINESS", "output": ["All Caps Craziness"]}, {"input": "rAnDoM CaPs CrAzInEsS", "output": ["Random Caps Craziness"]}], "starter_code": "\ndef drop_cap(str_):\n\t", "source_codes": ["**Solution Explanation**\n\nFor a given text we have to change every *word* (a maximal sequence of\nnon\u2011space characters) whose length is larger than\u202f2:\nmake the first letter uppercase and the rest of the word lowercase.\nWords of length\u202f1\u202for\u202f2 must stay unchanged \u2013 both their spelling *and*\ntheir original case are kept.\n\nThe required output has to preserve all spaces, including leading,\ntrailing and multiple consecutive spaces.  \nTherefore we must not delete or collapse any whitespace characters.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n1. **Split the string** on the literal space character (`' '`).\n   `str.split(' ')` creates a list that **keeps empty strings**\n   for runs of several spaces, which exactly matches the \u201cpreserve\n   everything\u201d requirement.\n2. **Process each part**  \n   * if its length\u202f>\u202f2 \u2192 `word.capitalize()` (first letter upper\u2011case,\n     rest lower\u2011case)  \n   * else \u2192 keep the part unchanged.\n3. **Join** the processed parts again with a single space `' '`.  \n   The number of spaces between words (including the empty parts) is\n   restored exactly as it was.\n4. **Read input** from standard input, call the transformation,\n   and print the result \u2013 `print` adds the required final newline.\n\nThe algorithm works in **O(n)** time where *n* is the length of the\ninput string, and uses **O(n)** additional memory for the list of\nparts.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the required transformed string.\n\n*Definitions*  \n\n* Let `S` be the input string.\n* Let `W = (w\u2081, w\u2082, \u2026, w_k)` be the list of *parts* obtained by\n  `S.split(' ')`.  \n  By definition of `split(' ')`, each `w_i` is either a maximal\n  consecutive sequence of non\u2011space characters (a word) or the empty\n  string (`''`).  \n  Moreover, the concatenation of the parts, inserting a single space\n  between consecutive parts, yields exactly `S`:\n\n  `S = w\u2081 + ' ' + w\u2082 + ' ' + \u2026 + ' ' + w_k`.\n\n*Algorithm step 2* creates a new list `R = (r\u2081, r\u2082, \u2026, r"], "responses": ["**Solution Explanation**\n\nFor a given text we have to change every *word* (a maximal sequence of\nnon\u2011space characters) whose length is larger than\u202f2:\nmake the first letter uppercase and the rest of the word lowercase.\nWords of length\u202f1\u202for\u202f2 must stay unchanged \u2013 both their spelling *and*\ntheir original case are kept.\n\nThe required output has to preserve all spaces, including leading,\ntrailing and multiple consecutive spaces.  \nTherefore we must not delete or collapse any whitespace characters.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n1. **Split the string** on the literal space character (`' '`).\n   `str.split(' ')` creates a list that **keeps empty strings**\n   for runs of several spaces, which exactly matches the \u201cpreserve\n   everything\u201d requirement.\n2. **Process each part**  \n   * if its length\u202f>\u202f2 \u2192 `word.capitalize()` (first letter upper\u2011case,\n     rest lower\u2011case)  \n   * else \u2192 keep the part unchanged.\n3. **Join** the processed parts again with a single space `' '`.  \n   The number of spaces between words (including the empty parts) is\n   restored exactly as it was.\n4. **Read input** from standard input, call the transformation,\n   and print the result \u2013 `print` adds the required final newline.\n\nThe algorithm works in **O(n)** time where *n* is the length of the\ninput string, and uses **O(n)** additional memory for the list of\nparts.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the required transformed string.\n\n*Definitions*  \n\n* Let `S` be the input string.\n* Let `W = (w\u2081, w\u2082, \u2026, w_k)` be the list of *parts* obtained by\n  `S.split(' ')`.  \n  By definition of `split(' ')`, each `w_i` is either a maximal\n  consecutive sequence of non\u2011space characters (a word) or the empty\n  string (`''`).  \n  Moreover, the concatenation of the parts, inserting a single space\n  between consecutive parts, yields exactly `S`:\n\n  `S = w\u2081 + ' ' + w\u2082 + ' ' + \u2026 + ' ' + w_k`.\n\n*Algorithm step 2* creates a new list `R = (r\u2081, r\u2082, \u2026, r"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 4724}
{"name": "4561", "description": "Consider the string `\"adfa\"` and the following rules: \n```Pearl\na) each character MUST be changed either to the one before or the one after in alphabet. \nb) \"a\" can only be changed to \"b\" and \"z\" to \"y\". \n```\nFrom our string, we get:\n```Pearl\n\"adfa\" -> [\"begb\",\"beeb\",\"bcgb\",\"bceb\"]\nAnother example: \"bd\" -> [\"ae\",\"ac\",\"ce\",\"cc\"]\n--We see that in each example, one of the possibilities is a palindrome.\n```\nI was working on the code for this but I couldn't quite figure it out. So far I have:\n\n```python\ndef solve(st):\n    return [all(ord(x) - ord(y) in [\"FIX\"] for x, y in zip(st, st[::-1]))][0]\n```\nI'm not sure what three numbers go into the array labelled `[\"FIX\"]`. This is the only thing missing. \n\nYou will be given a lowercase string and your task is to return `True` if at least one of the possiblities is a palindrome or `False` otherwise. You can use your own code or fix mine. \n\nMore examples in test cases. Good luck!", "difficulty": "introductory", "id": 4561, "sample_io": [{"input": "adfa", "output": [true]}, {"input": "bd", "output": [true]}], "test_list": [{"input": "abba", "output": [true]}, {"input": "abaazaba", "output": [false]}, {"input": "abccba", "output": [true]}, {"input": "adfa", "output": [true]}, {"input": "ae", "output": [false]}, {"input": "abzy", "output": [false]}, {"input": "ababbaba", "output": [true]}, {"input": "sq", "output": [true]}, {"input": "kxbkwgyydkcbtjcosgikfdyhuuprubpwthgflucpyylbofvqxkkvqthmdnywpaunfihvupbwpruwfybdmgeuocltdaidyyewmbzm", "output": [true]}], "starter_code": "\ndef solve(st):\n\t", "source_codes": ["import sys\n\ndef possible_shifts(ch: str) -> set:\n    \"\"\"\n    Return the set of letters reachable from `ch` by moving one step\n    left or right in the alphabet, respecting the boundary rules:\n        - 'a' can only become 'b'\n        - 'z' can only become 'y'\n    \"\"\"\n    if ch == 'a':\n        return {'b'}\n    if ch == 'z':\n        return {'y'}\n    return {chr(ord(ch) - 1), chr(ord(ch) + 1)}\n\n\ndef solve(st: str) -> bool:\n    \"\"\"\n    Return True if there exists at least one palindrome obtainable\n    by shifting every character of `st` one step left or right (with the\n    boundary rules).  Return False otherwise.\n    \"\"\"\n    n = len(st)\n    # Check each symmetric pair\n    for i in range(n // 2):\n        left = possible_shifts(st[i])\n        right = possible_shifts(st[n - 1 - i])\n        # No common letter -> impossible to match for a palindrome\n        if not left & right:\n            return False\n    # All pairs have at least one common choice\n    return True\n\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(solve(s))"], "responses": ["\nimport sys\n\ndef possible_shifts(ch: str) -> set:\n    \"\"\"\n    Return the set of letters reachable from `ch` by moving one step\n    left or right in the alphabet, respecting the boundary rules:\n        - 'a' can only become 'b'\n        - 'z' can only become 'y'\n    \"\"\"\n    if ch == 'a':\n        return {'b'}\n    if ch == 'z':\n        return {'y'}\n    return {chr(ord(ch) - 1), chr(ord(ch) + 1)}\n\n\ndef solve(st: str) -> bool:\n    \"\"\"\n    Return True if there exists at least one palindrome obtainable\n    by shifting every character of `st` one step left or right (with the\n    boundary rules).  Return False otherwise.\n    \"\"\"\n    n = len(st)\n    # Check each symmetric pair\n    for i in range(n // 2):\n        left = possible_shifts(st[i])\n        right = possible_shifts(st[n - 1 - i])\n        # No common letter -> impossible to match for a palindrome\n        if not left & right:\n            return False\n    # All pairs have at least one common choice\n    return True\n\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(solve(s))\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4561}
{"name": "4468", "description": "## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`", "difficulty": "introductory", "id": 4468, "sample_io": [{"input": "0", "output": [""]}, {"input": "56", "output": ["5*10+6"]}, {"input": "60", "output": ["6*10"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "10004", "output": ["1*10000+4"]}], "test_list": [{"input": "8964631", "output": ["8*1000000+9*100000+6*10000+4*1000+6*100+3*10+1"]}, {"input": "56", "output": ["5*10+6"]}, {"input": "999", "output": ["9*100+9*10+9"]}, {"input": "11", "output": ["1*10+1"]}, {"input": "991", "output": ["9*100+9*10+1"]}, {"input": "47", "output": ["4*10+7"]}, {"input": "234", "output": ["2*100+3*10+4"]}, {"input": "196587", "output": ["1*100000+9*10000+6*1000+5*100+8*10+7"]}, {"input": "660", "output": ["6*100+6*10"]}, {"input": "600", "output": ["6*100"]}, {"input": "9090", "output": ["9*1000+9*10"]}, {"input": "10104", "output": ["1*10000+1*100+4"]}, {"input": "80008", "output": ["8*10000+8"]}, {"input": "90000", "output": ["9*10000"]}, {"input": "0", "output": [""]}], "starter_code": "\ndef simplify(n):\n\t", "source_codes": ["def expand_number(num: int) -> str:\n    \"\"\"\n    Return the decimal expansion of a non\u2011negative integer.\n    For 0 an empty string is returned.\n    \"\"\"\n    if num == 0:\n        return \"\"\n\n    s = str(num)\n    length = len(s)\n    parts = []\n\n    for i, ch in enumerate(s):\n        digit = int(ch)\n        if digit == 0:          # skip zero digits\n            continue\n        exp = length - i - 1    # power of ten for this digit\n        if exp == 0:            # units place\n            parts.append(str(digit))\n        else:\n            parts.append(f\"{digit}*{10 ** exp}\")\n\n    return \"+\".join(parts)\n\n\ndef main() -> None:\n    try:\n        line = input().strip()\n    except EOFError:\n        return\n\n    n = int(line)\n    print(expand_number(n))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef expand_number(num: int) -> str:\n    \"\"\"\n    Return the decimal expansion of a non\u2011negative integer.\n    For 0 an empty string is returned.\n    \"\"\"\n    if num == 0:\n        return \"\"\n\n    s = str(num)\n    length = len(s)\n    parts = []\n\n    for i, ch in enumerate(s):\n        digit = int(ch)\n        if digit == 0:          # skip zero digits\n            continue\n        exp = length - i - 1    # power of ten for this digit\n        if exp == 0:            # units place\n            parts.append(str(digit))\n        else:\n            parts.append(f\"{digit}*{10 ** exp}\")\n\n    return \"+\".join(parts)\n\n\ndef main() -> None:\n    try:\n        line = input().strip()\n    except EOFError:\n        return\n\n    n = int(line)\n    print(expand_number(n))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4468}
{"name": "3613", "description": "# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 \u2264 string1.length \u2264 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value", "difficulty": "introductory", "id": 3613, "sample_io": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}], "test_list": [{"input": "aacb\naabc", "output": [true]}, {"input": "aa\nbc", "output": [false]}, {"input": "aaxxaaz\naazzaay", "output": [true]}, {"input": "aaxyaa\naazzaa", "output": [false]}, {"input": "aazzaa\naaxyaa", "output": [false]}, {"input": "jpeuizmi\nmxxcwriq", "output": [false]}], "starter_code": "\ndef is_substitution_cipher(s1, s2):\n\t", "source_codes": ["import sys\n\ndef canonical_pattern(s: str) -> list[int]:\n    \"\"\"\n    Return the pattern of a string.\n    The first distinct character gets id 0, the next distinct character id 1, etc.\n    Example: \"aacb\" -> [0, 0, 1, 2]\n    \"\"\"\n    mapping = {}\n    next_id = 0\n    pattern = []\n    for ch in s:\n        if ch not in mapping:\n            mapping[ch] = next_id\n            next_id += 1\n        pattern.append(mapping[ch])\n    return pattern\n\ndef are_translatable(s1: str, s2: str) -> bool:\n    \"\"\"True iff s1 and s2 can be obtained from each other using substitution ciphers.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    return canonical_pattern(s1) == canonical_pattern(s2)\n\ndef solve() -> None:\n    # Read two whitespace\u2011separated strings.\n    data = sys.stdin.read().split()\n    if len(data) < 2:\n        return\n    s1, s2 = data[0], data[1]\n\n    result = are_translatable(s1, s2)\n    # Print exactly \"True\" or \"False\" without extra whitespace.\n    sys.stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef canonical_pattern(s: str) -> list[int]:\n    \"\"\"\n    Return the pattern of a string.\n    The first distinct character gets id 0, the next distinct character id 1, etc.\n    Example: \"aacb\" -> [0, 0, 1, 2]\n    \"\"\"\n    mapping = {}\n    next_id = 0\n    pattern = []\n    for ch in s:\n        if ch not in mapping:\n            mapping[ch] = next_id\n            next_id += 1\n        pattern.append(mapping[ch])\n    return pattern\n\ndef are_translatable(s1: str, s2: str) -> bool:\n    \"\"\"True iff s1 and s2 can be obtained from each other using substitution ciphers.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    return canonical_pattern(s1) == canonical_pattern(s2)\n\ndef solve() -> None:\n    # Read two whitespace\u2011separated strings.\n    data = sys.stdin.read().split()\n    if len(data) < 2:\n        return\n    s1, s2 = data[0], data[1]\n\n    result = are_translatable(s1, s2)\n    # Print exactly \"True\" or \"False\" without extra whitespace.\n    sys.stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 3613}
{"name": "4465", "description": "Write a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.", "difficulty": "introductory", "id": 4465, "sample_io": [{"input": "123456", "output": [654321]}, {"input": "105", "output": [510]}, {"input": "12", "output": [21]}], "test_list": [{"input": "69", "output": [96]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [7210]}, {"input": "414", "output": [441]}, {"input": "608719", "output": [987610]}, {"input": "123456789", "output": [987654321]}, {"input": "700000000001", "output": [710000000000]}, {"input": "666666", "output": [666666]}, {"input": "2", "output": [2]}, {"input": "0", "output": [0]}], "starter_code": "\ndef super_size(n):\n\t", "source_codes": ["def super_size(num: int) -> int:\n    \"\"\"\n    Return the largest integer that can be formed by rearranging the digits of `num`.\n    Handles negative numbers as well (e.g. -123 -> -321).\n    \"\"\"\n    s = str(num)          # work with the string representation\n    sign = ''\n    if s.startswith('-'):  # preserve the sign if present\n        sign = '-'\n        s = s[1:]\n\n    # sort digits in descending order and rebuild the number\n    sorted_desc = ''.join(sorted(s, reverse=True))\n    return int(sign + sorted_desc)\n\n\ndef main() -> None:\n    import sys\n    # Read the whole input, split by any whitespace (handles one or many test cases)\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    results = []\n    for token in data.split():\n        try:\n            n = int(token)\n        except ValueError:\n            # Skip tokens that are not valid integers\n            continue\n        results.append(str(super_size(n)))  # convert back to string for joining\n\n    # Print each result on its own line\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef super_size(num: int) -> int:\n    \"\"\"\n    Return the largest integer that can be formed by rearranging the digits of `num`.\n    Handles negative numbers as well (e.g. -123 -> -321).\n    \"\"\"\n    s = str(num)          # work with the string representation\n    sign = ''\n    if s.startswith('-'):  # preserve the sign if present\n        sign = '-'\n        s = s[1:]\n\n    # sort digits in descending order and rebuild the number\n    sorted_desc = ''.join(sorted(s, reverse=True))\n    return int(sign + sorted_desc)\n\n\ndef main() -> None:\n    import sys\n    # Read the whole input, split by any whitespace (handles one or many test cases)\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    results = []\n    for token in data.split():\n        try:\n            n = int(token)\n        except ValueError:\n            # Skip tokens that are not valid integers\n            continue\n        results.append(str(super_size(n)))  # convert back to string for joining\n\n    # Print each result on its own line\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4465}
{"name": "3045", "description": "Given 2 elevators (named \"left\" and \"right\") in a building with 3 floors (numbered `0` to `2`), write a function `elevator` accepting 3 arguments (in order):\n\n- `left` - The current floor of the left elevator\n- `right` - The current floor of the right elevator\n- `call` -  The floor that called an elevator\n\nIt should return the name of the elevator closest to the called floor (`\"left\"`/`\"right\"`).\n\nIn the case where both elevators are equally distant from the called floor, choose the elevator to the right.\n\nYou can assume that the inputs will always be valid integers between 0-2.\n\nExamples:\n\n```python\nelevator(0, 1, 0) # => \"left\"\nelevator(0, 1, 1) # => \"right\"\nelevator(0, 1, 2) # => \"right\"\nelevator(0, 0, 0) # => \"right\"\nelevator(0, 2, 1) # => \"right\"\n```", "difficulty": "introductory", "id": 3045, "sample_io": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}], "test_list": [{"input": "0\n1\n0", "output": ["left"]}, {"input": "0\n1\n1", "output": ["right"]}, {"input": "0\n1\n2", "output": ["right"]}, {"input": "0\n0\n0", "output": ["right"]}, {"input": "0\n2\n1", "output": ["right"]}, {"input": "0\n0\n1", "output": ["right"]}, {"input": "0\n0\n2", "output": ["right"]}, {"input": "0\n2\n0", "output": ["left"]}, {"input": "0\n2\n2", "output": ["right"]}, {"input": "1\n0\n0", "output": ["right"]}, {"input": "1\n0\n1", "output": ["left"]}, {"input": "1\n0\n2", "output": ["left"]}, {"input": "1\n1\n0", "output": ["right"]}, {"input": "1\n1\n1", "output": ["right"]}, {"input": "1\n1\n2", "output": ["right"]}, {"input": "1\n2\n0", "output": ["left"]}, {"input": "1\n2\n1", "output": ["left"]}, {"input": "1\n2\n2", "output": ["right"]}, {"input": "2\n0\n0", "output": ["right"]}, {"input": "2\n0\n1", "output": ["right"]}, {"input": "2\n0\n2", "output": ["left"]}, {"input": "2\n1\n0", "output": ["right"]}, {"input": "2\n1\n1", "output": ["right"]}, {"input": "2\n1\n2", "output": ["left"]}, {"input": "2\n2\n0", "output": ["right"]}, {"input": "2\n2\n1", "output": ["right"]}, {"input": "2\n2\n2", "output": ["right"]}], "starter_code": "\ndef elevator(left, right, call):\n\t", "source_codes": ["def elevator(left: int, right: int, call: int) -> str:\n    \"\"\"\n    Return the name of the elevator ('left' or 'right') that is\n    closest to the floor that called the elevator.\n    If both elevators are equally distant, return the right one.\n    \"\"\"\n    left_dist = abs(call - left)\n    right_dist = abs(call - right)\n\n    # Choose right if left is not strictly closer (ties go to right)\n    return \"right\" if left_dist >= right_dist else \"left\"\n\n\ndef main() -> None:\n    # Read three integers from standard input, one per line\n    left = int(input())\n    right = int(input())\n    call = int(input())\n    \n    # Output the result\n    print(elevator(left, right, call))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef elevator(left: int, right: int, call: int) -> str:\n    \"\"\"\n    Return the name of the elevator ('left' or 'right') that is\n    closest to the floor that called the elevator.\n    If both elevators are equally distant, return the right one.\n    \"\"\"\n    left_dist = abs(call - left)\n    right_dist = abs(call - right)\n\n    # Choose right if left is not strictly closer (ties go to right)\n    return \"right\" if left_dist >= right_dist else \"left\"\n\n\ndef main() -> None:\n    # Read three integers from standard input, one per line\n    left = int(input())\n    right = int(input())\n    call = int(input())\n    \n    # Output the result\n    print(elevator(left, right, call))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 3045}
{"name": "4276", "description": "Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```", "difficulty": "introductory", "id": 4276, "sample_io": [{"input": "4.2", "output": [4]}, {"input": "4.3", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.8", "output": [5]}, {"input": "4.75", "output": [5]}], "test_list": [{"input": "4.2", "output": [4]}, {"input": "4.25", "output": [4.5]}, {"input": "4.4", "output": [4.5]}, {"input": "4.6", "output": [4.5]}, {"input": "4.75", "output": [5]}, {"input": "4.8", "output": [5]}, {"input": "4.5", "output": [4.5]}, {"input": "4.55", "output": [4.5]}, {"input": "4.74", "output": [4.5]}, {"input": "4.74999999999", "output": [4.5]}, {"input": "4.74999999991", "output": [4.5]}], "starter_code": "\ndef solution(n):\n\t", "source_codes": ["import sys\nimport math\n\ndef solution(x: float) -> float:\n    \"\"\"\n    Round x to the nearest 0.5 step.\n    Rounding is half\u2011up (ties are rounded to the larger step).\n    \"\"\"\n    # Multiply by 2, round half\u2011up, then divide back by 2.\n    return math.floor(x * 2 + 0.5) / 2.0\n\n\ndef main() -> None:\n    \"\"\"\n    Read a single number from standard input, call solution(), and print the result.\n    The output is an integer when there is no fractional part,\n    otherwise a number with exactly one digit after the decimal point.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    # Only the first token is required by the problem statement,\n    # but processing all tokens makes the script robust for multiple lines.\n    for token in data:\n        try:\n            x = float(token)\n        except ValueError:\n            continue\n\n        res = solution(x)\n\n        if res.is_integer():\n            # No fractional part \u2192 print as integer\n            sys.stdout.write(str(int(res)))\n        else:\n            # The only possible fractional part is .5, so one decimal place is enough\n            sys.stdout.write(f\"{res:.1f}\")\n\n        # If there are more tokens, separate outputs with a newline\n        if token != data[-1]:\n            sys.stdout.write(\"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport math\n\ndef solution(x: float) -> float:\n    \"\"\"\n    Round x to the nearest 0.5 step.\n    Rounding is half\u2011up (ties are rounded to the larger step).\n    \"\"\"\n    # Multiply by 2, round half\u2011up, then divide back by 2.\n    return math.floor(x * 2 + 0.5) / 2.0\n\n\ndef main() -> None:\n    \"\"\"\n    Read a single number from standard input, call solution(), and print the result.\n    The output is an integer when there is no fractional part,\n    otherwise a number with exactly one digit after the decimal point.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    # Only the first token is required by the problem statement,\n    # but processing all tokens makes the script robust for multiple lines.\n    for token in data:\n        try:\n            x = float(token)\n        except ValueError:\n            continue\n\n        res = solution(x)\n\n        if res.is_integer():\n            # No fractional part \u2192 print as integer\n            sys.stdout.write(str(int(res)))\n        else:\n            # The only possible fractional part is .5, so one decimal place is enough\n            sys.stdout.write(f\"{res:.1f}\")\n\n        # If there are more tokens, separate outputs with a newline\n        if token != data[-1]:\n            sys.stdout.write(\"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4276}
{"name": "2882", "description": "Imagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000", "difficulty": "introductory", "id": 2882, "sample_io": [{"input": "4", "output": [34]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [15]}, {"input": "4", "output": [34]}, {"input": "15", "output": [1695]}, {"input": "150", "output": [1687575]}, {"input": "100", "output": [500050]}, {"input": "500", "output": [62500250]}, {"input": "1000", "output": [500000500]}, {"input": "10000", "output": [500000005000]}], "starter_code": "\ndef cumulative_triangle(n):\n\t", "source_codes": ["def sum_of_nth_row(n: int) -> int:\n    \"\"\"\n    Return the sum of all numbers that appear in the n\u2011th row of the triangle.\n\n    The formula is:\n        sum = n * (n * n + 1) // 2\n    \"\"\"\n    return n * (n * n + 1) // 2\n\n\ndef main() -> None:\n    \"\"\"Read N from stdin, compute the sum, and print it.\"\"\"\n    tokens = input().strip().split()\n    if not tokens:\n        return\n    n = int(tokens[0])\n    print(sum_of_nth_row(n))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef sum_of_nth_row(n: int) -> int:\n    \"\"\"\n    Return the sum of all numbers that appear in the n\u2011th row of the triangle.\n\n    The formula is:\n        sum = n * (n * n + 1) // 2\n    \"\"\"\n    return n * (n * n + 1) // 2\n\n\ndef main() -> None:\n    \"\"\"Read N from stdin, compute the sum, and print it.\"\"\"\n    tokens = input().strip().split()\n    if not tokens:\n        return\n    n = int(tokens[0])\n    print(sum_of_nth_row(n))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 2882}
{"name": "4440", "description": "ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but **exactly** 4 digits or exactly 6 digits. \n\nIf the function is passed a valid PIN string, return `true`, else return `false`.\n\n## Examples \n```\n\"1234\"   -->  true\n\"12345\"  -->  false\n\"a234\"   -->  false\n```", "difficulty": "introductory", "id": 4440, "sample_io": [{"input": "1234", "output": [true]}, {"input": "12345", "output": [false]}, {"input": "a234", "output": [false]}], "test_list": [{"input": "1", "output": [false]}, {"input": "12", "output": [false]}, {"input": "123", "output": [false]}, {"input": "12345", "output": [false]}, {"input": "1234567", "output": [false]}, {"input": "-1234", "output": [false]}, {"input": "-12345", "output": [false]}, {"input": "1.234", "output": [false]}, {"input": "00000000", "output": [false]}, {"input": "a234", "output": [false]}, {"input": ".234", "output": [false]}, {"input": "1234", "output": [true]}, {"input": "0000", "output": [true]}, {"input": "1111", "output": [true]}, {"input": "123456", "output": [true]}, {"input": "098765", "output": [true]}, {"input": "000000", "output": [true]}, {"input": "090909", "output": [true]}], "starter_code": "\ndef validate_pin(pin):\n\t", "source_codes": ["import sys\n\ndef validate_pin(pin: str) -> bool:\n    \"\"\"\n    Return True if `pin` consists of exactly 4 or 6 digits, otherwise False.\n    \"\"\"\n    return pin.isdigit() and (len(pin) == 4 or len(pin) == 6)\n\n\ndef main() -> None:\n    # Read the input line; strip any trailing \\r or \\n characters\n    line = sys.stdin.readline()\n    if not line:\n        return                     # no input\n    pin = line.rstrip('\\r\\n')\n    print(validate_pin(pin))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef validate_pin(pin: str) -> bool:\n    \"\"\"\n    Return True if `pin` consists of exactly 4 or 6 digits, otherwise False.\n    \"\"\"\n    return pin.isdigit() and (len(pin) == 4 or len(pin) == 6)\n\n\ndef main() -> None:\n    # Read the input line; strip any trailing \\r or \\n characters\n    line = sys.stdin.readline()\n    if not line:\n        return                     # no input\n    pin = line.rstrip('\\r\\n')\n    print(validate_pin(pin))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4440}
{"name": "2771", "description": "Hofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book G\u00f6del, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!", "difficulty": "introductory", "id": 2771, "sample_io": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}], "test_list": [{"input": "1", "output": [1]}, {"input": "3", "output": [2]}, {"input": "7", "output": [5]}, {"input": "10", "output": [6]}, {"input": "100", "output": [56]}, {"input": "1000", "output": [502]}], "starter_code": "\ndef hofstadter_Q(n):\n\t", "source_codes": ["import sys\nfrom typing import List\n\ndef compute_up_to(max_n: int) -> List[int]:\n    \"\"\"\n    Build the Hofstadter Q sequence up to max_n (inclusive).\n    dp[i] will hold Q(i) for 1 <= i <= max_n.\n    \"\"\"\n    if max_n == 0:\n        return [0]                     # not used for valid queries\n    dp = [0] * (max_n + 1)            # 0\u2011based index, dp[0] is dummy\n    if max_n >= 1:\n        dp[1] = 1\n    if max_n >= 2:\n        dp[2] = 1\n    for i in range(3, max_n + 1):\n        dp[i] = dp[i - dp[i - 1]] + dp[i - dp[i - 2]]\n    return dp\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    queries = list(map(int, data))\n    max_n = max(queries)\n\n    dp = compute_up_to(max_n)\n\n    # Print each answer on its own line\n    out_lines = [str(dp[n]) for n in queries]\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nfrom typing import List\n\ndef compute_up_to(max_n: int) -> List[int]:\n    \"\"\"\n    Build the Hofstadter Q sequence up to max_n (inclusive).\n    dp[i] will hold Q(i) for 1 <= i <= max_n.\n    \"\"\"\n    if max_n == 0:\n        return [0]                     # not used for valid queries\n    dp = [0] * (max_n + 1)            # 0\u2011based index, dp[0] is dummy\n    if max_n >= 1:\n        dp[1] = 1\n    if max_n >= 2:\n        dp[2] = 1\n    for i in range(3, max_n + 1):\n        dp[i] = dp[i - dp[i - 1]] + dp[i - dp[i - 2]]\n    return dp\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    queries = list(map(int, data))\n    max_n = max(queries)\n\n    dp = compute_up_to(max_n)\n\n    # Print each answer on its own line\n    out_lines = [str(dp[n]) for n in queries]\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 2771}
{"name": "4335", "description": "What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:\n\n```\n'abba' & 'baab' == true\n\n'abba' & 'bbaa' == true\n\n'abba' & 'abbba' == false\n\n'abba' & 'abca' == false\n```\n\nWrite a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:\n\nanagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']\n\nanagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']\n\nanagrams('laser', ['lazing', 'lazy',  'lacer']) => []", "difficulty": "introductory", "id": 4335, "sample_io": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "laser\n['lazing', 'lazy', 'lacer']", "output": [[]]}], "test_list": [{"input": "abba\n['aabb', 'abcd', 'bbaa', 'dada']", "output": [["aabb", "bbaa"]]}, {"input": "racer\n['crazer', 'carer', 'racar', 'caers', 'racer']", "output": [["carer", "racer"]]}, {"input": "a\n['a', 'b', 'c', 'd']", "output": [["a"]]}, {"input": "ab\n['cc', 'ac', 'bc', 'cd', 'ab', 'ba', 'racar', 'caers', 'racer']", "output": [["ab", "ba"]]}, {"input": "abba\n['a', 'b', 'c', 'd', 'aabb', 'bbaa', 'abab', 'baba', 'baab', 'abcd', 'abbba', 'baaab', 'abbab', 'abbaa', 'babaa']", "output": [["aabb", "bbaa", "abab", "baba", "baab"]]}, {"input": "big\n['gig', 'dib', 'bid', 'biig']", "output": [[]]}], "starter_code": "\ndef anagrams(word, words):\n\t", "source_codes": ["import sys\nimport ast\nfrom collections import Counter\n\ndef anagrams(word: str, candidates: list) -> list:\n    \"\"\"Return all anagrams of `word` found in `candidates`.\"\"\"\n    target = Counter(word)\n    return [c for c in candidates\n            if len(c) == len(word) and Counter(c) == target]\n\ndef solve() -> None:\n    # read the word to find anagrams for\n    word_line = sys.stdin.readline()\n    if not word_line:\n        return\n    word = word_line.strip()\n\n    # read the list of candidate words\n    candidates = []\n    line = sys.stdin.readline()\n    if line:\n        line = line.strip()\n        # Accept a Python literal list or a whitespace\u2011separated list\n        if line.lstrip().startswith('['):\n            try:\n                candidates = ast.literal_eval(line)\n            except Exception:\n                candidates = line.split()\n        else:\n            candidates = line.split()\n\n    result = anagrams(word, candidates)\n    # Print the list of anagrams directly (as required by the problem statement)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport ast\nfrom collections import Counter\n\ndef anagrams(word: str, candidates: list) -> list:\n    \"\"\"Return all anagrams of `word` found in `candidates`.\"\"\"\n    target = Counter(word)\n    return [c for c in candidates\n            if len(c) == len(word) and Counter(c) == target]\n\ndef solve() -> None:\n    # read the word to find anagrams for\n    word_line = sys.stdin.readline()\n    if not word_line:\n        return\n    word = word_line.strip()\n\n    # read the list of candidate words\n    candidates = []\n    line = sys.stdin.readline()\n    if line:\n        line = line.strip()\n        # Accept a Python literal list or a whitespace\u2011separated list\n        if line.lstrip().startswith('['):\n            try:\n                candidates = ast.literal_eval(line)\n            except Exception:\n                candidates = line.split()\n        else:\n            candidates = line.split()\n\n    result = anagrams(word, candidates)\n    # Print the list of anagrams directly (as required by the problem statement)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 4335}
{"name": "3512", "description": "Just like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```", "difficulty": "introductory", "id": 3512, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "1000", "output": [5]}, {"input": "1000000", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "21", "output": [6]}, {"input": "302", "output": [1]}, {"input": "4003", "output": [7]}, {"input": "50004", "output": [8]}, {"input": "600005", "output": [5]}, {"input": "7000006", "output": [3]}, {"input": "80000007", "output": [8]}, {"input": "900000008", "output": [1]}, {"input": "1000000009", "output": [9]}], "starter_code": "\ndef last_fib_digit(n):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 3512}
{"name": "3435", "description": "# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters called airstrike to help them in war - dashes and dots are spreaded everywhere on the battlefield.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and `*` which means a bomb drop place. Return who wins the fight after bombs are exploded. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3 \n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3 \n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.  \nThe `*` bombs kills the adjacent letters ( i.e. `aa*aa` => `a___a`, `**aa**` => `______` );\n\n# Example\n\n# Alphabet war Collection\n\n\n\nAlphavet war \n\n\nAlphabet war - airstrike - letters massacre\n\n\nAlphabet wars - reinforces massacre\n\n\nAlphabet wars - nuclear strike\n\n\nAlphabet war - Wo lo loooooo priests join the war", "difficulty": "introductory", "id": 3435, "sample_io": [], "test_list": [{"input": "z", "output": ["Right side wins!"]}, {"input": "z*dq*mw*pb*s", "output": ["Let's fight again!"]}, {"input": "zdqmwpbs", "output": ["Let's fight again!"]}, {"input": "zz*zzs", "output": ["Right side wins!"]}, {"input": "sz**z**zs", "output": ["Left side wins!"]}, {"input": "z*z*z*zs", "output": ["Left side wins!"]}, {"input": "*wwwwww*z*", "output": ["Left side wins!"]}], "starter_code": "\ndef alphabet_war(fight):\n\t", "source_codes": ["def alphabet_war(fight: str) -> str:\n    left_power = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_power = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    n = len(fight)\n    removed = set()\n    # Step 1: mark all positions destroyed by bombs (including the bombs themselves)\n    for i, ch in enumerate(fight):\n        if ch == '*':\n            removed.add(i)  # the bomb itself\n            if i - 1 >= 0:\n                removed.add(i - 1)  # left neighbour\n            if i + 1 < n:\n                removed.add(i + 1)  # right neighbour\n    # Step 2: sum the powers of the letters that survived\n    left_score = 0\n    right_score = 0\n    for i, ch in enumerate(fight):\n        if i in removed:\n            continue\n        if ch in left_power:\n            left_score += left_power[ch]\n        elif ch in right_power:\n            right_score += right_power[ch]\n    # Determine the winner\n    if left_score > right_score:\n        return \"Left side wins!\"\n    if right_score > left_score:\n        return \"Right side wins!\"\n    return \"Let's fight again!\"\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read all lines \u2013 each line is a separate test case\n    lines = sys.stdin.read().splitlines()\n    if not lines:\n        sys.exit(0)\n\n    # If the first line is a number that matches the amount of remaining lines,\n    # treat it as the test\u2011case count.\n    if len(lines) > 1 and lines[0].strip().isdigit() and int(lines[0].strip()) == len(lines) - 1:\n        t = int(lines[0].strip())\n        test_cases = lines[1:1 + t]\n    else:\n        test_cases = lines\n\n    for s in test_cases:\n        print(alphabet_war(s.strip()))"], "responses": ["\ndef alphabet_war(fight: str) -> str:\n    left_power = {'w': 4, 'p': 3, 'b': 2, 's': 1}\n    right_power = {'m': 4, 'q': 3, 'd': 2, 'z': 1}\n    n = len(fight)\n    removed = set()\n    # Step 1: mark all positions destroyed by bombs (including the bombs themselves)\n    for i, ch in enumerate(fight):\n        if ch == '*':\n            removed.add(i)  # the bomb itself\n            if i - 1 >= 0:\n                removed.add(i - 1)  # left neighbour\n            if i + 1 < n:\n                removed.add(i + 1)  # right neighbour\n    # Step 2: sum the powers of the letters that survived\n    left_score = 0\n    right_score = 0\n    for i, ch in enumerate(fight):\n        if i in removed:\n            continue\n        if ch in left_power:\n            left_score += left_power[ch]\n        elif ch in right_power:\n            right_score += right_power[ch]\n    # Determine the winner\n    if left_score > right_score:\n        return \"Left side wins!\"\n    if right_score > left_score:\n        return \"Right side wins!\"\n    return \"Let's fight again!\"\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read all lines \u2013 each line is a separate test case\n    lines = sys.stdin.read().splitlines()\n    if not lines:\n        sys.exit(0)\n\n    # If the first line is a number that matches the amount of remaining lines,\n    # treat it as the test\u2011case count.\n    if len(lines) > 1 and lines[0].strip().isdigit() and int(lines[0].strip()) == len(lines) - 1:\n        t = int(lines[0].strip())\n        test_cases = lines[1:1 + t]\n    else:\n        test_cases = lines\n\n    for s in test_cases:\n        print(alphabet_war(s.strip()))\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 3435}
{"name": "3387", "description": "What's in a name?\n..Or rather, what's a name in? For us, a particular string is where we are looking for a name.\n\nTask\n\nTest whether or not the string contains all of the letters which spell a given name, in order.\n\nThe format\nA function passing two strings, searching for one (the name) within the other.\n``function nameInStr(str, name){ return true || false }``\n\nExamples\n\n    nameInStr(\"Across the rivers\", \"chris\") --> true\n                ^      ^  ^^   ^\n                c      h  ri   s\n                \n    Contains all of the letters in \"chris\", in order.\n----------------------------------------------------------\n    nameInStr(\"Next to a lake\", \"chris\") --> false\n    \n    Contains none of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"Under a sea\", \"chris\") --> false\n                   ^   ^\n                   r   s\n                   \n    Contains only some of the letters in \"chris\".\n--------------------------------------------------------------------\n    nameInStr(\"A crew that boards the ship\", \"chris\") --> false\n                 cr    h              s i\n                 cr                h  s i  \n                 c     h      r       s i\n                 ...\n                 \n    Contains all of the letters in \"chris\", but not in order.\n--------------------------------------------------------------------\n    nameInStr(\"A live son\", \"Allison\") --> false\n               ^ ^^   ^^^\n               A li   son\n                 \n    Contains all of the correct letters in \"Allison\", in order, \n    but not enough of all of them (missing an 'l').\n    \n\nNote: testing will _not_ be case-sensitive.", "difficulty": "introductory", "id": 3387, "sample_io": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}], "test_list": [{"input": "Across the rivers\nchris", "output": [true]}, {"input": "Next to a lake\nchris", "output": [false]}, {"input": "Under a sea\nchris", "output": [false]}, {"input": "A crew that boards the ship\nchris", "output": [false]}, {"input": "A live son\nAllison", "output": [false]}, {"input": "Just enough nice friends\nJennifer", "output": [false]}, {"input": "thomas\nThomas", "output": [true]}, {"input": "pippippi\nPippi", "output": [true]}, {"input": "pipipp\nPippi", "output": [false]}, {"input": "ppipip\nPippi", "output": [false]}], "starter_code": "\ndef name_in_str(str, name):\n\t", "source_codes": ["import sys\n\ndef nameInStr(text: str, name: str) -> bool:\n    \"\"\"\n    Return True if `name` appears as a subsequence of `text`\n    (case\u2011insensitive).  A subsequence means the characters of `name`\n    occur in `text` in the same order, possibly with other characters\n    between them.\n    \"\"\"\n    # Convert to the same case \u2013 casefold is stronger than lower()\n    text = text.casefold()\n    name = name.casefold()\n\n    i = 0                     # index of the next character of `name` we need\n    n = len(name)\n    for ch in text:\n        if i < n and ch == name[i]:\n            i += 1\n            if i == n:        # whole name matched, we can stop early\n                break\n    return i == n\n\n\ndef solve() -> None:\n    \"\"\"\n    Read two lines from standard input:\n        line 1 \u2013 the string to be searched,\n        line 2 \u2013 the name to find.\n    Print the boolean result of `nameInStr`.\n    \"\"\"\n    # Read the whole input; split into lines while preserving leading/trailing\n    # spaces inside each line (they are significant for subsequence checking).\n    data = sys.stdin.read().splitlines()\n    if not data:                     # empty input \u2013 nothing to do\n        return\n\n    s = data[0]                      # the string to be searched\n    name = data[1] if len(data) > 1 else ''   # the name to find (empty if missing)\n\n    print(nameInStr(s, name))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef nameInStr(text: str, name: str) -> bool:\n    \"\"\"\n    Return True if `name` appears as a subsequence of `text`\n    (case\u2011insensitive).  A subsequence means the characters of `name`\n    occur in `text` in the same order, possibly with other characters\n    between them.\n    \"\"\"\n    # Convert to the same case \u2013 casefold is stronger than lower()\n    text = text.casefold()\n    name = name.casefold()\n\n    i = 0                     # index of the next character of `name` we need\n    n = len(name)\n    for ch in text:\n        if i < n and ch == name[i]:\n            i += 1\n            if i == n:        # whole name matched, we can stop early\n                break\n    return i == n\n\n\ndef solve() -> None:\n    \"\"\"\n    Read two lines from standard input:\n        line 1 \u2013 the string to be searched,\n        line 2 \u2013 the name to find.\n    Print the boolean result of `nameInStr`.\n    \"\"\"\n    # Read the whole input; split into lines while preserving leading/trailing\n    # spaces inside each line (they are significant for subsequence checking).\n    data = sys.stdin.read().splitlines()\n    if not data:                     # empty input \u2013 nothing to do\n        return\n\n    s = data[0]                      # the string to be searched\n    name = data[1] if len(data) > 1 else ''   # the name to find (empty if missing)\n\n    print(nameInStr(s, name))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 3387}
