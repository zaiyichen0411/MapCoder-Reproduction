{"name": "2886", "description": "# Description:\n\n Find the longest successive exclamation marks and question marks combination in the string. A successive exclamation marks and question marks combination must contains two part: a substring of \"!\" and a substring \"?\", they are adjacent. \n \n If more than one result are found, return the one which at left side; If no such a combination found, return `\"\"`.\n\n# Examples\n\n```\nfind(\"!!\") === \"\"\nfind(\"!??\") === \"!??\"\nfind(\"!?!!\") === \"?!!\"\nfind(\"!!???!????\") === \"!!???\"\nfind(\"!!???!?????\") === \"!?????\"\nfind(\"!????!!!?\") === \"????!!!\" \nfind(\"!?!!??!!!?\") === \"??!!!\"\n```\n\n# Note\nPlease don't post issue about difficulty or duplicate. Because:\n>[That's unfair on the kata creator. This is a valid kata and introduces new people to javascript some regex or loops, depending on how they tackle this problem.  --matt c](https://www.codewars.com/kata/remove-exclamation-marks/discuss#57fabb625c9910c73000024e)", "difficulty": "introductory", "id": 2886, "sample_io": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "test_list": [{"input": "!!", "output": [""]}, {"input": "!??", "output": ["!??"]}, {"input": "!?!!", "output": ["?!!"]}, {"input": "!!???!????", "output": ["!!???"]}, {"input": "!!???!?????", "output": ["!?????"]}, {"input": "!????!!!?", "output": ["????!!!"]}, {"input": "!?!!??!!!?", "output": ["??!!!"]}], "starter_code": "\ndef find(s):\n\t", "source_codes": ["import sys\n\ndef find(s: str) -> str:\n    \"\"\"\n    Return the longest substring that is a run of '!' directly followed\n    by a run of '?' (or the opposite order). If no such combination\n    exists, return the empty string.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    # 1. compress into runs (character, length)\n    chars = []   # characters of each run\n    lens = []    # lengths of each run\n    last = s[0]\n    cnt = 1\n    for ch in s[1:]:\n        if ch == last:\n            cnt += 1\n        else:\n            chars.append(last)\n            lens.append(cnt)\n            last = ch\n            cnt = 1\n    chars.append(last)\n    lens.append(cnt)\n\n    best_len = 0\n    best_sub = \"\"\n\n    # 2. examine every adjacent run pair\n    for i in range(len(chars) - 1):\n        # a valid pair must be exactly one '!' and one '?' adjacent\n        if chars[i] in \"!?\" and chars[i+1] in \"!?\" and chars[i] != chars[i+1]:\n            cur_len = lens[i] + lens[i + 1]\n            if cur_len > best_len:               # strictly greater \u2192 keep leftmost on ties\n                best_len = cur_len\n                best_sub = chars[i] * lens[i] + chars[i + 1] * lens[i + 1]\n\n    return best_sub\n\n\ndef main() -> None:\n    # read the whole input, strip surrounding whitespace/newlines\n    s = sys.stdin.read().strip()\n    sys.stdout.write(find(s))\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef find(s: str) -> str:\n    \"\"\"\n    Return the longest substring that is a run of '!' directly followed\n    by a run of '?' (or the opposite order). If no such combination\n    exists, return the empty string.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    # 1. compress into runs (character, length)\n    chars = []   # characters of each run\n    lens = []    # lengths of each run\n    last = s[0]\n    cnt = 1\n    for ch in s[1:]:\n        if ch == last:\n            cnt += 1\n        else:\n            chars.append(last)\n            lens.append(cnt)\n            last = ch\n            cnt = 1\n    chars.append(last)\n    lens.append(cnt)\n\n    best_len = 0\n    best_sub = \"\"\n\n    # 2. examine every adjacent run pair\n    for i in range(len(chars) - 1):\n        # a valid pair must be exactly one '!' and one '?' adjacent\n        if chars[i] in \"!?\" and chars[i+1] in \"!?\" and chars[i] != chars[i+1]:\n            cur_len = lens[i] + lens[i + 1]\n            if cur_len > best_len:               # strictly greater \u2192 keep leftmost on ties\n                best_len = cur_len\n                best_sub = chars[i] * lens[i] + chars[i + 1] * lens[i + 1]\n\n    return best_sub\n\n\ndef main() -> None:\n    # read the whole input, strip surrounding whitespace/newlines\n    s = sys.stdin.read().strip()\n    sys.stdout.write(find(s))\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 2886}
