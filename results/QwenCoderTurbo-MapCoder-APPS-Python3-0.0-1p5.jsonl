{"name": "1617", "description": "I started this as a joke among friends, telling that converting numbers to other integer bases is for n00bs, while an actual coder at least converts numbers to more complex bases like [pi (or \u03c0 or however you wish to spell it in your language)](http://en.wikipedia.org/wiki/Pi), so they dared me proving I was better.\n\nAnd I did it in few hours, discovering that what I started as a joke actually has [some math ground and application (particularly the conversion to base pi, it seems)](http://en.wikipedia.org/wiki/Non-integer_representation).\n\nThat said, now I am daring you to do the same, that is to build a function so that it takes a **number** (any number, you are warned!) and optionally the **number of decimals** (default: 0) and a **base** (default: pi), returning the proper conversion **as a string**:\n\n#Note\nIn Java there is no easy way with optional parameters so all three parameters will be given; the same in C# because, as of now, the used version is not known. \n\n```python\nconverter(13) #returns '103'\nconverter(13,3) #returns '103.010'\nconverter(-13,0,2) #returns '-1101'\n```\n\nI know most of the world uses a comma as a [decimal mark](http://en.wikipedia.org/wiki/Decimal_mark), but as English language and culture are *de facto* the Esperanto of us coders, we will stick to our common glorious traditions and uses, adopting the trivial dot (\".\") as decimal separator; if the absolute value of the result is <1, you have of course to put one (and only one) leading 0 before the decimal separator.\n\nFinally, you may assume that decimals if provided will always be >= 0 and that no test base will be smaller than 2 (because, you know, converting to base 1 is pretty lame) or greater than 36; as usual, for digits greater than 9 you can use uppercase alphabet letter, so your base of numeration is going to be: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\nThat is my first 3-languages-kata, so I count on you all to give me extensive feedback, no matter how harsh it may sound, so to improve myself even further :)", "difficulty": "interview", "id": 1617, "sample_io": [{"input": "13", "output": ["103"]}, {"input": "13\n3", "output": ["103.010"]}, {"input": "-13\n0\n2", "output": ["-1101"]}], "test_list": [{"input": "13", "output": ["103"]}, {"input": "10", "output": ["100"]}, {"input": "13\n3", "output": ["103.010"]}, {"input": "13\n0\n8", "output": ["15"]}, {"input": "10\n0\n16", "output": ["A"]}, {"input": "10000\n4\n13", "output": ["4723.0000"]}, {"input": "7\n0\n19", "output": ["7"]}, {"input": "13.5\n4\n16", "output": ["D.8000"]}, {"input": "10.81\n0\n16", "output": ["A"]}, {"input": "1\n2\n2", "output": ["1.00"]}, {"input": "-10\n0\n23", "output": ["-A"]}, {"input": "0\n4\n26", "output": ["0.0000"]}, {"input": "-15.5\n2\n23", "output": ["-F.BB"]}, {"input": "13\n0\n10", "output": ["13"]}, {"input": "5.5\n1\n10", "output": ["5.5"]}], "starter_code": "\ndef converter(n, decimals=0, base=pi):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1617}
{"name": "1660", "description": "When we attended middle school were asked to simplify mathematical expressions like \"3x-yx+2xy-x\" (or usually bigger), and that was easy-peasy (\"2x+xy\"). But tell that to your pc and we'll see! \n\nWrite a function: `simplify`, that takes a string in input, representing a *multilinear non-constant polynomial in integers coefficients* (like `\"3x-zx+2xy-x\"`), and returns another string as output where the same expression has been simplified in the following way ( `->` means application of `simplify`):\n\n- All possible sums and subtraction of equivalent monomials (\"xy==yx\") has been done, e.g.: `\"cb+cba\" -> \"bc+abc\"`, `\"2xy-yx\" -> \"xy\"`, `\"-a+5ab+3a-c-2a\" -> \"-c+5ab\"`\n\n- All monomials appears in order of increasing number of variables, e.g.: `\"-abc+3a+2ac\" -> \"3a+2ac-abc\"`, `\"xyz-xz\" -> \"-xz+xyz\"`\n \n- If two monomials have the same number of variables, they appears in lexicographic order, e.g.: `\"a+ca-ab\" -> \"a-ab+ac\"`, `\"xzy+zby\" ->\"byz+xyz\"`\n  \n- There is no leading `+` sign if the first coefficient is positive, e.g.: `\"-y+x\" -> \"x-y\"`, but no restrictions for `-`:  `\"y-x\" ->\"-x+y\"`\n\n---\n\n__N.B.__ to keep it simplest, the string in input is restricted to represent only *multilinear non-constant polynomials*, so you won't find something like `-3+yx^2'. **Multilinear** means in this context: **of degree 1 on each variable**.\n\n**Warning**: the string in input can contain arbitrary variables represented by lowercase characters in the english alphabet.\n\n__Good Work :)__", "difficulty": "interview", "id": 1660, "sample_io": [{"input": "cb+cba", "output": ["bc+abc"]}, {"input": "2xy-yx", "output": ["xy"]}, {"input": "-a+5ab+3a-c-2a", "output": ["-c+5ab"]}, {"input": "-abc+3a+2ac", "output": ["3a+2ac-abc"]}, {"input": "xyz-xz", "output": ["-xz+xyz"]}, {"input": "a+ca-ab", "output": ["a-ab+ac"]}, {"input": "xzy+zby", "output": ["byz+xyz"]}, {"input": "-y+x", "output": ["x-y"]}, {"input": "y-x", "output": ["-x+y"]}], "test_list": [{"input": "dc+dcba", "output": ["cd+abcd"]}, {"input": "2xy-yx", "output": ["xy"]}, {"input": "-a+5ab+3a-c-2a", "output": ["-c+5ab"]}, {"input": "-abc+3a+2ac", "output": ["3a+2ac-abc"]}, {"input": "xyz-xz", "output": ["-xz+xyz"]}, {"input": "a+ca-ab", "output": ["a-ab+ac"]}, {"input": "xzy+zby", "output": ["byz+xyz"]}, {"input": "-y+x", "output": ["x-y"]}, {"input": "y-x", "output": ["-x+y"]}, {"input": "3a+b+4ac+bc-ab+3a-cb-a-a", "output": ["4a+b-ab+4ac"]}, {"input": "+n-5hn+7tjhn-4nh-3n-6hnjt+2jhn+9hn", "output": ["-2n+2hjn+hjnt"]}, {"input": "-8fk+5kv-4yk+7kf-qk+yqv-3vqy+4ky+4kf+yvqkf", "output": ["3fk-kq+5kv-2qvy+fkqvy"]}], "starter_code": "\ndef simplify(poly):\n\t", "source_codes": ["import sys\nimport re\n\ndef simplify(poly: str) -> str:\n    \"\"\"\n    Simplify a multilinear polynomial given as a string.\n    \"\"\"\n    # 1. Extract (sign, coefficient_digits, variable_letters) triples.\n    #    The pattern also matches empty leading sign.\n    pattern = r'([+-]?)(\\d*)([a-z]*)'\n    matches = re.findall(pattern, poly)\n\n    coeff_map = {}                     # variable_key -> summed coefficient\n    for sign, digits, letters in matches:\n        # ignore empty monomials (both parts empty)\n        if not digits and not letters:\n            continue\n        # the problem guarantees non\u2011constant polynomials,\n        # but we still ignore a pure constant if it occurs.\n        if not letters:\n            continue\n\n        # numeric coefficient\n        coeff = int(digits) if digits else 1\n        if sign == '-':\n            coeff = -coeff\n\n        # canonical variable string (sorted letters)\n        var_key = ''.join(sorted(letters))\n\n        # accumulate\n        coeff_map[var_key] = coeff_map.get(var_key, 0) + coeff\n\n    # 2. Remove zero coefficients\n    coeff_map = {v: c for v, c in coeff_map.items() if c != 0}\n\n    # 3. Sort by (degree, lexicographic)\n    sorted_items = sorted(coeff_map.items(),\n                          key=lambda kv: (len(kv[0]), kv[0]))\n\n    # 4. Build the output string\n    parts = []\n    for i, (var, coeff) in enumerate(sorted_items):\n        # separate sign from absolute value\n        if coeff < 0:\n            sign = '-'\n            mag = -coeff\n        else:\n            sign = '+'\n            mag = coeff\n\n        # magnitude part without sign\n        if var == '':\n            # constant term (should not appear for the given constraints)\n            mag_str = str(mag)\n        else:\n            if mag == 1:\n                mag_str = var          # omit the coefficient 1\n            else:\n                mag_str = str(mag) + var\n\n        # prepend sign according to position\n        if i == 0:\n            # first term \u2013 no leading '+'\n            parts.append(mag_str if sign == '+' else '-' + mag_str)\n        else:\n            parts.append(sign + mag_str)\n\n    result = ''.join(parts)\n\n    # if everything cancelled, output 0 (well\u2011behaved)\n    if not result:\n        result = '0'\n    return result\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Input may contain several lines \u2013 we only need the first one.\n    poly = data.splitlines()[0].strip()\n    print(simplify(poly))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport re\n\ndef simplify(poly: str) -> str:\n    \"\"\"\n    Simplify a multilinear polynomial given as a string.\n    \"\"\"\n    # 1. Extract (sign, coefficient_digits, variable_letters) triples.\n    #    The pattern also matches empty leading sign.\n    pattern = r'([+-]?)(\\d*)([a-z]*)'\n    matches = re.findall(pattern, poly)\n\n    coeff_map = {}                     # variable_key -> summed coefficient\n    for sign, digits, letters in matches:\n        # ignore empty monomials (both parts empty)\n        if not digits and not letters:\n            continue\n        # the problem guarantees non\u2011constant polynomials,\n        # but we still ignore a pure constant if it occurs.\n        if not letters:\n            continue\n\n        # numeric coefficient\n        coeff = int(digits) if digits else 1\n        if sign == '-':\n            coeff = -coeff\n\n        # canonical variable string (sorted letters)\n        var_key = ''.join(sorted(letters))\n\n        # accumulate\n        coeff_map[var_key] = coeff_map.get(var_key, 0) + coeff\n\n    # 2. Remove zero coefficients\n    coeff_map = {v: c for v, c in coeff_map.items() if c != 0}\n\n    # 3. Sort by (degree, lexicographic)\n    sorted_items = sorted(coeff_map.items(),\n                          key=lambda kv: (len(kv[0]), kv[0]))\n\n    # 4. Build the output string\n    parts = []\n    for i, (var, coeff) in enumerate(sorted_items):\n        # separate sign from absolute value\n        if coeff < 0:\n            sign = '-'\n            mag = -coeff\n        else:\n            sign = '+'\n            mag = coeff\n\n        # magnitude part without sign\n        if var == '':\n            # constant term (should not appear for the given constraints)\n            mag_str = str(mag)\n        else:\n            if mag == 1:\n                mag_str = var          # omit the coefficient 1\n            else:\n                mag_str = str(mag) + var\n\n        # prepend sign according to position\n        if i == 0:\n            # first term \u2013 no leading '+'\n            parts.append(mag_str if sign == '+' else '-' + mag_str)\n        else:\n            parts.append(sign + mag_str)\n\n    result = ''.join(parts)\n\n    # if everything cancelled, output 0 (well\u2011behaved)\n    if not result:\n        result = '0'\n    return result\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Input may contain several lines \u2013 we only need the first one.\n    poly = data.splitlines()[0].strip()\n    print(simplify(poly))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1660}
{"name": "1613", "description": "Complete the solution so that it strips all text that follows any of a set of comment markers passed in. Any whitespace at the end of the line should also be stripped out. \n\n**Example:**\n\nGiven an input string of:\n```\napples, pears # and bananas\ngrapes\nbananas !apples\n```\n\nThe output expected would be:\n```\napples, pears\ngrapes\nbananas\n```\n\nThe code would be called like so:\n\n```python\nresult = solution(\"apples, pears # and bananas\\ngrapes\\nbananas !apples\", [\"#\", \"!\"])\n# result should == \"apples, pears\\ngrapes\\nbananas\"\n\n```", "difficulty": "interview", "id": 1613, "sample_io": [{"input": "apples, pears # and bananas\ngrapes\nbananas !apples\n['#', '!']", "output": ["apples, pears\ngrapes\nbananas"]}], "test_list": [{"input": "apples, pears # and bananas\ngrapes\nbananas !apples\n['#', '!']", "output": ["apples, pears\ngrapes\nbananas"]}, {"input": "a #b\nc\nd $e f g\n['#', '$']", "output": ["a\nc\nd"]}, {"input": "apples, pears # and bananas\ngrapes\nbananas !#apples\n['#', '!']", "output": ["apples, pears\ngrapes\nbananas"]}, {"input": "apples, pears # and bananas\ngrapes\nbananas #!apples\n['#', '!']", "output": ["apples, pears\ngrapes\nbananas"]}, {"input": "apples, pears # and bananas\ngrapes\navocado @apples\n['@', '!']", "output": ["apples, pears # and bananas\ngrapes\navocado"]}, {"input": "apples, pears \u00a7 and bananas\ngrapes\navocado *apples\n['*', '\u00a7']", "output": ["apples, pears\ngrapes\navocado"]}, {"input": "\n['#', '!']", "output": [""]}, {"input": "#\n['#', '!']", "output": [""]}, {"input": "\n\u00a7\n['#', '\u00a7']", "output": ["\n"]}, {"input": "apples, pears # and bananas\ngrapes\nbananas !apples\n[]", "output": ["apples, pears # and bananas\ngrapes\nbananas !apples"]}], "starter_code": "\ndef solution(string,markers):\n\t", "source_codes": ["import ast\n\ndef solution(text: str, markers: list[str]) -> str:\n    \"\"\"Return *text* with everything after any marker in *markers* removed.\n    Trailing whitespace on each line is stripped.\n    \"\"\"\n    cleaned = []\n    for line in text.splitlines():\n        cut = len(line)\n        for m in markers:\n            idx = line.find(m)\n            if idx != -1 and idx < cut:\n                cut = idx\n        cleaned.append(line[:cut].rstrip())\n    return \"\\n\".join(cleaned)\n\n\ndef main():\n    lines = []\n    while True:\n        try:\n            line = input()\n            lines.append(line)\n        except EOFError:\n            break\n\n    markers_line_idx = None\n    for i, line in enumerate(lines):\n        try:\n            parsed = ast.literal_eval(line)\n            if isinstance(parsed, list) and all(isinstance(x, str) for x in parsed):\n                markers_line_idx = i\n                break\n        except Exception:\n            continue\n\n    if markers_line_idx is None:\n        markers = []\n        text = \"\\n\".join(lines)\n    else:\n        markers = ast.literal_eval(lines[markers_line_idx])\n        text = \"\\n\".join(lines[:markers_line_idx] + lines[markers_line_idx + 1:])\n\n    result = solution(text, markers)\n    print(result, end='')\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport ast\n\ndef solution(text: str, markers: list[str]) -> str:\n    \"\"\"Return *text* with everything after any marker in *markers* removed.\n    Trailing whitespace on each line is stripped.\n    \"\"\"\n    cleaned = []\n    for line in text.splitlines():\n        cut = len(line)\n        for m in markers:\n            idx = line.find(m)\n            if idx != -1 and idx < cut:\n                cut = idx\n        cleaned.append(line[:cut].rstrip())\n    return \"\\n\".join(cleaned)\n\n\ndef main():\n    lines = []\n    while True:\n        try:\n            line = input()\n            lines.append(line)\n        except EOFError:\n            break\n\n    markers_line_idx = None\n    for i, line in enumerate(lines):\n        try:\n            parsed = ast.literal_eval(line)\n            if isinstance(parsed, list) and all(isinstance(x, str) for x in parsed):\n                markers_line_idx = i\n                break\n        except Exception:\n            continue\n\n    if markers_line_idx is None:\n        markers = []\n        text = \"\\n\".join(lines)\n    else:\n        markers = ast.literal_eval(lines[markers_line_idx])\n        text = \"\\n\".join(lines[:markers_line_idx] + lines[markers_line_idx + 1:])\n\n    result = solution(text, markers)\n    print(result, end='')\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1613}
{"name": "1630", "description": "Story:\nIn the realm of numbers, the apocalypse has arrived. Hordes of zombie numbers have infiltrated and are ready to turn everything into undead. The properties of zombies are truly apocalyptic: they reproduce themselves unlimitedly and freely interact with each other. Anyone who equals them is doomed. Out of an infinite number of natural numbers, only a few remain. This world needs a hero who leads remaining numbers in hope for survival: The highest number to lead those who still remain.\n\nBriefing:\nThere is a list of positive natural numbers. Find the largest number that cannot be represented as the sum of this numbers, given that each number can be added unlimited times. Return this number, either 0 if there are no such numbers, or -1 if there are an infinite number of them.\n\nExample:\n```\nLet's say [3,4] are given numbers. Lets check each number one by one:\n1 - (no solution) - good\n2 - (no solution) - good\n3 = 3 won't go\n4 = 4 won't go\n5 - (no solution) - good\n6 = 3+3 won't go\n7 = 3+4 won't go\n8 = 4+4 won't go\n9 = 3+3+3 won't go\n10 = 3+3+4 won't go\n11 = 3+4+4 won't go\n13 = 3+3+3+4 won't go\n```\n...and so on. So 5 is the biggest 'good'. return 5\n\nTest specs:\nRandom cases will input up to 10 numbers with up to 1000 value\n\nSpecial thanks:\nThanks to Voile-sama, mathsisfun-sama, and Avanta-sama for heavy assistance. And to everyone who tried and beaten the kata ^_^", "difficulty": "interview", "id": 1630, "sample_io": [{"input": "[3,4]", "output": [5]}], "test_list": [{"input": "[7, 11]", "output": [59]}, {"input": "[1, 7, 15]", "output": [0]}, {"input": "[2, 10]", "output": [-1]}, {"input": "[687, 829, 998]", "output": [45664]}, {"input": "[]", "output": [-1]}, {"input": "[1]", "output": [0]}], "starter_code": "\ndef survivor(zombies):\n\t", "source_codes": ["import sys\nimport math\nimport heapq\nimport re\n\ndef solve() -> None:\n    \"\"\"\n    Reads a list of positive integers from standard input,\n    computes the largest integer that cannot be expressed as a\n    non\u2011negative linear combination of the given numbers\n    (unbounded usage) and prints the answer.\n\n    Output:\n        -1  if infinitely many integers are not representable,\n        0   if every positive integer is representable,\n        otherwise the required largest non\u2011representable integer.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        # No input \u2013 nothing to do.\n        return\n\n    # Extract all integer tokens (handles formats like \"[3,4]\" or \"3 4\")\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers:\n        # No denominations \u2013 no positive integer can be built,\n        # therefore infinitely many are not representable.\n        print(-1)\n        return\n\n    # Remove duplicates and sort\n    coins = sorted(set(numbers))\n\n    # 1) overall gcd\n    g = coins[0]\n    for c in coins[1:]:\n        g = math.gcd(g, c)\n    if g > 1:\n        # infinitely many unreachable numbers\n        print(-1)\n        return\n\n    # 2) presence of 1 makes everything reachable\n    if 1 in coins:\n        print(0)\n        return\n\n    # 3) general case: gcd == 1 and no coin equals 1\n    a = min(coins)               # modulus for residues\n    INF = 10 ** 18\n    dist = [INF] * a\n    dist[0] = 0\n    heap = [(0, 0)]              # (distance, residue)\n\n    while heap:\n        d, r = heapq.heappop(heap)\n        if d != dist[r]:\n            continue            # stale entry\n        for c in coins:\n            nr = (r + c) % a\n            nd = d + c\n            if nd < dist[nr]:\n                dist[nr] = nd\n                heapq.heappush(heap, (nd, nr))\n\n    max_dist = max(dist)         # the largest minimal reachable sum\n    answer = max_dist - a        # Frobenius number\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport math\nimport heapq\nimport re\n\ndef solve() -> None:\n    \"\"\"\n    Reads a list of positive integers from standard input,\n    computes the largest integer that cannot be expressed as a\n    non\u2011negative linear combination of the given numbers\n    (unbounded usage) and prints the answer.\n\n    Output:\n        -1  if infinitely many integers are not representable,\n        0   if every positive integer is representable,\n        otherwise the required largest non\u2011representable integer.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        # No input \u2013 nothing to do.\n        return\n\n    # Extract all integer tokens (handles formats like \"[3,4]\" or \"3 4\")\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers:\n        # No denominations \u2013 no positive integer can be built,\n        # therefore infinitely many are not representable.\n        print(-1)\n        return\n\n    # Remove duplicates and sort\n    coins = sorted(set(numbers))\n\n    # 1) overall gcd\n    g = coins[0]\n    for c in coins[1:]:\n        g = math.gcd(g, c)\n    if g > 1:\n        # infinitely many unreachable numbers\n        print(-1)\n        return\n\n    # 2) presence of 1 makes everything reachable\n    if 1 in coins:\n        print(0)\n        return\n\n    # 3) general case: gcd == 1 and no coin equals 1\n    a = min(coins)               # modulus for residues\n    INF = 10 ** 18\n    dist = [INF] * a\n    dist[0] = 0\n    heap = [(0, 0)]              # (distance, residue)\n\n    while heap:\n        d, r = heapq.heappop(heap)\n        if d != dist[r]:\n            continue            # stale entry\n        for c in coins:\n            nr = (r + c) % a\n            nd = d + c\n            if nd < dist[nr]:\n                dist[nr] = nd\n                heapq.heappush(heap, (nd, nr))\n\n    max_dist = max(dist)         # the largest minimal reachable sum\n    answer = max_dist - a        # Frobenius number\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1630}
{"name": "1668", "description": "Write a function that takes a positive integer and returns the next smaller positive integer containing the same digits.\n\nFor example:\n\n```python\nnext_smaller(21) == 12\nnext_smaller(531) == 513\nnext_smaller(2071) == 2017\n```\n\nReturn -1 (for `Haskell`: return `Nothing`, for `Rust`: return `None`), when there is no smaller number that contains the same digits. Also return -1 when the next smaller number with the same digits would require the leading digit to be zero.\n\n```python \nnext_smaller(9) == -1\nnext_smaller(135) == -1\nnext_smaller(1027) == -1  # 0721 is out since we don't write numbers with leading zeros\n```\n```ruby \nnext_smaller(9) == -1\nnext_smaller(135) == -1\nnext_smaller(1027) == -1  # 0721 is out since we don't write numbers with leading zeros\n```\n\n * some tests will include very large numbers.\n * test data only employs positive integers.\n\n*The function you write for this challenge is the inverse of this kata: \"[Next bigger number with the same digits](http://www.codewars.com/kata/next-bigger-number-with-the-same-digits).\"*", "difficulty": "interview", "id": 1668, "sample_io": [{"input": "21", "output": [12]}, {"input": "531", "output": [513]}, {"input": "2071", "output": [2017]}, {"input": "9", "output": [-1]}, {"input": "135", "output": [-1]}, {"input": "1027", "output": [-1]}], "test_list": [{"input": "21", "output": [12]}, {"input": "907", "output": [790]}, {"input": "531", "output": [513]}, {"input": "1027", "output": [-1]}, {"input": "441", "output": [414]}, {"input": "123456798", "output": [123456789]}, {"input": "513", "output": [351]}, {"input": "351", "output": [315]}, {"input": "315", "output": [153]}, {"input": "153", "output": [135]}, {"input": "135", "output": [-1]}, {"input": "100", "output": [-1]}, {"input": "2071", "output": [2017]}, {"input": "1207", "output": [1072]}, {"input": "414", "output": [144]}, {"input": "123456789", "output": [-1]}, {"input": "29009", "output": [20990]}, {"input": "1234567908", "output": [1234567890]}, {"input": "9999999999", "output": [-1]}, {"input": "59884848483559", "output": [59884848459853]}, {"input": "1023456789", "output": [-1]}, {"input": "51226262651257", "output": [51226262627551]}, {"input": "202233445566", "output": [-1]}, {"input": "506789", "output": [-1]}], "starter_code": "\ndef next_smaller(n):\n\t", "source_codes": ["import sys\n\ndef next_smaller(n: int) -> int:\n    \"\"\"\n    Return the next smaller positive integer that can be formed with the\n    same digits as `n`.  If it does not exist (or would start with a zero)\n    return -1.\n    \"\"\"\n    # Work with the digit characters \u2013 no overflow problems.\n    digits = list(str(n))\n    length = len(digits)\n\n    # 1) Find the rightmost position i where digits[i] > digits[i+1]\n    i = length - 2\n    while i >= 0 and digits[i] <= digits[i + 1]:\n        i -= 1\n    if i < 0:                     # already the smallest permutation\n        return -1\n\n    # 2) Find the rightmost digit smaller than digits[i] on the suffix\n    j = length - 1\n    while j > i and digits[j] >= digits[i]:\n        j -= 1\n    if j <= i:                     # shouldn't happen, but safety check\n        return -1\n\n    # 3) Swap them\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4) Sort the suffix after i in descending order (largest possible)\n    suffix = digits[i + 1:]\n    suffix.sort(reverse=True)\n    digits[i + 1:] = suffix\n\n    # 5) Reject leading zero\n    if digits[0] == '0':\n        return -1\n\n    # Convert back to integer (Python handles arbitrarily large ints)\n    return int(''.join(digits))\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # The problem describes a single input value, but we also support\n    # multiple numbers (one per line) by processing each token.\n    results = []\n    for token in data:\n        try:\n            n = int(token)\n        except ValueError:\n            continue\n        results.append(str(next_smaller(n)))\n    # Print results, one per line.\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\n#!/usr/bin/env python3\nimport sys\n\ndef next_smaller(n: int) -> int:\n    \"\"\"\n    Return the next smaller positive integer that can be formed with the\n    same digits as `n`.  If it does not exist (or would start with a zero)\n    return -1.\n    \"\"\"\n    # Work with the digit characters \u2013 no overflow problems.\n    digits = list(str(n))\n    length = len(digits)\n\n    # 1) Find the rightmost position i where digits[i] > digits[i+1]\n    i = length - 2\n    while i >= 0 and digits[i] <= digits[i + 1]:\n        i -= 1\n    if i < 0:                     # already the smallest permutation\n        return -1\n\n    # 2) Find the rightmost digit smaller than digits[i] on the suffix\n    j = length - 1\n    while j > i and digits[j] >= digits[i]:\n        j -= 1\n    if j <= i:                     # shouldn't happen, but safety check\n        return -1\n\n    # 3) Swap them\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4) Sort the suffix after i in descending order (largest possible)\n    suffix = digits[i + 1:]\n    suffix.sort(reverse=True)\n    digits[i + 1:] = suffix\n\n    # 5) Reject leading zero\n    if digits[0] == '0':\n        return -1\n\n    # Convert back to integer (Python handles arbitrarily large ints)\n    return int(''.join(digits))\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # The problem describes a single input value, but we also support\n    # multiple numbers (one per line) by processing each token.\n    results = []\n    for token in data:\n        try:\n            n = int(token)\n        except ValueError:\n            continue\n        results.append(str(next_smaller(n)))\n    # Print results, one per line.\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1668}
{"name": "1634", "description": "Let's define `increasing` numbers as the numbers whose digits, read from left to right, are never less than the previous ones: 234559 is an example of increasing number.\n\nConversely, `decreasing` numbers have all the digits read from left to right so that no digits is bigger than the previous one: 97732 is an example of decreasing number.\n\nYou do not need to be the next Gauss to figure that all numbers with 1 or 2 digits are either increasing or decreasing: 00, 01, 02, ..., 98, 99 are all belonging to one of this categories (if not both, like 22 or 55): 101 is indeed the first number which does NOT fall into either of the categories. Same goes for all the numbers up to 109, while 110 is again a decreasing number.\n\nNow your task is rather easy to declare (a bit less to perform): you have to build a function to return the total occurrences of all the increasing or decreasing numbers *below* 10 raised to the xth power (x will always be >= 0).\n\nTo give you a starting point, there are a grand total of increasing and decreasing numbers as shown in the table:\n\n|Total  | Below\n|---------------\n|1      | 1\n|10     | 10\n|100    | 100\n|475    | 1000\n|1675   | 10000\n|4954   | 100000\n|12952  | 1000000\n\nThis means that your function will have to behave like this:\n```python\ntotal_inc_dec(0)==1\ntotal_inc_dec(1)==10\ntotal_inc_dec(2)==100\ntotal_inc_dec(3)==475\ntotal_inc_dec(4)==1675\ntotal_inc_dec(5)==4954\ntotal_inc_dec(6)==12952\n```\n\n**Tips:** efficiency and trying to figure out how it works are essential: with a brute force approach, some tests with larger numbers may take more than the total computing power currently on Earth to be finished in the short allotted time.\n\nTo make it even clearer, the increasing or decreasing numbers between in the range 101-200 are: [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 122, 123, 124, 125, 126, 127, 128, 129, 133, 134, 135, 136, 137, 138, 139, 144, 145, 146, 147, 148, 149, 155, 156, 157, 158, 159, 166, 167, 168, 169, 177, 178, 179, 188, 189, 199, 200], that is 47 of them. In the following range, 201-300, there are 41 of them and so on, getting rarer and rarer.\n\n**Trivia:** just for the sake of your own curiosity, a number which is neither decreasing of increasing is called a `bouncy` number, like, say, 3848 or 37294; also, usually 0 is not considered being increasing, decreasing or bouncy, but it will be for the purpose of this kata", "difficulty": "interview", "id": 1634, "sample_io": [{"input": "0", "output": [1]}, {"input": "1", "output": [10]}, {"input": "2", "output": [100]}, {"input": "3", "output": [475]}, {"input": "4", "output": [1675]}, {"input": "5", "output": [4954]}, {"input": "6", "output": [12952]}], "test_list": [{"input": "0", "output": [1]}, {"input": "1", "output": [10]}, {"input": "2", "output": [100]}, {"input": "3", "output": [475]}, {"input": "4", "output": [1675]}, {"input": "5", "output": [4954]}, {"input": "6", "output": [12952]}, {"input": "10", "output": [277033]}, {"input": "20", "output": [40059819]}, {"input": "50", "output": [87959698326]}], "starter_code": "\ndef total_inc_dec(x):\n\t", "source_codes": ["0 \u2264 n < 10^x"], "responses": ["\n0 \u2264 n < 10^x\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1634}
{"name": "1645", "description": "The task is simply stated. Given an integer n (3 < n < 10^(9)), find the length of the smallest list of [*perfect squares*](https://en.wikipedia.org/wiki/Square_number) which add up to n. Come up with the best algorithm you can; you'll need it!\n\nExamples:\n\nsum_of_squares(17) = 2  17 = 16 + 1 (4 and 1 are perfect squares).\nsum_of_squares(15) = 4  15 = 9 + 4 + 1 + 1. There is no way to represent 15 as the sum of three perfect squares.\nsum_of_squares(16) = 1  16 itself is a perfect square.\n\nTime constraints:\n\n5 easy (sample) test cases: n < 20\n\n5 harder test cases: 1000 < n < 15000\n\n5 maximally hard test cases: 5 * 1e8 < n < 1e9\n\n```if:java\n300 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:c#\n350 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:python\n15 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:ruby\n25  random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:javascript\n100 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:crystal\n250 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:cpp\nRandom maximally hard test cases: 1e8 < n < 1e9\n```", "difficulty": "interview", "id": 1645, "sample_io": [{"input": "15", "output": [4]}, {"input": "16", "output": [1]}, {"input": "17", "output": [2]}], "test_list": [{"input": "15", "output": [4]}, {"input": "16", "output": [1]}, {"input": "17", "output": [2]}, {"input": "18", "output": [2]}, {"input": "19", "output": [3]}, {"input": "2017", "output": [2]}, {"input": "1008", "output": [4]}, {"input": "3456", "output": [3]}, {"input": "4000", "output": [2]}, {"input": "12321", "output": [1]}, {"input": "661915703", "output": [4]}, {"input": "999887641", "output": [1]}, {"input": "999950886", "output": [3]}, {"input": "999951173", "output": [2]}, {"input": "999998999", "output": [4]}], "starter_code": "\ndef sum_of_squares(n):\n\t", "source_codes": ["import sys\nimport math\n\ndef sum_of_squares(n: int) -> int:\n    \"\"\"Return the minimal number of perfect squares whose sum equals n.\n\n    Lagrange's four\u2011square theorem guarantees a solution exists.\n    Legendre's three\u2011square theorem tells us when four squares are necessary.\n    \"\"\"\n    # 1. One square?\n    r = math.isqrt(n)\n    if r * r == n:\n        return 1\n\n    # 2. Two squares?\n    for a in range(1, r + 1):\n        b2 = n - a * a\n        b = math.isqrt(b2)\n        if b * b == b2:\n            return 2\n\n    # 3. Legendre's three\u2011square theorem: numbers of the form 4^a*(8b+7) need four squares.\n    m = n\n    while m % 4 == 0:\n        m //= 4\n    if m % 8 == 7:\n        return 4\n\n    # 4. Otherwise three squares are sufficient.\n    return 3\n\n\ndef main() -> None:\n    # Read all whitespace\u2011separated integers from stdin.\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    out = [str(sum_of_squares(int(x))) for x in data]\n    sys.stdout.write(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport math\n\ndef sum_of_squares(n: int) -> int:\n    \"\"\"Return the minimal number of perfect squares whose sum equals n.\n\n    Lagrange's four\u2011square theorem guarantees a solution exists.\n    Legendre's three\u2011square theorem tells us when four squares are necessary.\n    \"\"\"\n    # 1. One square?\n    r = math.isqrt(n)\n    if r * r == n:\n        return 1\n\n    # 2. Two squares?\n    for a in range(1, r + 1):\n        b2 = n - a * a\n        b = math.isqrt(b2)\n        if b * b == b2:\n            return 2\n\n    # 3. Legendre's three\u2011square theorem: numbers of the form 4^a*(8b+7) need four squares.\n    m = n\n    while m % 4 == 0:\n        m //= 4\n    if m % 8 == 7:\n        return 4\n\n    # 4. Otherwise three squares are sufficient.\n    return 3\n\n\ndef main() -> None:\n    # Read all whitespace\u2011separated integers from stdin.\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    out = [str(sum_of_squares(int(x))) for x in data]\n    sys.stdout.write(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1645}
{"name": "1666", "description": "## Description\n\nGiven an array X of positive integers, its elements are to be transformed by running the following operation on them as many times as required:\n\n```if X[i] > X[j] then X[i] = X[i] - X[j]```\n\nWhen no more transformations are possible, return its sum (\"smallest possible sum\").\n\nFor instance, the successive transformation of the elements of input X = [6, 9, 21] is detailed below:\n```\nX_1 = [6, 9, 12] # -> X_1[2] = X[2] - X[1] = 21 - 9\nX_2 = [6, 9, 6]  # -> X_2[2] = X_1[2] - X_1[0] = 12 - 6\nX_3 = [6, 3, 6]  # -> X_3[1] = X_2[1] - X_2[0] = 9 - 6\nX_4 = [6, 3, 3]  # -> X_4[2] = X_3[2] - X_3[1] = 6 - 3\nX_5 = [3, 3, 3]  # -> X_5[1] = X_4[0] - X_4[1] = 6 - 3\n```\nThe returning output is the sum of the final transformation (here 9).\n\n## Example\n\n## Solution steps:\n\n## Additional notes:\n\nThere are performance tests consisted of very big numbers and arrays of size at least 30000. Please write an efficient algorithm to prevent timeout.", "difficulty": "interview", "id": 1666, "sample_io": [{"input": "[6, 9, 21]", "output": [9]}], "test_list": [{"input": "[6, 9, 21]", "output": [9]}, {"input": "[9]", "output": [9]}, {"input": "[30, 12]", "output": [12]}, {"input": "[11, 22]", "output": [22]}, {"input": "[1, 21, 55]", "output": [3]}, {"input": "[4, 16, 24]", "output": [12]}, {"input": "[3, 13, 23, 7, 83]", "output": [5]}, {"input": "[60, 12, 96, 48, 60, 24, 72, 36, 72, 72, 48]", "output": [132]}, {"input": "[71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71]", "output": [923]}], "starter_code": "\ndef solution(a):\n\t", "source_codes": ["import sys\nimport math\nimport re\nfrom functools import reduce\n\ndef solve() -> None:\n    \"\"\"\n    Reads the whole standard input, extracts all positive integers,\n    computes the smallest possible sum after repeatedly applying\n        if X[i] > X[j] then X[i] = X[i] - X[j]\n    and prints the answer.\n\n    The result is n * gcd(all numbers).\n    \"\"\"\n    # read complete input (handles possible trailing newlines)\n    data = sys.stdin.buffer.read().decode()\n    if not data:\n        return\n\n    # extract every integer, regardless of brackets, commas or spaces\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n\n    if not numbers:                # no numbers at all\n        print(0)\n        return\n\n    # gcd of the whole array\n    g = reduce(math.gcd, numbers)\n\n    # final sum = g repeated n times\n    print(g * len(numbers))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport math\nimport re\nfrom functools import reduce\n\ndef solve() -> None:\n    \"\"\"\n    Reads the whole standard input, extracts all positive integers,\n    computes the smallest possible sum after repeatedly applying\n        if X[i] > X[j] then X[i] = X[i] - X[j]\n    and prints the answer.\n\n    The result is n * gcd(all numbers).\n    \"\"\"\n    # read complete input (handles possible trailing newlines)\n    data = sys.stdin.buffer.read().decode()\n    if not data:\n        return\n\n    # extract every integer, regardless of brackets, commas or spaces\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n\n    if not numbers:                # no numbers at all\n        print(0)\n        return\n\n    # gcd of the whole array\n    g = reduce(math.gcd, numbers)\n\n    # final sum = g repeated n times\n    print(g * len(numbers))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1666}
{"name": "1659", "description": "# How many ways can you make the sum of a number?\n\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)#\n\n>In number theory and combinatorics, a partition of a positive integer *n*, also called an *integer partition*, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. If order matters, the sum becomes a composition. For example, 4 can be partitioned in five distinct ways:\n```\n4\n3 + 1\n2 + 2\n2 + 1 + 1\n1 + 1 + 1 + 1\n```\n\n## Examples\n\n### Basic\n\n```python\nexp_sum(1) # 1\nexp_sum(2) # 2  -> 1+1 , 2\nexp_sum(3) # 3 -> 1+1+1, 1+2, 3\nexp_sum(4) # 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4\nexp_sum(5) # 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3\n\nexp_sum(10) # 42\n```\n\n### Explosive\n\n```python\nexp_sum(50) # 204226\nexp_sum(80) # 15796476\nexp_sum(100) # 190569292\n```\n\nSee [here](http://www.numericana.com/data/partition.htm) for more examples.", "difficulty": "interview", "id": 1659, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [2]}, {"input": "3", "output": [3]}, {"input": "4", "output": [5]}, {"input": "5", "output": [7]}, {"input": "10", "output": [42]}, {"input": "50", "output": [204226]}, {"input": "80", "output": [15796476]}, {"input": "100", "output": [190569292]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [2]}, {"input": "3", "output": [3]}, {"input": "4", "output": [5]}, {"input": "5", "output": [7]}, {"input": "20", "output": [627]}, {"input": "30", "output": [5604]}, {"input": "40", "output": [37338]}, {"input": "43", "output": [63261]}, {"input": "60", "output": [966467]}, {"input": "70", "output": [4087968]}, {"input": "90", "output": [56634173]}, {"input": "200", "output": [3972999029388]}, {"input": "275", "output": [1520980492851175]}], "starter_code": "\ndef exp_sum(n):\n\t", "source_codes": ["import sys\n\ndef partition_numbers_up_to(max_n: int):\n    \"\"\"\n    Returns a list p where p[i] is the number of integer partitions of i,\n    for i = 0 .. max_n.\n    \"\"\"\n    p = [0] * (max_n + 1)\n    p[0] = 1                       # empty partition\n\n    for n in range(1, max_n + 1):\n        total = 0\n        k = 1\n        while True:\n            # generalized pentagonal numbers\n            g1 = k * (3 * k - 1) // 2   # for +k\n            if g1 > n:\n                break\n            sign = 1 if (k % 2 == 1) else -1   # (+) for odd k, (\u2011) for even k\n            total += sign * p[n - g1]\n\n            g2 = k * (3 * k + 1) // 2   # for -k\n            if g2 <= n:\n                total += sign * p[n - g2]\n\n            k += 1\n        p[n] = total\n    return p\n\n\ndef exp_sum(n: int) -> int:\n    \"\"\"Number of integer partitions of n.\"\"\"\n    # compute once up to n (fast enough) \u2013 could be cached globally if needed\n    return partition_numbers_up_to(n)[n]\n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    numbers = list(map(int, data))\n\n    max_n = max(numbers)\n    # Pre\u2011compute all needed values in one pass\n    part = partition_numbers_up_to(max_n)\n\n    out = [str(part[n]) for n in numbers]\n    sys.stdout.write(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    # If a single\u2011line I/O is preferred, the following two lines suffice:\n    # n = int(input())\n    # print(exp_sum(n))\n    # The more general version above handles any amount of test cases.\n    main()"], "responses": ["\nimport sys\n\ndef partition_numbers_up_to(max_n: int):\n    \"\"\"\n    Returns a list p where p[i] is the number of integer partitions of i,\n    for i = 0 .. max_n.\n    \"\"\"\n    p = [0] * (max_n + 1)\n    p[0] = 1                       # empty partition\n\n    for n in range(1, max_n + 1):\n        total = 0\n        k = 1\n        while True:\n            # generalized pentagonal numbers\n            g1 = k * (3 * k - 1) // 2   # for +k\n            if g1 > n:\n                break\n            sign = 1 if (k % 2 == 1) else -1   # (+) for odd k, (\u2011) for even k\n            total += sign * p[n - g1]\n\n            g2 = k * (3 * k + 1) // 2   # for -k\n            if g2 <= n:\n                total += sign * p[n - g2]\n\n            k += 1\n        p[n] = total\n    return p\n\n\ndef exp_sum(n: int) -> int:\n    \"\"\"Number of integer partitions of n.\"\"\"\n    # compute once up to n (fast enough) \u2013 could be cached globally if needed\n    return partition_numbers_up_to(n)[n]\n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    numbers = list(map(int, data))\n\n    max_n = max(numbers)\n    # Pre\u2011compute all needed values in one pass\n    part = partition_numbers_up_to(max_n)\n\n    out = [str(part[n]) for n in numbers]\n    sys.stdout.write(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    # If a single\u2011line I/O is preferred, the following two lines suffice:\n    # n = int(input())\n    # print(exp_sum(n))\n    # The more general version above handles any amount of test cases.\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1659}
{"name": "1647", "description": "Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:\n\n```\n12 ==> 21\n513 ==> 531\n2017 ==> 2071\n```\n\nIf the digits can't be rearranged to form a bigger number, return `-1` (or `nil` in Swift):\n\n```\n9 ==> -1\n111 ==> -1\n531 ==> -1\n```", "difficulty": "interview", "id": 1647, "sample_io": [{"input": "12", "output": [21]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [2071]}, {"input": "9", "output": [-1]}, {"input": "111", "output": [-1]}, {"input": "531", "output": [-1]}], "test_list": [{"input": "12", "output": [21]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [2071]}, {"input": "414", "output": [441]}, {"input": "144", "output": [414]}, {"input": "123456789", "output": [123456798]}, {"input": "1234567890", "output": [1234567908]}, {"input": "9876543210", "output": [-1]}, {"input": "9999999999", "output": [-1]}, {"input": "59884848459853", "output": [59884848483559]}], "starter_code": "\ndef next_bigger(n):\n\t", "source_codes": ["import sys\n\ndef next_bigger(n: int) -> int:\n    \"\"\"\n    Return the smallest integer larger than `n` that can be obtained by\n    permuting its decimal digits. If no such permutation exists, return -1.\n    \"\"\"\n    digits = list(str(n))\n\n    # 1. Find the first index from the right where digits[i] < digits[i+1]\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i < 0:                     # already the highest permutation\n        return -1\n\n    # 2. Find the smallest digit greater than digits[i] to its right\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # 3. Swap them\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4. Reverse the suffix to obtain the minimal ordering\n    digits[i + 1:] = reversed(digits[i + 1:])\n\n    return int(''.join(digits))\n\ndef solve() -> None:\n    \"\"\"\n    Read a single integer from standard input, compute its next bigger number,\n    and output the result (as a plain integer, not a list).\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:          # no input\n        return\n    n = int(data[0])\n    result = next_bigger(n)\n    # Output the integer directly, as required by the problem statement\n    sys.stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef next_bigger(n: int) -> int:\n    \"\"\"\n    Return the smallest integer larger than `n` that can be obtained by\n    permuting its decimal digits. If no such permutation exists, return -1.\n    \"\"\"\n    digits = list(str(n))\n\n    # 1. Find the first index from the right where digits[i] < digits[i+1]\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i < 0:                     # already the highest permutation\n        return -1\n\n    # 2. Find the smallest digit greater than digits[i] to its right\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # 3. Swap them\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4. Reverse the suffix to obtain the minimal ordering\n    digits[i + 1:] = reversed(digits[i + 1:])\n\n    return int(''.join(digits))\n\ndef solve() -> None:\n    \"\"\"\n    Read a single integer from standard input, compute its next bigger number,\n    and output the result (as a plain integer, not a list).\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:          # no input\n        return\n    n = int(data[0])\n    result = next_bigger(n)\n    # Output the integer directly, as required by the problem statement\n    sys.stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1647}
{"name": "1646", "description": "This is a very simply formulated task. Let's call an integer number `N` 'green' if `N\u00b2` ends with all of the digits of `N`. Some examples:\n\n`5` is green, because `5\u00b2 = 25` and `25` ends with `5`.\n\n`11` is not green, because `11\u00b2 = 121` and `121` does not end with `11`.\n\n`376` is green, because `376\u00b2 = 141376` and `141376` ends with `376`.\n\nYour task is to write a function `green` that returns `n`th green number, starting with `1` - `green (1) == 1`\n\n---\n\n## Data range\n\n```if:haskell\n`n <= 4000` for Haskell\n```\n```if:java\n`n <= 5000` for Java\n```\n```if:python\n`n <= 5000` for Python\n```\n```if:javascript\n`n <= 3000` for JavaScript\n\nReturn values should be `String`s, and should be exact. A BigNum library is recommended.\n```", "difficulty": "interview", "id": 1646, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [6]}, {"input": "4", "output": [25]}, {"input": "12", "output": [2890625]}, {"input": "13", "output": [7109376]}, {"input": "100", "output": [6188999442576576769103890995893380022607743740081787109376]}, {"input": "110", "output": [9580863811000557423423230896109004106619977392256259918212890625]}], "starter_code": "\ndef green(n):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1646}
{"name": "1656", "description": "With your birthday coming up soon, your eccentric friend sent you a message to say \"happy birthday\":\n\n    hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu\n    hhapppyyyy biirtttthdaaay too youuu\n    happy birrrthdayy to youuu\n    happpyyyy birrtthdaaay tooooo youu\n\nAt first it looks like a song, but upon closer investigation, you realize that your friend hid the phrase \"happy birthday\" thousands of times inside his message. In fact, it contains it more than 2 million times! To thank him, you'd like to reply with exactly how many times it occurs.\n\nTo count all the occurences, the procedure is as follows: look through the paragraph and find a `'h'`; then find an `'a'` later in the paragraph; then find an `'p'` after that, and so on. Now count the number of ways in which you can choose letters in this way to make the full phrase.\n\nMore precisely, given a text string, you are to determine how many times the search string appears as a sub-sequence of that string.\n\nWrite a function called `countSubsequences` that takes two arguments: `needle`, the string to be search for and `haystack`, the string to search in. In our example, `\"happy birthday\"` is the needle and the birthday message is the haystack. The function should return the number of times `needle` occurs as a sub-sequence of `haystack`.  Spaces are also considered part of the needle.\n\nSince the answers can be very large, return only the last 8 digits of the answer in case it exceeds 8 digits. The answers to the test cases will all be shorter than 8 digits.", "difficulty": "interview", "id": 1656, "sample_io": [], "test_list": [{"input": "happy birthday\nappyh appy birth day", "output": [1]}, {"input": "happy birthday\nhhaappyy bbiirrtthhddaayy", "output": [2048]}, {"input": "happy birthday\nhappy holidays", "output": [0]}, {"input": "happy birthday\nhappy birthday", "output": [1]}, {"input": "happy\nhhhappy", "output": [3]}, {"input": "happy birthday\nhhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu", "output": [7680]}], "starter_code": "\ndef count_subsequences(a, b):\n\t", "source_codes": ["import sys\n\nMOD = 10**8\n\ndef countSubsequences(needle: str, haystack: str) -> int:\n    \"\"\"Return the number of times ``needle`` occurs as a subsequence of\n    ``haystack``. If the total exceeds 8 digits only the last 8 digits are\n    returned (the test data guarantees the true answer is < 10\u2078).\"\"\"\n    n = len(needle)\n    # dp[i] \u2013 number of ways the first i characters of ``needle`` can be formed\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty pattern\n\n    for ch in haystack:\n        # iterate backwards so each character of haystack is used at most once\n        for i in range(n, 0, -1):\n            if needle[i - 1] == ch:\n                dp[i] = (dp[i] + dp[i - 1]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # read all input; first line is the needle, everything after belongs to haystack\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit(0)\n\n    needle = data[0]\n    haystack = \"\\n\".join(data[1:]) if len(data) > 1 else \"\"\n\n    result = countSubsequences(needle, haystack)\n    print(result)"], "responses": ["\nimport sys\n\nMOD = 10**8\n\ndef countSubsequences(needle: str, haystack: str) -> int:\n    \"\"\"Return the number of times ``needle`` occurs as a subsequence of\n    ``haystack``. If the total exceeds 8 digits only the last 8 digits are\n    returned (the test data guarantees the true answer is < 10\u2078).\"\"\"\n    n = len(needle)\n    # dp[i] \u2013 number of ways the first i characters of ``needle`` can be formed\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty pattern\n\n    for ch in haystack:\n        # iterate backwards so each character of haystack is used at most once\n        for i in range(n, 0, -1):\n            if needle[i - 1] == ch:\n                dp[i] = (dp[i] + dp[i - 1]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # read all input; first line is the needle, everything after belongs to haystack\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit(0)\n\n    needle = data[0]\n    haystack = \"\\n\".join(data[1:]) if len(data) > 1 else \"\"\n\n    result = countSubsequences(needle, haystack)\n    print(result)\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1656}
