{"name": "1627", "description": "### Background\n\nI was reading a [book](http://www.amazon.co.uk/Things-Make-Do-Fourth-Dimension/dp/1846147646/) recently, \"Things to Make and Do in the Fourth Dimension\" by comedian and mathematician Matt Parker, and in the first chapter of the book Matt talks about problems he likes to solve in his head to take his mind off the fact that he is in his dentist's chair, we've all been there!\n\nThe problem he talks about relates to polydivisible numbers, and I thought a kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)\n\n### Polydivisib... huh what?\n\nSo what are they?\n\nA polydivisible number is divisible in an unusual way. The first digit is cleanly divisible by `1`, the first two digits are cleanly divisible by `2`, the first three by `3` and so on.\n\nThe interesting thing about polydivisiblity is that it relates to the underlying number, but not the base it is written in, so if aliens came to Earth and used base `23` (`11` fingers on one hand and `12` on the other), no matter what squiggles they use to write numbers, they would find the same numbers polydivisible!\n\n### Polydivisibilty Example:\n\nLet's do a worked example to clear up any questions ...\n\nStarting wih the number `1,232` in base `10` then:\n\n```\n 1232\n 1    /1 = 1    Yay!\n 12   /2 = 6    Yay!\n 123  /3 = 41   Yay!\n 1232 /4 = 308  Yay!\n```\n\nThus `1,232` is a polydivisible number in base `4` and above.\n\nHowever starting wih the number `123,220` and using base `10` then:\n\n```\n 123220\n 1      /1 = 1            Yay!\n 12     /2 = 6            Yay!\n 123    /3 = 41           Yay!\n 1232   /4 = 308          Yay!\n 12322  /5 = 2464.4       Oh no, that's not a round number!\n 123220 /6 = 220536.333r  Oh no, that's not a round number!\n```\n\nThus `123,220` is not a polydivisible base 10 number, but what about in another base?\n\nAgain starting wih the number `123,220` and using base `6` then:\n\n```\n base 6   base 10\n 1      = 1       -> 1     /1 = 1     Yay!\n 12     = 8       -> 8     /2 = 4     Yay!\n 123    = 51      -> 51    /3 = 17    Yay!\n 1232   = 308     -> 308   /4 = 77    Yay!\n 12322  = 1850    -> 1850  /5 = 370   Yay!\n 123220 = 11100   -> 11100 /6 = 1850  Yay!\n```\n\nThus `123,220` is a polydivisible base `6` number (and a polydivisible base `10` number when converted to `11100` in base `10`).\n\n### Kata\n\nIn this kata you must implement two methods: `is_polydivisible(n, b)` and `get_polydivisible(n, b)`.\n\nThe first `is_polydivisible(n, b)` will return `True` if `n` is polydivisible in base `b` or `False` if not.\n\nThe second `get_polydivisible(n, b)` will return the `n`th polydivisible number using base `b`, the first polydivisible number is of course always `0`.\n\nYou can assume that all inputs are valid.\n\n```if:haskell\nAll necessary arithmetic can be done in `Int` range.\n```\n\n### Kata Examples:\n\n```python\n    is_polydivisible(\"1232\", 10)   # => True\n    is_polydivisible(\"123220\", 10) # => False\n    is_polydivisible(\"123220\", 6)  # => True\n    get_polydivisible(22, 10)      # => \"32\"\n    get_polydivisible(22, 16)      # => \"1A\"\n    get_polydivisible(42, 16)      # => \"42\"\n```\n\n#### A Note on Bases\n\nThe maximum base used is base `62`, and uses characters in the following order `[0-9][A-Z][a-z]` to denote its digits, base `n` will use the first `n` characters of this sequence.\n```if-not:haskell\nA constant CHARS has been declared with this sequence for you.\n```", "difficulty": "interview", "id": 1627, "sample_io": [{"input": "1232\n10", "output": [true]}, {"input": "123220\n10", "output": [false]}, {"input": "123220\n6", "output": [true]}], "test_list": [{"input": "123\n10", "output": [true]}, {"input": "1234\n10", "output": [false]}, {"input": "12345\n10", "output": [false]}, {"input": "12365\n10", "output": [true]}, {"input": "123220\n10", "output": [false]}, {"input": "50041\n6", "output": [true]}, {"input": "140410\n6", "output": [true]}, {"input": "203230\n6", "output": [true]}, {"input": "30043052\n6", "output": [true]}], "starter_code": "\ndef is_polydivisible(s, b):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1627}
{"name": "1656", "description": "With your birthday coming up soon, your eccentric friend sent you a message to say \"happy birthday\":\n\n    hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu\n    hhapppyyyy biirtttthdaaay too youuu\n    happy birrrthdayy to youuu\n    happpyyyy birrtthdaaay tooooo youu\n\nAt first it looks like a song, but upon closer investigation, you realize that your friend hid the phrase \"happy birthday\" thousands of times inside his message. In fact, it contains it more than 2 million times! To thank him, you'd like to reply with exactly how many times it occurs.\n\nTo count all the occurences, the procedure is as follows: look through the paragraph and find a `'h'`; then find an `'a'` later in the paragraph; then find an `'p'` after that, and so on. Now count the number of ways in which you can choose letters in this way to make the full phrase.\n\nMore precisely, given a text string, you are to determine how many times the search string appears as a sub-sequence of that string.\n\nWrite a function called `countSubsequences` that takes two arguments: `needle`, the string to be search for and `haystack`, the string to search in. In our example, `\"happy birthday\"` is the needle and the birthday message is the haystack. The function should return the number of times `needle` occurs as a sub-sequence of `haystack`.  Spaces are also considered part of the needle.\n\nSince the answers can be very large, return only the last 8 digits of the answer in case it exceeds 8 digits. The answers to the test cases will all be shorter than 8 digits.", "difficulty": "interview", "id": 1656, "sample_io": [], "test_list": [{"input": "happy birthday\nappyh appy birth day", "output": [1]}, {"input": "happy birthday\nhhaappyy bbiirrtthhddaayy", "output": [2048]}, {"input": "happy birthday\nhappy holidays", "output": [0]}, {"input": "happy birthday\nhappy birthday", "output": [1]}, {"input": "happy\nhhhappy", "output": [3]}, {"input": "happy birthday\nhhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu", "output": [7680]}], "starter_code": "\ndef count_subsequences(a, b):\n\t", "source_codes": ["import sys\n\ndef countSubsequences(needle: str, haystack: str) -> int:\n    \"\"\"\n    Returns the number of times `needle` appears as a subsequence of\n    `haystack`, modulo 10**8.\n    \"\"\"\n    MOD = 100_000_000               # keep only the last 8 digits\n    n = len(needle)\n\n    # dp[j] = ways to form first j characters of needle\n    dp = [0] * (n + 1)\n    dp[0] = 1                       # empty subsequence\n\n    for ch in haystack:\n        # iterate backwards so each character is used at most once\n        for j in range(n - 1, -1, -1):\n            if needle[j] == ch:\n                dp[j + 1] += dp[j]\n                # reduce to avoid huge numbers (still correct modulo MOD)\n                if dp[j + 1] >= MOD:\n                    dp[j + 1] %= MOD\n\n    return dp[n] % MOD\n\n\ndef main() -> None:\n    # read the two strings; keep spaces and any other characters\n    needle = sys.stdin.readline().rstrip('\\n')\n    haystack = sys.stdin.readline().rstrip('\\n')\n\n    print(countSubsequences(needle, haystack))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef countSubsequences(needle: str, haystack: str) -> int:\n    \"\"\"\n    Returns the number of times `needle` appears as a subsequence of\n    `haystack`, modulo 10**8.\n    \"\"\"\n    MOD = 100_000_000               # keep only the last 8 digits\n    n = len(needle)\n\n    # dp[j] = ways to form first j characters of needle\n    dp = [0] * (n + 1)\n    dp[0] = 1                       # empty subsequence\n\n    for ch in haystack:\n        # iterate backwards so each character is used at most once\n        for j in range(n - 1, -1, -1):\n            if needle[j] == ch:\n                dp[j + 1] += dp[j]\n                # reduce to avoid huge numbers (still correct modulo MOD)\n                if dp[j + 1] >= MOD:\n                    dp[j + 1] %= MOD\n\n    return dp[n] % MOD\n\n\ndef main() -> None:\n    # read the two strings; keep spaces and any other characters\n    needle = sys.stdin.readline().rstrip('\\n')\n    haystack = sys.stdin.readline().rstrip('\\n')\n\n    print(countSubsequences(needle, haystack))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1656}
{"name": "1649", "description": "Automatons, or Finite State Machines (FSM), are extremely useful to programmers when it comes to software design. You will be given a simplistic version of an FSM to code for a basic TCP session.\n\nThe outcome of this exercise will be to return the correct state of the TCP FSM based on the array of events given.\n\n---------------------------------\n\nThe input array of events will consist of one or more of the following strings:\n\n```\nAPP_PASSIVE_OPEN, APP_ACTIVE_OPEN, APP_SEND, APP_CLOSE, APP_TIMEOUT, RCV_SYN, RCV_ACK, RCV_SYN_ACK, RCV_FIN, RCV_FIN_ACK\n```\n\n---------------------------------\n\nThe states are as follows and should be returned in all capital letters as shown:\n\n```\nCLOSED, LISTEN, SYN_SENT, SYN_RCVD, ESTABLISHED, CLOSE_WAIT, LAST_ACK, FIN_WAIT_1, FIN_WAIT_2, CLOSING, TIME_WAIT\n```\n\n---------------------------------\n\nThe input will be an array of events. Your job is to traverse the FSM as determined by the events, and return the proper state as a string, all caps, as shown above.\n\nIf an event is not applicable to the current state, your code will return `\"ERROR\"`.\n\n### Action of each event upon each state:\n(the format is `INITIAL_STATE: EVENT -> NEW_STATE`)\n\n```\nCLOSED: APP_PASSIVE_OPEN -> LISTEN\nCLOSED: APP_ACTIVE_OPEN  -> SYN_SENT\nLISTEN: RCV_SYN          -> SYN_RCVD\nLISTEN: APP_SEND         -> SYN_SENT\nLISTEN: APP_CLOSE        -> CLOSED\nSYN_RCVD: APP_CLOSE      -> FIN_WAIT_1\nSYN_RCVD: RCV_ACK        -> ESTABLISHED\nSYN_SENT: RCV_SYN        -> SYN_RCVD\nSYN_SENT: RCV_SYN_ACK    -> ESTABLISHED\nSYN_SENT: APP_CLOSE      -> CLOSED\nESTABLISHED: APP_CLOSE   -> FIN_WAIT_1\nESTABLISHED: RCV_FIN     -> CLOSE_WAIT\nFIN_WAIT_1: RCV_FIN      -> CLOSING\nFIN_WAIT_1: RCV_FIN_ACK  -> TIME_WAIT\nFIN_WAIT_1: RCV_ACK      -> FIN_WAIT_2\nCLOSING: RCV_ACK         -> TIME_WAIT\nFIN_WAIT_2: RCV_FIN      -> TIME_WAIT\nTIME_WAIT: APP_TIMEOUT   -> CLOSED\nCLOSE_WAIT: APP_CLOSE    -> LAST_ACK\nLAST_ACK: RCV_ACK        -> CLOSED\n```\n\n![\"EFSM TCP\" ](http://theangelfallseries.com/img/EFSM_TCP.png)\n\n## Examples\n\n```\n[\"APP_PASSIVE_OPEN\", \"APP_SEND\", \"RCV_SYN_ACK\"] =>  \"ESTABLISHED\"\n\n[\"APP_ACTIVE_OPEN\"] =>  \"SYN_SENT\"\n\n[\"APP_ACTIVE_OPEN\", \"RCV_SYN_ACK\", \"APP_CLOSE\", \"RCV_FIN_ACK\", \"RCV_ACK\"] =>  \"ERROR\"\n```\n\n \n\nThis kata is similar to [Design a Simple Automaton (Finite State Machine)](https://www.codewars.com/kata/design-a-simple-automaton-finite-state-machine), and you may wish to try that kata before tackling this one.\n\nSee wikipedia page [Transmission Control Protocol]( http://en.wikipedia.org/wiki/Transmission_Control_Protocol)\nfor further details.\n\nSee http://www.medianet.kent.edu/techreports/TR2005-07-22-tcp-EFSM.pdf page 4, for the FSM diagram used for this kata.", "difficulty": "interview", "id": 1649, "sample_io": [{"input": "['APP_PASSIVE_OPEN', 'APP_SEND', 'RCV_SYN_ACK']", "output": ["ESTABLISHED"]}, {"input": "['APP_ACTIVE_OPEN']", "output": ["SYN_SENT"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN_ACK', 'APP_CLOSE', 'RCV_FIN_ACK', 'RCV_ACK']", "output": ["ERROR"]}], "test_list": [{"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK', 'APP_CLOSE']", "output": ["FIN_WAIT_1"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK']", "output": ["ESTABLISHED"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN']", "output": ["SYN_RCVD"]}, {"input": "['APP_PASSIVE_OPEN']", "output": ["LISTEN"]}, {"input": "['APP_ACTIVE_OPEN', 'APP_CLOSE']", "output": ["CLOSED"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN', 'APP_CLOSE', 'RCV_FIN', 'RCV_ACK']", "output": ["TIME_WAIT"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN', 'APP_CLOSE', 'RCV_FIN', 'RCV_ACK', 'APP_TIMEOUT']", "output": ["CLOSED"]}, {"input": "['RCV_SYN', 'RCV_ACK', 'APP_CLOSE']", "output": ["ERROR"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN', 'APP_CLOSE', 'RCV_ACK']", "output": ["FIN_WAIT_2"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN_ACK', 'RCV_FIN']", "output": ["CLOSE_WAIT"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN_ACK', 'RCV_FIN', 'APP_CLOSE']", "output": ["LAST_ACK"]}, {"input": "['APP_ACTIVE_OPEN']", "output": ["SYN_SENT"]}, {"input": "['APP_PASSIVE_OPEN', 'APP_CLOSE']", "output": ["CLOSED"]}, {"input": "['APP_ACTIVE_OPEN', 'RCV_SYN_ACK', 'APP_CLOSE']", "output": ["FIN_WAIT_1"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK', 'APP_PASSIVE_OPEN']", "output": ["ERROR"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK', 'APP_CLOSE', 'RCV_FIN_ACK', 'APP_TIMEOUT', 'APP_ACTIVE_OPEN', 'RCV_SYN', 'APP_CLOSE', 'RCV_FIN', 'RCV_ACK']", "output": ["TIME_WAIT"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK', 'APP_CLOSE', 'RCV_SYN']", "output": ["ERROR"]}, {"input": "['APP_PASSIVE_OPEN', 'APP_CLOSE', 'RCV_SYN']", "output": ["ERROR"]}, {"input": "['APP_PASSIVE_OPEN', 'RCV_SYN', 'RCV_ACK', 'APP_CLOSE', 'RCV_FIN']", "output": ["CLOSING"]}], "starter_code": "\ndef traverse_TCP_states(events):\n\t", "source_codes": ["import ast\nimport sys\nimport json\n\ndef connection_status(events):\n    \"\"\"\n    Simulate the TCP finite state machine.\n\n    Args:\n        events (list[str]): list of event strings.\n\n    Returns:\n        str: final state in upper case or \"ERROR\".\n    \"\"\"\n    state = \"CLOSED\"\n    # Transition table: state -> {event: next_state}\n    transitions = {\n        \"CLOSED\": {\n            \"APP_PASSIVE_OPEN\": \"LISTEN\",\n            \"APP_ACTIVE_OPEN\": \"SYN_SENT\",\n        },\n        \"LISTEN\": {\n            \"RCV_SYN\": \"SYN_RCVD\",\n            \"APP_SEND\": \"SYN_SENT\",\n            \"APP_CLOSE\": \"CLOSED\",\n        },\n        \"SYN_RCVD\": {\n            \"APP_CLOSE\": \"FIN_WAIT_1\",\n            \"RCV_ACK\": \"ESTABLISHED\",\n        },\n        \"SYN_SENT\": {\n            \"RCV_SYN\": \"SYN_RCVD\",\n            \"RCV_SYN_ACK\": \"ESTABLISHED\",\n            \"APP_CLOSE\": \"CLOSED\",\n        },\n        \"ESTABLISHED\": {\n            \"APP_CLOSE\": \"FIN_WAIT_1\",\n            \"RCV_FIN\": \"CLOSE_WAIT\",\n        },\n        \"FIN_WAIT_1\": {\n            \"RCV_FIN\": \"CLOSING\",\n            \"RCV_FIN_ACK\": \"TIME_WAIT\",\n            \"RCV_ACK\": \"FIN_WAIT_2\",\n        },\n        \"CLOSING\": {\n            \"RCV_ACK\": \"TIME_WAIT\",\n        },\n        \"FIN_WAIT_2\": {\n            \"RCV_FIN\": \"TIME_WAIT\",\n        },\n        \"TIME_WAIT\": {\n            \"APP_TIMEOUT\": \"CLOSED\",\n        },\n        \"CLOSE_WAIT\": {\n            \"APP_CLOSE\": \"LAST_ACK\",\n        },\n        \"LAST_ACK\": {\n            \"RCV_ACK\": \"CLOSED\",\n        },\n    }\n    for ev in events:\n        nxt = transitions.get(state, {}).get(ev)\n        if nxt is None:\n            return \"ERROR\"\n        state = nxt\n    return state\n\ndef parse_events(data):\n    \"\"\"\n    Parse the input string into a list of event strings.\n    Supports both JSON (double\u2011quoted strings) and Python literal syntax\n    (single\u2011quoted strings).  If the value is a string that itself contains\n    a list, it is parsed until a list is obtained.\n\n    Returns:\n        list or None if parsing fails.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return None\n\n    # Try JSON first\n    try:\n        parsed = json.loads(data)\n    except Exception:\n        try:\n            parsed = ast.literal_eval(data)\n        except Exception:\n            return None\n\n    # If we got a string (e.g., a JSON string that contains a list), keep parsing.\n    while isinstance(parsed, str):\n        try:\n            parsed = json.loads(parsed)\n        except Exception:\n            try:\n                parsed = ast.literal_eval(parsed)\n            except Exception:\n                return None\n    return parsed\n\ndef main():\n    data = sys.stdin.read()\n    events = parse_events(data)\n\n    if events is None or not isinstance(events, list):\n        print(\"ERROR\")\n        return\n\n    result = connection_status(events)\n    if result == \"ERROR\":\n        print(\"ERROR\")\n    else:\n        print([result])\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport ast\nimport sys\nimport json\n\ndef connection_status(events):\n    \"\"\"\n    Simulate the TCP finite state machine.\n\n    Args:\n        events (list[str]): list of event strings.\n\n    Returns:\n        str: final state in upper case or \"ERROR\".\n    \"\"\"\n    state = \"CLOSED\"\n    # Transition table: state -> {event: next_state}\n    transitions = {\n        \"CLOSED\": {\n            \"APP_PASSIVE_OPEN\": \"LISTEN\",\n            \"APP_ACTIVE_OPEN\": \"SYN_SENT\",\n        },\n        \"LISTEN\": {\n            \"RCV_SYN\": \"SYN_RCVD\",\n            \"APP_SEND\": \"SYN_SENT\",\n            \"APP_CLOSE\": \"CLOSED\",\n        },\n        \"SYN_RCVD\": {\n            \"APP_CLOSE\": \"FIN_WAIT_1\",\n            \"RCV_ACK\": \"ESTABLISHED\",\n        },\n        \"SYN_SENT\": {\n            \"RCV_SYN\": \"SYN_RCVD\",\n            \"RCV_SYN_ACK\": \"ESTABLISHED\",\n            \"APP_CLOSE\": \"CLOSED\",\n        },\n        \"ESTABLISHED\": {\n            \"APP_CLOSE\": \"FIN_WAIT_1\",\n            \"RCV_FIN\": \"CLOSE_WAIT\",\n        },\n        \"FIN_WAIT_1\": {\n            \"RCV_FIN\": \"CLOSING\",\n            \"RCV_FIN_ACK\": \"TIME_WAIT\",\n            \"RCV_ACK\": \"FIN_WAIT_2\",\n        },\n        \"CLOSING\": {\n            \"RCV_ACK\": \"TIME_WAIT\",\n        },\n        \"FIN_WAIT_2\": {\n            \"RCV_FIN\": \"TIME_WAIT\",\n        },\n        \"TIME_WAIT\": {\n            \"APP_TIMEOUT\": \"CLOSED\",\n        },\n        \"CLOSE_WAIT\": {\n            \"APP_CLOSE\": \"LAST_ACK\",\n        },\n        \"LAST_ACK\": {\n            \"RCV_ACK\": \"CLOSED\",\n        },\n    }\n    for ev in events:\n        nxt = transitions.get(state, {}).get(ev)\n        if nxt is None:\n            return \"ERROR\"\n        state = nxt\n    return state\n\ndef parse_events(data):\n    \"\"\"\n    Parse the input string into a list of event strings.\n    Supports both JSON (double\u2011quoted strings) and Python literal syntax\n    (single\u2011quoted strings).  If the value is a string that itself contains\n    a list, it is parsed until a list is obtained.\n\n    Returns:\n        list or None if parsing fails.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return None\n\n    # Try JSON first\n    try:\n        parsed = json.loads(data)\n    except Exception:\n        try:\n            parsed = ast.literal_eval(data)\n        except Exception:\n            return None\n\n    # If we got a string (e.g., a JSON string that contains a list), keep parsing.\n    while isinstance(parsed, str):\n        try:\n            parsed = json.loads(parsed)\n        except Exception:\n            try:\n                parsed = ast.literal_eval(parsed)\n            except Exception:\n                return None\n    return parsed\n\ndef main():\n    data = sys.stdin.read()\n    events = parse_events(data)\n\n    if events is None or not isinstance(events, list):\n        print(\"ERROR\")\n        return\n\n    result = connection_status(events)\n    if result == \"ERROR\":\n        print(\"ERROR\")\n    else:\n        print([result])\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1649}
{"name": "1646", "description": "This is a very simply formulated task. Let's call an integer number `N` 'green' if `N\u00b2` ends with all of the digits of `N`. Some examples:\n\n`5` is green, because `5\u00b2 = 25` and `25` ends with `5`.\n\n`11` is not green, because `11\u00b2 = 121` and `121` does not end with `11`.\n\n`376` is green, because `376\u00b2 = 141376` and `141376` ends with `376`.\n\nYour task is to write a function `green` that returns `n`th green number, starting with `1` - `green (1) == 1`\n\n---\n\n## Data range\n\n```if:haskell\n`n <= 4000` for Haskell\n```\n```if:java\n`n <= 5000` for Java\n```\n```if:python\n`n <= 5000` for Python\n```\n```if:javascript\n`n <= 3000` for JavaScript\n\nReturn values should be `String`s, and should be exact. A BigNum library is recommended.\n```", "difficulty": "interview", "id": 1646, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [5]}, {"input": "3", "output": [6]}, {"input": "4", "output": [25]}, {"input": "12", "output": [2890625]}, {"input": "13", "output": [7109376]}, {"input": "100", "output": [6188999442576576769103890995893380022607743740081787109376]}, {"input": "110", "output": [9580863811000557423423230896109004106619977392256259918212890625]}], "starter_code": "\ndef green(n):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1646}
{"name": "1660", "description": "When we attended middle school were asked to simplify mathematical expressions like \"3x-yx+2xy-x\" (or usually bigger), and that was easy-peasy (\"2x+xy\"). But tell that to your pc and we'll see! \n\nWrite a function: `simplify`, that takes a string in input, representing a *multilinear non-constant polynomial in integers coefficients* (like `\"3x-zx+2xy-x\"`), and returns another string as output where the same expression has been simplified in the following way ( `->` means application of `simplify`):\n\n- All possible sums and subtraction of equivalent monomials (\"xy==yx\") has been done, e.g.: `\"cb+cba\" -> \"bc+abc\"`, `\"2xy-yx\" -> \"xy\"`, `\"-a+5ab+3a-c-2a\" -> \"-c+5ab\"`\n\n- All monomials appears in order of increasing number of variables, e.g.: `\"-abc+3a+2ac\" -> \"3a+2ac-abc\"`, `\"xyz-xz\" -> \"-xz+xyz\"`\n \n- If two monomials have the same number of variables, they appears in lexicographic order, e.g.: `\"a+ca-ab\" -> \"a-ab+ac\"`, `\"xzy+zby\" ->\"byz+xyz\"`\n  \n- There is no leading `+` sign if the first coefficient is positive, e.g.: `\"-y+x\" -> \"x-y\"`, but no restrictions for `-`:  `\"y-x\" ->\"-x+y\"`\n\n---\n\n__N.B.__ to keep it simplest, the string in input is restricted to represent only *multilinear non-constant polynomials*, so you won't find something like `-3+yx^2'. **Multilinear** means in this context: **of degree 1 on each variable**.\n\n**Warning**: the string in input can contain arbitrary variables represented by lowercase characters in the english alphabet.\n\n__Good Work :)__", "difficulty": "interview", "id": 1660, "sample_io": [{"input": "cb+cba", "output": ["bc+abc"]}, {"input": "2xy-yx", "output": ["xy"]}, {"input": "-a+5ab+3a-c-2a", "output": ["-c+5ab"]}, {"input": "-abc+3a+2ac", "output": ["3a+2ac-abc"]}, {"input": "xyz-xz", "output": ["-xz+xyz"]}, {"input": "a+ca-ab", "output": ["a-ab+ac"]}, {"input": "xzy+zby", "output": ["byz+xyz"]}, {"input": "-y+x", "output": ["x-y"]}, {"input": "y-x", "output": ["-x+y"]}], "test_list": [{"input": "dc+dcba", "output": ["cd+abcd"]}, {"input": "2xy-yx", "output": ["xy"]}, {"input": "-a+5ab+3a-c-2a", "output": ["-c+5ab"]}, {"input": "-abc+3a+2ac", "output": ["3a+2ac-abc"]}, {"input": "xyz-xz", "output": ["-xz+xyz"]}, {"input": "a+ca-ab", "output": ["a-ab+ac"]}, {"input": "xzy+zby", "output": ["byz+xyz"]}, {"input": "-y+x", "output": ["x-y"]}, {"input": "y-x", "output": ["-x+y"]}, {"input": "3a+b+4ac+bc-ab+3a-cb-a-a", "output": ["4a+b-ab+4ac"]}, {"input": "+n-5hn+7tjhn-4nh-3n-6hnjt+2jhn+9hn", "output": ["-2n+2hjn+hjnt"]}, {"input": "-8fk+5kv-4yk+7kf-qk+yqv-3vqy+4ky+4kf+yvqkf", "output": ["3fk-kq+5kv-2qvy+fkqvy"]}], "starter_code": "\ndef simplify(poly):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1660}
{"name": "1616", "description": "In this kata we want to convert a string into an integer. The strings simply represent the numbers in words.\n\nExamples:\n\n* \"one\" => 1\n* \"twenty\" => 20\n* \"two hundred forty-six\" => 246\n* \"seven hundred eighty-three thousand nine hundred and nineteen\" => 783919\n\nAdditional Notes:\n\n* The minimum number is \"zero\" (inclusively)\n* The maximum number, which must be supported is 1 million (inclusively)\n* The \"and\" in e.g. \"one hundred and twenty-four\" is optional, in some cases it's present and in others it's not\n* All tested numbers are valid, you don't need to validate them", "difficulty": "interview", "id": 1616, "sample_io": [{"input": "one", "output": [1]}, {"input": "twenty", "output": [20]}, {"input": "two hundred forty-six", "output": [246]}, {"input": "seven hundred eighty-three thousand nine hundred and nineteen", "output": [783919]}], "test_list": [{"input": "zero", "output": [0]}, {"input": "one", "output": [1]}, {"input": "two", "output": [2]}, {"input": "three", "output": [3]}, {"input": "four", "output": [4]}, {"input": "five", "output": [5]}, {"input": "six", "output": [6]}, {"input": "seven", "output": [7]}, {"input": "eight", "output": [8]}, {"input": "nine", "output": [9]}, {"input": "ten", "output": [10]}, {"input": "twenty", "output": [20]}, {"input": "twenty-one", "output": [21]}, {"input": "thirty-seven", "output": [37]}, {"input": "forty-six", "output": [46]}, {"input": "fifty-nine", "output": [59]}, {"input": "sixty-eight", "output": [68]}, {"input": "seventy-two", "output": [72]}, {"input": "eighty-three", "output": [83]}, {"input": "ninety-four", "output": [94]}, {"input": "one hundred", "output": [100]}, {"input": "one hundred one", "output": [101]}, {"input": "one hundred and one", "output": [101]}, {"input": "one hundred sixty-nine", "output": [169]}, {"input": "two hundred and ninety-nine", "output": [299]}, {"input": "seven hundred thirty-six", "output": [736]}, {"input": "two thousand", "output": [2000]}, {"input": "one thousand three hundred and thirty-seven", "output": [1337]}, {"input": "ten thousand", "output": [10000]}, {"input": "twenty-six thousand three hundred and fifty-nine", "output": [26359]}, {"input": "thirty-five thousand", "output": [35000]}, {"input": "ninety-nine thousand nine hundred and ninety-nine", "output": [99999]}, {"input": "six hundred sixty-six thousand six hundred sixty-six", "output": [666666]}, {"input": "seven hundred thousand", "output": [700000]}, {"input": "two hundred thousand three", "output": [200003]}, {"input": "two hundred thousand and three", "output": [200003]}, {"input": "two hundred three thousand", "output": [203000]}, {"input": "five hundred thousand three hundred", "output": [500300]}, {"input": "eight hundred eighty-eight thousand eight hundred and eighty-eight", "output": [888888]}, {"input": "one million", "output": [1000000]}], "starter_code": "\ndef parse_int(string):\n\t", "source_codes": ["import sys\n\ndef parse_int(s: str) -> int:\n    \"\"\"\n    Convert an English description of an integer (zero .. one million) to the\n    integer itself.\n    \"\"\"\n    # Normalise: lower case, replace hyphens, remove optional 'and'\n    s = s.lower().replace('-', ' ')\n    tokens = [t for t in s.split() if t != 'and']\n\n    # Simple word mappings\n    units = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    teens = {\n        'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13,\n        'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17,\n        'eighteen': 18, 'nineteen': 19\n    }\n    tens = {\n        'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,\n        'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90\n    }\n\n    # Unified lookup table for simple words\n    word_to_val = {}\n    word_to_val.update(units)\n    word_to_val.update(teens)\n    word_to_val.update(tens)\n\n    total = 0   # completed higher\u2011scale blocks\n    cur = 0     # value inside the current block\n\n    for token in tokens:\n        if token in word_to_val:\n            cur += word_to_val[token]\n        elif token == 'hundred':\n            cur *= 100\n        elif token == 'thousand':\n            total += cur * 1000\n            cur = 0\n        elif token == 'million':\n            total += cur * 1000000   # 1_000_000 works on Python 3.6+\n            cur = 0\n        else:\n            # According to the problem the input is always valid.\n            continue\n\n    return total + cur\n\n\ndef solve() -> None:\n    \"\"\"\n    Read each non\u2011empty line from stdin, convert it to an integer\n    and print the result.\n    \"\"\"\n    outputs = []\n    for raw_line in sys.stdin:\n        line = raw_line.strip()\n        if line:\n            outputs.append(str(parse_int(line)))\n    sys.stdout.write(\"\\n\".join(outputs))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef parse_int(s: str) -> int:\n    \"\"\"\n    Convert an English description of an integer (zero .. one million) to the\n    integer itself.\n    \"\"\"\n    # Normalise: lower case, replace hyphens, remove optional 'and'\n    s = s.lower().replace('-', ' ')\n    tokens = [t for t in s.split() if t != 'and']\n\n    # Simple word mappings\n    units = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    teens = {\n        'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13,\n        'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17,\n        'eighteen': 18, 'nineteen': 19\n    }\n    tens = {\n        'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,\n        'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90\n    }\n\n    # Unified lookup table for simple words\n    word_to_val = {}\n    word_to_val.update(units)\n    word_to_val.update(teens)\n    word_to_val.update(tens)\n\n    total = 0   # completed higher\u2011scale blocks\n    cur = 0     # value inside the current block\n\n    for token in tokens:\n        if token in word_to_val:\n            cur += word_to_val[token]\n        elif token == 'hundred':\n            cur *= 100\n        elif token == 'thousand':\n            total += cur * 1000\n            cur = 0\n        elif token == 'million':\n            total += cur * 1000000   # 1_000_000 works on Python 3.6+\n            cur = 0\n        else:\n            # According to the problem the input is always valid.\n            continue\n\n    return total + cur\n\n\ndef solve() -> None:\n    \"\"\"\n    Read each non\u2011empty line from stdin, convert it to an integer\n    and print the result.\n    \"\"\"\n    outputs = []\n    for raw_line in sys.stdin:\n        line = raw_line.strip()\n        if line:\n            outputs.append(str(parse_int(line)))\n    sys.stdout.write(\"\\n\".join(outputs))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1616}
{"name": "1621", "description": "Write a function that counts how many different ways you can make change for an amount of money, given an array of coin denominations. For example, there are 3 ways to give change for 4 if you have coins with denomination 1 and 2: \n```\n1+1+1+1, 1+1+2, 2+2.\n```\nThe order of coins does not matter:\n```\n1+1+2 == 2+1+1\n```\nAlso, assume that you have an infinite amount of coins.\n\nYour function should take an amount to change and an array of unique denominations for the coins:\n\n```python\n  count_change(4, [1,2]) # => 3\n  count_change(10, [5,2,3]) # => 4\n  count_change(11, [5,7]) # => 0\n```", "difficulty": "interview", "id": 1621, "sample_io": [{"input": "4\n[1, 2]", "output": [3]}, {"input": "10\n[5, 2, 3]", "output": [4]}, {"input": "11\n[5, 7]", "output": [0]}], "test_list": [{"input": "4\n[1, 2]", "output": [3]}, {"input": "10\n[5, 2, 3]", "output": [4]}, {"input": "11\n[5, 7]", "output": [0]}, {"input": "98\n[3, 14, 8]", "output": [19]}, {"input": "199\n[3, 5, 9, 15]", "output": [760]}, {"input": "300\n[5, 10, 20, 50, 100, 200, 500]", "output": [1022]}, {"input": "301\n[5, 10, 20, 50, 100, 200, 500]", "output": [0]}, {"input": "419\n[2, 5, 10, 20, 50]", "output": [18515]}], "starter_code": "\ndef count_change(money, coins):\n\t", "source_codes": ["import re\n\ndef count_change(amount: int, coins):\n    \"\"\"\n    Returns the number of different ways to make `amount` using an\n    unlimited supply of the denominations in `coins`.\n    \"\"\"\n    if amount < 0:\n        return 0\n\n    # DP array: dp[i] = number of ways to reach sum i\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # one way to make 0 (choose no coins)\n\n    for c in sorted(coins):\n        if c > amount:\n            continue\n        for i in range(c, amount + 1):\n            dp[i] += dp[i - c]\n\n    return dp[amount]\n\ndef solve():\n    # Read amount\n    amount_line = input().strip()\n    if not amount_line:               # no input\n        return\n    amount = int(amount_line)\n\n    # Read coin list (e.g. \"[1, 2]\")\n    coin_line = input().strip()\n    # Extract all integers from the line\n    coin_nums = list(map(int, re.findall(r'-?\\d+', coin_line)))\n    # Keep only positive unique denominations\n    coins = sorted(set(c for c in coin_nums if c > 0))\n\n    result = count_change(amount, coins)\n    # Print integer, not a list\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport re\n\ndef count_change(amount: int, coins):\n    \"\"\"\n    Returns the number of different ways to make `amount` using an\n    unlimited supply of the denominations in `coins`.\n    \"\"\"\n    if amount < 0:\n        return 0\n\n    # DP array: dp[i] = number of ways to reach sum i\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # one way to make 0 (choose no coins)\n\n    for c in sorted(coins):\n        if c > amount:\n            continue\n        for i in range(c, amount + 1):\n            dp[i] += dp[i - c]\n\n    return dp[amount]\n\ndef solve():\n    # Read amount\n    amount_line = input().strip()\n    if not amount_line:               # no input\n        return\n    amount = int(amount_line)\n\n    # Read coin list (e.g. \"[1, 2]\")\n    coin_line = input().strip()\n    # Extract all integers from the line\n    coin_nums = list(map(int, re.findall(r'-?\\d+', coin_line)))\n    # Keep only positive unique denominations\n    coins = sorted(set(c for c in coin_nums if c > 0))\n\n    result = count_change(amount, coins)\n    # Print integer, not a list\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1621}
{"name": "1628", "description": "If n is the numerator and d the denominator of a fraction, that fraction is defined a (reduced) proper fraction if and only if GCD(n,d)==1.\n\nFor example `5/16` is a proper fraction, while `6/16` is not, as both 6 and 16 are divisible by 2, thus the fraction can be reduced to `3/8`.\n\nNow, if you consider a given number d, how many proper fractions can be built using d as a denominator?\n\nFor example, let's assume that d is 15: you can build a total of 8 different proper fractions between 0 and 1 with it: 1/15, 2/15, 4/15, 7/15, 8/15, 11/15, 13/15 and 14/15.\n\nYou are to build a function that computes how many proper fractions you can build with a given denominator:\n```python\nproper_fractions(1)==0\nproper_fractions(2)==1\nproper_fractions(5)==4\nproper_fractions(15)==8\nproper_fractions(25)==20\n```\n\nBe ready to handle big numbers.\n\nEdit: to be extra precise, the term should be \"reduced\" fractions, thanks to [girianshiido](http://www.codewars.com/users/girianshiido) for pointing this out and sorry for the use of an improper word :)", "difficulty": "interview", "id": 1628, "sample_io": [{"input": "1", "output": [0]}, {"input": "2", "output": [1]}, {"input": "5", "output": [4]}, {"input": "15", "output": [8]}, {"input": "25", "output": [20]}], "test_list": [{"input": "1", "output": [0]}, {"input": "2", "output": [1]}, {"input": "5", "output": [4]}, {"input": "15", "output": [8]}, {"input": "25", "output": [20]}, {"input": "9999999", "output": [6637344]}, {"input": "500000003", "output": [500000002]}, {"input": "1532420", "output": [608256]}, {"input": "123456789", "output": [82260072]}, {"input": "9999999999", "output": [5890320000]}], "starter_code": "\ndef proper_fractions(n):\n\t", "source_codes": ["import sys\nimport random\nimport math\n\n# ---------- Miller\u2013Rabin primality test (deterministic for 64\u2011bit) ----------\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    # small primes \u2013 fast trial division\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    for p in small_primes:\n        if n % p == 0:\n            return n == p\n    # write n\u20111 = d\u00b72^s  with d odd\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    # deterministic bases for n < 2^64\n    for a in (2, 325, 9375, 28178, 450775, 9780504, 1795265022):\n        if a % n == 0:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = (x * x) % n\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n# ---------- Pollard's Rho factorisation ----------\ndef pollard_rho(n: int) -> int:\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    # random polynomial f(x) = x^2 + c (mod n)\n    while True:\n        c = random.randrange(1, n - 1)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d == 1:\n            x = f(x)\n            y = f(f(y))\n            d = math.gcd(abs(x - y), n)\n        if d != n:\n            return d\n        # otherwise retry with a new constant c\n\n# ---------- recursive factor accumulation ----------\ndef factor(n: int, res: dict) -> None:\n    \"\"\"store prime factors of n in dictionary res: prime -> exponent\"\"\"\n    if n == 1:\n        return\n    if is_prime(n):\n        res[n] = res.get(n, 0) + 1\n        return\n    d = pollard_rho(n)\n    factor(d, res)\n    factor(n // d, res)\n\n# ---------- Euler's totient ----------\ndef phi(d: int) -> int:\n    \"\"\"Euler's totient, but phi(1) = 0 for this problem\"\"\"\n    if d == 1:\n        return 0\n    factors = {}\n    factor(d, factors)\n    result = d\n    for p in factors.keys():\n        result -= result // p\n    return result\n\n# ---------- main ----------\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    print(phi(n))\n\nif __name__ == \"__main__\":\n    # make randomness deterministic only for reproducibility in tests\n    random.seed(0xC0FFEE)\n    main()"], "responses": ["\nimport sys\nimport random\nimport math\n\n# ---------- Miller\u2013Rabin primality test (deterministic for 64\u2011bit) ----------\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    # small primes \u2013 fast trial division\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    for p in small_primes:\n        if n % p == 0:\n            return n == p\n    # write n\u20111 = d\u00b72^s  with d odd\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    # deterministic bases for n < 2^64\n    for a in (2, 325, 9375, 28178, 450775, 9780504, 1795265022):\n        if a % n == 0:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = (x * x) % n\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n# ---------- Pollard's Rho factorisation ----------\ndef pollard_rho(n: int) -> int:\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    # random polynomial f(x) = x^2 + c (mod n)\n    while True:\n        c = random.randrange(1, n - 1)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d == 1:\n            x = f(x)\n            y = f(f(y))\n            d = math.gcd(abs(x - y), n)\n        if d != n:\n            return d\n        # otherwise retry with a new constant c\n\n# ---------- recursive factor accumulation ----------\ndef factor(n: int, res: dict) -> None:\n    \"\"\"store prime factors of n in dictionary res: prime -> exponent\"\"\"\n    if n == 1:\n        return\n    if is_prime(n):\n        res[n] = res.get(n, 0) + 1\n        return\n    d = pollard_rho(n)\n    factor(d, res)\n    factor(n // d, res)\n\n# ---------- Euler's totient ----------\ndef phi(d: int) -> int:\n    \"\"\"Euler's totient, but phi(1) = 0 for this problem\"\"\"\n    if d == 1:\n        return 0\n    factors = {}\n    factor(d, factors)\n    result = d\n    for p in factors.keys():\n        result -= result // p\n    return result\n\n# ---------- main ----------\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    print(phi(n))\n\nif __name__ == \"__main__\":\n    # make randomness deterministic only for reproducibility in tests\n    random.seed(0xC0FFEE)\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1628}
{"name": "1604", "description": "You are at the top left cell $(1, 1)$ of an $n \\times m$ labyrinth. Your goal is to get to the bottom right cell $(n, m)$. You can only move right or down, one cell per step. Moving right from a cell $(x, y)$ takes you to the cell $(x, y + 1)$, while moving down takes you to the cell $(x + 1, y)$.\n\nSome cells of the labyrinth contain rocks. When you move to a cell with rock, the rock is pushed to the next cell in the direction you're moving. If the next cell contains a rock, it gets pushed further, and so on.\n\nThe labyrinth is surrounded by impenetrable walls, thus any move that would put you or any rock outside of the labyrinth is illegal.\n\nCount the number of different legal paths you can take from the start to the goal modulo $10^9 + 7$. Two paths are considered different if there is at least one cell that is visited in one path, but not visited in the other.\n\n\n-----Input-----\n\nThe first line contains two integers $n, m$\u00a0\u2014 dimensions of the labyrinth ($1 \\leq n, m \\leq 2000$).\n\nNext $n$ lines describe the labyrinth. Each of these lines contains $m$ characters. The $j$-th character of the $i$-th of these lines is equal to \"R\" if the cell $(i, j)$ contains a rock, or \".\" if the cell $(i, j)$ is empty.\n\nIt is guaranteed that the starting cell $(1, 1)$ is empty.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the number of different legal paths from $(1, 1)$ to $(n, m)$ modulo $10^9 + 7$.\n\n\n-----Examples-----\nInput\n1 1\n.\n\nOutput\n1\n\nInput\n2 3\n...\n..R\n\nOutput\n0\n\nInput\n4 4\n...R\n.RR.\n.RR.\nR...\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample case we can't (and don't have to) move, hence the only path consists of a single cell $(1, 1)$.\n\nIn the second sample case the goal is blocked and is unreachable.\n\nIllustrations for the third sample case can be found here: https://assets.codeforces.com/rounds/1225/index.html", "difficulty": "interview", "id": 1604, "sample_io": [{"input": "1 1\n.\n", "output": ["1\n"]}, {"input": "2 3\n...\n..R\n", "output": ["0\n"]}, {"input": "4 4\n...R\n.RR.\n.RR.\nR...\n", "output": ["4\n"]}], "test_list": [{"input": "1 1\n.\n", "output": ["1\n"]}, {"input": "2 3\n...\n..R\n", "output": ["0\n"]}, {"input": "4 4\n...R\n.RR.\n.RR.\nR...\n", "output": ["4\n"]}, {"input": "1 3\n.R.\n", "output": ["0\n"]}, {"input": "2 2\n.R\nR.\n", "output": ["0\n"]}, {"input": "10 10\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n..........\n", "output": ["48620\n"]}], "starter_code": "", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1604}
{"name": "1622", "description": "# Ten-Pin Bowling\n\nIn the game of ten-pin bowling, a player rolls a bowling ball down a lane to knock over pins. There are ten pins set at the end of the bowling lane. Each player has 10 frames to roll a bowling ball down a lane and knock over as many pins as possible. The first nine frames are ended after two rolls or when the player knocks down all the pins. The last frame a player will receive an extra roll every time they knock down all ten pins; up to a maximum of three total rolls. \n\n## The Challenge\n\nIn this challenge you will be given a string representing a player's ten frames. It will look something like this: `'X X 9/ 80 X X 90 8/ 7/ 44'` (in Java: `\"X X 9/ 80 X X 90 8/ 7/ 44\"`), where each frame is space-delimited, `'X'` represents strikes, and `'/'` represents spares. Your goal is take in this string of frames into a function called `bowlingScore` and return the players total score.\n\n## Scoring\n\nThe scoring for ten-pin bowling can be difficult to understand, and if you're like most people, easily forgotten if you don't play often. Here is a quick breakdown:\n\n### Frames\n\nIn Ten-Pin Bowling there are ten frames per game. Frames are the players turn to bowl, which can be multiple rolls. The first 9 frames you get 2 rolls maximum to try to get all 10 pins down. **On the 10th or last frame a player will receive an extra roll each time they get all ten pins down to a maximum of three total rolls. Also on the last frame bonuses are not awarded for strikes and spares moving forward.**\n\nIn this challenge, three frames might be represented like this: `54 72 44`. In this case, the player has had three frames. On their first frame they scored 9 points (5 + 4), on their second frame they scored 9 points (7 + 2) and on their third frame they scored 8 points (4 + 4). This is a very simple example of bowling scoring. It gets more complicated when we introduce strikes and spares.\n\n### Strikes \nRepresented in this challenge as `'X'`\n\nA strike is scored when a player knocks all ten pins down in one roll. In the first 9 frames this will conclude the players turn and it will be scored as 10 points plus the points received from the next two rolls. So if a player were to have two frames `X 54`, the total score of those two frames would be 28. The first frame would be worth 19 (10 + 5 + 4) and the second frame would be worth 9 (5 + 4).\n\nA perfect game in bowling is 12 strikes in a row and would be represented like this `'X X X X X X X X X XXX'` (in Java: `\"X X X X X X X X X XXX\"`). This adds up to a total score of 300.\n\n### Spares\nRepresented in this challenge as `'/'`\n\nA spare is scored when a player knocks down all ten pins in two rolls. In the first 9 frames this will be scored as 10 points plus the next roll. So if a player were to have two frames `9/ 54`, the total score of the two frames would be 24. The first frame would be worth 15 (10 + 5) and the second frame would be worth 9 (5 + 4).\n\nFor a more detailed explanation see Wikipedia: \n\nhttp://en.wikipedia.org/wiki/Ten-pin_bowling#Scoring", "difficulty": "interview", "id": 1622, "sample_io": [{"input": "X X X X X X X X X XXX", "output": [300]}, {"input": "X X 9/ 80 X X 90 8/ 7/ 44", "output": [171]}], "test_list": [{"input": "11 11 11 11 11 11 11 11 11 11", "output": [20]}, {"input": "X X X X X X X X X XXX", "output": [300]}, {"input": "00 5/ 4/ 53 33 22 4/ 5/ 45 XXX", "output": [115]}, {"input": "5/ 4/ 3/ 2/ 1/ 0/ X 9/ 4/ 8/8", "output": [150]}, {"input": "5/ 4/ 3/ 2/ 1/ 0/ X 9/ 4/ 7/2", "output": [143]}, {"input": "X X 9/ 80 X X 90 8/ 7/ 44", "output": [171]}, {"input": "6/ 5/ 6/ 2/ 3/ 0/ 1/ 8/ 3/ 6/5", "output": [139]}, {"input": "00 00 00 00 00 00 00 00 00 0/X", "output": [20]}, {"input": "00 00 00 00 00 00 00 00 X 0/X", "output": [40]}], "starter_code": "\ndef bowling_score(frames):\n\t", "source_codes": ["def bowlingScore(frames_str: str) -> int:\n    \"\"\"Return the total score of a single bowling game.\"\"\"\n    # ----- 1. expand the frames into a flat list of rolls -----\n    tokens = frames_str.split()\n    rolls = []\n    for token in tokens:\n        if token == 'X':                 # a strike, one roll of 10 pins\n            rolls.append(10)\n        else:                            # token may contain 1\u20113 characters\n            for ch in token:\n                if ch == 'X':\n                    rolls.append(10)\n                elif ch == '-':          # miss (value 0)\n                    rolls.append(0)\n                elif ch == '/':          # spare: 10 - previous roll\n                    rolls.append(10 - rolls[-1])\n                else:                    # digit 0\u20119\n                    rolls.append(int(ch))\n\n    # ----- 2. compute the ten\u2011frame score -----\n    score = 0\n    i = 0                     # current position in rolls list\n    for _ in range(10):       # ten frames\n        if rolls[i] == 10:                 # strike\n            score += 10 + rolls[i + 1] + rolls[i + 2]\n            i += 1                         # strike consumes one roll\n        else:\n            frame_sum = rolls[i] + rolls[i + 1]\n            if frame_sum == 10:            # spare\n                score += 10 + rolls[i + 2]\n            else:                           # open frame\n                score += frame_sum\n            i += 2                         # normal frame consumes two rolls\n    return score\n\n\nif __name__ == '__main__':\n    # Read the input as a single line\n    frames_str = input().strip()\n    if not frames_str:\n        # If there's no input, exit without printing\n        import sys\n        sys.exit()\n    print(bowlingScore(frames_str))"], "responses": ["\ndef bowlingScore(frames_str: str) -> int:\n    \"\"\"Return the total score of a single bowling game.\"\"\"\n    # ----- 1. expand the frames into a flat list of rolls -----\n    tokens = frames_str.split()\n    rolls = []\n    for token in tokens:\n        if token == 'X':                 # a strike, one roll of 10 pins\n            rolls.append(10)\n        else:                            # token may contain 1\u20113 characters\n            for ch in token:\n                if ch == 'X':\n                    rolls.append(10)\n                elif ch == '-':          # miss (value 0)\n                    rolls.append(0)\n                elif ch == '/':          # spare: 10 - previous roll\n                    rolls.append(10 - rolls[-1])\n                else:                    # digit 0\u20119\n                    rolls.append(int(ch))\n\n    # ----- 2. compute the ten\u2011frame score -----\n    score = 0\n    i = 0                     # current position in rolls list\n    for _ in range(10):       # ten frames\n        if rolls[i] == 10:                 # strike\n            score += 10 + rolls[i + 1] + rolls[i + 2]\n            i += 1                         # strike consumes one roll\n        else:\n            frame_sum = rolls[i] + rolls[i + 1]\n            if frame_sum == 10:            # spare\n                score += 10 + rolls[i + 2]\n            else:                           # open frame\n                score += frame_sum\n            i += 2                         # normal frame consumes two rolls\n    return score\n\n\nif __name__ == '__main__':\n    # Read the input as a single line\n    frames_str = input().strip()\n    if not frames_str:\n        # If there's no input, exit without printing\n        import sys\n        sys.exit()\n    print(bowlingScore(frames_str))\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1622}
{"name": "1640", "description": "Given two strings s1 and s2, we want to visualize how different the two strings are.\nWe will only take into account the *lowercase* letters (a to z).\nFirst let us count the frequency of each *lowercase* letters in s1 and s2.\n\n`s1 = \"A aaaa bb c\"`\n\n`s2 = \"& aaa bbb c d\"`\n\n`s1 has 4 'a', 2 'b', 1 'c'`\n\n`s2 has 3 'a', 3 'b', 1 'c', 1 'd'`\n\nSo the maximum for 'a' in s1 and s2 is 4 from s1; the maximum for 'b' is 3 from s2.\nIn the following we will not consider letters when the maximum of their occurrences\nis less than or equal to 1.\n\nWe can resume the differences between s1 and s2 in the following string:\n`\"1:aaaa/2:bbb\"`\nwhere `1` in `1:aaaa` stands for string s1 and `aaaa` because the maximum for `a` is 4.\nIn the same manner `2:bbb` stands for string s2 and `bbb` because the maximum for `b` is 3.\n\nThe task is to produce a string in which each *lowercase* letters of s1 or s2 appears as many times as\nits maximum if this maximum is *strictly greater than 1*; these letters will be prefixed by the \nnumber of the string where they appear with their maximum value and `:`. \nIf the maximum is in s1 as well as in s2 the prefix is `=:`.\n\nIn the result, substrings (a substring is for example 2:nnnnn or 1:hhh; it contains the prefix) will be in decreasing order of their length and when they have the same length sorted in ascending lexicographic order (letters and digits - more precisely sorted by codepoint); the different groups will be separated by '/'. See examples and \"Example Tests\".\n\nHopefully other examples can make this clearer.\n\n```\ns1 = \"my&friend&Paul has heavy hats! &\"\ns2 = \"my friend John has many many friends &\"\nmix(s1, s2) --> \"2:nnnnn/1:aaaa/1:hhh/2:mmm/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss\"\n\ns1 = \"mmmmm m nnnnn y&friend&Paul has heavy hats! &\"\ns2 = \"my frie n d Joh n has ma n y ma n y frie n ds n&\"\nmix(s1, s2) --> \"1:mmmmmm/=:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss\"\n\ns1=\"Are the kids at home? aaaaa fffff\"\ns2=\"Yes they are here! aaaaa fffff\"\nmix(s1, s2) --> \"=:aaaaaa/2:eeeee/=:fffff/1:tt/2:rr/=:hh\"\n```\n# Note for Swift, R, PowerShell\nThe prefix `=:` is replaced by `E:`\n``` \ns1 = \"mmmmm m nnnnn y&friend&Paul has heavy hats! &\"\ns2 = \"my frie n d Joh n has ma n y ma n y frie n ds n&\"\nmix(s1, s2) --> \"1:mmmmmm/E:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/E:ee/E:ss\"\n```", "difficulty": "interview", "id": 1640, "sample_io": [{"input": "my&friend&Paul has heavy hats! &\nmy friend John has many many friends &", "output": ["2:nnnnn/1:aaaa/1:hhh/2:mmm/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss"]}, {"input": "mmmmm m nnnnn y&friend&Paul has heavy hats! &\nmy frie n d Joh n has ma n y ma n y frie n ds n&", "output": ["1:mmmmmm/=:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss"]}, {"input": "Are the kids at home? aaaaa fffff\nYes they are here! aaaaa fffff", "output": ["=:aaaaaa/2:eeeee/=:fffff/1:tt/2:rr/=:hh"]}, {"input": "mmmmm m nnnnn y&friend&Paul has heavy hats! &\nmy frie n d Joh n has ma n y ma n y frie n ds n&", "output": ["1:mmmmmm/E:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/E:ee/E:ss"]}], "test_list": [{"input": "Are they here\nyes, they are here", "output": ["2:eeeee/2:yy/=:hh/=:rr"]}, {"input": "looping is fun but dangerous\nless dangerous than coding", "output": ["1:ooo/1:uuu/2:sss/=:nnn/1:ii/2:aa/2:dd/2:ee/=:gg"]}, {"input": " In many languages\n there's a pair of functions", "output": ["1:aaa/1:nnn/1:gg/2:ee/2:ff/2:ii/2:oo/2:rr/2:ss/2:tt"]}, {"input": "Lords of the Fallen\ngamekult", "output": ["1:ee/1:ll/1:oo"]}, {"input": "codewars\ncodewars", "output": [""]}, {"input": "A generation must confront the looming \ncodewarrs", "output": ["1:nnnnn/1:ooooo/1:tttt/1:eee/1:gg/1:ii/1:mm/=:rr"]}], "starter_code": "\ndef mix(s1, s2):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1640}
{"name": "1658", "description": "The aim is to calculate `exponential(x)` (written `exp(x)` in most math libraries) as an irreducible fraction, the numerator of this fraction having a given number of digits.\n\nWe call this function `expand`, it takes two parameters, `x` of which we want to evaluate the exponential, `digits` which is the required number of digits for the numerator. \n\nThe function `expand` will return an array of the form `[numerator, denominator]`; we stop the loop in the Taylor expansion (see references below) when the numerator has a number of digits `>=` the required number of digits\n\n# Examples:\n```\nexpand(1, 2) --> 65/24 (we will write this [65, 24] or (65, 24) in Haskell; \n65/24 ~ 2.708...)\n\nexpand(2, 5) --> [20947, 2835]\n\nexpand(3, 10) --> [7205850259, 358758400]\n\nexpand(1.5, 10) --> [36185315027,8074035200]\n```\n**Note**\n```expand(1,5) = [109601, 40320]``` is the same as ```expand(1, 6)```\n\n#Method:\nAs said above the way here is to use `Taylor expansion` of the exponential function though it is not always the best approximation by a rational.\n\n#References:\nhttps://en.wikipedia.org/wiki/Exponential_function#Formal_definition\n\nhttp://www.efunda.com/math/taylor_series/exponential.cfm", "difficulty": "interview", "id": 1658, "sample_io": [{"input": "1\n2", "output": [[65, 24]]}, {"input": "2\n5", "output": [[20947, 2835]]}, {"input": "3\n10", "output": [[7205850259, 358758400]]}, {"input": "1.5\n10", "output": [[36185315027, 8074035200]]}], "test_list": [{"input": "1\n2", "output": [[65, 24]]}, {"input": "1\n5", "output": [[109601, 40320]]}, {"input": "1\n6", "output": [[109601, 40320]]}, {"input": "10\n3", "output": [[683, 3]]}, {"input": "10\n4", "output": [[1933, 3]]}, {"input": "10\n40", "output": [[1239343290542858204293897268755807211243, 56266098342252742161373730812700463]]}, {"input": "10\n39", "output": [[1239343290542858204293897268755807211243, 56266098342252742161373730812700463]]}, {"input": "10\n38", "output": [[1239343290542858204293897268755807211243, 56266098342252742161373730812700463]]}, {"input": "1.5\n10", "output": [[36185315027, 8074035200]]}, {"input": "1.6\n10", "output": [[27425286391, 5537109375]]}, {"input": "1.7\n10", "output": [[3933851989, 720000000]]}, {"input": "1.7\n12", "output": [[22069373989681, 4032000000000]]}, {"input": "1.7\n15", "output": [[1986362246947787, 362880000000000]]}, {"input": "1.8\n20", "output": [[13246837419514181887, 2189687500000000000]]}, {"input": "2.0\n20", "output": [[355236915407681299637, 48076088562799171875]]}, {"input": "1.95\n60", "output": [[12382830214749612215651955187527316512224932853910667762866497, 1761755672416929554471321600000000000000000000000000000000000]]}], "starter_code": "\ndef expand(x, digit):\n\t", "source_codes": ["import sys\nfrom fractions import Fraction\n\ndef expand(x_str: str, digits: int):\n    \"\"\"\n    Return the Taylor expansion of exp(x) as an irreducible fraction,\n    stopped when the numerator reaches at least `digits` decimal digits.\n    The result is a list [numerator, denominator].\n    \"\"\"\n    x = Fraction(x_str)\n\n    # exp(0) = 1\n    if x == 0:\n        return [1, 1]\n\n    total = Fraction(0, 1)   # accumulated sum\n    term = Fraction(1, 1)    # current term x^n / n!\n    n = 0\n\n    while True:\n        total += term\n        # stop as soon as the numerator has the required number of digits\n        if len(str(abs(total.numerator))) >= digits:\n            break\n\n        # prepare next term: term_{n+1} = term_n * x / (n+1)\n        n += 1\n        term = term * x / n\n\n    return [total.numerator, total.denominator]\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    x_str = data[0]\n    digits = int(data[1]) if len(data) > 1 else 0\n\n    result = expand(x_str, digits)\n    # required output format: a list that contains the result list\n    print([result])\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nfrom fractions import Fraction\n\ndef expand(x_str: str, digits: int):\n    \"\"\"\n    Return the Taylor expansion of exp(x) as an irreducible fraction,\n    stopped when the numerator reaches at least `digits` decimal digits.\n    The result is a list [numerator, denominator].\n    \"\"\"\n    x = Fraction(x_str)\n\n    # exp(0) = 1\n    if x == 0:\n        return [1, 1]\n\n    total = Fraction(0, 1)   # accumulated sum\n    term = Fraction(1, 1)    # current term x^n / n!\n    n = 0\n\n    while True:\n        total += term\n        # stop as soon as the numerator has the required number of digits\n        if len(str(abs(total.numerator))) >= digits:\n            break\n\n        # prepare next term: term_{n+1} = term_n * x / (n+1)\n        n += 1\n        term = term * x / n\n\n    return [total.numerator, total.denominator]\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    x_str = data[0]\n    digits = int(data[1]) if len(data) > 1 else 0\n\n    result = expand(x_str, digits)\n    # required output format: a list that contains the result list\n    print([result])\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1658}
