{"name": "1626", "description": "Consider the following array:\n\n```\n[1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789, 12345678910, 1234567891011...]\n```\n\nIf we join these blocks of numbers, we come up with an infinite sequence which starts with `112123123412345123456...`. The list is infinite.\n\nYou will be given an number (`n`) and your task will be to return the element at that index in the sequence, where `1 \u2264 n \u2264 10^18`. Assume the indexes start with `1`, not `0`.  For example:\n\n```\nsolve(1) = 1, because the first character in the sequence is 1. There is no index 0. \nsolve(2) = 1, because the second character is also 1.\nsolve(3) = 2, because the third character is 2.\n```\n\nMore examples in the test cases. Good luck!", "difficulty": "interview", "id": 1626, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [1]}, {"input": "3", "output": [2]}, {"input": "100", "output": [1]}, {"input": "2100", "output": [2]}, {"input": "31000", "output": [2]}, {"input": "55", "output": [1]}, {"input": "123456", "output": [6]}, {"input": "123456789", "output": [3]}, {"input": "999999999999999999", "output": [4]}, {"input": "1000000000000000000", "output": [1]}, {"input": "999999999999999993", "output": [7]}], "starter_code": "\ndef solve(n):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1626}
{"name": "1621", "description": "Write a function that counts how many different ways you can make change for an amount of money, given an array of coin denominations. For example, there are 3 ways to give change for 4 if you have coins with denomination 1 and 2: \n```\n1+1+1+1, 1+1+2, 2+2.\n```\nThe order of coins does not matter:\n```\n1+1+2 == 2+1+1\n```\nAlso, assume that you have an infinite amount of coins.\n\nYour function should take an amount to change and an array of unique denominations for the coins:\n\n```python\n  count_change(4, [1,2]) # => 3\n  count_change(10, [5,2,3]) # => 4\n  count_change(11, [5,7]) # => 0\n```", "difficulty": "interview", "id": 1621, "sample_io": [{"input": "4\n[1, 2]", "output": [3]}, {"input": "10\n[5, 2, 3]", "output": [4]}, {"input": "11\n[5, 7]", "output": [0]}], "test_list": [{"input": "4\n[1, 2]", "output": [3]}, {"input": "10\n[5, 2, 3]", "output": [4]}, {"input": "11\n[5, 7]", "output": [0]}, {"input": "98\n[3, 14, 8]", "output": [19]}, {"input": "199\n[3, 5, 9, 15]", "output": [760]}, {"input": "300\n[5, 10, 20, 50, 100, 200, 500]", "output": [1022]}, {"input": "301\n[5, 10, 20, 50, 100, 200, 500]", "output": [0]}, {"input": "419\n[2, 5, 10, 20, 50]", "output": [18515]}], "starter_code": "\ndef count_change(money, coins):\n\t", "source_codes": ["import sys\nimport ast\nimport re\n\ndef count_change(amount: int, coins):\n    \"\"\"\n    Return the number of unordered ways to make `amount` using an unlimited\n    supply of the denominations given in `coins`.\n    \"\"\"\n    # Ensure denominations are unique and processed in increasing order\n    coins = sorted(set(coins))\n    # dp[i] = number of ways to make amount i\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for c in coins:\n        for x in range(c, amount + 1):\n            dp[x] += dp[x - c]\n    return dp[amount]\n\ndef _parse_coins_line(line: str):\n    \"\"\"\n    Try to interpret the line as a Python literal (e.g. [1,2]),\n    otherwise extract all integers it contains.\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return []\n    try:\n        return ast.literal_eval(line)\n    except Exception:\n        # Fallback: extract any integers (including negative) from the line\n        return [int(tok) for tok in re.findall(r'-?\\d+', line)]\n\ndef main():\n    # Read the whole input, split into non\u2011empty lines\n    data = sys.stdin.read().splitlines()\n    data = [ln for ln in data if ln.strip()]\n    if not data:\n        return\n\n    # The first non\u2011empty line must contain the amount\n    amount = int(data[0].strip())\n\n    # The remaining lines (if any) contain the coin list.\n    # We join them in case the list spans multiple lines.\n    if len(data) > 1:\n        coin_line = ' '.join(data[1:])\n    else:\n        # If there is only one line, the coin list may follow the amount on the same line.\n        tokens = data[0].split()\n        coin_line = ' '.join(tokens[1:]) if len(tokens) > 1 else ''\n\n    coins = _parse_coins_line(coin_line)\n\n    result = count_change(amount, coins)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport ast\nimport re\n\ndef count_change(amount: int, coins):\n    \"\"\"\n    Return the number of unordered ways to make `amount` using an unlimited\n    supply of the denominations given in `coins`.\n    \"\"\"\n    # Ensure denominations are unique and processed in increasing order\n    coins = sorted(set(coins))\n    # dp[i] = number of ways to make amount i\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for c in coins:\n        for x in range(c, amount + 1):\n            dp[x] += dp[x - c]\n    return dp[amount]\n\ndef _parse_coins_line(line: str):\n    \"\"\"\n    Try to interpret the line as a Python literal (e.g. [1,2]),\n    otherwise extract all integers it contains.\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return []\n    try:\n        return ast.literal_eval(line)\n    except Exception:\n        # Fallback: extract any integers (including negative) from the line\n        return [int(tok) for tok in re.findall(r'-?\\d+', line)]\n\ndef main():\n    # Read the whole input, split into non\u2011empty lines\n    data = sys.stdin.read().splitlines()\n    data = [ln for ln in data if ln.strip()]\n    if not data:\n        return\n\n    # The first non\u2011empty line must contain the amount\n    amount = int(data[0].strip())\n\n    # The remaining lines (if any) contain the coin list.\n    # We join them in case the list spans multiple lines.\n    if len(data) > 1:\n        coin_line = ' '.join(data[1:])\n    else:\n        # If there is only one line, the coin list may follow the amount on the same line.\n        tokens = data[0].split()\n        coin_line = ' '.join(tokens[1:]) if len(tokens) > 1 else ''\n\n    coins = _parse_coins_line(coin_line)\n\n    result = count_change(amount, coins)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1621}
{"name": "1665", "description": "Complete the function/method (depending on the language) to return `true`/`True` when its argument is an array that has the same nesting structures and same corresponding length of nested arrays as the first array.\n\nFor example:\n\n```python\n# should return True\nsame_structure_as([ 1, 1, 1 ], [ 2, 2, 2 ] )\nsame_structure_as([ 1, [ 1, 1 ] ], [ 2, [ 2, 2 ] ] )\n\n# should return False \nsame_structure_as([ 1, [ 1, 1 ] ], [ [ 2, 2 ], 2 ] )\nsame_structure_as([ 1, [ 1, 1 ] ], [ [ 2 ], 2 ] )\n\n# should return True\nsame_structure_as([ [ [ ], [ ] ] ], [ [ [ ], [ ] ] ] )\n\n# should return False\nsame_structure_as([ [ [ ], [ ] ] ], [ [ 1, 1 ] ] )\n```\n\n~~~if:javascript\nFor your convenience, there is already a function 'isArray(o)' declared and defined that returns true if its argument is an array, false otherwise.\n~~~\n\n~~~if:php\nYou may assume that all arrays passed in will be non-associative.\n~~~", "difficulty": "interview", "id": 1665, "sample_io": [{"input": "[1, 1, 1]\n[2, 2, 2]", "output": [true]}, {"input": "[1, [1, 1]]\n[2, [2, 2]]", "output": [true]}, {"input": "[1, [1, 1]]\n[[2, 2], 2]", "output": [false]}, {"input": "[1, [1, 1]]\n[[2], 2]", "output": [false]}, {"input": "[[[], []]]\n[[[], []]]", "output": [true]}, {"input": "[[[], []]]\n[[1, 1]]", "output": [false]}], "test_list": [{"input": "[1, [1, 1]]\n[[2, 2], 2]", "output": [false]}, {"input": "[1, [1, 1]]\n[2, [2]]", "output": [false]}, {"input": "[[[], []]]\n[[[], []]]", "output": [true]}, {"input": "[[[], []]]\n[[1, 1]]", "output": [false]}, {"input": "[1, [[[1]]]]\n[2, [[[2]]]]", "output": [true]}, {"input": "[]\n1", "output": [false]}, {"input": "[]\n{}", "output": [false]}, {"input": "[1, '[', ']']\n['[', ']', 1]", "output": [true]}], "starter_code": "\ndef same_structure_as(a, b):\n\t", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1665}
{"name": "1629", "description": "# Task\n Sorting is one of the most basic computational devices used in Computer Science. \n \n Given a sequence (length \u2264 1000) of 3 different key values (7, 8, 9), your task is to find the minimum number of exchange operations necessary to make the sequence sorted. \n\n One operation is the switching of 2 key values in the sequence.\n\n# Example\n\n For `sequence = [7, 7, 8, 8, 9, 9]`, the result should be `0`.\n \n It's already a sorted sequence.\n\n For `sequence = [9, 7, 8, 8, 9, 7]`, the result should be `1`.\n \n We can switching `sequence[0]` and `sequence[5]`.\n \n For `sequence = [8, 8, 7, 9, 9, 9, 8, 9, 7]`, the result should be `4`.\n \n We can:\n```\n [8, 8, 7, 9, 9, 9, 8, 9, 7] \n switching sequence[0] and sequence[3]\n --> [9, 8, 7, 8, 9, 9, 8, 9, 7]\n switching sequence[0] and sequence[8]\n --> [7, 8, 7, 8, 9, 9, 8, 9, 9]\n switching sequence[1] and sequence[2]\n --> [7, 7, 8, 8, 9, 9, 8, 9, 9]\n switching sequence[5] and sequence[7]\n --> [7, 7, 8, 8, 8, 9, 9, 9, 9] \n```\nSo `4` is the minimum number of operations for the sequence to become sorted.\n\n# Input/Output\n\n\n - `[input]` integer array `sequence`\n\n  The Sequence.\n\n\n - `[output]` an integer\n\n  the minimum number of operations.", "difficulty": "interview", "id": 1629, "sample_io": [{"input": "[7, 7, 8, 8, 9, 9]", "output": [0]}, {"input": "[9, 7, 8, 8, 9, 7]", "output": [1]}, {"input": "[8, 8, 7, 9, 9, 9, 8, 9, 7]", "output": [4]}], "test_list": [{"input": "[7, 7, 8, 8, 9, 9]", "output": [0]}, {"input": "[9, 7, 8, 8, 9, 7]", "output": [1]}, {"input": "[8, 8, 7, 9, 9, 9, 8, 9, 7]", "output": [4]}, {"input": "[9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7]", "output": [6]}, {"input": "[9, 9, 9, 7, 7, 8, 9, 7, 8, 9, 7, 9]", "output": [4]}, {"input": "[9, 9, 7, 7, 8, 8]", "output": [4]}, {"input": "[9, 7, 9]", "output": [1]}, {"input": "[8, 7, 8]", "output": [1]}, {"input": "[7, 8, 7, 8]", "output": [1]}, {"input": "[8, 8, 7, 8]", "output": [1]}, {"input": "[8, 8, 7, 7, 8]", "output": [2]}], "starter_code": "\ndef exchange_sort(sequence):\n\t", "source_codes": ["import sys\nimport ast\nimport re\nfrom typing import List\n\ndef min_exchange_operations(seq: List[int]) -> int:\n    \"\"\"Return the minimal number of swaps needed to sort a 7/8/9 sequence.\"\"\"\n    # map values to type indices 0,1,2\n    value_to_type = {7: 0, 8: 1, 9: 2}\n\n    # total amount of each value\n    cnt = [0, 0, 0]\n    for v in seq:\n        cnt[value_to_type[v]] += 1\n\n    # M[t][z] = how many elements of type t are placed in zone z\n    M = [[0, 0, 0] for _ in range(3)]\n\n    for idx, v in enumerate(seq):\n        t = value_to_type[v]\n        if idx < cnt[0]:\n            z = 0                     # zone for 7s\n        elif idx < cnt[0] + cnt[1]:\n            z = 1                     # zone for 8s\n        else:\n            z = 2                     # zone for 9s\n        M[t][z] += 1\n\n    # ---- direct swaps (2\u2011cycles) ---------------------------------\n    direct = 0\n    for i in range(3):\n        for j in range(i + 1, 3):\n            d = min(M[i][j], M[j][i])\n            direct += d\n            M[i][j] -= d\n            M[j][i] -= d\n\n    # ---- remaining misplacements are 3\u2011cycles --------------------\n    rem = sum(M[i][j] for i in range(3) for j in range(3) if i != j)\n    cycles_swaps = 2 * (rem // 3)\n\n    return direct + cycles_swaps\n\n\ndef main():\n    # read whole input (may contain line breaks)\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # try to parse as a Python literal list, otherwise extract integers\n    try:\n        seq = ast.literal_eval(data)\n        if isinstance(seq, tuple):\n            seq = list(seq)\n    except Exception:\n        seq = list(map(int, re.findall(r'-?\\d+', data)))\n\n    ans = min_exchange_operations(seq)\n    # required output format: a single integer\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport ast\nimport re\nfrom typing import List\n\ndef min_exchange_operations(seq: List[int]) -> int:\n    \"\"\"Return the minimal number of swaps needed to sort a 7/8/9 sequence.\"\"\"\n    # map values to type indices 0,1,2\n    value_to_type = {7: 0, 8: 1, 9: 2}\n\n    # total amount of each value\n    cnt = [0, 0, 0]\n    for v in seq:\n        cnt[value_to_type[v]] += 1\n\n    # M[t][z] = how many elements of type t are placed in zone z\n    M = [[0, 0, 0] for _ in range(3)]\n\n    for idx, v in enumerate(seq):\n        t = value_to_type[v]\n        if idx < cnt[0]:\n            z = 0                     # zone for 7s\n        elif idx < cnt[0] + cnt[1]:\n            z = 1                     # zone for 8s\n        else:\n            z = 2                     # zone for 9s\n        M[t][z] += 1\n\n    # ---- direct swaps (2\u2011cycles) ---------------------------------\n    direct = 0\n    for i in range(3):\n        for j in range(i + 1, 3):\n            d = min(M[i][j], M[j][i])\n            direct += d\n            M[i][j] -= d\n            M[j][i] -= d\n\n    # ---- remaining misplacements are 3\u2011cycles --------------------\n    rem = sum(M[i][j] for i in range(3) for j in range(3) if i != j)\n    cycles_swaps = 2 * (rem // 3)\n\n    return direct + cycles_swaps\n\n\ndef main():\n    # read whole input (may contain line breaks)\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # try to parse as a Python literal list, otherwise extract integers\n    try:\n        seq = ast.literal_eval(data)\n        if isinstance(seq, tuple):\n            seq = list(seq)\n    except Exception:\n        seq = list(map(int, re.findall(r'-?\\d+', data)))\n\n    ans = min_exchange_operations(seq)\n    # required output format: a single integer\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1629}
{"name": "1630", "description": "Story:\nIn the realm of numbers, the apocalypse has arrived. Hordes of zombie numbers have infiltrated and are ready to turn everything into undead. The properties of zombies are truly apocalyptic: they reproduce themselves unlimitedly and freely interact with each other. Anyone who equals them is doomed. Out of an infinite number of natural numbers, only a few remain. This world needs a hero who leads remaining numbers in hope for survival: The highest number to lead those who still remain.\n\nBriefing:\nThere is a list of positive natural numbers. Find the largest number that cannot be represented as the sum of this numbers, given that each number can be added unlimited times. Return this number, either 0 if there are no such numbers, or -1 if there are an infinite number of them.\n\nExample:\n```\nLet's say [3,4] are given numbers. Lets check each number one by one:\n1 - (no solution) - good\n2 - (no solution) - good\n3 = 3 won't go\n4 = 4 won't go\n5 - (no solution) - good\n6 = 3+3 won't go\n7 = 3+4 won't go\n8 = 4+4 won't go\n9 = 3+3+3 won't go\n10 = 3+3+4 won't go\n11 = 3+4+4 won't go\n13 = 3+3+3+4 won't go\n```\n...and so on. So 5 is the biggest 'good'. return 5\n\nTest specs:\nRandom cases will input up to 10 numbers with up to 1000 value\n\nSpecial thanks:\nThanks to Voile-sama, mathsisfun-sama, and Avanta-sama for heavy assistance. And to everyone who tried and beaten the kata ^_^", "difficulty": "interview", "id": 1630, "sample_io": [{"input": "[3,4]", "output": [5]}], "test_list": [{"input": "[7, 11]", "output": [59]}, {"input": "[1, 7, 15]", "output": [0]}, {"input": "[2, 10]", "output": [-1]}, {"input": "[687, 829, 998]", "output": [45664]}, {"input": "[]", "output": [-1]}, {"input": "[1]", "output": [0]}], "starter_code": "\ndef survivor(zombies):\n\t", "source_codes": ["import sys\nimport ast\nimport re\nimport math\nimport heapq\nfrom typing import List\n\n\ndef largest_unrepresentable(A: List[int]) -> int:\n    \"\"\"\n    Return the Frobenius number for the coin set A.\n    -1  : infinitely many numbers cannot be represented\n     0  : every natural number can be represented\n    otherwise the largest unrepresentable integer\n    \"\"\"\n    if not A:\n        return 0\n\n    # gcd of all numbers \u2013 if >1 there are infinitely many gaps\n    g = A[0]\n    for x in A[1:]:\n        g = math.gcd(g, x)\n    if g != 1:\n        return -1\n\n    m = min(A)                     # smallest coin\n    if m == 1:                     # then every number is reachable\n        return 0\n\n    INF = 10 ** 18\n    dist = [INF] * m               # dist[r] \u2013 minimal sum that gives remainder r\n    dist[0] = 0\n    pq = [(0, 0)]                  # (distance, remainder)\n\n    while pq:\n        d, r = heapq.heappop(pq)\n        if d != dist[r]:\n            continue                # stale entry\n        for c in A:\n            nr = (r + c) % m\n            nd = d + c\n            if nd < dist[nr]:\n                dist[nr] = nd\n                heapq.heappush(pq, (nd, nr))\n\n    # the largest minimal sum for any remainder, then subtract the extra m\n    return max(dist) - m\n\n\ndef solve() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Try to parse a literal Python list/tuple, otherwise fall back to regex\n    try:\n        numbers = ast.literal_eval(raw)\n        if isinstance(numbers, (list, tuple)):\n            A = [int(x) for x in numbers if isinstance(x, int) and x > 0]\n        else:\n            raise ValueError\n    except Exception:\n        nums = re.findall(r'\\d+', raw)\n        A = [int(x) for x in nums if int(x) > 0]\n\n    # Duplicate values are irrelevant\n    A = sorted(set(A))\n\n    ans = largest_unrepresentable(A)\n\n    # Output the integer, not a list\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport ast\nimport re\nimport math\nimport heapq\nfrom typing import List\n\n\ndef largest_unrepresentable(A: List[int]) -> int:\n    \"\"\"\n    Return the Frobenius number for the coin set A.\n    -1  : infinitely many numbers cannot be represented\n     0  : every natural number can be represented\n    otherwise the largest unrepresentable integer\n    \"\"\"\n    if not A:\n        return 0\n\n    # gcd of all numbers \u2013 if >1 there are infinitely many gaps\n    g = A[0]\n    for x in A[1:]:\n        g = math.gcd(g, x)\n    if g != 1:\n        return -1\n\n    m = min(A)                     # smallest coin\n    if m == 1:                     # then every number is reachable\n        return 0\n\n    INF = 10 ** 18\n    dist = [INF] * m               # dist[r] \u2013 minimal sum that gives remainder r\n    dist[0] = 0\n    pq = [(0, 0)]                  # (distance, remainder)\n\n    while pq:\n        d, r = heapq.heappop(pq)\n        if d != dist[r]:\n            continue                # stale entry\n        for c in A:\n            nr = (r + c) % m\n            nd = d + c\n            if nd < dist[nr]:\n                dist[nr] = nd\n                heapq.heappush(pq, (nd, nr))\n\n    # the largest minimal sum for any remainder, then subtract the extra m\n    return max(dist) - m\n\n\ndef solve() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Try to parse a literal Python list/tuple, otherwise fall back to regex\n    try:\n        numbers = ast.literal_eval(raw)\n        if isinstance(numbers, (list, tuple)):\n            A = [int(x) for x in numbers if isinstance(x, int) and x > 0]\n        else:\n            raise ValueError\n    except Exception:\n        nums = re.findall(r'\\d+', raw)\n        A = [int(x) for x in nums if int(x) > 0]\n\n    # Duplicate values are irrelevant\n    A = sorted(set(A))\n\n    ans = largest_unrepresentable(A)\n\n    # Output the integer, not a list\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1630}
{"name": "1647", "description": "Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:\n\n```\n12 ==> 21\n513 ==> 531\n2017 ==> 2071\n```\n\nIf the digits can't be rearranged to form a bigger number, return `-1` (or `nil` in Swift):\n\n```\n9 ==> -1\n111 ==> -1\n531 ==> -1\n```", "difficulty": "interview", "id": 1647, "sample_io": [{"input": "12", "output": [21]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [2071]}, {"input": "9", "output": [-1]}, {"input": "111", "output": [-1]}, {"input": "531", "output": [-1]}], "test_list": [{"input": "12", "output": [21]}, {"input": "513", "output": [531]}, {"input": "2017", "output": [2071]}, {"input": "414", "output": [441]}, {"input": "144", "output": [414]}, {"input": "123456789", "output": [123456798]}, {"input": "1234567890", "output": [1234567908]}, {"input": "9876543210", "output": [-1]}, {"input": "9999999999", "output": [-1]}, {"input": "59884848459853", "output": [59884848483559]}], "starter_code": "\ndef next_bigger(n):\n\t", "source_codes": ["def next_bigger(num: int) -> int:\n    \"\"\"\n    Return the next larger integer that can be formed by rearranging the\n    digits of `num`. If such a number does not exist, return -1.\n    \"\"\"\n    # Work with the digit characters for easy swapping / reversing.\n    digits = list(str(num))\n    n = len(digits)\n\n    # 1) Find the rightmost index i with digits[i] < digits[i + 1].\n    i = n - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n\n    # No such i \u2192 digits are in descending order \u2192 answer does not exist.\n    if i < 0:\n        return -1\n\n    # 2) Find the rightmost digit to the right of i that is larger than digits[i].\n    j = n - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # 3) Swap them.\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4) Reverse the suffix after position i to obtain the smallest ordering.\n    digits[i + 1:] = list(reversed(digits[i + 1:]))\n\n    # 5) Convert back to integer.\n    return int(''.join(digits))\n\n\nif __name__ == \"__main__\":\n    # Read the input, convert to integer, compute the answer and print it.\n    num = int(input())\n    result = next_bigger(num)\n    # The test harness expects the output in list format.\n    print([result])"], "responses": ["\ndef next_bigger(num: int) -> int:\n    \"\"\"\n    Return the next larger integer that can be formed by rearranging the\n    digits of `num`. If such a number does not exist, return -1.\n    \"\"\"\n    # Work with the digit characters for easy swapping / reversing.\n    digits = list(str(num))\n    n = len(digits)\n\n    # 1) Find the rightmost index i with digits[i] < digits[i + 1].\n    i = n - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n\n    # No such i \u2192 digits are in descending order \u2192 answer does not exist.\n    if i < 0:\n        return -1\n\n    # 2) Find the rightmost digit to the right of i that is larger than digits[i].\n    j = n - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # 3) Swap them.\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # 4) Reverse the suffix after position i to obtain the smallest ordering.\n    digits[i + 1:] = list(reversed(digits[i + 1:]))\n\n    # 5) Convert back to integer.\n    return int(''.join(digits))\n\n\nif __name__ == \"__main__\":\n    # Read the input, convert to integer, compute the answer and print it.\n    num = int(input())\n    result = next_bigger(num)\n    # The test harness expects the output in list format.\n    print([result])\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1647}
{"name": "1663", "description": "In this Kata we focus on finding a sum S(n) which is the total number of divisors taken for all natural numbers less or equal to n. More formally, we investigate the sum of n components denoted by d(1) + d(2) + ... + d(n) in which for any i starting from 1 up to n the value of d(i) tells us how many distinct numbers divide i without a remainder. \n\nYour solution should work for possibly large values of n without a timeout.\nAssume n to be greater than zero and not greater than 999 999 999 999 999.\nBrute force approaches will not be feasible options in such cases. It is fairly simple to conclude that for every n>1 there holds a recurrence S(n) = S(n-1) + d(n) with initial case S(1) = 1.\n\nFor example:\nS(1) = 1\nS(2) = 3\nS(3) = 5\nS(4) = 8\nS(5) = 10\n\nBut is the fact useful anyway? If you find it is rather not, maybe this will help: \n\nTry to convince yourself that for any natural k, the number S(k) is the same as the number of pairs (m,n) that solve the inequality mn <= k in natural numbers.\nOnce it becomes clear, we can think of a partition of all the solutions into classes just by saying that a pair (m,n) belongs to the class indexed by n.\nThe question now arises if it is possible to count solutions of n-th class. If f(n) stands for the number of solutions that belong to n-th class, it means that S(k) = f(1) + f(2) + f(3) + ...\n\nThe reasoning presented above leads us to some kind of a formula for S(k), however not necessarily the most efficient one. Can you imagine that all the solutions to inequality mn <= k can be split using sqrt(k) as pivotal item?", "difficulty": "interview", "id": 1663, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [3]}, {"input": "3", "output": [5]}, {"input": "4", "output": [8]}, {"input": "5", "output": [10]}], "test_list": [{"input": "5", "output": [10]}, {"input": "10", "output": [27]}, {"input": "20", "output": [66]}, {"input": "59", "output": [249]}, {"input": "105", "output": [510]}, {"input": "785", "output": [5364]}, {"input": "1001", "output": [7077]}, {"input": "8009", "output": [73241]}, {"input": "9999999999999", "output": [300880375389561]}, {"input": "9999999999998", "output": [300880375389537]}, {"input": "9999999999995", "output": [300880375389493]}, {"input": "9999999949950", "output": [300880373832097]}], "starter_code": "\ndef count_divisors(n):\n\t", "source_codes": ["import sys\n\ndef sum_of_divisors(n: int) -> int:\n    \"\"\"\n    Returns S(n) = sum_{i=1}^{n} d(i), where d(i) is the number of\n    distinct divisors of i.  Uses the identity\n        S(n) = sum_{k=1}^{n} n // k\n    and evaluates it in O(sqrt(n)) by grouping equal quotients.\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        q = n // k                 # current quotient\n        nxt = n // q               # last index with this quotient\n        total += q * (nxt - k + 1)\n        k = nxt + 1\n    return total\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    print(sum_of_divisors(n))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef sum_of_divisors(n: int) -> int:\n    \"\"\"\n    Returns S(n) = sum_{i=1}^{n} d(i), where d(i) is the number of\n    distinct divisors of i.  Uses the identity\n        S(n) = sum_{k=1}^{n} n // k\n    and evaluates it in O(sqrt(n)) by grouping equal quotients.\n    \"\"\"\n    total = 0\n    k = 1\n    while k <= n:\n        q = n // k                 # current quotient\n        nxt = n // q               # last index with this quotient\n        total += q * (nxt - k + 1)\n        k = nxt + 1\n    return total\n\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    print(sum_of_divisors(n))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1663}
{"name": "1659", "description": "# How many ways can you make the sum of a number?\n\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)#\n\n>In number theory and combinatorics, a partition of a positive integer *n*, also called an *integer partition*, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. If order matters, the sum becomes a composition. For example, 4 can be partitioned in five distinct ways:\n```\n4\n3 + 1\n2 + 2\n2 + 1 + 1\n1 + 1 + 1 + 1\n```\n\n## Examples\n\n### Basic\n\n```python\nexp_sum(1) # 1\nexp_sum(2) # 2  -> 1+1 , 2\nexp_sum(3) # 3 -> 1+1+1, 1+2, 3\nexp_sum(4) # 5 -> 1+1+1+1, 1+1+2, 1+3, 2+2, 4\nexp_sum(5) # 7 -> 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 5, 2+3\n\nexp_sum(10) # 42\n```\n\n### Explosive\n\n```python\nexp_sum(50) # 204226\nexp_sum(80) # 15796476\nexp_sum(100) # 190569292\n```\n\nSee [here](http://www.numericana.com/data/partition.htm) for more examples.", "difficulty": "interview", "id": 1659, "sample_io": [{"input": "1", "output": [1]}, {"input": "2", "output": [2]}, {"input": "3", "output": [3]}, {"input": "4", "output": [5]}, {"input": "5", "output": [7]}, {"input": "10", "output": [42]}, {"input": "50", "output": [204226]}, {"input": "80", "output": [15796476]}, {"input": "100", "output": [190569292]}], "test_list": [{"input": "1", "output": [1]}, {"input": "2", "output": [2]}, {"input": "3", "output": [3]}, {"input": "4", "output": [5]}, {"input": "5", "output": [7]}, {"input": "20", "output": [627]}, {"input": "30", "output": [5604]}, {"input": "40", "output": [37338]}, {"input": "43", "output": [63261]}, {"input": "60", "output": [966467]}, {"input": "70", "output": [4087968]}, {"input": "90", "output": [56634173]}, {"input": "200", "output": [3972999029388]}, {"input": "275", "output": [1520980492851175]}], "starter_code": "\ndef exp_sum(n):\n\t", "source_codes": ["import sys\n\ndef partitions_up_to(max_n: int):\n    \"\"\"\n    Compute all partition numbers p(0)\u2026p(max_n) using Euler's recurrence.\n    Returns a list p where p[i] == p(i).\n    \"\"\"\n    # p[i] will hold the partition number of i\n    p = [0] * (max_n + 1)\n    p[0] = 1  # one partition of 0 (the empty sum)\n\n    for i in range(1, max_n + 1):\n        total = 0\n        k = 1\n        while True:\n            pent1 = k * (3 * k - 1) // 2          # g(k)\n            if pent1 > i:\n                break\n            sign = 1 if (k & 1) else -1           # (-1)^{k+1}\n            total += sign * p[i - pent1]\n\n            pent2 = k * (3 * k + 1) // 2          # g(-k)\n            if pent2 <= i:\n                total += sign * p[i - pent2]\n\n            k += 1\n        p[i] = total\n    return p\n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    nums = list(map(int, data))\n\n    # Detect the optional leading test\u2011case count.\n    if len(nums) > 1 and nums[0] == len(nums) - 1:\n        queries = nums[1:]\n    else:\n        queries = nums\n\n    max_n = max(queries) if queries else 0\n    part = partitions_up_to(max_n)\n\n    # Output each answer on its own line.\n    out_lines = (str(part[x]) for x in queries)\n    sys.stdout.write(\"\\n\".join(out_lines))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef partitions_up_to(max_n: int):\n    \"\"\"\n    Compute all partition numbers p(0)\u2026p(max_n) using Euler's recurrence.\n    Returns a list p where p[i] == p(i).\n    \"\"\"\n    # p[i] will hold the partition number of i\n    p = [0] * (max_n + 1)\n    p[0] = 1  # one partition of 0 (the empty sum)\n\n    for i in range(1, max_n + 1):\n        total = 0\n        k = 1\n        while True:\n            pent1 = k * (3 * k - 1) // 2          # g(k)\n            if pent1 > i:\n                break\n            sign = 1 if (k & 1) else -1           # (-1)^{k+1}\n            total += sign * p[i - pent1]\n\n            pent2 = k * (3 * k + 1) // 2          # g(-k)\n            if pent2 <= i:\n                total += sign * p[i - pent2]\n\n            k += 1\n        p[i] = total\n    return p\n\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    nums = list(map(int, data))\n\n    # Detect the optional leading test\u2011case count.\n    if len(nums) > 1 and nums[0] == len(nums) - 1:\n        queries = nums[1:]\n    else:\n        queries = nums\n\n    max_n = max(queries) if queries else 0\n    part = partitions_up_to(max_n)\n\n    # Output each answer on its own line.\n    out_lines = (str(part[x]) for x in queries)\n    sys.stdout.write(\"\\n\".join(out_lines))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1659}
{"name": "1618", "description": "Create a function that differentiates a polynomial for a given value of `x`.\n\nYour function will receive 2 arguments: a polynomial as a string, and a point to evaluate the equation as an integer.\n\n## Assumptions:\n\n* There will be a coefficient near each `x`, unless the coefficient equals `1` or `-1`.\n* There will be an exponent near each `x`, unless the exponent equals `0` or `1`.\n* All exponents will be greater or equal to zero\n\n## Examples:\n\n```python\ndifferenatiate(\"12x+2\", 3)      ==>   returns 12\ndifferenatiate(\"x^2+3x+2\", 3)   ==>   returns 9\n```", "difficulty": "interview", "id": 1618, "sample_io": [{"input": "12x+2\n3", "output": [12]}, {"input": "x^2+3x+2\n3", "output": [9]}], "test_list": [{"input": "12x+2\n3", "output": [12]}, {"input": "x-66\n3", "output": [1]}, {"input": "x^2-x\n3", "output": [5]}, {"input": "-5x^2+10x+4\n3", "output": [-20]}, {"input": "x^2+3x+3\n3", "output": [9]}, {"input": "1000x^2+300x+200\n531", "output": [1062300]}, {"input": "21x^2+35x+3\n2071", "output": [87017]}, {"input": "66x^3+3x^2+3\n441", "output": [38509884]}, {"input": "21x^4+3x^3\n414", "output": [5962009860]}, {"input": "-21x^5+3x^3\n12398", "output": [-2480823269890144044]}, {"input": "-x^2+3x-3\n1234567908", "output": [-2469135813]}, {"input": "-7x^5+22x^4-55x^3-94x^2+87x-56\n-3", "output": [-6045]}, {"input": "-123x^5+3x\n8559", "output": [-3300404885229567012]}, {"input": "x^2\n59884848483559", "output": [119769696967118]}], "starter_code": "\ndef differentiate(equation, point):\n\t", "source_codes": ["import sys\n\ndef differentiate(poly_str: str, x: int) -> int:\n    \"\"\"Return the derivative of `poly_str` evaluated at `x`.\"\"\"\n    # remove all spaces\n    poly = poly_str.replace(' ', '')\n    if not poly:\n        return 0\n\n    # ensure a leading sign for uniform parsing\n    if poly[0] not in '+-':\n        poly = '+' + poly\n\n    result = 0\n    i = 0\n    n = len(poly)\n\n    while i < n:\n        sign_char = poly[i]               # '+' or '-'\n        sign = 1 if sign_char == '+' else -1\n        i += 1\n\n        # locate the next sign to isolate the current term\n        j = i\n        while j < n and poly[j] not in '+-':\n            j += 1\n        term = poly[i:j]\n        i = j\n\n        if not term:          # should not happen, but be safe\n            continue\n\n        if 'x' in term:\n            idx = term.index('x')\n            coeff_str = term[:idx]          # characters before 'x'\n            coeff_mag = int(coeff_str) if coeff_str else 1\n            exp_str = term[idx + 1:]        # characters after 'x'\n\n            if exp_str == '':\n                exp = 1\n            else:\n                # the exponent part must start with '^'\n                exp = int(exp_str[1:]) if exp_str[0] == '^' else 1\n\n            coeff = sign * coeff_mag\n\n            if exp == 0:                     # constant term \u2192 derivative 0\n                continue\n\n            # contribution of this term to the derivative\n            result += coeff * exp * (x ** (exp - 1))\n\n        # else: constant term, its derivative is zero \u2192 ignore\n\n    return result\n\n\ndef main() -> None:\n    poly_line = sys.stdin.readline().strip()\n    x_val = int(sys.stdin.readline().strip())\n    print(differentiate(poly_line, x_val))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef differentiate(poly_str: str, x: int) -> int:\n    \"\"\"Return the derivative of `poly_str` evaluated at `x`.\"\"\"\n    # remove all spaces\n    poly = poly_str.replace(' ', '')\n    if not poly:\n        return 0\n\n    # ensure a leading sign for uniform parsing\n    if poly[0] not in '+-':\n        poly = '+' + poly\n\n    result = 0\n    i = 0\n    n = len(poly)\n\n    while i < n:\n        sign_char = poly[i]               # '+' or '-'\n        sign = 1 if sign_char == '+' else -1\n        i += 1\n\n        # locate the next sign to isolate the current term\n        j = i\n        while j < n and poly[j] not in '+-':\n            j += 1\n        term = poly[i:j]\n        i = j\n\n        if not term:          # should not happen, but be safe\n            continue\n\n        if 'x' in term:\n            idx = term.index('x')\n            coeff_str = term[:idx]          # characters before 'x'\n            coeff_mag = int(coeff_str) if coeff_str else 1\n            exp_str = term[idx + 1:]        # characters after 'x'\n\n            if exp_str == '':\n                exp = 1\n            else:\n                # the exponent part must start with '^'\n                exp = int(exp_str[1:]) if exp_str[0] == '^' else 1\n\n            coeff = sign * coeff_mag\n\n            if exp == 0:                     # constant term \u2192 derivative 0\n                continue\n\n            # contribution of this term to the derivative\n            result += coeff * exp * (x ** (exp - 1))\n\n        # else: constant term, its derivative is zero \u2192 ignore\n\n    return result\n\n\ndef main() -> None:\n    poly_line = sys.stdin.readline().strip()\n    x_val = int(sys.stdin.readline().strip())\n    print(differentiate(poly_line, x_val))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 1618}
{"name": "1638", "description": "# Longest Palindromic Substring (Linear)\n\nA palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g.,\n'madam' or 'racecar'. Even the letter 'x' is considered a palindrome. \n\nFor this Kata, you are given a string ```s```. Write a function that returns the longest _contiguous_ palindromic substring in ```s``` (it could be the entire string). In the event that there are multiple longest palindromic substrings, return the first to occur.\n\nI'm not trying to trick you here:\n- You can assume that all inputs are valid strings.\n- Only the letters a-z will be used, all lowercase (your solution should, in theory, extend to more than just the letters a-z though). \n\n**NOTE:** Quadratic asymptotic complexity _(O(N^2))_ or above will __NOT__ work here.\n\n-----\n\n## Examples\n\n### Basic Tests\n\n```\nInput: \"babad\"\nOutput: \"bab\"\n(Note: \"bab\" occurs before \"aba\")\n```\n```\nInput: \"abababa\"\nOutput: \"abababa\"\n```\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n### Edge Cases\n\n```\nInput: \"ab\"\nOutput: \"a\"\n```\n```\nInput: \"\"\nOutput: \"\"\n```\n-----\n\n## Testing\n\nAlong with the example tests given:\n\n - There are **500** tests using strings of length in range [1 - 1,000]\n - There are **50** tests using strings of length in range [1,000 - 10,000]\n - There are **5** tests using strings of length in range [10,000 - 100,000]\n \nAll test cases can be passed within 10 seconds, but non-linear solutions will time out every time. _Linear performance is essential_. \n\n## Good Luck!\n\n-----\n\nThis problem was inspired by [this](https://leetcode.com/problems/longest-palindromic-substring/) challenge on LeetCode. Except this is the performance version :^)", "difficulty": "interview", "id": 1638, "sample_io": [{"input": "babad", "output": ["bab"]}, {"input": "abababa", "output": ["abababa"]}, {"input": "cbbd", "output": ["bb"]}, {"input": "ab", "output": ["a"]}, {"input": "", "output": [""]}], "test_list": [{"input": "babad", "output": ["bab"]}, {"input": "madam", "output": ["madam"]}, {"input": "dde", "output": ["dd"]}, {"input": "ababbab", "output": ["babbab"]}, {"input": "abababa", "output": ["abababa"]}, {"input": "banana", "output": ["anana"]}, {"input": "abba", "output": ["abba"]}, {"input": "cbbd", "output": ["bb"]}, {"input": "zz", "output": ["zz"]}, {"input": "dddd", "output": ["dddd"]}, {"input": "", "output": [""]}, {"input": "abcdefghijklmnopqrstuvwxyz", "output": ["a"]}, {"input": "ttaaftffftfaafatf", "output": ["aaftffftfaa"]}, {"input": "bbaaacc", "output": ["aaa"]}, {"input": "m", "output": ["m"]}], "starter_code": "\ndef longest_palindrome(s):\n\t", "source_codes": ["longest_palindrome(s):\n    if s is empty: return \"\"\n\n    # 1. Build transformed string\n    #   \"^#a#b#c#$\"  (^ and $ are sentinels)\n    t = \"^#\" + \"#\".join(s) + \"#$\"\n    n = len(t)\n\n    # 2. Manacher \u2013 compute radii\n    p = [0] * n                 # p[i] = palindrome length (original string)\n    centre = 0                  # centre of the current rightmost palindrome\n    right  = 0                  # right border (exclusive)\n\n    for i = 1 \u2026 n-2:\n        mir = 2*centre - i       # mirror of i around centre\n        if i < right:\n            p[i] = min(right - i, p[mir])\n\n        # try to expand palindrome centred at i\n        while t[i + p[i] + 1] == t[i - p[i] - 1]:\n            p[i] += 1\n\n        # if we expanded past the right border, update centre / right\n        if i + p[i] > right:\n            centre = i\n            right  = i + p[i]\n\n    # 3. Find the longest palindrome, tie\u2011break by first occurrence\n    max_len = 0\n    best_center = 0\n    for i = 1 \u2026 n-2:\n        if p[i] > max_len:\n            max_len = p[i]\n            best_center = i\n\n    # 4. Convert centre / length back to original indices\n    start = (best_center - max_len) // 2\n    return s[start : start + max_len]"], "responses": ["\nlongest_palindrome(s):\n    if s is empty: return \"\"\n\n    # 1. Build transformed string\n    #   \"^#a#b#c#$\"  (^ and $ are sentinels)\n    t = \"^#\" + \"#\".join(s) + \"#$\"\n    n = len(t)\n\n    # 2. Manacher \u2013 compute radii\n    p = [0] * n                 # p[i] = palindrome length (original string)\n    centre = 0                  # centre of the current rightmost palindrome\n    right  = 0                  # right border (exclusive)\n\n    for i = 1 \u2026 n-2:\n        mir = 2*centre - i       # mirror of i around centre\n        if i < right:\n            p[i] = min(right - i, p[mir])\n\n        # try to expand palindrome centred at i\n        while t[i + p[i] + 1] == t[i - p[i] - 1]:\n            p[i] += 1\n\n        # if we expanded past the right border, update centre / right\n        if i + p[i] > right:\n            centre = i\n            right  = i + p[i]\n\n    # 3. Find the longest palindrome, tie\u2011break by first occurrence\n    max_len = 0\n    best_center = 0\n    for i = 1 \u2026 n-2:\n        if p[i] > max_len:\n            max_len = p[i]\n            best_center = i\n\n    # 4. Convert centre / length back to original indices\n    start = (best_center - max_len) // 2\n    return s[start : start + max_len]\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 1638}
{"name": "2096", "description": "You are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n\n-----Input-----\n\nThe first line of input data contains integer n (1 \u2264 n \u2264 10^5)\u00a0\u2014 the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} \u2264 n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 \u2264 l_{j} \u2264 n)\u00a0\u2014 indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n\n\n-----Note-----\n\nIn the first sample output:\n\nAfter sorting the first subsequence we will get sequence 1\u00a02\u00a03\u00a06\u00a05\u00a04.\n\nSorting the second subsequence changes nothing.\n\nAfter sorting the third subsequence we will get sequence 1\u00a02\u00a03\u00a04\u00a05\u00a06.\n\nSorting the last subsequence changes nothing.", "difficulty": "competition", "id": 2096, "sample_io": [{"input": "6\n3 2 1 6 5 4\n", "output": ["4\n2 1 3\n1 2\n2 4 6\n1 5\n"]}, {"input": "6\n83 -75 -49 11 37 62\n", "output": ["1\n6 1 2 3 4 5 6\n"]}], "test_list": [{"input": "6\n3 2 1 6 5 4\n", "output": ["4\n2 1 3\n1 2\n2 4 6\n1 5\n"]}, {"input": "6\n83 -75 -49 11 37 62\n", "output": ["1\n6 1 2 3 4 5 6\n"]}, {"input": "1\n1\n", "output": ["1\n1 1\n"]}, {"input": "2\n1 2\n", "output": ["2\n1 1\n1 2\n"]}, {"input": "2\n2 1\n", "output": ["1\n2 1 2\n"]}, {"input": "3\n1 2 3\n", "output": ["3\n1 1\n1 2\n1 3\n"]}, {"input": "3\n3 2 1\n", "output": ["2\n2 1 3\n1 2\n"]}, {"input": "3\n3 1 2\n", "output": ["1\n3 1 2 3\n"]}, {"input": "10\n3 7 10 1 9 5 4 8 6 2\n", "output": ["3\n6 1 4 7 2 10 3\n3 5 6 9\n1 8\n"]}, {"input": "20\n363756450 -204491568 95834122 -840249197 -49687658 470958158 -445130206 189801569 802780784 -790013317 -192321079 586260100 -751917965 -354684803 418379342 -253230108 193944314 712662868 853829789 735867677\n", "output": ["3\n7 1 4 7 2 10 3 13\n11 5 14 15 6 16 12 17 18 20 19 9\n2 8 11\n"]}, {"input": "50\n39 7 45 25 31 26 50 11 19 37 8 16 22 33 14 6 12 46 49 48 29 27 41 15 34 24 3 13 20 47 9 36 5 43 40 21 2 38 35 42 23 28 1 32 10 17 30 18 44 4\n", "output": ["6\n20 1 43 34 25 4 50 7 2 37 10 45 3 27 22 13 28 42 40 35 39\n23 5 33 14 15 24 26 6 16 12 17 46 18 48 20 29 21 36 32 44 49 19 9 31\n2 8 11\n2 23 41\n2 30 47\n1 38\n"]}, {"input": "100\n39 77 67 25 81 26 50 11 73 95 86 16 90 33 14 79 12 100 68 64 60 27 41 15 34 24 3 61 83 47 57 65 99 43 40 21 94 72 82 85 23 71 76 32 10 17 30 18 44 59 35 89 6 63 7 69 62 70 4 29 92 87 31 48 36 28 45 97 93 98 56 38 58 80 8 1 74 91 53 55 54 51 96 5 42 52 9 22 78 88 75 13 66 2 37 20 49 19 84 46\n", "output": ["6\n41 1 76 43 34 25 4 59 50 7 55 80 74 77 2 94 37 95 10 45 67 3 27 22 88 90 13 92 61 28 66 93 69 56 71 42 85 40 35 51 82 39\n45 5 84 99 33 14 15 24 26 6 53 79 16 12 17 46 100 18 48 64 20 96 83 29 60 21 36 65 32 44 49 97 68 19 98 70 58 73 9 87 62 57 31 63 54 81\n8 8 75 91 78 89 52 86 11\n2 23 41\n2 30 47\n2 38 72\n"]}], "starter_code": "", "source_codes": ["import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = [0] * (n + 1)               # 1\u2011based\n    for i in range(1, n + 1):\n        a[i] = int(next(it))\n\n    # 1. build permutation: pos[i] = rank of a[i] in the sorted order (1\u2011based)\n    pairs = [(a[i], i) for i in range(1, n + 1)]\n    pairs.sort(key=lambda x: x[0])  # sort by value\n    pos = [0] * (n + 1)             # pos[i] = destination index\n    for rank, (_, idx) in enumerate(pairs, start=1):\n        pos[idx] = rank\n\n    # 2. find all cycles\n    visited = [False] * (n + 1)\n    cycles = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            cur = i\n            cur_cycle = []\n            while not visited[cur]:\n                visited[cur] = True\n                cur_cycle.append(cur)\n                cur = pos[cur]\n            cycles.append(cur_cycle)\n\n    # 3. output\n    out_lines = []\n    out_lines.append(str(len(cycles)))\n    for cyc in cycles:\n        cyc.sort()                     # any order is allowed, sorting improves readability\n        out_lines.append(str(len(cyc)) + ' ' + ' '.join(map(str, cyc)))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = [0] * (n + 1)               # 1\u2011based\n    for i in range(1, n + 1):\n        a[i] = int(next(it))\n\n    # 1. build permutation: pos[i] = rank of a[i] in the sorted order (1\u2011based)\n    pairs = [(a[i], i) for i in range(1, n + 1)]\n    pairs.sort(key=lambda x: x[0])  # sort by value\n    pos = [0] * (n + 1)             # pos[i] = destination index\n    for rank, (_, idx) in enumerate(pairs, start=1):\n        pos[idx] = rank\n\n    # 2. find all cycles\n    visited = [False] * (n + 1)\n    cycles = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            cur = i\n            cur_cycle = []\n            while not visited[cur]:\n                visited[cur] = True\n                cur_cycle.append(cur)\n                cur = pos[cur]\n            cycles.append(cur_cycle)\n\n    # 3. output\n    out_lines = []\n    out_lines.append(str(len(cycles)))\n    for cyc in cycles:\n        cyc.sort()                     # any order is allowed, sorting improves readability\n        out_lines.append(str(len(cyc)) + ' ' + ' '.join(map(str, cyc)))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 2096}
{"name": "2098", "description": "As you know, majority of students and teachers of Summer Informatics School live in Berland for the most part of the year. Since corruption there is quite widespread, the following story is not uncommon.\n\nElections are coming. You know the number of voters and the number of parties\u00a0\u2014 $n$ and $m$ respectively. For each voter you know the party he is going to vote for. However, he can easily change his vote given a certain amount of money. In particular, if you give $i$-th voter $c_i$ bytecoins you can ask him to vote for any other party you choose.\n\nThe United Party of Berland has decided to perform a statistical study\u00a0\u2014 you need to calculate the minimum number of bytecoins the Party needs to spend to ensure its victory. In order for a party to win the elections, it needs to receive strictly more votes than any other party.\n\n\n-----Input-----\n\nThe first line of input contains two integers $n$ and $m$ ($1 \\le n, m \\le 3000$)\u00a0\u2014 the number of voters and the number of parties respectively.\n\nEach of the following $n$ lines contains two integers $p_i$ and $c_i$ ($1 \\le p_i \\le m$, $1 \\le c_i \\le 10^9$)\u00a0\u2014 the index of this voter's preferred party and the number of bytecoins needed for him to reconsider his decision.\n\nThe United Party of Berland has the index $1$.\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the minimum number of bytecoins needed for The United Party of Berland to win the elections.\n\n\n-----Examples-----\nInput\n1 2\n1 100\n\nOutput\n0\n\nInput\n5 5\n2 100\n3 200\n4 300\n5 400\n5 900\n\nOutput\n500\n\nInput\n5 5\n2 100\n3 200\n4 300\n5 800\n5 900\n\nOutput\n600\n\n\n\n-----Note-----\n\nIn the first sample, The United Party wins the elections even without buying extra votes.\n\nIn the second sample, The United Party can buy the votes of the first and the fourth voter. This way The Party gets two votes, while parties $3$, $4$ and $5$ get one vote and party number $2$ gets no votes.\n\nIn the third sample, The United Party can buy the votes of the first three voters and win, getting three votes against two votes of the fifth party.", "difficulty": "competition", "id": 2098, "sample_io": [{"input": "1 2\n1 100\n", "output": ["0\n"]}, {"input": "5 5\n2 100\n3 200\n4 300\n5 400\n5 900\n", "output": ["500\n"]}, {"input": "5 5\n2 100\n3 200\n4 300\n5 800\n5 900\n", "output": ["600\n"]}], "test_list": [{"input": "1 2\n1 100\n", "output": ["0\n"]}, {"input": "5 5\n2 100\n3 200\n4 300\n5 400\n5 900\n", "output": ["500\n"]}, {"input": "5 5\n2 100\n3 200\n4 300\n5 800\n5 900\n", "output": ["600\n"]}, {"input": "5 5\n1 3\n1 6\n5 4\n3 7\n2 10\n", "output": ["0\n"]}, {"input": "5 5\n1 7\n3 3\n2 7\n2 4\n1 2\n", "output": ["3\n"]}, {"input": "5 5\n2 5\n2 4\n2 1\n3 6\n3 7\n", "output": ["10\n"]}, {"input": "1 3000\n918 548706881\n", "output": ["548706881\n"]}, {"input": "10 10\n7 29\n10 31\n9 40\n5 17\n5 30\n6 85\n2 53\n7 23\n4 57\n10 9\n", "output": ["49\n"]}, {"input": "10 10\n1 73\n2 8\n3 88\n1 5\n2 100\n1 29\n1 57\n3 37\n7 46\n3 21\n", "output": ["0\n"]}, {"input": "10 10\n5 81\n7 68\n7 48\n1 10\n5 37\n7 97\n8 54\n7 41\n7 56\n5 21\n", "output": ["110\n"]}, {"input": "1 3000\n2006 226621946\n", "output": ["226621946\n"]}, {"input": "10 2\n1 1\n1 1\n1 1\n1 1\n1 1\n2 1\n2 1\n2 1\n2 1\n2 1\n", "output": ["1\n"]}], "starter_code": "", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 2098}
{"name": "2189", "description": "T is playing a game with his friend, HL.\n\nThere are $n$ piles of stones, the $i$-th pile initially has $a_i$ stones. \n\nT and HL will take alternating turns, with T going first. In each turn, a player chooses a non-empty pile and then removes a single stone from it. However, one cannot choose a pile that has been chosen in the previous turn (the pile that was chosen by the other player, or if the current turn is the first turn then the player can choose any non-empty pile). The player who cannot choose a pile in his turn loses, and the game ends.\n\nAssuming both players play optimally, given the starting configuration of $t$ games, determine the winner of each game.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer $t$ $(1 \\le t \\le 100)$ \u2014 the number of games. The description of the games follows. Each description contains two lines:\n\nThe first line contains a single integer $n$ $(1 \\le n \\le 100)$ \u2014 the number of piles.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ $(1 \\le a_i \\le 100)$.\n\n\n-----Output-----\n\nFor each game, print on a single line the name of the winner, \"T\" or \"HL\" (without quotes)\n\n\n-----Example-----\nInput\n2\n1\n2\n2\n1 1\n\nOutput\nT\nHL\n\n\n\n-----Note-----\n\nIn the first game, T removes a single stone from the only pile in his first turn. After that, although the pile still contains $1$ stone, HL cannot choose from this pile because it has been chosen by T in the previous turn. Therefore, T is the winner.", "difficulty": "competition", "id": 2189, "sample_io": [{"input": "2\n1\n2\n2\n1 1\n", "output": ["T\nHL\n"]}], "test_list": [{"input": "2\n1\n2\n2\n1 1\n", "output": ["T\nHL\n"]}, {"input": "1\n4\n2 3 1 2\n", "output": ["HL\n"]}, {"input": "2\n2\n1 4\n3\n3 1 3\n", "output": ["T\nT\n"]}, {"input": "3\n2\n4 3\n4\n2 2 2 3\n3\n1 4 1\n", "output": ["T\nT\nT\n"]}, {"input": "4\n5\n1 3 1 3 4\n1\n4\n1\n5\n2\n3 3\n", "output": ["HL\nT\nT\nHL\n"]}, {"input": "1\n3\n2 1 1\n", "output": ["HL\n"]}, {"input": "1\n4\n3 1 1 1\n", "output": ["HL\n"]}, {"input": "1\n7\n10 3 1 1 1 1 1\n", "output": ["T\n"]}], "starter_code": "", "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 2189}
{"name": "2063", "description": "The \"BerCorp\" company has got n employees. These employees can use m approved official languages for the formal correspondence. The languages are numbered with integers from 1 to m. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.\n\nFind the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating).\n\n\n-----Input-----\n\nThe first line contains two integers n and m (2 \u2264 n, m \u2264 100) \u2014 the number of employees and the number of languages.\n\nThen n lines follow \u2014 each employee's language list. At the beginning of the i-th line is integer k_{i} (0 \u2264 k_{i} \u2264 m) \u2014 the number of languages the i-th employee knows. Next, the i-th line contains k_{i} integers \u2014 a_{ij} (1 \u2264 a_{ij} \u2264 m) \u2014 the identifiers of languages the i-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.\n\nThe numbers in the lines are separated by single spaces.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).\n\n\n-----Examples-----\nInput\n5 5\n1 2\n2 2 3\n2 3 4\n2 4 5\n1 5\n\nOutput\n0\n\nInput\n8 7\n0\n3 1 2 3\n1 1\n2 5 4\n2 6 7\n1 3\n2 7 4\n1 1\n\nOutput\n2\n\nInput\n2 2\n1 2\n0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the second sample the employee 1 can learn language 2, and employee 8 can learn language 4.\n\nIn the third sample employee 2 must learn language 2.", "difficulty": "competition", "id": 2063, "sample_io": [{"input": "5 5\n1 2\n2 2 3\n2 3 4\n2 4 5\n1 5\n", "output": ["0\n"]}, {"input": "8 7\n0\n3 1 2 3\n1 1\n2 5 4\n2 6 7\n1 3\n2 7 4\n1 1\n", "output": ["2\n"]}, {"input": "2 2\n1 2\n0\n", "output": ["1\n"]}], "test_list": [{"input": "5 5\n1 2\n2 2 3\n2 3 4\n2 4 5\n1 5\n", "output": ["0\n"]}, {"input": "8 7\n0\n3 1 2 3\n1 1\n2 5 4\n2 6 7\n1 3\n2 7 4\n1 1\n", "output": ["2\n"]}, {"input": "2 2\n1 2\n0\n", "output": ["1\n"]}, {"input": "2 2\n0\n0\n", "output": ["2\n"]}, {"input": "5 5\n1 3\n0\n0\n2 4 1\n0\n", "output": ["4\n"]}, {"input": "6 2\n0\n0\n2 1 2\n1 1\n1 1\n0\n", "output": ["3\n"]}, {"input": "7 3\n3 1 3 2\n3 2 1 3\n2 2 3\n1 1\n2 2 3\n3 3 2 1\n3 2 3 1\n", "output": ["0\n"]}, {"input": "8 4\n0\n0\n4 2 3 1 4\n4 2 1 4 3\n3 4 3 1\n1 2\n2 4 1\n2 4 2\n", "output": ["2\n"]}, {"input": "10 10\n5 7 5 2 8 1\n7 10 6 9 5 8 2 4\n2 2 7\n5 8 6 9 10 1\n2 9 5\n3 6 5 2\n6 5 8 7 9 10 4\n0\n1 1\n2 8 6\n", "output": ["1\n"]}, {"input": "2 2\n2 1 2\n2 1 2\n", "output": ["0\n"]}, {"input": "2 2\n2 1 2\n1 1\n", "output": ["0\n"]}, {"input": "2 2\n1 2\n1 1\n", "output": ["1\n"]}, {"input": "3 100\n0\n0\n0\n", "output": ["3\n"]}, {"input": "3 3\n0\n0\n0\n", "output": ["3\n"]}], "starter_code": "", "source_codes": ["read n, m\nlang_of[language] = list of employees that know it\nany_known = False\n\nfor each employee i:\n        read k and the k languages\n        if k > 0: any_known = True\n        store i in the list of each read language\n\nmake a Disjoint Set Union (Union\u2011Find) over the n employees\nfor every language:\n        union all employees stored in its list   (pairwise with the first)\n\ncomponents = number of different DSU roots\nif any_known:\n        answer = components - 1\nelse:\n        answer = n\n\noutput answer"], "responses": ["\nread n, m\nlang_of[language] = list of employees that know it\nany_known = False\n\nfor each employee i:\n        read k and the k languages\n        if k > 0: any_known = True\n        store i in the list of each read language\n\nmake a Disjoint Set Union (Union\u2011Find) over the n employees\nfor every language:\n        union all employees stored in its list   (pairwise with the first)\n\ncomponents = number of different DSU roots\nif any_known:\n        answer = components - 1\nelse:\n        answer = n\n\noutput answer\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": 2063}
{"name": "2092", "description": "There are literally dozens of snooker competitions held each year, and team Jinotega tries to attend them all (for some reason they prefer name \"snookah\")! When a competition takes place somewhere far from their hometown, Ivan, Artsem and Konstantin take a flight to the contest and back.\n\nJinotega's best friends, team Base have found a list of their itinerary receipts with information about departure and arrival airports. Now they wonder, where is Jinotega now: at home or at some competition far away? They know that:   this list contains all Jinotega's flights in this year (in arbitrary order),  Jinotega has only flown from his hometown to a snooker contest and back,  after each competition Jinotega flies back home (though they may attend a competition in one place several times),  and finally, at the beginning of the year Jinotega was at home. \n\nPlease help them to determine Jinotega's location!\n\n\n-----Input-----\n\nIn the first line of input there is a single integer n: the number of Jinotega's flights (1 \u2264 n \u2264 100). In the second line there is a string of 3 capital Latin letters: the name of Jinotega's home airport. In the next n lines there is flight information, one flight per line, in form \"XXX->YYY\", where \"XXX\" is the name of departure airport \"YYY\" is the name of arrival airport. Exactly one of these airports is Jinotega's home airport.\n\nIt is guaranteed that flights information is consistent with the knowledge of Jinotega's friends, which is described in the main part of the statement.\n\n\n-----Output-----\n\nIf Jinotega is now at home, print \"home\" (without quotes), otherwise print \"contest\".\n\n\n-----Examples-----\nInput\n4\nSVO\nSVO->CDG\nLHR->SVO\nSVO->LHR\nCDG->SVO\n\nOutput\nhome\n\nInput\n3\nSVO\nSVO->HKT\nHKT->SVO\nSVO->RAP\n\nOutput\ncontest\n\n\n\n-----Note-----\n\nIn the first sample Jinotega might first fly from SVO to CDG and back, and then from SVO to LHR and back, so now they should be at home. In the second sample Jinotega must now be at RAP because a flight from RAP back to SVO is not on the list.", "difficulty": "competition", "id": 2092, "sample_io": [{"input": "4\nSVO\nSVO->CDG\nLHR->SVO\nSVO->LHR\nCDG->SVO\n", "output": ["home\n"]}, {"input": "3\nSVO\nSVO->HKT\nHKT->SVO\nSVO->RAP\n", "output": ["contest\n"]}], "test_list": [{"input": "4\nSVO\nSVO->CDG\nLHR->SVO\nSVO->LHR\nCDG->SVO\n", "output": ["home\n"]}, {"input": "3\nSVO\nSVO->HKT\nHKT->SVO\nSVO->RAP\n", "output": ["contest\n"]}, {"input": "1\nESJ\nESJ->TSJ\n", "output": ["contest\n"]}, {"input": "2\nXMR\nFAJ->XMR\nXMR->FAJ\n", "output": ["home\n"]}, {"input": "3\nZIZ\nDWJ->ZIZ\nZIZ->DWJ\nZIZ->DWJ\n", "output": ["contest\n"]}, {"input": "10\nPVO\nDMN->PVO\nDMN->PVO\nPVO->DMN\nDMN->PVO\nPVO->DMN\nPVO->DMN\nPVO->DMN\nDMN->PVO\nPVO->DMN\nDMN->PVO\n", "output": ["home\n"]}, {"input": "11\nIAU\nIAU->RUQ\nIAU->RUQ\nRUQ->IAU\nRUQ->IAU\nIAU->RUQ\nRUQ->IAU\nIAU->RUQ\nRUQ->IAU\nIAU->RUQ\nIAU->RUQ\nRUQ->IAU\n", "output": ["contest\n"]}, {"input": "10\nHPN\nDFI->HPN\nHPN->KAB\nHPN->DFI\nVSO->HPN\nHPN->KZX\nHPN->VSO\nKZX->HPN\nLDW->HPN\nKAB->HPN\nHPN->LDW\n", "output": ["home\n"]}, {"input": "11\nFGH\nFGH->BRZ\nUBK->FGH\nQRE->FGH\nFGH->KQK\nFGH->QRE\nKQK->FGH\nFGH->UBK\nBRZ->FGH\nFGH->ALX\nALX->FGH\nFGH->KQK\n", "output": ["contest\n"]}, {"input": "50\nPFH\nJFV->PFH\nBVP->PFH\nPFH->BVP\nPFH->JFV\nPFH->ETQ\nPFH->LQJ\nZTO->PFH\nPFH->BVP\nPFH->RXO\nPFH->ZTO\nHWL->PFH\nPFH->HIV\nPFH->AFP\nPFH->HWL\nOBB->PFH\nHIV->PFH\nPFH->LSR\nAFP->PFH\nLQJ->PFH\nHWL->PFH\nETQ->PFH\nPFH->HWL\nLSR->PFH\nWBR->PFH\nBNZ->PFH\nHQR->PFH\nZTO->PFH\nPFH->WBR\nPFH->BYJ\nRXO->PFH\nFHZ->PFH\nFHZ->PFH\nPFN->PFH\nPFH->GMB\nPFH->JFV\nJFV->PFH\nGNZ->PFH\nPFH->BNZ\nPFH->GNZ\nPFH->HQR\nBYJ->PFH\nGMB->PFH\nPFH->FHZ\nPFH->FHZ\nPFH->ZTO\nPFH->UGD\nBVP->PFH\nUGD->PFH\nPFH->PFN\nPFH->OBB\n", "output": ["home\n"]}, {"input": "1\nAAK\nAAK->ABA\n", "output": ["contest\n"]}, {"input": "1\nXYZ\nXYZ->XYR\n", "output": ["contest\n"]}], "starter_code": "", "source_codes": ["def solve() -> None:\n    \"\"\"\n    Reads the flight list, computes the balance of departures from home\n    versus arrivals to home, and prints where Jinotega is now.\n    \"\"\"\n    # read number of flights\n    n = int(input().strip())\n    # read home airport code\n    home = input().strip()\n\n    balance = 0  # +1 for a departure from home, -1 for an arrival to home\n\n    for _ in range(n):\n        flight = input().strip()\n        dep, arr = flight.split('->')\n        dep = dep.strip()\n        arr = arr.strip()\n\n        if dep == home:\n            balance += 1\n        else:               # by the statement arr == home\n            balance -= 1\n\n    print(\"home\" if balance == 0 else \"contest\")\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\ndef solve() -> None:\n    \"\"\"\n    Reads the flight list, computes the balance of departures from home\n    versus arrivals to home, and prints where Jinotega is now.\n    \"\"\"\n    # read number of flights\n    n = int(input().strip())\n    # read home airport code\n    home = input().strip()\n\n    balance = 0  # +1 for a departure from home, -1 for an arrival to home\n\n    for _ in range(n):\n        flight = input().strip()\n        dep, arr = flight.split('->')\n        dep = dep.strip()\n        arr = arr.strip()\n\n        if dep == home:\n            balance += 1\n        else:               # by the statement arr == home\n            balance -= 1\n\n    print(\"home\" if balance == 0 else \"contest\")\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": 2092}
