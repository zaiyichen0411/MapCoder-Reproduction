{"name": "mbpp_4_heap_queue_largest", "language": "Python3", "prompt": "from typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "heap_queue_largest", "test": "def check(candidate):\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    assert candidate([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n\ndef test_check():\n    check(heap_queue_largest)\n\ntest_check()\n", "sample_io": ["assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"], "source_codes": ["import heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        nums: List of integers\n        n: Number of largest elements to return\n        \n    Returns:\n        List of n largest integers in descending order\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to efficiently find n largest elements\n    return heapq.nlargest(n, nums)"], "responses": ["\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        nums: List of integers\n        n: Number of largest elements to return\n        \n    Returns:\n        List of n largest integers in descending order\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to efficiently find n largest elements\n    return heapq.nlargest(n, nums)\n\n\n"], "prompt_tokens": [1648], "completion_tokens": [1128], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_4_heap_queue_largest"}
{"name": "mbpp_120_max_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 200\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 484\n\ndef test_check():\n    check(max_product_tuple)\n\ntest_check()\n", "sample_io": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"], "source_codes": ["def max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    max_abs_product = float('-inf')\n    \n    for a, b in list1:\n        product = a * b\n        abs_product = abs(product)\n        if abs_product > max_abs_product:\n            max_abs_product = abs_product\n    \n    return max_abs_product"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError(\"List cannot be empty\")\n    \n    max_abs_product = float('-inf')\n    \n    for a, b in list1:\n        product = a * b\n        abs_product = abs(product)\n        if abs_product > max_abs_product:\n            max_abs_product = abs_product\n    \n    return max_abs_product\n\n\n"], "prompt_tokens": [1881], "completion_tokens": [959], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_120_max_product_tuple"}
{"name": "mbpp_230_replace_blank", "language": "Python3", "prompt": "def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n\tWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_blank", "test": "def check(candidate):\n    assert candidate('hello people', '@') == 'hello@people'\n    assert candidate('python program language', '$') == 'python$program$language'\n    assert candidate('blank space', '-') == 'blank-space'\n\ndef test_check():\n    check(replace_blank)\n\ntest_check()\n", "sample_io": ["assert replace_blank('hello people', '@') == 'hello@people'"], "source_codes": ["def replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)"], "responses": ["\ndef replace_blank(str1: str, char: str) -> str:\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return str1.replace(' ', char)\n\n\n"], "prompt_tokens": [1606], "completion_tokens": [702], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_230_replace_blank"}
{"name": "mbpp_600_is_Even", "language": "Python3", "prompt": "def is_Even(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number is even or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Even", "test": "def check(candidate):\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(3) == False\n\ndef test_check():\n    check(is_Even)\n\ntest_check()\n", "sample_io": ["assert is_Even(1) == False"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_600_is_Even"}
{"name": "mbpp_440_find_adverb_position", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    \"\"\"\n\tWrite a function to find the first adverb and their positions in a given sentence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_adverb_position", "test": "def check(candidate):\n    assert candidate('clearly!! we can see the sky') == (0, 7, 'clearly')\n    assert candidate('seriously!! there are many roses') == (0, 9, 'seriously')\n    assert candidate('unfortunately!! sita is going to home') == (0, 13, 'unfortunately')\n\ndef test_check():\n    check(find_adverb_position)\n\ntest_check()\n", "sample_io": ["assert find_adverb_position('clearly!! we can see the sky') == (0, 7, 'clearly')"], "source_codes": ["import re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    # Handle empty string case\n    if not text:\n        return (-1, -1, \"\")\n    \n    # Use regex to find all words with their positions\n    # This pattern matches sequences of alphanumeric characters and apostrophes\n    words = list(re.finditer(r\"[a-zA-Z']+\", text))\n    \n    # Check each word to see if it's an adverb (ending in 'ly')\n    for match in words:\n        word = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        \n        # Remove trailing punctuation for checking\n        cleaned_word = word.rstrip('.,!?:;\"\\'()[]{}')\n        \n        # Check if the cleaned word ends with 'ly' and has at least 3 characters\n        if len(cleaned_word) >= 3 and cleaned_word.endswith('ly'):\n            # Return the position in the original text (including punctuation)\n            return (start_pos, end_pos, text[start_pos:end_pos])\n    \n    # If no adverb is found, return default values\n    return (-1, -1, \"\")"], "responses": ["\nimport re\nfrom typing import Tuple\n\ndef find_adverb_position(text: str) -> Tuple[int, int, str]:\n    # Handle empty string case\n    if not text:\n        return (-1, -1, \"\")\n    \n    # Use regex to find all words with their positions\n    # This pattern matches sequences of alphanumeric characters and apostrophes\n    words = list(re.finditer(r\"[a-zA-Z']+\", text))\n    \n    # Check each word to see if it's an adverb (ending in 'ly')\n    for match in words:\n        word = match.group()\n        start_pos = match.start()\n        end_pos = match.end()\n        \n        # Remove trailing punctuation for checking\n        cleaned_word = word.rstrip('.,!?:;\"\\'()[]{}')\n        \n        # Check if the cleaned word ends with 'ly' and has at least 3 characters\n        if len(cleaned_word) >= 3 and cleaned_word.endswith('ly'):\n            # Return the position in the original text (including punctuation)\n            return (start_pos, end_pos, text[start_pos:end_pos])\n    \n    # If no adverb is found, return default values\n    return (-1, -1, \"\")\n\n\n"], "prompt_tokens": [1917], "completion_tokens": [1317], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_440_find_adverb_position"}
{"name": "mbpp_773_occurance_substring", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n\tWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "occurance_substring", "test": "def check(candidate):\n    assert candidate('python programming, python language', 'python') == ('python', 0, 6)\n    assert candidate('python programming,programming language', 'programming') == ('programming', 7, 18)\n    assert candidate('python programming,programming language', 'language') == ('language', 31, 39)\n    assert candidate('c++ programming, c++ language', 'python') == None\n\ndef test_check():\n    check(occurance_substring)\n\ntest_check()\n", "sample_io": ["assert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"], "source_codes": ["def occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n    \n    Args:\n        text: The string to search in\n        pattern: The substring to search for\n        \n    Returns:\n        A tuple containing (pattern, start_index, end_index) or None if not found\n    \"\"\"\n    # Handle empty pattern case\n    if pattern == \"\":\n        return (\"\", 0, 0)\n    \n    # Find the first occurrence of pattern in text\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate end index (exclusive)\n    end_index = start_index + len(pattern)\n    \n    # Return the result tuple\n    return (pattern, start_index, end_index)"], "responses": ["\nfrom typing import Optional, Tuple\n\ndef occurance_substring(text: str, pattern: str) -> Optional[Tuple[str, int, int]]:\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n    \n    Args:\n        text: The string to search in\n        pattern: The substring to search for\n        \n    Returns:\n        A tuple containing (pattern, start_index, end_index) or None if not found\n    \"\"\"\n    # Handle empty pattern case\n    if pattern == \"\":\n        return (\"\", 0, 0)\n    \n    # Find the first occurrence of pattern in text\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate end index (exclusive)\n    end_index = start_index + len(pattern)\n    \n    # Return the result tuple\n    return (pattern, start_index, end_index)\n\n\n"], "prompt_tokens": [1987], "completion_tokens": [1048], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_773_occurance_substring"}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "Python3", "prompt": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_total_number_of_sequences", "test": "def check(candidate):\n    assert candidate(10, 4) == 4\n    assert candidate(5, 2) == 6\n    assert candidate(16, 3) == 84\n\ndef test_check():\n    check(get_total_number_of_sequences)\n\ntest_check()\n", "sample_io": ["assert get_total_number_of_sequences(10, 4) == 4"], "source_codes": ["def get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    # dp[j] will store the number of sequences of current length ending with j\n    dp = [0] * (m + 1)\n    \n    # Base case: sequences of length 1\n    for j in range(1, m + 1):\n        dp[j] = 1\n    \n    # For each length from 2 to n\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        # For each possible ending value j\n        for j in range(1, m + 1):\n            # Sum up all dp[prev] where prev * 2 <= j\n            # This means prev can be from 1 to j // 2\n            for prev in range(1, j // 2 + 1):\n                new_dp[j] += dp[prev]\n        dp = new_dp\n    \n    # Sum all dp[j] to get total number of sequences of length n\n    return sum(dp)"], "responses": ["\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    # dp[j] will store the number of sequences of current length ending with j\n    dp = [0] * (m + 1)\n    \n    # Base case: sequences of length 1\n    for j in range(1, m + 1):\n        dp[j] = 1\n    \n    # For each length from 2 to n\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        # For each possible ending value j\n        for j in range(1, m + 1):\n            # Sum up all dp[prev] where prev * 2 <= j\n            # This means prev can be from 1 to j // 2\n            for prev in range(1, j // 2 + 1):\n                new_dp[j] += dp[prev]\n        dp = new_dp\n    \n    # Sum all dp[j] to get total number of sequences of length n\n    return sum(dp)\n\n\n"], "prompt_tokens": [2765], "completion_tokens": [1855], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_239_get_total_number_of_sequences"}
{"name": "mbpp_265_list_split", "language": "Python3", "prompt": "from typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_split", "test": "def check(candidate):\n    assert candidate(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]]\n    assert candidate(['python', 'java', 'C', 'C++', 'DBMS', 'SQL'], 2) == [['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]\n\ndef test_check():\n    check(list_split)\n\ntest_check()\n", "sample_io": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"], "source_codes": ["def list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if not S or step <= 0:\n        return []\n    \n    result = []\n    for i in range(step):\n        sublist = []\n        for j in range(i, len(S), step):\n            sublist.append(S[j])\n        result.append(sublist)\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef list_split(S: List[Any], step: int) -> List[List[Any]]:\n    if not S or step <= 0:\n        return []\n    \n    result = []\n    for i in range(step):\n        sublist = []\n        for j in range(i, len(S), step):\n            sublist.append(S[j])\n        result.append(sublist)\n    \n    return result\n\n\n"], "prompt_tokens": [3326], "completion_tokens": [1820], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_265_list_split"}
{"name": "mbpp_412_remove_odd", "language": "Python3", "prompt": "from typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove odd numbers from a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [2]\n    assert candidate([2, 4, 6]) == [2, 4, 6]\n    assert candidate([10, 20, 3]) == [10, 20]\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd([1, 2, 3]) == [2]"], "source_codes": ["def remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [num for num in l if num % 2 == 0]"], "responses": ["\nfrom typing import List\n\ndef remove_odd(l: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to remove odd numbers from a given list.\n    \"\"\"\n    return [num for num in l if num % 2 == 0]\n\n\n"], "prompt_tokens": [1713], "completion_tokens": [981], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_412_remove_odd"}
{"name": "mbpp_414_overlapping", "language": "Python3", "prompt": "from typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether any value in a sequence exists in a sequence or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "overlapping", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False\n    assert candidate([1, 2, 3], [4, 5, 6]) == False\n    assert candidate([1, 4, 5], [1, 4, 5]) == True\n\ndef test_check():\n    check(overlapping)\n\ntest_check()\n", "sample_io": ["assert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"], "source_codes": ["def overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether any value in a sequence exists in a sequence or not.\n    \"\"\"\n    # Handle edge cases: if either list is empty, there can't be any overlap\n    if not list1 or not list2:\n        return False\n    \n    # Convert the smaller list to a set for O(1) average case lookup\n    # This optimizes the membership testing\n    if len(list1) <= len(list2):\n        smaller_set = set(list1)\n        larger_list = list2\n    else:\n        smaller_set = set(list2)\n        larger_list = list1\n    \n    # Use any() for short-circuit evaluation - returns True as soon as \n    # it finds an element that exists in the set\n    return any(element in smaller_set for element in larger_list)"], "responses": ["\nfrom typing import List\n\ndef overlapping(list1: List[int], list2: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check whether any value in a sequence exists in a sequence or not.\n    \"\"\"\n    # Handle edge cases: if either list is empty, there can't be any overlap\n    if not list1 or not list2:\n        return False\n    \n    # Convert the smaller list to a set for O(1) average case lookup\n    # This optimizes the membership testing\n    if len(list1) <= len(list2):\n        smaller_set = set(list1)\n        larger_list = list2\n    else:\n        smaller_set = set(list2)\n        larger_list = list1\n    \n    # Use any() for short-circuit evaluation - returns True as soon as \n    # it finds an element that exists in the set\n    return any(element in smaller_set for element in larger_list)\n\n\n"], "prompt_tokens": [1936], "completion_tokens": [1047], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_414_overlapping"}
{"name": "mbpp_160_find_solution", "language": "Python3", "prompt": "from typing import Optional, Tuple\n\ndef find_solution(a: int, b: int, n: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_solution", "test": "def check(candidate):\n    assert candidate(2, 3, 7) == (2, 1)\n    assert candidate(4, 2, 7) == None\n    assert candidate(1, 13, 17) == (4, 1)\n\ndef test_check():\n    check(find_solution)\n\ntest_check()\n", "sample_io": ["assert find_solution(2, 3, 7) == (2, 1)"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_160_find_solution"}
{"name": "mbpp_559_max_sub_array_sum", "language": "Python3", "prompt": "from typing import List\n\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of the largest contiguous sublist in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sub_array_sum", "test": "def check(candidate):\n    assert candidate([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n    assert candidate([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8\n    assert candidate([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10\n\ndef test_check():\n    check(max_sub_array_sum)\n\ntest_check()\n", "sample_io": ["assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"], "source_codes": ["def max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far"], "responses": ["\ndef max_sub_array_sum(a: List[int], size: int) -> int:\n    if size == 0:\n        return 0\n    \n    max_so_far = a[0]\n    max_ending_here = a[0]\n    \n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n\n"], "prompt_tokens": [2150], "completion_tokens": [1445], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_559_max_sub_array_sum"}
{"name": "mbpp_809_check_smaller", "language": "Python3", "prompt": "from typing import Tuple\n\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n\tWrite a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_smaller", "test": "def check(candidate):\n    assert candidate((1, 2, 3), (2, 3, 4)) == False\n    assert candidate((4, 5, 6), (3, 4, 5)) == True\n    assert candidate((11, 12, 13), (10, 11, 12)) == True\n\ndef test_check():\n    check(check_smaller)\n\ntest_check()\n", "sample_io": ["assert check_smaller((1, 2, 3), (2, 3, 4)) == False"], "source_codes": ["def check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    for i in range(3):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    return True"], "responses": ["\ndef check_smaller(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> bool:\n    \"\"\"\n    Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \"\"\"\n    for i in range(3):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    return True\n\n\n"], "prompt_tokens": [2214], "completion_tokens": [1060], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_809_check_smaller"}
{"name": "mbpp_629_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to find even numbers from a list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [2, 4]\n    assert candidate([4, 5, 6, 7, 8, 0, 1]) == [4, 6, 8, 0]\n    assert candidate([8, 12, 15, 19]) == [8, 12]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5]) == [2, 4]"], "source_codes": ["def Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]"], "responses": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to find even numbers from a list of numbers.\n    \"\"\"\n    return [num for num in list if num % 2 == 0]\n\n\n"], "prompt_tokens": [1652], "completion_tokens": [754], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_629_Split"}
{"name": "mbpp_723_count_same_pair", "language": "Python3", "prompt": "from typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n\tThe input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_same_pair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 11\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17], [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 1\n    assert candidate([0, 1, 1, 2], [0, 1, 2, 2]) == 3\n\ndef test_check():\n    check(count_same_pair)\n\ntest_check()\n", "sample_io": ["assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"], "source_codes": ["def count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Count indices where the lists have the same values.\n    \n    Args:\n        nums1: First list of integers\n        nums2: Second list of integers\n        \n    Returns:\n        Number of indices where corresponding elements are equal\n    \"\"\"\n    # Handle edge case of empty lists\n    if not nums1 or not nums2:\n        return 0\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through both lists simultaneously\n    for num1, num2 in zip(nums1, nums2):\n        # If elements are equal, increment counter\n        if num1 == num2:\n            count += 1\n    \n    return count"], "responses": ["\nfrom typing import List\n\ndef count_same_pair(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Count indices where the lists have the same values.\n    \n    Args:\n        nums1: First list of integers\n        nums2: Second list of integers\n        \n    Returns:\n        Number of indices where corresponding elements are equal\n    \"\"\"\n    # Handle edge case of empty lists\n    if not nums1 or not nums2:\n        return 0\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through both lists simultaneously\n    for num1, num2 in zip(nums1, nums2):\n        # If elements are equal, increment counter\n        if num1 == num2:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1870], "completion_tokens": [965], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_723_count_same_pair"}
{"name": "mbpp_242_count_charac", "language": "Python3", "prompt": "def count_charac(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the total number of characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_charac", "test": "def check(candidate):\n    assert candidate('python programming') == 18\n    assert candidate('language') == 8\n    assert candidate('words') == 5\n\ndef test_check():\n    check(count_charac)\n\ntest_check()\n", "sample_io": ["assert count_charac('python programming') == 18"], "source_codes": ["def count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)"], "responses": ["\ndef count_charac(str1: str) -> int:\n    \"\"\"\n    Write a function to count the total number of characters in a string.\n    \"\"\"\n    return len(str1)\n\n\n"], "prompt_tokens": [1535], "completion_tokens": [773], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_242_count_charac"}
{"name": "mbpp_616_tuple_modulo", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function which takes two tuples of the same length and performs the element wise modulo.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_modulo", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n    assert candidate((11, 5, 6, 7), (6, 7, 8, 6)) == (5, 5, 6, 1)\n    assert candidate((12, 6, 7, 8), (7, 8, 9, 7)) == (5, 6, 7, 1)\n\ndef test_check():\n    check(tuple_modulo)\n\ntest_check()\n", "sample_io": ["assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)"], "source_codes": ["def tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))"], "responses": ["\nfrom typing import Tuple\n\ndef tuple_modulo(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function which takes two tuples of the same length and performs the element wise modulo.\n    \"\"\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n\n\n"], "prompt_tokens": [2093], "completion_tokens": [1145], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_616_tuple_modulo"}
{"name": "mbpp_583_catalan_number", "language": "Python3", "prompt": "def catalan_number(num: int) -> int:\n    \"\"\"\n\tWrite a function which returns nth catalan number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "catalan_number", "test": "def check(candidate):\n    assert candidate(10) == 16796\n    assert candidate(9) == 4862\n    assert candidate(7) == 429\n\ndef test_check():\n    check(catalan_number)\n\ntest_check()\n", "sample_io": ["assert catalan_number(10) == 16796"], "source_codes": ["def catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns nth catalan number.\n    \"\"\"\n    if num == 0:\n        return 1\n    \n    # Create array to store catalan numbers\n    catalan = [0] * (num + 1)\n    \n    # Initialize first two values\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill catalan array using the recursive formula\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]"], "responses": ["\ndef catalan_number(num: int) -> int:\n    \"\"\"\n    Write a function which returns nth catalan number.\n    \"\"\"\n    if num == 0:\n        return 1\n    \n    # Create array to store catalan numbers\n    catalan = [0] * (num + 1)\n    \n    # Initialize first two values\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill catalan array using the recursive formula\n    for i in range(2, num + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[num]\n\n\n"], "prompt_tokens": [1779], "completion_tokens": [1176], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_583_catalan_number"}
{"name": "mbpp_129_magic_square_test", "language": "Python3", "prompt": "from typing import List\n\ndef magic_square_test(my_matrix: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to calculate whether the matrix is a magic square.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "magic_square_test", "test": "def check(candidate):\n    assert candidate([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    assert candidate([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n\ndef test_check():\n    check(magic_square_test)\n\ntest_check()\n", "sample_io": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_129_magic_square_test"}
{"name": "mbpp_61_count_Substrings", "language": "Python3", "prompt": "def count_Substrings(s: str) -> int:\n    \"\"\"\n\tWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Substrings", "test": "def check(candidate):\n    assert candidate('112112') == 6\n    assert candidate('111') == 6\n    assert candidate('1101112') == 12\n\ndef test_check():\n    check(count_Substrings)\n\ntest_check()\n", "sample_io": ["assert count_Substrings('112112') == 6"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_61_count_Substrings"}
{"name": "mbpp_287_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 20\n    assert candidate(3) == 56\n    assert candidate(4) == 120\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 20"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_287_square_Sum"}
{"name": "mbpp_93_power", "language": "Python3", "prompt": "def power(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the value of 'a' to the power 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power", "test": "def check(candidate):\n    assert candidate(3, 4) == 81\n    assert candidate(2, 3) == 8\n    assert candidate(5, 5) == 3125\n\ndef test_check():\n    check(power)\n\ntest_check()\n", "sample_io": ["assert power(3, 4) == 81"], "source_codes": ["def power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    # Handle edge cases\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if a == 0:\n        return 0\n    \n    # Calculate power using iterative multiplication\n    result = 1\n    for _ in range(b):\n        result *= a\n    \n    return result"], "responses": ["\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n    \"\"\"\n    # Handle edge cases\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if a == 0:\n        return 0\n    \n    # Calculate power using iterative multiplication\n    result = 1\n    for _ in range(b):\n        result *= a\n    \n    return result\n\n\n"], "prompt_tokens": [1771], "completion_tokens": [1177], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_93_power"}
{"name": "mbpp_607_find_literals", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n\tWrite a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_literals", "test": "def check(candidate):\n    assert candidate('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n    assert candidate('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)\n    assert candidate('Hardest choices required strongest will', 'will') == ('will', 35, 39)\n\ndef test_check():\n    check(find_literals)\n\ntest_check()\n", "sample_io": ["assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"], "source_codes": ["import re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern and return the matching substring, start index, and end index.\n    \n    Args:\n        text: The string to search in\n        pattern: The regex pattern to search for\n        \n    Returns:\n        A tuple containing (matched_substring, start_index, end_index)\n        \n    Raises:\n        ValueError: If no match is found\n    \"\"\"\n    match = re.search(pattern, text)\n    \n    if match is None:\n        raise ValueError(\"No match found\")\n    \n    matched_substring = match.group()\n    start_index = match.start()\n    end_index = match.end()\n    \n    return (matched_substring, start_index, end_index)"], "responses": ["\nimport re\nfrom typing import Tuple\n\ndef find_literals(text: str, pattern: str) -> Tuple[str, int, int]:\n    \"\"\"\n    Search a string for a regex pattern and return the matching substring, start index, and end index.\n    \n    Args:\n        text: The string to search in\n        pattern: The regex pattern to search for\n        \n    Returns:\n        A tuple containing (matched_substring, start_index, end_index)\n        \n    Raises:\n        ValueError: If no match is found\n    \"\"\"\n    match = re.search(pattern, text)\n    \n    if match is None:\n        raise ValueError(\"No match found\")\n    \n    matched_substring = match.group()\n    start_index = match.start()\n    end_index = match.end()\n    \n    return (matched_substring, start_index, end_index)\n\n\n"], "prompt_tokens": [2108], "completion_tokens": [1343], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_607_find_literals"}
{"name": "mbpp_94_index_minimum", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n\tGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_minimum", "test": "def check(candidate):\n    assert candidate([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    assert candidate([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'\n    assert candidate([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'\n\ndef test_check():\n    check(index_minimum)\n\ntest_check()\n", "sample_io": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"], "source_codes": ["def index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_value = test_list[0][1]\n    min_element = test_list[0][0]\n    \n    for element, value in test_list:\n        if value < min_value:\n            min_value = value\n            min_element = element\n    \n    return min_element"], "responses": ["\nfrom typing import List, Tuple\n\ndef index_minimum(test_list: List[Tuple[str, int]]) -> str:\n    \"\"\"\n    Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_value = test_list[0][1]\n    min_element = test_list[0][0]\n    \n    for element, value in test_list:\n        if value < min_value:\n            min_value = value\n            min_element = element\n    \n    return min_element\n\n\n"], "prompt_tokens": [1360], "completion_tokens": [1090], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_94_index_minimum"}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "Python3", "prompt": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sum_Of_Powers_Of_Two", "test": "def check(candidate):\n    assert candidate(10) == True\n    assert candidate(7) == False\n    assert candidate(14) == True\n\ndef test_check():\n    check(is_Sum_Of_Powers_Of_Two)\n\ntest_check()\n", "sample_io": ["assert is_Sum_Of_Powers_Of_Two(10) == True"], "source_codes": ["def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \n    A number can be represented as sum of non-zero powers of 2 if and only if it is a positive integer\n    and it's not zero (since we need non-zero powers of 2).\n    This is equivalent to checking if n > 0.\n    \"\"\"\n    return n > 0"], "responses": ["\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \n    A number can be represented as sum of non-zero powers of 2 if and only if it is a positive integer\n    and it's not zero (since we need non-zero powers of 2).\n    This is equivalent to checking if n > 0.\n    \"\"\"\n    return n > 0\n\n\n"], "prompt_tokens": [700], "completion_tokens": [1267], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_138_is_Sum_Of_Powers_Of_Two"}
{"name": "mbpp_594_diff_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the difference of the first even and first odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "diff_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n    assert candidate([1, 5, 7, 9, 10]) == 9\n\ndef test_check():\n    check(diff_even_odd)\n\ntest_check()\n", "sample_io": ["assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"], "source_codes": ["def diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    # Find first even and first odd numbers\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n    # If we didn't find both even and odd numbers, return None or raise exception\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number\")\n        \n    return first_even - first_odd"], "responses": ["\nfrom typing import List\n\ndef diff_even_odd(list1: List[int]) -> int:\n    first_even = None\n    first_odd = None\n    \n    # Find first even and first odd numbers\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n    # If we didn't find both even and odd numbers, return None or raise exception\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number\")\n        \n    return first_even - first_odd\n\n\n"], "prompt_tokens": [1897], "completion_tokens": [1160], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_594_diff_even_odd"}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "Python3", "prompt": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_binomial_Coeff_Sum", "test": "def check(candidate):\n    assert candidate(4) == 8\n    assert candidate(6) == 32\n    assert candidate(2) == 2\n\ndef test_check():\n    check(even_binomial_Coeff_Sum)\n\ntest_check()\n", "sample_io": ["assert even_binomial_Coeff_Sum(4) == 8"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_274_even_binomial_Coeff_Sum"}
{"name": "mbpp_126_sum", "language": "Python3", "prompt": "def sum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of common divisors of two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum", "test": "def check(candidate):\n    assert candidate(10, 15) == 6\n    assert candidate(100, 150) == 93\n    assert candidate(4, 6) == 3\n\ndef test_check():\n    check(sum)\n\ntest_check()\n", "sample_io": ["assert sum(10, 15) == 6"], "source_codes": ["import math\n\ndef sum(a: int, b: int) -> int:\n    # Handle edge cases\n    if a == 0 or b == 0:\n        return 0\n    \n    # Work with absolute values\n    a, b = abs(a), abs(b)\n    \n    # Find GCD of the two numbers\n    gcd_val = math.gcd(a, b)\n    \n    # Find sum of all divisors of the GCD\n    divisor_sum = 0\n    i = 1\n    while i * i <= gcd_val:\n        if gcd_val % i == 0:\n            divisor_sum += i\n            if i != gcd_val // i:  # Avoid double counting for perfect squares\n                divisor_sum += gcd_val // i\n        i += 1\n    \n    return divisor_sum"], "responses": ["\nimport math\n\ndef sum(a: int, b: int) -> int:\n    # Handle edge cases\n    if a == 0 or b == 0:\n        return 0\n    \n    # Work with absolute values\n    a, b = abs(a), abs(b)\n    \n    # Find GCD of the two numbers\n    gcd_val = math.gcd(a, b)\n    \n    # Find sum of all divisors of the GCD\n    divisor_sum = 0\n    i = 1\n    while i * i <= gcd_val:\n        if gcd_val % i == 0:\n            divisor_sum += i\n            if i != gcd_val // i:  # Avoid double counting for perfect squares\n                divisor_sum += gcd_val // i\n        i += 1\n    \n    return divisor_sum\n\n\n"], "prompt_tokens": [2150], "completion_tokens": [1380], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_126_sum"}
{"name": "mbpp_769_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the difference between two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Diff", "test": "def check(candidate):\n    assert candidate([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 1]) == [2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3], [6, 7, 1]) == [2, 3, 6, 7]\n\ndef test_check():\n    check(Diff)\n\ntest_check()\n", "sample_io": ["assert Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"], "source_codes": ["def Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Get the difference between two lists, considering duplicates.\n    \n    Returns elements in li1 that are not in li2, preserving duplicates appropriately.\n    For each element in li2, one occurrence is removed from li1 if present.\n    \n    Args:\n        li1: First list of integers\n        li2: Second list of integers\n    \n    Returns:\n        List of integers representing the difference\n    \"\"\"\n    # Count occurrences in li2\n    li2_count = Counter(li2)\n    \n    # Build result by checking each element in li1\n    result = []\n    for item in li1:\n        if li2_count[item] > 0:\n            # If item exists in li2 with positive count, decrement count\n            li2_count[item] -= 1\n        else:\n            # Otherwise add to result\n            result.append(item)\n            \n    return result"], "responses": ["\nfrom typing import List\nfrom collections import Counter\n\ndef Diff(li1: List[int], li2: List[int]) -> List[int]:\n    \"\"\"\n    Get the difference between two lists, considering duplicates.\n    \n    Returns elements in li1 that are not in li2, preserving duplicates appropriately.\n    For each element in li2, one occurrence is removed from li1 if present.\n    \n    Args:\n        li1: First list of integers\n        li2: Second list of integers\n    \n    Returns:\n        List of integers representing the difference\n    \"\"\"\n    # Count occurrences in li2\n    li2_count = Counter(li2)\n    \n    # Build result by checking each element in li1\n    result = []\n    for item in li1:\n        if li2_count[item] > 0:\n            # If item exists in li2 with positive count, decrement count\n            li2_count[item] -= 1\n        else:\n            # Otherwise add to result\n            result.append(item)\n            \n    return result\n\n\n"], "prompt_tokens": [3422], "completion_tokens": [1558], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_769_Diff"}
{"name": "mbpp_796_return_sum", "language": "Python3", "prompt": "from typing import Dict\n\ndef return_sum(dict: Dict[str, int]) -> int:\n    \"\"\"\n\tWrite function to find the sum of all items in the given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_796_return_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "return_sum", "test": "def check(candidate):\n    assert candidate({ 'a': 100, 'b': 200, 'c': 300 }) == 600\n    assert candidate({ 'a': 25, 'b': 18, 'c': 45 }) == 88\n    assert candidate({ 'a': 36, 'b': 39, 'c': 49 }) == 124\n\ndef test_check():\n    check(return_sum)\n\ntest_check()\n", "sample_io": ["assert return_sum({ 'a': 100, 'b': 200, 'c': 300 }) == 600"], "source_codes": ["def return_sum(d: Dict[str, int]) -> int:\n    return sum(d.values())"], "responses": ["\ndef return_sum(d: Dict[str, int]) -> int:\n    return sum(d.values())\n\n\n"], "prompt_tokens": [4971], "completion_tokens": [1786], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_796_return_sum"}
{"name": "mbpp_574_surfacearea_cylinder", "language": "Python3", "prompt": "def surfacearea_cylinder(r: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the surface area of a cylinder.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "surfacearea_cylinder", "test": "def check(candidate):\n    assert candidate(10, 5) == 942.45\n    assert candidate(4, 5) == 226.18800000000002\n    assert candidate(4, 10) == 351.848\n\ndef test_check():\n    check(surfacearea_cylinder)\n\ntest_check()\n", "sample_io": ["assert surfacearea_cylinder(10, 5) == 942.45"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_574_surfacearea_cylinder"}
{"name": "mbpp_783_rgb_to_hsv", "language": "Python3", "prompt": "from typing import List\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    \"\"\"\n\tWrite a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rgb_to_hsv", "test": "def check(candidate):\n    assert candidate(255, 255, 255) == [0.0, 0.0, 100.0]\n    assert candidate(0, 215, 0) == [120.0, 100.0, 84.31372549019608]\n    assert candidate(10, 215, 110) == [149.26829268292684, 95.34883720930233, 84.31372549019608]\n\ndef test_check():\n    check(rgb_to_hsv)\n\ntest_check()\n", "sample_io": ["assert rgb_to_hsv(255, 255, 255) == [0.0, 0.0, 100.0]"], "source_codes": ["def rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Validate input\n    for val in [r, g, b]:\n        if not (0 <= val <= 255):\n            raise ValueError(\"RGB values must be in the range 0-255\")\n    \n    # Normalize RGB values\n    r_norm, g_norm, b_norm = r / 255.0, g / 255.0, b / 255.0\n    \n    # Find max and min values\n    max_val = max(r_norm, g_norm, b_norm)\n    min_val = min(r_norm, g_norm, b_norm)\n    delta = max_val - min_val\n    \n    # Calculate Value (V) - scaled to 0-100\n    v = max_val * 100\n    \n    # Calculate Saturation (S)\n    if max_val == 0:\n        s = 0\n    else:\n        s = delta / max_val\n    \n    # Calculate Hue (H)\n    if delta == 0:\n        h = 0\n    else:\n        if max_val == r_norm:\n            h = 60 * (((g_norm - b_norm) / delta) % 6)\n        elif max_val == g_norm:\n            h = 60 * (((b_norm - r_norm) / delta) + 2)\n        else:  # max_val == b_norm\n            h = 60 * (((r_norm - g_norm) / delta) + 4)\n    \n    return [h, s, v]"], "responses": ["\ndef rgb_to_hsv(r: int, g: int, b: int) -> List[float]:\n    # Validate input\n    for val in [r, g, b]:\n        if not (0 <= val <= 255):\n            raise ValueError(\"RGB values must be in the range 0-255\")\n    \n    # Normalize RGB values\n    r_norm, g_norm, b_norm = r / 255.0, g / 255.0, b / 255.0\n    \n    # Find max and min values\n    max_val = max(r_norm, g_norm, b_norm)\n    min_val = min(r_norm, g_norm, b_norm)\n    delta = max_val - min_val\n    \n    # Calculate Value (V) - scaled to 0-100\n    v = max_val * 100\n    \n    # Calculate Saturation (S)\n    if max_val == 0:\n        s = 0\n    else:\n        s = delta / max_val\n    \n    # Calculate Hue (H)\n    if delta == 0:\n        h = 0\n    else:\n        if max_val == r_norm:\n            h = 60 * (((g_norm - b_norm) / delta) % 6)\n        elif max_val == g_norm:\n            h = 60 * (((b_norm - r_norm) / delta) + 2)\n        else:  # max_val == b_norm\n            h = 60 * (((r_norm - g_norm) / delta) + 4)\n    \n    return [h, s, v]\n\n\n"], "prompt_tokens": [5740], "completion_tokens": [3510], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_783_rgb_to_hsv"}
{"name": "mbpp_70_get_equal", "language": "Python3", "prompt": "from typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    \"\"\"\n\tWrite a function to find whether all the given lists have equal length or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_equal", "test": "def check(candidate):\n    assert candidate([[11, 22, 33], [44, 55, 66]]) == True\n    assert candidate([[1, 2, 3], [4, 5, 6, 7]]) == False\n    assert candidate([[1, 2], [3, 4]]) == True\n\ndef test_check():\n    check(get_equal)\n\ntest_check()\n", "sample_io": ["assert get_equal([[11, 22, 33], [44, 55, 66]]) == True"], "source_codes": ["def get_equal(Input: List[List[int]]) -> bool:\n    # Handle edge cases\n    if len(Input) == 0:\n        return True\n    \n    if len(Input) == 1:\n        return True\n    \n    # Get the length of the first sublist as reference\n    reference_length = len(Input[0])\n    \n    # Check if all other sublists have the same length\n    for i in range(1, len(Input)):\n        if len(Input[i]) != reference_length:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import List\n\ndef get_equal(Input: List[List[int]]) -> bool:\n    # Handle edge cases\n    if len(Input) == 0:\n        return True\n    \n    if len(Input) == 1:\n        return True\n    \n    # Get the length of the first sublist as reference\n    reference_length = len(Input[0])\n    \n    # Check if all other sublists have the same length\n    for i in range(1, len(Input)):\n        if len(Input[i]) != reference_length:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1643], "completion_tokens": [806], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_70_get_equal"}
{"name": "mbpp_267_square_Sum", "language": "Python3", "prompt": "def square_Sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_Sum", "test": "def check(candidate):\n    assert candidate(2) == 10\n    assert candidate(3) == 35\n    assert candidate(4) == 84\n\ndef test_check():\n    check(square_Sum)\n\ntest_check()\n", "sample_io": ["assert square_Sum(2) == 10"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_267_square_Sum"}
{"name": "mbpp_171_perimeter_pentagon", "language": "Python3", "prompt": "def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n\tWrite a function to find the perimeter of a regular pentagon from the length of its sides.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perimeter_pentagon", "test": "def check(candidate):\n    assert candidate(5) == 25\n    assert candidate(10) == 50\n    assert candidate(15) == 75\n\ndef test_check():\n    check(perimeter_pentagon)\n\ntest_check()\n", "sample_io": ["assert perimeter_pentagon(5) == 25"], "source_codes": ["def perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a"], "responses": ["\ndef perimeter_pentagon(a: int) -> int:\n    \"\"\"\n    Write a function to find the perimeter of a regular pentagon from the length of its sides.\n    \"\"\"\n    return 5 * a\n\n\n"], "prompt_tokens": [1518], "completion_tokens": [679], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_171_perimeter_pentagon"}
{"name": "mbpp_222_check_type", "language": "Python3", "prompt": "from typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if all the elements in tuple have same data type or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_type", "test": "def check(candidate):\n    assert candidate((5, 6, 7, 3, 5, 6)) == True\n    assert candidate((1, 2, '4')) == False\n    assert candidate((3, 2, 1, 4, 5)) == True\n\ndef test_check():\n    check(check_type)\n\ntest_check()\n", "sample_io": ["assert check_type((5, 6, 7, 3, 5, 6)) == True"], "source_codes": ["def check_type(test_tuple: Any) -> bool:\n    # Check if input is a tuple\n    if not isinstance(test_tuple, tuple):\n        return False\n    \n    # Empty tuple - vacuously true\n    if len(test_tuple) == 0:\n        return True\n    \n    # Single element tuple - always true\n    if len(test_tuple) == 1:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Check if all elements have the same type as the first\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import Any\n\ndef check_type(test_tuple: Any) -> bool:\n    # Check if input is a tuple\n    if not isinstance(test_tuple, tuple):\n        return False\n    \n    # Empty tuple - vacuously true\n    if len(test_tuple) == 0:\n        return True\n    \n    # Single element tuple - always true\n    if len(test_tuple) == 1:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Check if all elements have the same type as the first\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1812], "completion_tokens": [932], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_222_check_type"}
{"name": "mbpp_164_are_equivalent", "language": "Python3", "prompt": "def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n\tWrite a function to determine if the sum of the divisors of two integers are the same.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "are_equivalent", "test": "def check(candidate):\n    assert candidate(36, 57) == False\n    assert candidate(2, 4) == False\n    assert candidate(23, 47) == True\n\ndef test_check():\n    check(are_equivalent)\n\ntest_check()\n", "sample_io": ["assert are_equivalent(36, 57) == False"], "source_codes": ["def are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid double counting for perfect squares\n                    divisor_sum += n // i\n            i += 1\n        return divisor_sum\n    \n    # Handle edge cases\n    if num1 <= 0 or num2 <= 0:\n        return False\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)"], "responses": ["\ndef are_equivalent(num1: int, num2: int) -> bool:\n    \"\"\"\n    Write a function to determine if the sum of the divisors of two integers are the same.\n    \"\"\"\n    def sum_of_divisors(n: int) -> int:\n        if n <= 0:\n            return 0\n        \n        divisor_sum = 0\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                divisor_sum += i\n                if i != n // i:  # Avoid double counting for perfect squares\n                    divisor_sum += n // i\n            i += 1\n        return divisor_sum\n    \n    # Handle edge cases\n    if num1 <= 0 or num2 <= 0:\n        return False\n    \n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n\n\n"], "prompt_tokens": [2226], "completion_tokens": [1558], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_164_are_equivalent"}
{"name": "mbpp_803_is_perfect_square", "language": "Python3", "prompt": "def is_perfect_square(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_perfect_square", "test": "def check(candidate):\n    assert candidate(10) == False\n    assert candidate(36) == True\n    assert candidate(14) == False\n    assert candidate(196) == True\n    assert candidate(125) == False\n    assert candidate(15625) == True\n\ndef test_check():\n    check(is_perfect_square)\n\ntest_check()\n", "sample_io": ["assert is_perfect_square(10) == False"], "source_codes": ["def is_perfect_square(n: int) -> bool:\n    # Handle edge cases\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search for the square root\n    low = 1\n    high = n\n    \n    while low <= high:\n        mid = (low + high) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False"], "responses": ["\ndef is_perfect_square(n: int) -> bool:\n    # Handle edge cases\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search for the square root\n    low = 1\n    high = n\n    \n    while low <= high:\n        mid = (low + high) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\n\n"], "prompt_tokens": [1747], "completion_tokens": [1043], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_803_is_perfect_square"}
{"name": "mbpp_305_start_withp", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n\tWrite a function to return two words from a list of words starting with letter 'p'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "start_withp", "test": "def check(candidate):\n    assert candidate(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')\n    assert candidate(['Python Programming', 'Java Programming']) == ('Python', 'Programming')\n    assert candidate(['Pqrst Pqr', 'qrstuv']) == ('Pqrst', 'Pqr')\n\ndef test_check():\n    check(start_withp)\n\ntest_check()\n", "sample_io": ["assert start_withp(['Python PHP', 'Java JavaScript', 'c c++']) == ('Python', 'PHP')"], "source_codes": ["def start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = []\n    \n    # Split each string into individual words and check each word\n    for item in words:\n        # Split by space to get individual words\n        individual_words = item.split()\n        for word in individual_words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n    \n    if len(p_words) < 2:\n        raise ValueError(\"At least two words starting with 'p' are required\")\n    \n    return (p_words[0], p_words[1])"], "responses": ["\nfrom typing import List, Tuple\n\ndef start_withp(words: List[str]) -> Tuple[str, str]:\n    \"\"\"\n    Write a function to return two words from a list of words starting with letter 'p'.\n    \"\"\"\n    p_words = []\n    \n    # Split each string into individual words and check each word\n    for item in words:\n        # Split by space to get individual words\n        individual_words = item.split()\n        for word in individual_words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n    \n    if len(p_words) < 2:\n        raise ValueError(\"At least two words starting with 'p' are required\")\n    \n    return (p_words[0], p_words[1])\n\n\n"], "prompt_tokens": [3561], "completion_tokens": [1684], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_305_start_withp"}
{"name": "mbpp_617_min_Jumps", "language": "Python3", "prompt": "from typing import Tuple\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    \"\"\"\n\tWrite a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Jumps", "test": "def check(candidate):\n    assert candidate((3, 4), 11) == 3.5\n    assert candidate((3, 4), 0) == 0\n    assert candidate((11, 14), 11) == 1\n\ndef test_check():\n    check(min_Jumps)\n\ntest_check()\n", "sample_io": ["assert min_Jumps((3, 4), 11) == 3.5"], "source_codes": ["import math\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0.0\n    \n    step1, step2 = steps\n    \n    # BFS approach\n    queue = deque([(0.0, 0.0, 0.0)])  # (x, y, jumps)\n    visited = set()\n    visited.add((0, 0))\n    \n    # Limit search space\n    max_distance = d + max(step1, step2) * 5\n    \n    while queue:\n        x, y, jumps = queue.popleft()\n        \n        # Check if we've reached the target\n        if abs(x - d) < 1e-9 and abs(y) < 1e-9:\n            return jumps\n        \n        # Pruning: if we're already too far, skip\n        if abs(x) > max_distance or abs(y) > max_distance:\n            continue\n            \n        # Try all possible moves with both step sizes\n        for step in [step1, step2]:\n            # Try 8 directions for movement\n            directions = [\n                (1, 0), (-1, 0), (0, 1), (0, -1),  # Cardinal directions\n                (1, 1), (1, -1), (-1, 1), (-1, -1)  # Diagonals\n            ]\n            \n            for dx, dy in directions:\n                # Normalize the direction vector\n                if dx != 0 and dy != 0:  # Diagonal\n                    length = math.sqrt(dx*dx + dy*dy)\n                    actual_dx = dx * step / length\n                    actual_dy = dy * step / length\n                else:  # Cardinal\n                    actual_dx = dx * step\n                    actual_dy = dy * step\n                \n                nx, ny = x + actual_dx, y + actual_dy\n                \n                # Check if we've reached the target\n                if abs(nx - d) < 1e-9 and abs(ny) < 1e-9:\n                    return jumps + 1.0\n                \n                # Quantize coordinates for visited set to handle floating point precision\n                nx_key = round(nx * 1000)\n                ny_key = round(ny * 1000)\n                \n                # Add to queue if within bounds and not visited\n                if (abs(nx) <= max_distance and abs(ny) <= max_distance and \n                    (nx_key, ny_key) not in visited):\n                    visited.add((nx_key, ny_key))\n                    queue.append((nx, ny, jumps + 1.0))\n    \n    return float('inf')"], "responses": ["\nfrom typing import Tuple\nfrom collections import deque\nimport math\n\ndef min_Jumps(steps: Tuple[int, int], d: int) -> float:\n    if d == 0:\n        return 0.0\n    \n    step1, step2 = steps\n    \n    # BFS approach\n    queue = deque([(0.0, 0.0, 0.0)])  # (x, y, jumps)\n    visited = set()\n    visited.add((0, 0))\n    \n    # Limit search space\n    max_distance = d + max(step1, step2) * 5\n    \n    while queue:\n        x, y, jumps = queue.popleft()\n        \n        # Check if we've reached the target\n        if abs(x - d) < 1e-9 and abs(y) < 1e-9:\n            return jumps\n        \n        # Pruning: if we're already too far, skip\n        if abs(x) > max_distance or abs(y) > max_distance:\n            continue\n            \n        # Try all possible moves with both step sizes\n        for step in [step1, step2]:\n            # Try 8 directions for movement\n            directions = [\n                (1, 0), (-1, 0), (0, 1), (0, -1),  # Cardinal directions\n                (1, 1), (1, -1), (-1, 1), (-1, -1)  # Diagonals\n            ]\n            \n            for dx, dy in directions:\n                # Normalize the direction vector\n                if dx != 0 and dy != 0:  # Diagonal\n                    length = math.sqrt(dx*dx + dy*dy)\n                    actual_dx = dx * step / length\n                    actual_dy = dy * step / length\n                else:  # Cardinal\n                    actual_dx = dx * step\n                    actual_dy = dy * step\n                \n                nx, ny = x + actual_dx, y + actual_dy\n                \n                # Check if we've reached the target\n                if abs(nx - d) < 1e-9 and abs(ny) < 1e-9:\n                    return jumps + 1.0\n                \n                # Quantize coordinates for visited set to handle floating point precision\n                nx_key = round(nx * 1000)\n                ny_key = round(ny * 1000)\n                \n                # Add to queue if within bounds and not visited\n                if (abs(nx) <= max_distance and abs(ny) <= max_distance and \n                    (nx_key, ny_key) not in visited):\n                    visited.add((nx_key, ny_key))\n                    queue.append((nx, ny, jumps + 1.0))\n    \n    return float('inf')\n\n\n"], "prompt_tokens": [7525], "completion_tokens": [6040], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_617_min_Jumps"}
{"name": "mbpp_117_list_to_float", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n\tWrite a function to convert all possible convertible elements in a list of lists to floats.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "list_to_float", "test": "def check(candidate):\n    assert candidate([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\n    assert candidate([('4', '4'), ('2', '27'), ('4.12', '9'), ('7', '11')]) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\n    assert candidate([('6', '78'), ('5', '26.45'), ('1.33', '4'), ('82', '13')]) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\n\ndef test_check():\n    check(list_to_float)\n\ntest_check()\n", "sample_io": ["assert list_to_float([('3', '4'), ('1', '26.45'), ('7.32', '8'), ('4', '8')]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]"], "source_codes": ["def list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    Invalid strings are replaced with 0.0.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        try:\n            first_float = float(tuple_item[0])\n        except ValueError:\n            first_float = 0.0\n            \n        try:\n            second_float = float(tuple_item[1])\n        except ValueError:\n            second_float = 0.0\n            \n        result.append((first_float, second_float))\n    \n    return result"], "responses": ["\nfrom typing import List, Tuple\n\ndef list_to_float(test_list: List[Tuple[str, str]]) -> List[Tuple[float, float]]:\n    \"\"\"\n    Convert all possible convertible elements in a list of tuples to floats.\n    Invalid strings are replaced with 0.0.\n    \"\"\"\n    result = []\n    for tuple_item in test_list:\n        try:\n            first_float = float(tuple_item[0])\n        except ValueError:\n            first_float = 0.0\n            \n        try:\n            second_float = float(tuple_item[1])\n        except ValueError:\n            second_float = 0.0\n            \n        result.append((first_float, second_float))\n    \n    return result\n\n\n"], "prompt_tokens": [1934], "completion_tokens": [1211], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_117_list_to_float"}
{"name": "mbpp_425_count_element_in_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n\tWrite a function to count the number of sublists containing a particular element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_425_count_element_in_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_element_in_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'A') == 3\n    assert candidate([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']], 'E') == 1\n\ndef test_check():\n    check(count_element_in_list)\n\ntest_check()\n", "sample_io": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"], "source_codes": ["def count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Write a function to count the number of sublists containing a particular element.\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Handle edge case of empty main list\n    if not list1:\n        return 0\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        # Check if element exists in current sublist\n        if x in sublist:\n            # Increment counter if element is found\n            count += 1\n    \n    # Return final count\n    return count"], "responses": ["\nfrom typing import List, Any\n\ndef count_element_in_list(list1: List[List[Any]], x: Any) -> int:\n    \"\"\"\n    Write a function to count the number of sublists containing a particular element.\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Handle edge case of empty main list\n    if not list1:\n        return 0\n    \n    # Iterate through each sublist\n    for sublist in list1:\n        # Check if element exists in current sublist\n        if x in sublist:\n            # Increment counter if element is found\n            count += 1\n    \n    # Return final count\n    return count\n\n\n"], "prompt_tokens": [2080], "completion_tokens": [1102], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_425_count_element_in_list"}
{"name": "mbpp_67_bell_number", "language": "Python3", "prompt": "def bell_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the number of ways to partition a set of Bell numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(10) == 115975\n    assert candidate(56) == 6775685320645824322581483068371419745979053216268760300\n\ndef test_check():\n    check(bell_number)\n\ntest_check()\n", "sample_io": ["assert bell_number(2) == 2"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_67_bell_number"}
{"name": "mbpp_404_minimum", "language": "Python3", "prompt": "def minimum(a: int, b: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum of two numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "minimum", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(-5, -4) == -5\n    assert candidate(0, 0) == 0\n\ndef test_check():\n    check(minimum)\n\ntest_check()\n", "sample_io": ["assert minimum(1, 2) == 1"], "source_codes": ["def minimum(a: int, b: int) -> int:\n    \"\"\"\n    Find the minimum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n    \n    Returns:\n        int: The smaller of the two numbers\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"], "responses": ["\ndef minimum(a: int, b: int) -> int:\n    \"\"\"\n    Find the minimum of two numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n    \n    Returns:\n        int: The smaller of the two numbers\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n\n\n"], "prompt_tokens": [1713], "completion_tokens": [1126], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_404_minimum"}
{"name": "mbpp_14_find_Volume", "language": "Python3", "prompt": "def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n\tWrite a python function to find the volume of a triangular prism.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Volume", "test": "def check(candidate):\n    assert candidate(10, 8, 6) == 240\n    assert candidate(3, 2, 2) == 6\n    assert candidate(1, 2, 1) == 1\n\ndef test_check():\n    check(find_Volume)\n\ntest_check()\n", "sample_io": ["assert find_Volume(10, 8, 6) == 240"], "source_codes": ["def find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: Length of the prism\n        b: Base of the triangular face\n        h: Height of the triangular face\n    \n    Returns:\n        int: Volume of the triangular prism\n    \"\"\"\n    return (l * b * h) // 2"], "responses": ["\ndef find_Volume(l: int, b: int, h: int) -> int:\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        l: Length of the prism\n        b: Base of the triangular face\n        h: Height of the triangular face\n    \n    Returns:\n        int: Volume of the triangular prism\n    \"\"\"\n    return (l * b * h) // 2\n\n\n"], "prompt_tokens": [1309], "completion_tokens": [1210], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_14_find_Volume"}
{"name": "mbpp_8_square_nums", "language": "Python3", "prompt": "from typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find squares of individual elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "square_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30]) == [100, 400, 900]\n    assert candidate([12, 15]) == [144, 225]\n\ndef test_check():\n    check(square_nums)\n\ntest_check()\n", "sample_io": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["def square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [x ** 2 for x in nums]"], "responses": ["\nfrom typing import List\n\ndef square_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to find squares of individual elements in a list.\n    \"\"\"\n    return [x ** 2 for x in nums]\n\n\n"], "prompt_tokens": [1680], "completion_tokens": [869], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_8_square_nums"}
{"name": "mbpp_722_filter_data", "language": "Python3", "prompt": "from typing import Dict, Tuple\n\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    \"\"\"\n\tThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_data", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.9, 67) == { 'Cierra Vega': (6.2, 70), 'Kierra Gentry': (6.0, 68) }\n    assert candidate({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 5.7, 64) == { 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }\n\ndef test_check():\n    check(filter_data)\n\ntest_check()\n", "sample_io": ["assert filter_data({ 'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66) }, 6.0, 70) == { 'Cierra Vega': (6.2, 70) }"], "source_codes": ["def filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height > h and weight > w}"], "responses": ["\ndef filter_data(students: Dict[str, Tuple[float, int]], h: float, w: int) -> Dict[str, Tuple[float, int]]:\n    return {name: (height, weight) for name, (height, weight) in students.items() if height > h and weight > w}\n\n\n"], "prompt_tokens": [4232], "completion_tokens": [1717], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_722_filter_data"}
{"name": "mbpp_244_next_Perfect_Square", "language": "Python3", "prompt": "def next_Perfect_Square(N: int) -> int:\n    \"\"\"\n\tWrite a python function to find the next perfect square greater than a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_Perfect_Square", "test": "def check(candidate):\n    assert candidate(35) == 36\n    assert candidate(6) == 9\n    assert candidate(9) == 16\n\ndef test_check():\n    check(next_Perfect_Square)\n\ntest_check()\n", "sample_io": ["assert next_Perfect_Square(35) == 36"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_244_next_Perfect_Square"}
{"name": "mbpp_755_second_smallest", "language": "Python3", "prompt": "from typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find the second smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "second_smallest", "test": "def check(candidate):\n    assert candidate([1, 2, -8, -2, 0, -2]) == -2\n    assert candidate([1, 1, -0.5, 0, 2, -2, -2]) == -0.5\n    assert candidate([2, 2]) == None\n    assert candidate([2, 2, 2]) == None\n\ndef test_check():\n    check(second_smallest)\n\ntest_check()\n", "sample_io": ["assert second_smallest([1, 2, -8, -2, 0, -2]) == -2"], "source_codes": ["def second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    # Handle edge cases: empty list or single element\n    if len(numbers) < 2:\n        return None\n    \n    # Get unique values\n    unique_numbers = list(set(numbers))\n    \n    # If all elements are the same, there's no second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique values\n    unique_numbers.sort()\n    \n    # Return the second smallest (index 1)\n    return float(unique_numbers[1])"], "responses": ["\nfrom typing import List, Union, Optional\n\ndef second_smallest(numbers: List[Union[int, float]]) -> Optional[float]:\n    # Handle edge cases: empty list or single element\n    if len(numbers) < 2:\n        return None\n    \n    # Get unique values\n    unique_numbers = list(set(numbers))\n    \n    # If all elements are the same, there's no second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique values\n    unique_numbers.sort()\n    \n    # Return the second smallest (index 1)\n    return float(unique_numbers[1])\n\n\n"], "prompt_tokens": [2055], "completion_tokens": [1136], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_755_second_smallest"}
{"name": "mbpp_405_check_tuplex", "language": "Python3", "prompt": "from typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    \"\"\"\n\tWrite a function to check whether an element exists within a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_405_check_tuplex.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_tuplex", "test": "def check(candidate):\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], '5') == False\n    assert candidate(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 3) == True\n\ndef test_check():\n    check(check_tuplex)\n\ntest_check()\n", "sample_io": ["assert check_tuplex(['w', 3, 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e'], 'r') == True"], "source_codes": ["def check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    # Handle empty list case\n    if not tuplex:\n        return False\n    \n    # Check if tuple1 is iterable\n    try:\n        iter(tuple1)\n    except TypeError:\n        return False\n    \n    # Check if any element from tuplex exists in tuple1\n    for element in tuplex:\n        try:\n            if element in tuple1:\n                return True\n        except TypeError:\n            # Handle case where element cannot be compared with items in tuple1\n            continue\n    \n    return False"], "responses": ["\nfrom typing import List, Union, Any\n\ndef check_tuplex(tuplex: List[Union[str, int]], tuple1: Any) -> bool:\n    # Handle empty list case\n    if not tuplex:\n        return False\n    \n    # Check if tuple1 is iterable\n    try:\n        iter(tuple1)\n    except TypeError:\n        return False\n    \n    # Check if any element from tuplex exists in tuple1\n    for element in tuplex:\n        try:\n            if element in tuple1:\n                return True\n        except TypeError:\n            # Handle case where element cannot be compared with items in tuple1\n            continue\n    \n    return False\n\n\n"], "prompt_tokens": [4045], "completion_tokens": [1782], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_405_check_tuplex"}
{"name": "mbpp_292_find", "language": "Python3", "prompt": "def find(n: int, m: int) -> int:\n    \"\"\"\n\tWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find", "test": "def check(candidate):\n    assert candidate(10, 3) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(20, 5) == 4\n\ndef test_check():\n    check(find)\n\ntest_check()\n", "sample_io": ["assert find(10, 3) == 3"], "source_codes": ["def find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n: Dividend (integer)\n        m: Divisor (integer, non-zero)\n        \n    Returns:\n        Integer quotient rounded down (floor division result)\n    \"\"\"\n    return n // m"], "responses": ["\ndef find(n: int, m: int) -> int:\n    \"\"\"\n    Find quotient of two numbers (rounded down to the nearest integer).\n    \n    Args:\n        n: Dividend (integer)\n        m: Divisor (integer, non-zero)\n        \n    Returns:\n        Integer quotient rounded down (floor division result)\n    \"\"\"\n    return n // m\n\n\n"], "prompt_tokens": [1681], "completion_tokens": [988], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_292_find"}
{"name": "mbpp_603_get_ludic", "language": "Python3", "prompt": "from typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to get all lucid numbers smaller than or equal to a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_ludic", "test": "def check(candidate):\n    assert candidate(10) == [1, 2, 3, 5, 7]\n    assert candidate(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n    assert candidate(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n\ndef test_check():\n    check(get_ludic)\n\ntest_check()\n", "sample_io": ["assert get_ludic(10) == [1, 2, 3, 5, 7]"], "source_codes": ["def get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Initialize list with numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    result = []\n    \n    while numbers:\n        # Add the first element to result (it's a ludic number)\n        result.append(numbers[0])\n        \n        # If only one element left, it's already added to result\n        if len(numbers) == 1:\n            break\n            \n        # Get step size (the first element of remaining numbers after removing the just added one)\n        step = numbers[1]\n        \n        # Remove every 'step'-th element starting from the beginning of remaining numbers\n        # Keep elements at positions 0, 1, 2, ..., but remove those at step-1, 2*step-1, 3*step-1, etc. (0-indexed)\n        new_numbers = []\n        for i in range(1, len(numbers)):  # Start from index 1 (skip the first element we just took)\n            # For the remaining list [numbers[1], numbers[2], ...], \n            # we remove every 'step'-th element (1-indexed in this sub-list)\n            if (i) % step != 0:  # i is 1-indexed position in the sublist starting from numbers[1]\n                new_numbers.append(numbers[i])\n        numbers = [result[-1]] + new_numbers  # Put back the last ludic number?\n        # No, that's wrong. We should work on the remaining list\n        \n        # Let me restart with clearer logic:\n        new_numbers = []\n        for i in range(1, len(numbers)):  # Process elements after the first one we just took\n            # In 1-indexed terms relative to numbers[1:], position is (i-1+1) = i-th position\n            # So we remove elements at positions step, 2*step, 3*step, ... (1-indexed)\n            if (i - 1 + 1) % step != 0:  # (i) % step != 0 where i is 1-indexed position in sublist\n                new_numbers.append(numbers[i])\n        numbers = new_numbers\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef get_ludic(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    # Initialize list with numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    result = []\n    \n    while numbers:\n        # Add the first element to result (it's a ludic number)\n        result.append(numbers[0])\n        \n        # If only one element left, it's already added to result\n        if len(numbers) == 1:\n            break\n            \n        # Get step size (the first element of remaining numbers after removing the just added one)\n        step = numbers[1]\n        \n        # Remove every 'step'-th element starting from the beginning of remaining numbers\n        # Keep elements at positions 0, 1, 2, ..., but remove those at step-1, 2*step-1, 3*step-1, etc. (0-indexed)\n        new_numbers = []\n        for i in range(1, len(numbers)):  # Start from index 1 (skip the first element we just took)\n            # For the remaining list [numbers[1], numbers[2], ...], \n            # we remove every 'step'-th element (1-indexed in this sub-list)\n            if (i) % step != 0:  # i is 1-indexed position in the sublist starting from numbers[1]\n                new_numbers.append(numbers[i])\n        numbers = [result[-1]] + new_numbers  # Put back the last ludic number?\n        # No, that's wrong. We should work on the remaining list\n        \n        # Let me restart with clearer logic:\n        new_numbers = []\n        for i in range(1, len(numbers)):  # Process elements after the first one we just took\n            # In 1-indexed terms relative to numbers[1:], position is (i-1+1) = i-th position\n            # So we remove elements at positions step, 2*step, 3*step, ... (1-indexed)\n            if (i - 1 + 1) % step != 0:  # (i) % step != 0 where i is 1-indexed position in sublist\n                new_numbers.append(numbers[i])\n        numbers = new_numbers\n    \n    return result\n\n\n"], "prompt_tokens": [6501], "completion_tokens": [5812], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_603_get_ludic"}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "Python3", "prompt": "from typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_Of_Subarray_Prod", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 20\n    assert candidate([1, 2]) == 5\n    assert candidate([1, 2, 3, 4]) == 84\n\ndef test_check():\n    check(sum_Of_Subarray_Prod)\n\ntest_check()\n", "sample_io": ["assert sum_Of_Subarray_Prod([1, 2, 3]) == 20"], "source_codes": ["def sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \n    The approach uses the mathematical insight that each element at index i\n    contributes to the sum as: element_value * (i+1) * (n-i)\n    where n is the length of the array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    result = 0\n    \n    for i in range(n):\n        # Each element's contribution: value * (number of subarrays starting at or before i) \n        # * (number of subarrays ending at or after i)\n        contribution = arr[i] * (i + 1) * (n - i)\n        result += contribution\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef sum_Of_Subarray_Prod(arr: List[int]) -> int:\n    \"\"\"\n    Find sum of products of all possible sublists of a given list.\n    \n    The approach uses the mathematical insight that each element at index i\n    contributes to the sum as: element_value * (i+1) * (n-i)\n    where n is the length of the array.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    result = 0\n    \n    for i in range(n):\n        # Each element's contribution: value * (number of subarrays starting at or before i) \n        # * (number of subarrays ending at or after i)\n        contribution = arr[i] * (i + 1) * (n - i)\n        result += contribution\n    \n    return result\n\n\n"], "prompt_tokens": [2117], "completion_tokens": [1259], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_734_sum_Of_Subarray_Prod"}
{"name": "mbpp_563_extract_values", "language": "Python3", "prompt": "from typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_values", "test": "def check(candidate):\n    assert candidate('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']\n    assert candidate('\"python\",\"program\",\"language\"') == ['python', 'program', 'language']\n    assert candidate('\"red\",\"blue\",\"green\",\"yellow\"') == ['red', 'blue', 'green', 'yellow']\n\ndef test_check():\n    check(extract_values)\n\ntest_check()\n", "sample_io": ["assert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"], "source_codes": ["import re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Pattern to match content between double quotation marks\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    return matches"], "responses": ["\nimport re\nfrom typing import List\n\ndef extract_values(text: str) -> List[str]:\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    # Pattern to match content between double quotation marks\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n"], "prompt_tokens": [1595], "completion_tokens": [885], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_563_extract_values"}
{"name": "mbpp_567_issort_list", "language": "Python3", "prompt": "from typing import List\n\ndef issort_list(list1: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a specified list is sorted or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "issort_list", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n    assert candidate([1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == False\n    assert candidate([1, 2, 4, 6, 8, 10, 15, 14, 20]) == False\n\ndef test_check():\n    check(issort_list)\n\ntest_check()\n", "sample_io": ["assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_567_issort_list"}
{"name": "mbpp_475_sort_counter", "language": "Python3", "prompt": "from typing import Dict, List, Tuple\n\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a dictionary by value.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_counter", "test": "def check(candidate):\n    assert candidate({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    assert candidate({ 'Math': 400, 'Physics': 300, 'Chemistry': 250 }) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    assert candidate({ 'Math': 900, 'Physics': 1000, 'Chemistry': 1250 }) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n\ndef test_check():\n    check(sort_counter)\n\ntest_check()\n", "sample_io": ["assert sort_counter({ 'Math': 81, 'Physics': 83, 'Chemistry': 87 }) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"], "source_codes": ["def sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)"], "responses": ["\ndef sort_counter(dict1: Dict[str, int]) -> List[Tuple[str, int]]:\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n\n"], "prompt_tokens": [3661], "completion_tokens": [1117], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_475_sort_counter"}
{"name": "mbpp_65_recursive_list_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    \"\"\"\n\tWrite a function to flatten a list and sum all of its elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "recursive_list_sum", "test": "def check(candidate):\n    assert candidate([1, 2, [3, 4], [5, 6]]) == 21\n    assert candidate([7, 10, [15, 14], [19, 41]]) == 106\n    assert candidate([10, 20, [30, 40], [50, 60]]) == 210\n\ndef test_check():\n    check(recursive_list_sum)\n\ntest_check()\n", "sample_io": ["assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"], "source_codes": ["def recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, int):\n            total += element\n        else:\n            total += recursive_list_sum(element)\n    return total"], "responses": ["\nfrom typing import List, Union\n\ndef recursive_list_sum(data_list: List[Union[int, List[int]]]) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, int):\n            total += element\n        else:\n            total += recursive_list_sum(element)\n    return total\n\n\n"], "prompt_tokens": [1954], "completion_tokens": [1280], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_65_recursive_list_sum"}
{"name": "mbpp_560_union_elements", "language": "Python3", "prompt": "from typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the union of the elements of two given lists and output them in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "union_elements", "test": "def check(candidate):\n    assert candidate([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]\n    assert candidate([1, 2, 3, 4], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([11, 12, 13, 14], [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17]\n\ndef test_check():\n    check(union_elements)\n\ntest_check()\n", "sample_io": ["assert union_elements([3, 4, 5, 6], [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10]"], "source_codes": ["def union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \n    Args:\n        test_tup1: First list of integers\n        test_tup2: Second list of integers\n    \n    Returns:\n        A sorted list containing the union of elements from both input lists\n    \"\"\"\n    # Convert lists to sets to remove duplicates within each list\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation\n    union_set = set1 | set2\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef union_elements(test_tup1: List[int], test_tup2: List[int]) -> List[int]:\n    \"\"\"\n    Find the union of the elements of two given lists and output them in sorted order.\n    \n    Args:\n        test_tup1: First list of integers\n        test_tup2: Second list of integers\n    \n    Returns:\n        A sorted list containing the union of elements from both input lists\n    \"\"\"\n    # Convert lists to sets to remove duplicates within each list\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    # Perform union operation\n    union_set = set1 | set2\n    \n    # Convert back to list and sort\n    result = sorted(list(union_set))\n    \n    return result\n\n\n"], "prompt_tokens": [1968], "completion_tokens": [1079], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_560_union_elements"}
{"name": "mbpp_737_check_str", "language": "Python3", "prompt": "def check_str(string: str) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given string is starting with a vowel or not using regex.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_str", "test": "def check(candidate):\n    assert candidate('annie') == True\n    assert candidate('dawood') == False\n    assert candidate('Else') == True\n\ndef test_check():\n    check(check_str)\n\ntest_check()\n", "sample_io": ["assert check_str('annie') == True"], "source_codes": ["import re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Check if string is empty\n    if not string:\n        return False\n    \n    # Define regex pattern to match vowels at the start of string (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if string starts with a vowel\n    return bool(re.match(pattern, string))"], "responses": ["\nimport re\n\ndef check_str(string: str) -> bool:\n    \"\"\"\n    Write a function to check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    # Check if string is empty\n    if not string:\n        return False\n    \n    # Define regex pattern to match vowels at the start of string (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if string starts with a vowel\n    return bool(re.match(pattern, string))\n\n\n"], "prompt_tokens": [1651], "completion_tokens": [833], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_737_check_str"}
{"name": "mbpp_626_triangle_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef triangle_area(r: int) -> Optional[int]:\n    \"\"\"\n\tWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "triangle_area", "test": "def check(candidate):\n    assert candidate(-1) == None\n    assert candidate(0) == 0\n    assert candidate(2) == 4\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n", "sample_io": ["assert triangle_area(-1) == None"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_626_triangle_area"}
{"name": "mbpp_253_count_integer", "language": "Python3", "prompt": "from typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n\tWrite a python function that returns the number of integer elements in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_integer", "test": "def check(candidate):\n    assert candidate([1, 2, 'abc', 1.2]) == 2\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([1, 1.2, 4, 5.1]) == 2\n\ndef test_check():\n    check(count_integer)\n\ntest_check()\n", "sample_io": ["assert count_integer([1, 2, 'abc', 1.2]) == 2"], "source_codes": ["def count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count"], "responses": ["\nfrom typing import List, Union\n\ndef count_integer(list1: List[Union[int, str, float]]) -> int:\n    \"\"\"\n    Write a python function that returns the number of integer elements in a given list.\n    \"\"\"\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1790], "completion_tokens": [840], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_253_count_integer"}
{"name": "mbpp_463_max_subarray_product", "language": "Python3", "prompt": "from typing import List\n\ndef max_subarray_product(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum product subarray of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_subarray_product", "test": "def check(candidate):\n    assert candidate([1, -2, -3, 0, 7, -8, -2]) == 112\n    assert candidate([6, -3, -10, 0, 2]) == 180\n    assert candidate([-2, -40, 0, -2, -3]) == 80\n\ndef test_check():\n    check(max_subarray_product)\n\ntest_check()\n", "sample_io": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"], "source_codes": ["def max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    current_max = arr[0]\n    current_min = arr[0]\n    global_max = arr[0]\n    \n    for i in range(1, len(arr)):\n        num = arr[i]\n        \n        # If the current number is negative, swap max and min\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        # Update current max and min products\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        \n        # Update global maximum\n        global_max = max(global_max, current_max)\n    \n    return global_max"], "responses": ["\ndef max_subarray_product(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    current_max = arr[0]\n    current_min = arr[0]\n    global_max = arr[0]\n    \n    for i in range(1, len(arr)):\n        num = arr[i]\n        \n        # If the current number is negative, swap max and min\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        # Update current max and min products\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        \n        # Update global maximum\n        global_max = max(global_max, current_max)\n    \n    return global_max\n\n\n"], "prompt_tokens": [2104], "completion_tokens": [1271], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_463_max_subarray_product"}
{"name": "mbpp_223_is_majority", "language": "Python3", "prompt": "from typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    \"\"\"\n\tWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_majority", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    assert candidate([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    assert candidate([1, 1, 1, 2, 2], 5, 1) == True\n    assert candidate([1, 1, 2, 2], 5, 1) == False\n\ndef test_check():\n    check(is_majority)\n\ntest_check()\n", "sample_io": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"], "source_codes": ["def is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Check if x is the middle element\n    if n == 0 or arr[n // 2] != x:\n        return False\n    \n    # Find the first occurrence of x\n    def find_first_occurrence(arr, n, x):\n        left, right = 0, n - 1\n        first_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_pos = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return first_pos\n    \n    # Find the last occurrence of x\n    def find_last_occurrence(arr, n, x):\n        left, right = 0, n - 1\n        last_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_pos = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return last_pos\n    \n    # Get the first and last positions\n    first = find_first_occurrence(arr, n, x)\n    last = find_last_occurrence(arr, n, x)\n    \n    # If x is not found, return False (this shouldn't happen if we passed the initial check)\n    if first == -1 or last == -1:\n        return False\n    \n    # Calculate frequency\n    frequency = last - first + 1\n    \n    # Check if frequency is greater than n/2\n    return frequency > n // 2"], "responses": ["\nfrom typing import List\n\ndef is_majority(arr: List[int], n: int, x: int) -> bool:\n    # Check if x is the middle element\n    if n == 0 or arr[n // 2] != x:\n        return False\n    \n    # Find the first occurrence of x\n    def find_first_occurrence(arr, n, x):\n        left, right = 0, n - 1\n        first_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                first_pos = mid\n                right = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return first_pos\n    \n    # Find the last occurrence of x\n    def find_last_occurrence(arr, n, x):\n        left, right = 0, n - 1\n        last_pos = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                last_pos = mid\n                left = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return last_pos\n    \n    # Get the first and last positions\n    first = find_first_occurrence(arr, n, x)\n    last = find_last_occurrence(arr, n, x)\n    \n    # If x is not found, return False (this shouldn't happen if we passed the initial check)\n    if first == -1 or last == -1:\n        return False\n    \n    # Calculate frequency\n    frequency = last - first + 1\n    \n    # Check if frequency is greater than n/2\n    return frequency > n // 2\n\n\n"], "prompt_tokens": [2744], "completion_tokens": [1970], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_223_is_majority"}
{"name": "mbpp_794_text_starta_endb", "language": "Python3", "prompt": "def text_starta_endb(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_starta_endb", "test": "def check(candidate):\n    assert candidate('aabbbb') == True\n    assert candidate('aabAbbbc') == False\n    assert candidate('accddbbjjj') == False\n\ndef test_check():\n    check(text_starta_endb)\n\ntest_check()\n", "sample_io": ["assert text_starta_endb('aabbbb') == True"], "source_codes": ["def text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Check if string has at least 2 characters\n    if len(text) < 2:\n        return False\n    \n    # Check if first character is 'a' and last character is 'b'\n    return text[0] == 'a' and text[-1] == 'b'"], "responses": ["\ndef text_starta_endb(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Check if string has at least 2 characters\n    if len(text) < 2:\n        return False\n    \n    # Check if first character is 'a' and last character is 'b'\n    return text[0] == 'a' and text[-1] == 'b'\n\n\n"], "prompt_tokens": [1854], "completion_tokens": [898], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_794_text_starta_endb"}
{"name": "mbpp_79_word_len", "language": "Python3", "prompt": "def word_len(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the length of the word is odd or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "word_len", "test": "def check(candidate):\n    assert candidate('Hadoop') == False\n    assert candidate('great') == True\n    assert candidate('structure') == True\n\ndef test_check():\n    check(word_len)\n\ntest_check()\n", "sample_io": ["assert word_len('Hadoop') == False"], "source_codes": ["def word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1"], "responses": ["\ndef word_len(s: str) -> bool:\n    \"\"\"\n    Write a python function to check whether the length of the word is odd or not.\n    \"\"\"\n    return len(s) % 2 == 1\n\n\n"], "prompt_tokens": [1402], "completion_tokens": [618], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_79_word_len"}
{"name": "mbpp_390_add_string", "language": "Python3", "prompt": "from typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to apply a given format string to all of the elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_string", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']\n    assert candidate(['a', 'b', 'c', 'd'], 'python{0}') == ['pythona', 'pythonb', 'pythonc', 'pythond']\n    assert candidate([5, 6, 7, 8], 'string{0}') == ['string5', 'string6', 'string7', 'string8']\n\ndef test_check():\n    check(add_string)\n\ntest_check()\n", "sample_io": ["assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"], "source_codes": ["def add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(str(item)) for item in list_]"], "responses": ["\nfrom typing import List, Any\n\ndef add_string(list_: List[Any], string: str) -> List[str]:\n    \"\"\"\n    Write a function to apply a given format string to all of the elements in a list.\n    \"\"\"\n    return [string.format(str(item)) for item in list_]\n\n\n"], "prompt_tokens": [1964], "completion_tokens": [1112], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_390_add_string"}
{"name": "mbpp_741_all_Characters_Same", "language": "Python3", "prompt": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n\tWrite a python function to check whether all the characters are same or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_Characters_Same", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('aaa') == True\n    assert candidate('data') == False\n\ndef test_check():\n    check(all_Characters_Same)\n\ntest_check()\n", "sample_io": ["assert all_Characters_Same('python') == False"], "source_codes": ["def all_Characters_Same(s: str) -> bool:\n    # Handle edge cases\n    if len(s) <= 1:\n        return True\n    \n    # Set the first character as reference\n    reference_char = s[0]\n    \n    # Traverse the string starting from the second character\n    for i in range(1, len(s)):\n        # If any character differs from the reference, return False\n        if s[i] != reference_char:\n            return False\n    \n    # If loop completes, all characters are the same\n    return True"], "responses": ["\ndef all_Characters_Same(s: str) -> bool:\n    # Handle edge cases\n    if len(s) <= 1:\n        return True\n    \n    # Set the first character as reference\n    reference_char = s[0]\n    \n    # Traverse the string starting from the second character\n    for i in range(1, len(s)):\n        # If any character differs from the reference, return False\n        if s[i] != reference_char:\n            return False\n    \n    # If loop completes, all characters are the same\n    return True\n\n\n"], "prompt_tokens": [1574], "completion_tokens": [770], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_741_all_Characters_Same"}
{"name": "mbpp_775_odd_position", "language": "Python3", "prompt": "from typing import List\n\ndef odd_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every odd index contains odd numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_position", "test": "def check(candidate):\n    assert candidate([2, 1, 4, 3, 6, 7, 6, 3]) == True\n    assert candidate([4, 1, 2]) == True\n    assert candidate([1, 2, 3]) == False\n\ndef test_check():\n    check(odd_position)\n\ntest_check()\n", "sample_io": ["assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_775_odd_position"}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "Python3", "prompt": "from typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    \"\"\"\n\tWrite a python function to reverse an array upto a given position.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_Array_Upto_K", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n    assert candidate([4, 5, 6, 7], 2) == [5, 4, 6, 7]\n    assert candidate([9, 8, 7, 6, 5], 3) == [7, 8, 9, 6, 5]\n\ndef test_check():\n    check(reverse_Array_Upto_K)\n\ntest_check()\n", "sample_io": ["assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"], "source_codes": ["def reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    # Handle edge case when input array is empty\n    if not input:\n        return []\n    \n    # If k is 0 or negative, return original array unchanged\n    if k <= 0:\n        return input[:]\n    \n    # Determine the effective reversal range\n    effective_k = min(k, len(input))\n    \n    # Extract the portion to be reversed and reverse it\n    reversed_part = input[:effective_k][::-1]\n    \n    # Extract the remaining unchanged part\n    remaining_part = input[effective_k:]\n    \n    # Concatenate the reversed portion with the remaining part\n    return reversed_part + remaining_part"], "responses": ["\nfrom typing import List\n\ndef reverse_Array_Upto_K(input: List[int], k: int) -> List[int]:\n    # Handle edge case when input array is empty\n    if not input:\n        return []\n    \n    # If k is 0 or negative, return original array unchanged\n    if k <= 0:\n        return input[:]\n    \n    # Determine the effective reversal range\n    effective_k = min(k, len(input))\n    \n    # Extract the portion to be reversed and reverse it\n    reversed_part = input[:effective_k][::-1]\n    \n    # Extract the remaining unchanged part\n    remaining_part = input[effective_k:]\n    \n    # Concatenate the reversed portion with the remaining part\n    return reversed_part + remaining_part\n\n\n"], "prompt_tokens": [2209], "completion_tokens": [1202], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_644_reverse_Array_Upto_K"}
{"name": "mbpp_588_big_diff", "language": "Python3", "prompt": "from typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the difference between largest and smallest value in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_diff", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([4, 5, 12]) == 8\n    assert candidate([9, 2, 3]) == 7\n\ndef test_check():\n    check(big_diff)\n\ntest_check()\n", "sample_io": ["assert big_diff([1, 2, 3, 4]) == 3"], "source_codes": ["def big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = nums[0]\n    max_val = nums[0]\n    \n    for num in nums[1:]:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    \n    return max_val - min_val"], "responses": ["\nfrom typing import List\n\ndef big_diff(nums: List[int]) -> int:\n    \"\"\"\n    Find the difference between largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = nums[0]\n    max_val = nums[0]\n    \n    for num in nums[1:]:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    \n    return max_val - min_val\n\n\n"], "prompt_tokens": [1686], "completion_tokens": [1035], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_588_big_diff"}
{"name": "mbpp_297_flatten_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n\tWrite a function to flatten a given nested list structure.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "flatten_list", "test": "def check(candidate):\n    assert candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    assert candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n    assert candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n\ndef test_check():\n    check(flatten_list)\n\ntest_check()\n", "sample_io": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"], "source_codes": ["def flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    result = []\n    for element in list1:\n        if isinstance(element, int):\n            result.append(element)\n        else:\n            result.extend(flatten_list(element))\n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef flatten_list(list1: List[Union[int, List]]) -> List[int]:\n    result = []\n    for element in list1:\n        if isinstance(element, int):\n            result.append(element)\n        else:\n            result.extend(flatten_list(element))\n    return result\n\n\n"], "prompt_tokens": [6379], "completion_tokens": [2676], "no_of_try": 1, "api_calls": 10, "is_solved": true, "task_id": "mbpp_297_flatten_list"}
{"name": "mbpp_445_index_multiplication", "language": "Python3", "prompt": "from typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise multiplication of list elements in the given two lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "index_multiplication", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]]\n\ndef test_check():\n    check(index_multiplication)\n\ntest_check()\n", "sample_io": ["assert index_multiplication([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]]"], "source_codes": ["def index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle edge case of empty outer lists\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    # Get dimensions\n    rows = len(test_tup1)\n    cols = len(test_tup1[0]) if rows > 0 else 0\n    \n    # Validate dimensions match\n    if rows != len(test_tup2) or cols != len(test_tup2[0]):\n        raise ValueError(\"Input lists must have the same dimensions\")\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each row\n    for i in range(rows):\n        row_result = []\n        # Iterate through each column\n        for j in range(cols):\n            # Multiply corresponding elements\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row_result.append(product)\n        result.append(row_result)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef index_multiplication(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle edge case of empty outer lists\n    if not test_tup1 or not test_tup2:\n        return []\n    \n    # Get dimensions\n    rows = len(test_tup1)\n    cols = len(test_tup1[0]) if rows > 0 else 0\n    \n    # Validate dimensions match\n    if rows != len(test_tup2) or cols != len(test_tup2[0]):\n        raise ValueError(\"Input lists must have the same dimensions\")\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each row\n    for i in range(rows):\n        row_result = []\n        # Iterate through each column\n        for j in range(cols):\n            # Multiply corresponding elements\n            product = test_tup1[i][j] * test_tup2[i][j]\n            row_result.append(product)\n        result.append(row_result)\n    \n    return result\n\n\n"], "prompt_tokens": [2199], "completion_tokens": [1409], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_445_index_multiplication"}
{"name": "mbpp_256_count_Primes_nums", "language": "Python3", "prompt": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Primes_nums", "test": "def check(candidate):\n    assert candidate(5) == 2\n    assert candidate(10) == 4\n    assert candidate(100) == 25\n\ndef test_check():\n    check(count_Primes_nums)\n\ntest_check()\n", "sample_io": ["assert count_Primes_nums(5) == 2"], "source_codes": ["def count_Primes_nums(n: int) -> int:\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as true. A value in prime[i] will finally be\n    # false if i is not a prime, else true.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p starting from p*p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count"], "responses": ["\ndef count_Primes_nums(n: int) -> int:\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries as true. A value in prime[i] will finally be\n    # false if i is not a prime, else true.\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    p = 2\n    while p * p < n:\n        # If prime[p] is not changed, then it is a prime\n        if prime[p]:\n            # Update all multiples of p starting from p*p\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    # Count all prime numbers\n    count = 0\n    for i in range(2, n):\n        if prime[i]:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1801], "completion_tokens": [1024], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_256_count_Primes_nums"}
{"name": "mbpp_170_sum_range_list", "language": "Python3", "prompt": "from typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    \"\"\"\n\tWrite a function to find the sum of numbers in a list within a range specified by two indices.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_range_list", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7) == 16\n    assert candidate([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10) == 38\n\ndef test_check():\n    check(sum_range_list)\n\ntest_check()\n", "sample_io": ["assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"], "source_codes": ["def sum_range_list(list1: List[int], m: int, n: int) -> int:\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    len_list = len(list1)\n    \n    # Handle negative indices according to Python's convention\n    if m < 0:\n        m = len_list + m\n    if n < 0:\n        n = len_list + n\n    \n    # Ensure indices are within bounds\n    m = max(0, m)\n    n = min(len_list - 1, n)\n    \n    # If m > n after adjustment, return 0 (no elements to sum)\n    if m > n:\n        return 0\n    \n    # Calculate sum using slicing\n    return sum(list1[m:n+1])"], "responses": ["\nfrom typing import List\n\ndef sum_range_list(list1: List[int], m: int, n: int) -> int:\n    # Handle empty list\n    if not list1:\n        return 0\n    \n    len_list = len(list1)\n    \n    # Handle negative indices according to Python's convention\n    if m < 0:\n        m = len_list + m\n    if n < 0:\n        n = len_list + n\n    \n    # Ensure indices are within bounds\n    m = max(0, m)\n    n = min(len_list - 1, n)\n    \n    # If m > n after adjustment, return 0 (no elements to sum)\n    if m > n:\n        return 0\n    \n    # Calculate sum using slicing\n    return sum(list1[m:n+1])\n\n\n"], "prompt_tokens": [6861], "completion_tokens": [3530], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_170_sum_range_list"}
{"name": "mbpp_71_comb_sort", "language": "Python3", "prompt": "from typing import List\n\ndef comb_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "comb_sort", "test": "def check(candidate):\n    assert candidate([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n    assert candidate([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]\n    assert candidate([99, 15, 13, 47]) == [13, 15, 47, 99]\n\ndef test_check():\n    check(comb_sort)\n\ntest_check()\n", "sample_io": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_71_comb_sort"}
{"name": "mbpp_451_remove_whitespaces", "language": "Python3", "prompt": "def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_whitespaces", "test": "def check(candidate):\n    assert candidate(' Google    Flutter ') == 'GoogleFlutter'\n    assert candidate(' Google    Dart ') == 'GoogleDart'\n    assert candidate(' iOS    Swift ') == 'iOSSwift'\n\ndef test_check():\n    check(remove_whitespaces)\n\ntest_check()\n", "sample_io": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"], "source_codes": ["def remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return \"\".join(text1.split())"], "responses": ["\ndef remove_whitespaces(text1: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return \"\".join(text1.split())\n\n\n"], "prompt_tokens": [1637], "completion_tokens": [898], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_451_remove_whitespaces"}
{"name": "mbpp_747_lcs_of_three", "language": "Python3", "prompt": "def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    \"\"\"\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lcs_of_three", "test": "def check(candidate):\n    assert candidate('AGGT12', '12TXAYB', '12XBA') == 2\n    assert candidate('Reels', 'Reelsfor', 'ReelsforReels') == 5\n    assert candidate('abcd1e2', 'bc12ea', 'bd1ea') == 3\n\ndef test_check():\n    check(lcs_of_three)\n\ntest_check()\n", "sample_io": ["assert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2"], "source_codes": ["def lcs_of_three(X: str, Y: str, Z: str) -> int:\n    # Handle edge cases\n    if not X or not Y or not Z:\n        return 0\n    \n    # Get lengths of the three strings\n    m, n, p = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table with dimensions (m+1) x (n+1) x (p+1)\n    # Initialize all values to 0\n    dp = [[[0 for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                # If all three characters match\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    # Take the maximum of the three possible subproblems\n                    dp[i][j][k] = max(\n                        dp[i - 1][j][k],    # Exclude character from X\n                        dp[i][j - 1][k],    # Exclude character from Y\n                        dp[i][j][k - 1]     # Exclude character from Z\n                    )\n    \n    # Return the length of LCS of the three full strings\n    return dp[m][n][p]"], "responses": ["\ndef lcs_of_three(X: str, Y: str, Z: str) -> int:\n    # Handle edge cases\n    if not X or not Y or not Z:\n        return 0\n    \n    # Get lengths of the three strings\n    m, n, p = len(X), len(Y), len(Z)\n    \n    # Create a 3D DP table with dimensions (m+1) x (n+1) x (p+1)\n    # Initialize all values to 0\n    dp = [[[0 for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                # If all three characters match\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    # Take the maximum of the three possible subproblems\n                    dp[i][j][k] = max(\n                        dp[i - 1][j][k],    # Exclude character from X\n                        dp[i][j - 1][k],    # Exclude character from Y\n                        dp[i][j][k - 1]     # Exclude character from Z\n                    )\n    \n    # Return the length of LCS of the three full strings\n    return dp[m][n][p]\n\n\n"], "prompt_tokens": [2189], "completion_tokens": [1371], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_747_lcs_of_three"}
{"name": "mbpp_257_swap_numbers", "language": "Python3", "prompt": "from typing import List\n\ndef swap_numbers(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in two numbers and returns a list with the second number and then the first number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_numbers", "test": "def check(candidate):\n    assert candidate(10, 20) == [20, 10]\n    assert candidate(15, 17) == [17, 15]\n    assert candidate(100, 200) == [200, 100]\n\ndef test_check():\n    check(swap_numbers)\n\ntest_check()\n", "sample_io": ["assert swap_numbers(10, 20) == [20, 10]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_257_swap_numbers"}
{"name": "mbpp_64_subject_marks", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to sort a list of tuples using the second value of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "subject_marks", "test": "def check(candidate):\n    assert candidate([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    assert candidate([('Telugu', 49), ('Hindhi', 54), ('Social', 33)]) == [('Social', 33), ('Telugu', 49), ('Hindhi', 54)]\n    assert candidate([('Physics', 96), ('Chemistry', 97), ('Biology', 45)]) == [('Biology', 45), ('Physics', 96), ('Chemistry', 97)]\n\ndef test_check():\n    check(subject_marks)\n\ntest_check()\n", "sample_io": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"], "source_codes": ["def subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])"], "responses": ["\nfrom typing import List, Tuple\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    \"\"\"\n    Write a function to sort a list of tuples using the second value of each tuple.\n    \"\"\"\n    return sorted(subjectmarks, key=lambda x: x[1])\n\n\n"], "prompt_tokens": [2088], "completion_tokens": [1031], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_64_subject_marks"}
{"name": "mbpp_116_tuple_to_int", "language": "Python3", "prompt": "from typing import Tuple\n\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    \"\"\"\n\tWrite a function to convert a given tuple of positive integers into a single integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_int", "test": "def check(candidate):\n    assert candidate((1, 2, 3)) == 123\n    assert candidate((4, 5, 6)) == 456\n    assert candidate((5, 6, 7)) == 567\n\ndef test_check():\n    check(tuple_to_int)\n\ntest_check()\n", "sample_io": ["assert tuple_to_int((1, 2, 3)) == 123"], "source_codes": ["def tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    # Convert each integer to string and concatenate them\n    concatenated_str = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated_str)"], "responses": ["\ndef tuple_to_int(nums: Tuple[int, int, int]) -> int:\n    # Convert each integer to string and concatenate them\n    concatenated_str = ''.join(str(num) for num in nums)\n    # Convert the concatenated string back to integer\n    return int(concatenated_str)\n\n\n"], "prompt_tokens": [1745], "completion_tokens": [1010], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_116_tuple_to_int"}
{"name": "mbpp_479_first_Digit", "language": "Python3", "prompt": "def first_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the first digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_Digit", "test": "def check(candidate):\n    assert candidate(123) == 1\n    assert candidate(456) == 4\n    assert candidate(12) == 1\n\ndef test_check():\n    check(first_Digit)\n\ntest_check()\n", "sample_io": ["assert first_Digit(123) == 1"], "source_codes": ["def first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The first digit of the number\n    \"\"\"\n    # Handle the edge case where n is 0\n    if n == 0:\n        return 0\n    \n    # Convert to absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Convert to string and get the first character\n    first_digit_char = str(abs_n)[0]\n    \n    # Convert back to integer and return\n    return int(first_digit_char)"], "responses": ["\ndef first_Digit(n: int) -> int:\n    \"\"\"\n    Find the first digit of a given number.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The first digit of the number\n    \"\"\"\n    # Handle the edge case where n is 0\n    if n == 0:\n        return 0\n    \n    # Convert to absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Convert to string and get the first character\n    first_digit_char = str(abs_n)[0]\n    \n    # Convert back to integer and return\n    return int(first_digit_char)\n\n\n"], "prompt_tokens": [1137], "completion_tokens": [923], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_479_first_Digit"}
{"name": "mbpp_118_string_to_list", "language": "Python3", "prompt": "from typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n\tWrite a function to convert a string to a list of strings split on the space character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "string_to_list", "test": "def check(candidate):\n    assert candidate('python programming') == ['python', 'programming']\n    assert candidate('lists tuples strings') == ['lists', 'tuples', 'strings']\n    assert candidate('write a program') == ['write', 'a', 'program']\n\ndef test_check():\n    check(string_to_list)\n\ntest_check()\n", "sample_io": ["assert string_to_list('python programming') == ['python', 'programming']"], "source_codes": ["def string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()"], "responses": ["\nfrom typing import List\n\ndef string_to_list(string: str) -> List[str]:\n    \"\"\"\n    Write a function to convert a string to a list of strings split on the space character.\n    \"\"\"\n    return string.split()\n\n\n"], "prompt_tokens": [1517], "completion_tokens": [745], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_118_string_to_list"}
{"name": "mbpp_763_find_min_diff", "language": "Python3", "prompt": "from typing import List\n\ndef find_min_diff(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_min_diff", "test": "def check(candidate):\n    assert candidate([1, 5, 3, 19, 18, 25], 6) == 1\n    assert candidate([4, 3, 2, 6], 4) == 1\n    assert candidate([30, 5, 20, 9], 4) == 4\n\ndef test_check():\n    check(find_min_diff)\n\ntest_check()\n", "sample_io": ["assert find_min_diff([1, 5, 3, 19, 18, 25], 6) == 1"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_763_find_min_diff"}
{"name": "mbpp_408_k_smallest_pairs", "language": "Python3", "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "k_smallest_pairs", "test": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n", "sample_io": ["assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"], "source_codes": ["import heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, i, j)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Set to keep track of visited indices\n    visited = set()\n    visited.add((0, 0))\n    result = []\n    \n    while heap and len(result) < k:\n        # Pop the smallest sum pair\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    if not nums1 or not nums2 or k == 0:\n        return []\n    \n    # Min heap to store (sum, i, j)\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    # Set to keep track of visited indices\n    visited = set()\n    visited.add((0, 0))\n    result = []\n    \n    while heap and len(result) < k:\n        # Pop the smallest sum pair\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Add next possible pairs\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n            \n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result\n\n\n"], "prompt_tokens": [2323], "completion_tokens": [1396], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_408_k_smallest_pairs"}
{"name": "mbpp_748_capital_words_spaces", "language": "Python3", "prompt": "def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n\tWrite a function to put spaces between words starting with capital letters in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "capital_words_spaces", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('PythonProgrammingExamples') == 'Python Programming Examples'\n    assert candidate('GetReadyToBeCodingFreak') == 'Get Ready To Be Coding Freak'\n\ndef test_check():\n    check(capital_words_spaces)\n\ntest_check()\n", "sample_io": ["assert capital_words_spaces('Python') == 'Python'"], "source_codes": ["def capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return \"\"\n    \n    result = [str1[0]]  # Start with the first character\n    \n    for i in range(1, len(str1)):\n        # If current character is uppercase, add a space before it\n        if str1[i].isupper():\n            result.append(' ')\n        result.append(str1[i])\n    \n    return ''.join(result)"], "responses": ["\ndef capital_words_spaces(str1: str) -> str:\n    \"\"\"\n    Write a function to put spaces between words starting with capital letters in a given string.\n    \"\"\"\n    if not str1:\n        return \"\"\n    \n    result = [str1[0]]  # Start with the first character\n    \n    for i in range(1, len(str1)):\n        # If current character is uppercase, add a space before it\n        if str1[i].isupper():\n            result.append(' ')\n        result.append(str1[i])\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [1587], "completion_tokens": [757], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_748_capital_words_spaces"}
{"name": "mbpp_252_convert", "language": "Python3", "prompt": "from typing import Tuple\n\ndef convert(numbers: int) -> Tuple[float, float]:\n    \"\"\"\n\tWrite a python function to convert complex numbers to polar coordinates.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "convert", "test": "def check(candidate):\n    assert candidate(1) == (1.0, 0.0)\n    assert candidate(4) == (4.0, 0.0)\n    assert candidate(5) == (5.0, 0.0)\n\ndef test_check():\n    check(convert)\n\ntest_check()\n", "sample_io": ["assert convert(1) == (1.0, 0.0)"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_252_convert"}
{"name": "mbpp_436_neg_nos", "language": "Python3", "prompt": "from typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to return the negative numbers in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "neg_nos", "test": "def check(candidate):\n    assert candidate([-1, 4, 5, -6]) == [-1, -6]\n    assert candidate([-1, -2, 3, 4]) == [-1, -2]\n    assert candidate([-7, -6, 8, 9]) == [-7, -6]\n\ndef test_check():\n    check(neg_nos)\n\ntest_check()\n", "sample_io": ["assert neg_nos([-1, 4, 5, -6]) == [-1, -6]"], "source_codes": ["def neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]"], "responses": ["\nfrom typing import List\n\ndef neg_nos(list1: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n    \"\"\"\n    return [num for num in list1 if num < 0]\n\n\n"], "prompt_tokens": [1886], "completion_tokens": [928], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_436_neg_nos"}
{"name": "mbpp_397_median_numbers", "language": "Python3", "prompt": "def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_numbers", "test": "def check(candidate):\n    assert candidate(25, 55, 65) == 55.0\n    assert candidate(20, 10, 30) == 20.0\n    assert candidate(15, 45, 75) == 45.0\n\ndef test_check():\n    check(median_numbers)\n\ntest_check()\n", "sample_io": ["assert median_numbers(25, 55, 65) == 55.0"], "source_codes": ["def median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        c (int): Third number\n        \n    Returns:\n        float: The median of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))"], "responses": ["\ndef median_numbers(a: int, b: int, c: int) -> float:\n    \"\"\"\n    Find the median of three numbers.\n    \n    Args:\n        a (int): First number\n        b (int): Second number\n        c (int): Third number\n        \n    Returns:\n        float: The median of the three numbers\n    \"\"\"\n    return float(a + b + c - min(a, b, c) - max(a, b, c))\n\n\n"], "prompt_tokens": [2001], "completion_tokens": [1217], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_397_median_numbers"}
{"name": "mbpp_462_combinations_list", "language": "Python3", "prompt": "from typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    \"\"\"\n\tWrite a function to find all possible combinations of the elements of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_list", "test": "def check(candidate):\n    assert candidate(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    assert candidate(['red', 'green', 'blue', 'white', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]\n    assert candidate(['red', 'green', 'black', 'orange']) == [[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]\n\ndef test_check():\n    check(combinations_list)\n\ntest_check()\n", "sample_io": ["assert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"], "source_codes": ["def combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    if not list1:\n        return [[]]\n    \n    result = [[]]\n    \n    for element in list1:\n        new_combinations = []\n        for combination in result:\n            new_combinations.append(combination + [element])\n        result.extend(new_combinations)\n    \n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef combinations_list(list1: List[str]) -> List[Union[List[None], List[str]]]:\n    if not list1:\n        return [[]]\n    \n    result = [[]]\n    \n    for element in list1:\n        new_combinations = []\n        for combination in result:\n            new_combinations.append(combination + [element])\n        result.extend(new_combinations)\n    \n    return result\n\n\n"], "prompt_tokens": [6690], "completion_tokens": [2730], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_462_combinations_list"}
{"name": "mbpp_745_divisible_by_digits", "language": "Python3", "prompt": "from typing import List\n\ndef divisible_by_digits(startnum: int, endnum: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisible_by_digits", "test": "def check(candidate):\n    assert candidate(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    assert candidate(1, 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n    assert candidate(20, 25) == [22, 24]\n\ndef test_check():\n    check(divisible_by_digits)\n\ntest_check()\n", "sample_io": ["assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_745_divisible_by_digits"}
{"name": "mbpp_554_Split", "language": "Python3", "prompt": "from typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function which takes a list of integers and only returns the odd ones.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Split", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n    assert candidate([10, 11, 12, 13]) == [11, 13]\n    assert candidate([7, 8, 9, 1]) == [7, 9, 1]\n\ndef test_check():\n    check(Split)\n\ntest_check()\n", "sample_io": ["assert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"], "source_codes": ["def Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]"], "responses": ["\nfrom typing import List\n\ndef Split(list: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function which takes a list of integers and only returns the odd ones.\n    \"\"\"\n    return [num for num in list if num % 2 != 0]\n\n\n"], "prompt_tokens": [1888], "completion_tokens": [890], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_554_Split"}
{"name": "mbpp_128_long_words", "language": "Python3", "prompt": "from typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n\tWrite a function to find words that are longer than n characters from a given list of words.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "long_words", "test": "def check(candidate):\n    assert candidate(3, 'python is a programming language') == ['python', 'programming', 'language']\n    assert candidate(2, 'writing a program') == ['writing', 'program']\n    assert candidate(5, 'sorting list') == ['sorting']\n\ndef test_check():\n    check(long_words)\n\ntest_check()\n", "sample_io": ["assert long_words(3, 'python is a programming language') == ['python', 'programming', 'language']"], "source_codes": ["def long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string.\n    \n    Args:\n        n: Minimum length threshold (words must be longer than this)\n        str: Input string containing words separated by whitespace\n        \n    Returns:\n        List of words that are longer than n characters\n    \"\"\"\n    # Handle empty string case\n    if not str:\n        return []\n    \n    # Split the string into words and filter those longer than n\n    words = str.split()\n    return [word for word in words if len(word) > n]"], "responses": ["\nfrom typing import List\n\ndef long_words(n: int, str: str) -> List[str]:\n    \"\"\"\n    Find words that are longer than n characters from a given string.\n    \n    Args:\n        n: Minimum length threshold (words must be longer than this)\n        str: Input string containing words separated by whitespace\n        \n    Returns:\n        List of words that are longer than n characters\n    \"\"\"\n    # Handle empty string case\n    if not str:\n        return []\n    \n    # Split the string into words and filter those longer than n\n    words = str.split()\n    return [word for word in words if len(word) > n]\n\n\n"], "prompt_tokens": [1915], "completion_tokens": [1105], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_128_long_words"}
{"name": "mbpp_69_is_sublist", "language": "Python3", "prompt": "from typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check whether a list contains the given sublist or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_sublist", "test": "def check(candidate):\n    assert candidate([2, 4, 3, 5, 7], [3, 7]) == False\n    assert candidate([2, 4, 3, 5, 7], [4, 3]) == True\n    assert candidate([2, 4, 3, 5, 7], [1, 6]) == False\n\ndef test_check():\n    check(is_sublist)\n\ntest_check()\n", "sample_io": ["assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"], "source_codes": ["def is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge case: empty sublist is always a sublist\n    if not s:\n        return True\n    \n    # Handle edge case: sublist longer than main list\n    if len(s) > len(l):\n        return False\n    \n    # Iterate through main list up to where sublist can still fit\n    for i in range(len(l) - len(s) + 1):\n        # Check if sublist matches starting at position i\n        match = True\n        for j in range(len(s)):\n            if l[i + j] != s[j]:\n                match = False\n                break\n        \n        # If we found a complete match, return True\n        if match:\n            return True\n    \n    # No match found after checking all positions\n    return False"], "responses": ["\nfrom typing import List\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n    # Handle edge case: empty sublist is always a sublist\n    if not s:\n        return True\n    \n    # Handle edge case: sublist longer than main list\n    if len(s) > len(l):\n        return False\n    \n    # Iterate through main list up to where sublist can still fit\n    for i in range(len(l) - len(s) + 1):\n        # Check if sublist matches starting at position i\n        match = True\n        for j in range(len(s)):\n            if l[i + j] != s[j]:\n                match = False\n                break\n        \n        # If we found a complete match, return True\n        if match:\n            return True\n    \n    # No match found after checking all positions\n    return False\n\n\n"], "prompt_tokens": [2242], "completion_tokens": [1200], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_69_is_sublist"}
{"name": "mbpp_431_common_element", "language": "Python3", "prompt": "from typing import List, Any, Optional\n\ndef common_element(list1: List[Any], list2: List[Any]) -> Optional[bool]:\n    \"\"\"\n\tWrite a function that takes two lists and returns true if they have at least one common element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "common_element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True\n    assert candidate([1, 2, 3, 4, 5], [6, 7, 8, 9]) == None\n    assert candidate(['a', 'b', 'c'], ['d', 'b', 'e']) == True\n\ndef test_check():\n    check(common_element)\n\ntest_check()\n", "sample_io": ["assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_431_common_element"}
{"name": "mbpp_732_replace_specialchar", "language": "Python3", "prompt": "def replace_specialchar(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_specialchar", "test": "def check(candidate):\n    assert candidate('Python language, Programming language.') == 'Python:language::Programming:language:'\n    assert candidate('a b c,d e f') == 'a:b:c:d:e:f'\n    assert candidate('ram reshma,ram rahim') == 'ram:reshma:ram:rahim'\n\ndef test_check():\n    check(replace_specialchar)\n\ntest_check()\n", "sample_io": ["assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"], "source_codes": ["import re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)"], "responses": ["\nimport re\n\ndef replace_specialchar(text: str) -> str:\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n\n\n"], "prompt_tokens": [1688], "completion_tokens": [745], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_732_replace_specialchar"}
{"name": "mbpp_141_pancake_sort", "language": "Python3", "prompt": "from typing import List\n\ndef pancake_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort a list of elements.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pancake_sort", "test": "def check(candidate):\n    assert candidate([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n    assert candidate([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]\n    assert candidate([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]\n\ndef test_check():\n    check(pancake_sort)\n\ntest_check()\n", "sample_io": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_141_pancake_sort"}
{"name": "mbpp_308_large_product", "language": "Python3", "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "large_product", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n", "sample_io": ["assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"], "source_codes": ["import heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Use a min-heap to keep track of the N largest products\n    heap = []\n    \n    # Generate all possible products\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(heap) < N:\n                heapq.heappush(heap, product)\n            else:\n                # If current product is larger than the smallest in heap, replace it\n                if product > heap[0]:\n                    heapq.heapreplace(heap, product)\n    \n    # Extract elements from heap and sort in descending order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    # Reverse to get descending order\n    return result[::-1]"], "responses": ["\nfrom typing import List\nimport heapq\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    # Handle edge cases\n    if not nums1 or not nums2 or N <= 0:\n        return []\n    \n    # Use a min-heap to keep track of the N largest products\n    heap = []\n    \n    # Generate all possible products\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(heap) < N:\n                heapq.heappush(heap, product)\n            else:\n                # If current product is larger than the smallest in heap, replace it\n                if product > heap[0]:\n                    heapq.heapreplace(heap, product)\n    \n    # Extract elements from heap and sort in descending order\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    # Reverse to get descending order\n    return result[::-1]\n\n\n"], "prompt_tokens": [2359], "completion_tokens": [1351], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_308_large_product"}
{"name": "mbpp_293_otherside_rightangle", "language": "Python3", "prompt": "def otherside_rightangle(w: int, h: int) -> float:\n    \"\"\"\n\tWrite a function to find the third side of a right angled triangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "otherside_rightangle", "test": "def check(candidate):\n    assert candidate(7, 8) == 10.63014581273465\n    assert candidate(3, 4) == 5\n    assert candidate(7, 15) == 16.55294535724685\n\ndef test_check():\n    check(otherside_rightangle)\n\ntest_check()\n", "sample_io": ["assert otherside_rightangle(7, 8) == 10.63014581273465"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_293_otherside_rightangle"}
{"name": "mbpp_106_add_lists", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    \"\"\"\n\tWrite a function to append the given list to the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_lists", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    assert candidate([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\n    assert candidate([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)\n\ndef test_check():\n    check(add_lists)\n\ntest_check()\n", "sample_io": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"], "source_codes": ["def add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    # Convert the list to a tuple and concatenate with the existing tuple\n    result = test_tup + tuple(test_list)\n    return result"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_lists(test_list: List[int], test_tup: Tuple[int, int]) -> Tuple[int, int, int, int, int]:\n    # Convert the list to a tuple and concatenate with the existing tuple\n    result = test_tup + tuple(test_list)\n    return result\n\n\n"], "prompt_tokens": [1953], "completion_tokens": [1207], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_106_add_lists"}
{"name": "mbpp_720_add_dict_to_tuple", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n\tWrite a function to add a dictionary to the tuple. The output should be a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_dict_to_tuple", "test": "def check(candidate):\n    assert candidate((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })\n    assert candidate((1, 2, 3), { 'UTS': 2, 'is': 3, 'Worst': 4 }) == (1, 2, 3, { 'UTS': 2, 'is': 3, 'Worst': 4 })\n    assert candidate((8, 9, 10), { 'POS': 3, 'is': 4, 'Okay': 5 }) == (8, 9, 10, { 'POS': 3, 'is': 4, 'Okay': 5 })\n\ndef test_check():\n    check(add_dict_to_tuple)\n\ntest_check()\n", "sample_io": ["assert add_dict_to_tuple((4, 5, 6), { 'MSAM': 1, 'is': 2, 'best': 3 }) == (4, 5, 6, { 'MSAM': 1, 'is': 2, 'best': 3 })"], "source_codes": ["def add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef add_dict_to_tuple(test_tup: Tuple[int, int, int], test_dict: Dict[str, int]) -> Tuple[int, int, int, Dict[str, int]]:\n    \"\"\"\n    Write a function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return (*test_tup, test_dict)\n\n\n"], "prompt_tokens": [2061], "completion_tokens": [1099], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_720_add_dict_to_tuple"}
