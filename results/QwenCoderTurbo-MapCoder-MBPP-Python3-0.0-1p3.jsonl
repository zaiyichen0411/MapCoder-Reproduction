{"name": "mbpp_395_first_non_repeating_character", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first non-repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_non_repeating_character", "test": "def check(candidate):\n    assert candidate('abcabc') == None\n    assert candidate('abc') == 'a'\n    assert candidate('ababc') == 'c'\n\ndef test_check():\n    check(first_non_repeating_character)\n\ntest_check()\n", "sample_io": ["assert first_non_repeating_character('abcabc') == None"], "source_codes": ["def first_non_repeating_character(str1: str) -> Optional[str]:\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # No non-repeating character found\n    return None"], "responses": ["\nfrom typing import Optional\n\ndef first_non_repeating_character(str1: str) -> Optional[str]:\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Count frequency of each character\n    char_count = {}\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # No non-repeating character found\n    return None\n\n\n"], "prompt_tokens": [1696], "completion_tokens": [1042], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_395_first_non_repeating_character"}
{"name": "mbpp_457_Find_Min", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min", "test": "def check(candidate):\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1]\n    assert candidate([[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1]\n    assert candidate([['x'], ['x', 'y'], ['x', 'y', 'z']]) == ['x']\n\ndef test_check():\n    check(Find_Min)\n\ntest_check()\n", "sample_io": ["assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"], "source_codes": ["def Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_sublist = lst[0]\n    min_length = len(lst[0])\n    \n    for sublist in lst[1:]:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist"], "responses": ["\nfrom typing import List, Any\n\ndef Find_Min(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the sublist having minimum length.\n\t\"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    min_sublist = lst[0]\n    min_length = len(lst[0])\n    \n    for sublist in lst[1:]:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist\n\n\n"], "prompt_tokens": [1811], "completion_tokens": [1056], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_457_Find_Min"}
{"name": "mbpp_725_extract_quotation", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    \"\"\"\n\tWrite a function to extract values between quotation marks \" \" of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_quotation", "test": "def check(candidate):\n    assert candidate('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    assert candidate('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']\n    assert candidate('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']\n    assert candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == []\n\ndef test_check():\n    check(extract_quotation)\n\ntest_check()\n", "sample_io": ["assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"], "source_codes": ["import re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    # Pattern to match quoted strings, handling escaped quotes\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*)\"'\n    matches = re.findall(pattern, text1)\n    return matches"], "responses": ["\nimport re\nfrom typing import List, Any\n\ndef extract_quotation(text1: str) -> List[Any]:\n    # Pattern to match quoted strings, handling escaped quotes\n    pattern = r'\"((?:[^\"\\\\]|\\\\.)*)\"'\n    matches = re.findall(pattern, text1)\n    return matches\n\n\n"], "prompt_tokens": [2968], "completion_tokens": [959], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_725_extract_quotation"}
{"name": "mbpp_9_find_Rotations", "language": "Python3", "prompt": "def find_Rotations(str: str) -> int:\n    \"\"\"\n\tWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Rotations", "test": "def check(candidate):\n    assert candidate('aaaa') == 1\n    assert candidate('ab') == 2\n    assert candidate('abc') == 3\n\ndef test_check():\n    check(find_Rotations)\n\ntest_check()\n", "sample_io": ["assert find_Rotations('aaaa') == 1"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_9_find_Rotations"}
{"name": "mbpp_792_count_list", "language": "Python3", "prompt": "from typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to count the number of lists in a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_list", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    assert candidate([[1, 2], [2, 3], [4, 5]]) == 3\n    assert candidate([[1, 0], [2, 0]]) == 2\n\ndef test_check():\n    check(count_list)\n\ntest_check()\n", "sample_io": ["assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"], "source_codes": ["def count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)"], "responses": ["\nfrom typing import List\n\ndef count_list(input_list: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n    \"\"\"\n    return len(input_list)\n\n\n"], "prompt_tokens": [1627], "completion_tokens": [716], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_792_count_list"}
{"name": "mbpp_477_is_lower", "language": "Python3", "prompt": "def is_lower(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert the given string to lower case.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_lower", "test": "def check(candidate):\n    assert candidate('InValid') == 'invalid'\n    assert candidate('TruE') == 'true'\n    assert candidate('SenTenCE') == 'sentence'\n\ndef test_check():\n    check(is_lower)\n\ntest_check()\n", "sample_io": ["assert is_lower('InValid') == 'invalid'"], "source_codes": ["def is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()"], "responses": ["\ndef is_lower(string: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    \"\"\"\n    return string.lower()\n\n\n"], "prompt_tokens": [1522], "completion_tokens": [658], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_477_is_lower"}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "Python3", "prompt": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n\tWrite a python function to find the average of cubes of first n natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Average_Of_Cube", "test": "def check(candidate):\n    assert candidate(2) == 4.5\n    assert candidate(3) == 12\n    assert candidate(1) == 1\n\ndef test_check():\n    check(find_Average_Of_Cube)\n\ntest_check()\n", "sample_io": ["assert find_Average_Of_Cube(2) == 4.5"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_422_find_Average_Of_Cube"}
{"name": "mbpp_637_noprofit_noloss", "language": "Python3", "prompt": "def noprofit_noloss(actual_cost: int, sale_amount: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given amount has no profit and no loss\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "noprofit_noloss", "test": "def check(candidate):\n    assert candidate(1500, 1200) == False\n    assert candidate(100, 100) == True\n    assert candidate(2000, 5000) == False\n\ndef test_check():\n    check(noprofit_noloss)\n\ntest_check()\n", "sample_io": ["assert noprofit_noloss(1500, 1200) == False"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_637_noprofit_noloss"}
{"name": "mbpp_557_toggle_string", "language": "Python3", "prompt": "def toggle_string(string: str) -> str:\n    \"\"\"\n\tWrite a function to toggle the case of all characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_string", "test": "def check(candidate):\n    assert candidate('Python') == 'pYTHON'\n    assert candidate('Pangram') == 'pANGRAM'\n    assert candidate('LIttLE') == 'liTTle'\n\ndef test_check():\n    check(toggle_string)\n\ntest_check()\n", "sample_io": ["assert toggle_string('Python') == 'pYTHON'"], "source_codes": ["def toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    if not string:\n        return \"\"\n    \n    result = []\n    for char in string:\n        if char.isalpha():\n            if char.isupper():\n                result.append(char.lower())\n            else:\n                result.append(char.upper())\n        else:\n            result.append(char)\n    \n    return \"\".join(result)"], "responses": ["\ndef toggle_string(string: str) -> str:\n    \"\"\"\n    Write a function to toggle the case of all characters in a string.\n    \"\"\"\n    if not string:\n        return \"\"\n    \n    result = []\n    for char in string:\n        if char.isalpha():\n            if char.isupper():\n                result.append(char.lower())\n            else:\n                result.append(char.upper())\n        else:\n            result.append(char)\n    \n    return \"\".join(result)\n\n\n"], "prompt_tokens": [1643], "completion_tokens": [789], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_557_toggle_string"}
{"name": "mbpp_786_right_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the right insertion point for a specified value in sorted order.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "right_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(right_insertion)\n\ntest_check()\n", "sample_io": ["assert right_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["def right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"], "responses": ["\nfrom typing import List\n\ndef right_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "prompt_tokens": [1955], "completion_tokens": [977], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_786_right_insertion"}
{"name": "mbpp_807_first_odd", "language": "Python3", "prompt": "from typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the first odd number in a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5]) == 1\n    assert candidate([2, 4, 1, 3]) == 1\n    assert candidate([8, 9, 1]) == 9\n\ndef test_check():\n    check(first_odd)\n\ntest_check()\n", "sample_io": ["assert first_odd([1, 3, 5]) == 1"], "source_codes": ["def first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list\n        \n    Raises:\n        ValueError: If no odd number is found in the list\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    \n    raise ValueError(\"No odd number found in the list\")"], "responses": ["\nfrom typing import List\n\ndef first_odd(nums: List[int]) -> int:\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The first odd number in the list\n        \n    Raises:\n        ValueError: If no odd number is found in the list\n    \"\"\"\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    \n    raise ValueError(\"No odd number found in the list\")\n\n\n"], "prompt_tokens": [1764], "completion_tokens": [1018], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_807_first_odd"}
{"name": "mbpp_631_replace_spaces", "language": "Python3", "prompt": "def replace_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to replace whitespaces with an underscore and vice versa in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_spaces", "test": "def check(candidate):\n    assert candidate('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    assert candidate('The_Avengers') == 'The Avengers'\n    assert candidate('Fast and Furious') == 'Fast_and_Furious'\n\ndef test_check():\n    check(replace_spaces)\n\ntest_check()\n", "sample_io": ["assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_631_replace_spaces"}
{"name": "mbpp_573_unique_product", "language": "Python3", "prompt": "from typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to calculate the product of the unique numbers in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_product", "test": "def check(candidate):\n    assert candidate([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n    assert candidate([1, 2, 3, 1]) == 6\n    assert candidate([7, 8, 9, 0, 1, 1]) == 0\n\ndef test_check():\n    check(unique_product)\n\ntest_check()\n", "sample_io": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"], "source_codes": ["def unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a python function to calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 1 (multiplicative identity)\n    if not list_data:\n        return 1\n    \n    # Convert the input list to a set to eliminate duplicate elements\n    unique_numbers = set(list_data)\n    \n    # Initialize a product variable to 1\n    product = 1\n    \n    # Iterate through each unique element in the set\n    for num in unique_numbers:\n        # Multiply the current product by each element\n        product *= num\n    \n    # Return the final product value\n    return product"], "responses": ["\nfrom typing import List\n\ndef unique_product(list_data: List[int]) -> int:\n    \"\"\"\n    Write a python function to calculate the product of the unique numbers in a given list.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 1 (multiplicative identity)\n    if not list_data:\n        return 1\n    \n    # Convert the input list to a set to eliminate duplicate elements\n    unique_numbers = set(list_data)\n    \n    # Initialize a product variable to 1\n    product = 1\n    \n    # Iterate through each unique element in the set\n    for num in unique_numbers:\n        # Multiply the current product by each element\n        product *= num\n    \n    # Return the final product value\n    return product\n\n\n"], "prompt_tokens": [1665], "completion_tokens": [897], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_573_unique_product"}
{"name": "mbpp_643_text_match_wordz_middle", "language": "Python3", "prompt": "def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n\tWrite a function that checks if a strings contains 'z', except at the start and end of the word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz_middle", "test": "def check(candidate):\n    assert candidate('pythonzabc.') == True\n    assert candidate('zxyabc.') == False\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz_middle)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz_middle('pythonzabc.') == True"], "source_codes": ["def text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n    \n    # Check each word\n    for word in words:\n        # If word has less than 3 characters, z cannot be in the middle\n        if len(word) < 3:\n            continue\n            \n        # Check characters from index 1 to second-to-last index\n        for i in range(1, len(word) - 1):\n            if word[i] == 'z':\n                return True\n    \n    # If no 'z' found in middle of any word, return False\n    return False"], "responses": ["\ndef text_match_wordz_middle(text: str) -> bool:\n    \"\"\"\n    Write a function that checks if a strings contains 'z', except at the start and end of the word.\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n    \n    # Check each word\n    for word in words:\n        # If word has less than 3 characters, z cannot be in the middle\n        if len(word) < 3:\n            continue\n            \n        # Check characters from index 1 to second-to-last index\n        for i in range(1, len(word) - 1):\n            if word[i] == 'z':\n                return True\n    \n    # If no 'z' found in middle of any word, return False\n    return False\n\n\n"], "prompt_tokens": [1815], "completion_tokens": [907], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_643_text_match_wordz_middle"}
{"name": "mbpp_299_max_aggregate", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    \"\"\"\n\tWrite a function to calculate the maximum aggregate from the list of tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_aggregate", "test": "def check(candidate):\n    assert candidate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)\n    assert candidate([('Juan Whelan', 50), ('Sabah Colley', 48), ('Peter Nichols', 37), ('Juan Whelan', 22), ('Sabah Colley', 14)]) == ('Juan Whelan', 72)\n    assert candidate([('Juan Whelan', 10), ('Sabah Colley', 20), ('Peter Nichols', 30), ('Juan Whelan', 40), ('Sabah Colley', 50)]) == ('Sabah Colley', 70)\n\ndef test_check():\n    check(max_aggregate)\n\ntest_check()\n", "sample_io": ["assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"], "source_codes": ["def max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    if not stdata:\n        return (\"\", 0)\n    \n    aggregates = {}\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    max_name = \"\"\n    max_value = float('-inf')\n    for name, value in aggregates.items():\n        if value > max_value:\n            max_value = value\n            max_name = name\n    \n    return (max_name, max_value)"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_aggregate(stdata: List[Tuple[str, int]]) -> Tuple[str, int]:\n    if not stdata:\n        return (\"\", 0)\n    \n    aggregates = {}\n    for name, value in stdata:\n        if name in aggregates:\n            aggregates[name] += value\n        else:\n            aggregates[name] = value\n    \n    max_name = \"\"\n    max_value = float('-inf')\n    for name, value in aggregates.items():\n        if value > max_value:\n            max_value = value\n            max_name = name\n    \n    return (max_name, max_value)\n\n\n"], "prompt_tokens": [1900], "completion_tokens": [1000], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_299_max_aggregate"}
{"name": "mbpp_474_replace_char", "language": "Python3", "prompt": "def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n\tWrite a function to replace characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "replace_char", "test": "def check(candidate):\n    assert candidate('polygon', 'y', 'l') == 'pollgon'\n    assert candidate('character', 'c', 'a') == 'aharaater'\n    assert candidate('python', 'l', 'a') == 'python'\n\ndef test_check():\n    check(replace_char)\n\ntest_check()\n", "sample_io": ["assert replace_char('polygon', 'y', 'l') == 'pollgon'"], "source_codes": ["def replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return \"\"\n    \n    # Convert string to list for mutable operations\n    char_list = list(str1)\n    \n    # Iterate through each character with its index\n    for i, char in enumerate(char_list):\n        # If current character matches the target character\n        if char == ch:\n            # Replace it with the new character\n            char_list[i] = newch\n    \n    # Join the list back into a string and return\n    return \"\".join(char_list)"], "responses": ["\ndef replace_char(str1: str, ch: str, newch: str) -> str:\n    \"\"\"\n    Write a function to replace characters in a string.\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return \"\"\n    \n    # Convert string to list for mutable operations\n    char_list = list(str1)\n    \n    # Iterate through each character with its index\n    for i, char in enumerate(char_list):\n        # If current character matches the target character\n        if char == ch:\n            # Replace it with the new character\n            char_list[i] = newch\n    \n    # Join the list back into a string and return\n    return \"\".join(char_list)\n\n\n"], "prompt_tokens": [1738], "completion_tokens": [884], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_474_replace_char"}
{"name": "mbpp_433_check_greater", "language": "Python3", "prompt": "from typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the entered number is greater than the elements of the given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_greater", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 4) == False\n    assert candidate([2, 3, 4, 5, 6], 8) == True\n    assert candidate([9, 7, 4, 8, 6, 1], 11) == True\n\ndef test_check():\n    check(check_greater)\n\ntest_check()\n", "sample_io": ["assert check_greater([1, 2, 3, 4, 5], 4) == False"], "source_codes": ["def check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: if array is empty, return True\n    if not arr:\n        return True\n    \n    # Check if number is greater than all elements in the array\n    for element in arr:\n        if number <= element:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import List\n\ndef check_greater(arr: List[int], number: int) -> bool:\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    # Handle edge case: if array is empty, return True\n    if not arr:\n        return True\n    \n    # Check if number is greater than all elements in the array\n    for element in arr:\n        if number <= element:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1836], "completion_tokens": [902], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_433_check_greater"}
{"name": "mbpp_427_change_date_format", "language": "Python3", "prompt": "def change_date_format(dt: str) -> str:\n    \"\"\"\n\tWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "change_date_format", "test": "def check(candidate):\n    assert candidate('2026-01-02') == '02-01-2026'\n    assert candidate('2020-11-13') == '13-11-2020'\n    assert candidate('2021-04-26') == '26-04-2021'\n\ndef test_check():\n    check(change_date_format)\n\ntest_check()\n", "sample_io": ["assert change_date_format('2026-01-02') == '02-01-2026'"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_427_change_date_format"}
{"name": "mbpp_442_positive_count", "language": "Python3", "prompt": "from typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    \"\"\"\n\tWrite a function to find the ration of positive numbers in an array of integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "positive_count", "test": "def check(candidate):\n    assert candidate([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54\n    assert candidate([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56\n\ndef test_check():\n    check(positive_count)\n\ntest_check()\n", "sample_io": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"], "source_codes": ["def positive_count(nums: List[int]) -> float:\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)"], "responses": ["\nfrom typing import List\n\ndef positive_count(nums: List[int]) -> float:\n    if not nums:\n        return 0.0\n    \n    positive_count = sum(1 for num in nums if num > 0)\n    return positive_count / len(nums)\n\n\n"], "prompt_tokens": [4442], "completion_tokens": [2105], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_442_positive_count"}
{"name": "mbpp_453_sumofFactors", "language": "Python3", "prompt": "def sumofFactors(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of even factors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sumofFactors", "test": "def check(candidate):\n    assert candidate(18) == 26\n    assert candidate(30) == 48\n    assert candidate(6) == 8\n\ndef test_check():\n    check(sumofFactors)\n\ntest_check()\n", "sample_io": ["assert sumofFactors(18) == 26"], "source_codes": ["def sumofFactors(n: int) -> int:\n    if n % 2 != 0 or n == 1:\n        return 0\n    \n    # Find prime factorization\n    factors = {}\n    temp = n\n    d = 2\n    \n    while d * d <= temp:\n        while temp % d == 0:\n            if d not in factors:\n                factors[d] = 0\n            factors[d] += 1\n            temp //= d\n        d += 1\n    \n    if temp > 1:\n        factors[temp] = 1\n    \n    # If 2 is not a factor, there are no even factors\n    if 2 not in factors:\n        return 0\n    \n    # Calculate sum of even divisors\n    # For 2, we sum from 2^1 to 2^k (exclude 2^0=1 to ensure even divisors)\n    # For other primes p with power a, we sum from p^0 to p^a\n    result = 0\n    pow_2 = factors[2]\n    # Sum of 2^1 + 2^2 + ... + 2^pow_2\n    sum_2 = (2 * (2**pow_2 - 1)) // (2 - 1)  # Geometric series sum\n    \n    result = sum_2\n    \n    # For each other prime factor, calculate sum of its powers\n    for prime in factors:\n        if prime != 2:\n            power = factors[prime]\n            # Sum of 1 + p + p^2 + ... + p^power\n            if prime == 1:\n                sum_prime = power + 1\n            else:\n                sum_prime = (prime**(power + 1) - 1) // (prime - 1)\n            result *= sum_prime\n    \n    return result"], "responses": ["\ndef sumofFactors(n: int) -> int:\n    if n % 2 != 0 or n == 1:\n        return 0\n    \n    # Find prime factorization\n    factors = {}\n    temp = n\n    d = 2\n    \n    while d * d <= temp:\n        while temp % d == 0:\n            if d not in factors:\n                factors[d] = 0\n            factors[d] += 1\n            temp //= d\n        d += 1\n    \n    if temp > 1:\n        factors[temp] = 1\n    \n    # If 2 is not a factor, there are no even factors\n    if 2 not in factors:\n        return 0\n    \n    # Calculate sum of even divisors\n    # For 2, we sum from 2^1 to 2^k (exclude 2^0=1 to ensure even divisors)\n    # For other primes p with power a, we sum from p^0 to p^a\n    result = 0\n    pow_2 = factors[2]\n    # Sum of 2^1 + 2^2 + ... + 2^pow_2\n    sum_2 = (2 * (2**pow_2 - 1)) // (2 - 1)  # Geometric series sum\n    \n    result = sum_2\n    \n    # For each other prime factor, calculate sum of its powers\n    for prime in factors:\n        if prime != 2:\n            power = factors[prime]\n            # Sum of 1 + p + p^2 + ... + p^power\n            if prime == 1:\n                sum_prime = power + 1\n            else:\n                sum_prime = (prime**(power + 1) - 1) // (prime - 1)\n            result *= sum_prime\n    \n    return result\n\n\n"], "prompt_tokens": [1942], "completion_tokens": [1654], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_453_sumofFactors"}
{"name": "mbpp_478_remove_lowercase", "language": "Python3", "prompt": "def remove_lowercase(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove lowercase substrings from a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_lowercase", "test": "def check(candidate):\n    assert candidate('PYTHon') == 'PYTH'\n    assert candidate('FInD') == 'FID'\n    assert candidate('STRinG') == 'STRG'\n\ndef test_check():\n    check(remove_lowercase)\n\ntest_check()\n", "sample_io": ["assert remove_lowercase('PYTHon') == 'PYTH'"], "source_codes": ["def remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())"], "responses": ["\ndef remove_lowercase(str1: str) -> str:\n    \"\"\"\n    Write a function to remove lowercase substrings from a given string.\n    \"\"\"\n    return ''.join(char for char in str1 if not char.islower())\n\n\n"], "prompt_tokens": [1559], "completion_tokens": [808], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_478_remove_lowercase"}
{"name": "mbpp_18_remove_dirty_chars", "language": "Python3", "prompt": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n\tWrite a function to remove characters from the first string which are present in the second string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_dirty_chars", "test": "def check(candidate):\n    assert candidate('probasscurve', 'pros') == 'bacuve'\n    assert candidate('digitalindia', 'talent') == 'digiidi'\n    assert candidate('exoticmiles', 'toxic') == 'emles'\n\ndef test_check():\n    check(remove_dirty_chars)\n\ntest_check()\n", "sample_io": ["assert remove_dirty_chars('probasscurve', 'pros') == 'bacuve'"], "source_codes": ["def remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Build result string by including only characters not in the set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    return ''.join(result)"], "responses": ["\ndef remove_dirty_chars(string: str, second_string: str) -> str:\n    # Convert second_string to a set for O(1) lookup\n    chars_to_remove = set(second_string)\n    \n    # Build result string by including only characters not in the set\n    result = []\n    for char in string:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    return ''.join(result)\n\n\n"], "prompt_tokens": [1717], "completion_tokens": [918], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_18_remove_dirty_chars"}
{"name": "mbpp_730_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n\tWrite a function to remove consecutive duplicates of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd', 'a', 'a']) == ['a', 'b', 'c', 'd', 'a']\n\ndef test_check():\n    check(consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"], "source_codes": ["def consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements of any type\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    # Handle edge case: empty list\n    if not nums:\n        return []\n    \n    # Initialize result with first element\n    result = [nums[0]]\n    \n    # Iterate through remaining elements\n    for i in range(1, len(nums)):\n        # Add element to result if it's different from the previous one\n        if nums[i] != nums[i-1]:\n            result.append(nums[i])\n            \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef consecutive_duplicates(nums: List[Any]) -> List[Any]:\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n    \n    Args:\n        nums: A list of elements of any type\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    # Handle edge case: empty list\n    if not nums:\n        return []\n    \n    # Initialize result with first element\n    result = [nums[0]]\n    \n    # Iterate through remaining elements\n    for i in range(1, len(nums)):\n        # Add element to result if it's different from the previous one\n        if nums[i] != nums[i-1]:\n            result.append(nums[i])\n            \n    return result\n\n\n"], "prompt_tokens": [1861], "completion_tokens": [1037], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_730_consecutive_duplicates"}
{"name": "mbpp_446_count_Occurrence", "language": "Python3", "prompt": "from typing import Any, List\n\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    \"\"\"\n\tWrite a python function to count the occurence of all elements of list in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Occurrence", "test": "def check(candidate):\n    assert candidate(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    assert candidate((1, 2, 3, 1, 4, 6, 7, 1, 4), [1, 4, 7]) == 6\n    assert candidate((1, 2, 3, 4, 5, 6), [1, 2]) == 2\n\ndef test_check():\n    check(count_Occurrence)\n\ntest_check()\n", "sample_io": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"], "source_codes": ["def count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    # Handle edge cases\n    if not tup or not lst:\n        return 0\n    \n    # Initialize counter\n    total_count = 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count occurrences of the current element in the tuple\n        total_count += tup.count(element)\n    \n    return total_count"], "responses": ["\ndef count_Occurrence(tup: Any, lst: List[Any]) -> int:\n    # Handle edge cases\n    if not tup or not lst:\n        return 0\n    \n    # Initialize counter\n    total_count = 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count occurrences of the current element in the tuple\n        total_count += tup.count(element)\n    \n    return total_count\n\n\n"], "prompt_tokens": [2173], "completion_tokens": [1130], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_446_count_Occurrence"}
{"name": "mbpp_772_remove_length", "language": "Python3", "prompt": "def remove_length(test_str: str, K: int) -> str:\n    \"\"\"\n\tWrite a function to remove all the words with k length in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_length", "test": "def check(candidate):\n    assert candidate('The person is most value tet', 3) == 'person is most value'\n    assert candidate('If you told me about this ok', 4) == 'If you me about ok'\n    assert candidate('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'\n\ndef test_check():\n    check(remove_length)\n\ntest_check()\n", "sample_io": ["assert remove_length('The person is most value tet', 3) == 'person is most value'"], "source_codes": ["def remove_length(test_str: str, K: int) -> str:\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)"], "responses": ["\ndef remove_length(test_str: str, K: int) -> str:\n    # Split the string into words\n    words = test_str.split()\n    \n    # Filter out words with length K\n    filtered_words = [word for word in words if len(word) != K]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)\n\n\n"], "prompt_tokens": [1796], "completion_tokens": [1082], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_772_remove_length"}
{"name": "mbpp_752_jacobsthal_num", "language": "Python3", "prompt": "def jacobsthal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "jacobsthal_num", "test": "def check(candidate):\n    assert candidate(5) == 11\n    assert candidate(2) == 1\n    assert candidate(4) == 5\n    assert candidate(13) == 2731\n\ndef test_check():\n    check(jacobsthal_num)\n\ntest_check()\n", "sample_io": ["assert jacobsthal_num(5) == 11"], "source_codes": ["def jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Calculate Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"], "responses": ["\ndef jacobsthal_num(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Calculate Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "prompt_tokens": [2434], "completion_tokens": [1259], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_752_jacobsthal_num"}
{"name": "mbpp_145_max_Abs_Diff", "language": "Python3", "prompt": "from typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the maximum difference between any two elements in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_Abs_Diff", "test": "def check(candidate):\n    assert candidate([2, 1, 5, 3]) == 4\n    assert candidate([9, 3, 2, 5, 1]) == 8\n    assert candidate([3, 2, 1]) == 2\n\ndef test_check():\n    check(max_Abs_Diff)\n\ntest_check()\n", "sample_io": ["assert max_Abs_Diff([2, 1, 5, 3]) == 4"], "source_codes": ["def max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        The maximum absolute difference between any two elements\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Handle single element array\n    if len(arr) == 1:\n        return 0\n    \n    # Initialize min and max with first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        elif arr[i] > max_val:\n            max_val = arr[i]\n    \n    # Return the maximum difference\n    return max_val - min_val"], "responses": ["\nfrom typing import List\n\ndef max_Abs_Diff(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        The maximum absolute difference between any two elements\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Handle single element array\n    if len(arr) == 1:\n        return 0\n    \n    # Initialize min and max with first element\n    min_val = arr[0]\n    max_val = arr[0]\n    \n    # Iterate through the rest of the array\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        elif arr[i] > max_val:\n            max_val = arr[i]\n    \n    # Return the maximum difference\n    return max_val - min_val\n\n\n"], "prompt_tokens": [1736], "completion_tokens": [963], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_145_max_Abs_Diff"}
{"name": "mbpp_572_two_unique_nums", "language": "Python3", "prompt": "from typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "two_unique_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]\n    assert candidate([1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\ndef test_check():\n    check(two_unique_nums)\n\ntest_check()\n", "sample_io": ["assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"], "source_codes": ["def two_unique_nums(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n    \n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Keep only numbers that appear exactly once, maintaining original order\n    result = []\n    for num in nums:\n        if count[num] == 1:\n            result.append(num)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef two_unique_nums(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n    \n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Keep only numbers that appear exactly once, maintaining original order\n    result = []\n    for num in nums:\n        if count[num] == 1:\n            result.append(num)\n    \n    return result\n\n\n"], "prompt_tokens": [3592], "completion_tokens": [1395], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_572_two_unique_nums"}
{"name": "mbpp_556_find_Odd_Pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose xor value is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Odd_Pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1], 5) == 6\n    assert candidate([7, 2, 8, 1, 0, 5, 11], 7) == 12\n    assert candidate([1, 2, 3], 3) == 2\n\ndef test_check():\n    check(find_Odd_Pair)\n\ntest_check()\n", "sample_io": ["assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"], "source_codes": ["def find_Odd_Pair(A: List[int], N: int) -> int:\n    # Handle edge cases\n    if N <= 1:\n        return 0\n    \n    # Count odd and even numbers\n    odd_count = 0\n    even_count = 0\n    \n    for num in A:\n        if num % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n    \n    # The number of pairs with odd XOR is the product of odd_count and even_count\n    return odd_count * even_count"], "responses": ["\nfrom typing import List\n\ndef find_Odd_Pair(A: List[int], N: int) -> int:\n    # Handle edge cases\n    if N <= 1:\n        return 0\n    \n    # Count odd and even numbers\n    odd_count = 0\n    even_count = 0\n    \n    for num in A:\n        if num % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n    \n    # The number of pairs with odd XOR is the product of odd_count and even_count\n    return odd_count * even_count\n\n\n"], "prompt_tokens": [1915], "completion_tokens": [1094], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_556_find_Odd_Pair"}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "Python3", "prompt": "from typing import List\n\ndef max_sum_increasing_subseq(a: List[int], n: int, index: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_sum_increasing_subseq", "test": "def check(candidate):\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11\n    assert candidate([1, 101, 2, 3, 100, 4, 5], 7, 2, 5) == 7\n    assert candidate([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71\n\ndef test_check():\n    check(max_sum_increasing_subseq)\n\ntest_check()\n", "sample_io": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_306_max_sum_increasing_subseq"}
{"name": "mbpp_388_highest_Power_of_2", "language": "Python3", "prompt": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the highest power of 2 that is less than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "highest_Power_of_2", "test": "def check(candidate):\n    assert candidate(10) == 8\n    assert candidate(19) == 16\n    assert candidate(32) == 32\n\ndef test_check():\n    check(highest_Power_of_2)\n\ntest_check()\n", "sample_io": ["assert highest_Power_of_2(10) == 8"], "source_codes": ["def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # If n is already a power of 2, return it\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the highest power of 2 less than n\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power"], "responses": ["\ndef highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # If n is already a power of 2, return it\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the highest power of 2 less than n\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power\n\n\n"], "prompt_tokens": [1901], "completion_tokens": [1210], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_388_highest_Power_of_2"}
{"name": "mbpp_401_add_nested_tuples", "language": "Python3", "prompt": "from typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to perform index wise addition of list elements in the given two nested lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_nested_tuples", "test": "def check(candidate):\n    assert candidate([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]\n    assert candidate([[2, 4], [5, 6], [3, 10], [2, 11]], [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]]\n    assert candidate([[3, 5], [6, 7], [4, 11], [3, 12]], [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]]\n\ndef test_check():\n    check(add_nested_tuples)\n\ntest_check()\n", "sample_io": ["assert add_nested_tuples([[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]]"], "source_codes": ["def add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 and not test_tup2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each row\n    for i in range(len(test_tup1)):\n        row = []\n        # Iterate through each column in the row\n        for j in range(len(test_tup1[i])):\n            # Perform element-wise addition\n            sum_element = test_tup1[i][j] + test_tup2[i][j]\n            row.append(sum_element)\n        result.append(row)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef add_nested_tuples(test_tup1: List[List[int]], test_tup2: List[List[int]]) -> List[List[int]]:\n    # Handle empty lists\n    if not test_tup1 and not test_tup2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each row\n    for i in range(len(test_tup1)):\n        row = []\n        # Iterate through each column in the row\n        for j in range(len(test_tup1[i])):\n            # Perform element-wise addition\n            sum_element = test_tup1[i][j] + test_tup2[i][j]\n            row.append(sum_element)\n        result.append(row)\n    \n    return result\n\n\n"], "prompt_tokens": [1989], "completion_tokens": [1185], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_401_add_nested_tuples"}
{"name": "mbpp_435_last_Digit", "language": "Python3", "prompt": "def last_Digit(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the last digit of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "last_Digit", "test": "def check(candidate):\n    assert candidate(123) == 3\n    assert candidate(25) == 5\n    assert candidate(30) == 0\n\ndef test_check():\n    check(last_Digit)\n\ntest_check()\n", "sample_io": ["assert last_Digit(123) == 3"], "source_codes": ["def last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number (always positive)\n    \"\"\"\n    return abs(n) % 10"], "responses": ["\ndef last_Digit(n: int) -> int:\n    \"\"\"\n    Find the last digit of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The last digit of the number (always positive)\n    \"\"\"\n    return abs(n) % 10\n\n\n"], "prompt_tokens": [1755], "completion_tokens": [823], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_435_last_Digit"}
{"name": "mbpp_611_max_of_nth", "language": "Python3", "prompt": "from typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    \"\"\"\n\tWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_of_nth", "test": "def check(candidate):\n    assert candidate([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    assert candidate([[6, 7, 8], [2, 4, 6], [9, 10, 20]], 1) == 10\n    assert candidate([[7, 8, 9], [3, 5, 7], [10, 11, 21]], 1) == 11\n\ndef test_check():\n    check(max_of_nth)\n\ntest_check()\n", "sample_io": ["assert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"], "source_codes": ["def max_of_nth(test_list: List[List[int]], N: int) -> int:\n    # Handle edge cases\n    if not test_list or N < 0:\n        raise ValueError(\"Invalid input: empty matrix or negative column index\")\n    \n    # Extract the Nth column elements\n    column_elements = []\n    for row in test_list:\n        if len(row) > N:  # Check if the row has enough elements\n            column_elements.append(row[N])\n    \n    # If no elements were found in the Nth column\n    if not column_elements:\n        raise ValueError(f\"Column {N} does not exist in the matrix\")\n    \n    # Return the maximum value in the Nth column\n    return max(column_elements)"], "responses": ["\nfrom typing import List\n\ndef max_of_nth(test_list: List[List[int]], N: int) -> int:\n    # Handle edge cases\n    if not test_list or N < 0:\n        raise ValueError(\"Invalid input: empty matrix or negative column index\")\n    \n    # Extract the Nth column elements\n    column_elements = []\n    for row in test_list:\n        if len(row) > N:  # Check if the row has enough elements\n            column_elements.append(row[N])\n    \n    # If no elements were found in the Nth column\n    if not column_elements:\n        raise ValueError(f\"Column {N} does not exist in the matrix\")\n    \n    # Return the maximum value in the Nth column\n    return max(column_elements)\n\n\n"], "prompt_tokens": [2469], "completion_tokens": [1492], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_611_max_of_nth"}
{"name": "mbpp_280_sequential_search", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n\tWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequential_search", "test": "def check(candidate):\n    assert candidate([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)\n    assert candidate([12, 32, 45, 62, 35, 47, 44, 61], 61) == (True, 7)\n    assert candidate([9, 10, 17, 19, 22, 39, 48, 56], 48) == (True, 6)\n\ndef test_check():\n    check(sequential_search)\n\ntest_check()\n", "sample_io": ["assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"], "source_codes": ["def sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    for index, value in enumerate(dlist):\n        if value == item:\n            return (True, index)\n    \n    return (False, -1)"], "responses": ["\nfrom typing import List, Tuple\n\ndef sequential_search(dlist: List[int], item: int) -> Tuple[bool, int]:\n    \"\"\"\n    Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    for index, value in enumerate(dlist):\n        if value == item:\n            return (True, index)\n    \n    return (False, -1)\n\n\n"], "prompt_tokens": [2207], "completion_tokens": [1153], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_280_sequential_search"}
{"name": "mbpp_576_is_Sub_Array", "language": "Python3", "prompt": "from typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list is sublist of another or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Sub_Array", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 5], [1, 2]) == False\n    assert candidate([1, 2, 1], [1, 2, 1]) == True\n    assert candidate([1, 0, 2, 2], [2, 2, 0]) == False\n\ndef test_check():\n    check(is_Sub_Array)\n\ntest_check()\n", "sample_io": ["assert is_Sub_Array([1, 4, 3, 5], [1, 2]) == False"], "source_codes": ["def is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    # If B is empty, it's a sublist of any list\n    if not B:\n        return True\n    \n    # If B is longer than A, it can't be a sublist\n    if len(B) > len(A):\n        return False\n    \n    # Check each possible starting position in A\n    for i in range(len(A) - len(B) + 1):\n        # Check if B matches the subarray of A starting at position i\n        if A[i:i+len(B)] == B:\n            return True\n    \n    # If we've checked all positions and found no match\n    return False"], "responses": ["\nfrom typing import List\n\ndef is_Sub_Array(A: List[int], B: List[int]) -> bool:\n    # If B is empty, it's a sublist of any list\n    if not B:\n        return True\n    \n    # If B is longer than A, it can't be a sublist\n    if len(B) > len(A):\n        return False\n    \n    # Check each possible starting position in A\n    for i in range(len(A) - len(B) + 1):\n        # Check if B matches the subarray of A starting at position i\n        if A[i:i+len(B)] == B:\n            return True\n    \n    # If we've checked all positions and found no match\n    return False\n\n\n"], "prompt_tokens": [2050], "completion_tokens": [1080], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_576_is_Sub_Array"}
{"name": "mbpp_131_reverse_vowels", "language": "Python3", "prompt": "def reverse_vowels(str1: str) -> str:\n    \"\"\"\n\tWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_vowels", "test": "def check(candidate):\n    assert candidate('Python') == 'Python'\n    assert candidate('USA') == 'ASU'\n    assert candidate('ab') == 'ab'\n\ndef test_check():\n    check(reverse_vowels)\n\ntest_check()\n", "sample_io": ["assert reverse_vowels('Python') == 'Python'"], "source_codes": ["def reverse_vowels(str1: str) -> str:\n    # Convert string to list for mutability\n    chars = list(str1)\n    \n    # Define vowels set for O(1) lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Initialize two pointers\n    left, right = 0, len(str1) - 1\n    \n    # Process until pointers meet\n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and chars[left] not in vowels:\n            left += 1\n            \n        # Move right pointer to previous vowel\n        while left < right and chars[right] not in vowels:\n            right -= 1\n            \n        # Swap vowels if both pointers are valid\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    \n    # Convert back to string and return\n    return ''.join(chars)"], "responses": ["\ndef reverse_vowels(str1: str) -> str:\n    # Convert string to list for mutability\n    chars = list(str1)\n    \n    # Define vowels set for O(1) lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Initialize two pointers\n    left, right = 0, len(str1) - 1\n    \n    # Process until pointers meet\n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and chars[left] not in vowels:\n            left += 1\n            \n        # Move right pointer to previous vowel\n        while left < right and chars[right] not in vowels:\n            right -= 1\n            \n        # Swap vowels if both pointers are valid\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    \n    # Convert back to string and return\n    return ''.join(chars)\n\n\n"], "prompt_tokens": [1793], "completion_tokens": [994], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_131_reverse_vowels"}
{"name": "mbpp_432_median_trapezium", "language": "Python3", "prompt": "def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n\tWrite a function to find the median length of a trapezium.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "median_trapezium", "test": "def check(candidate):\n    assert candidate(15, 25, 35) == 20\n    assert candidate(10, 20, 30) == 15\n    assert candidate(6, 9, 4) == 7.5\n\ndef test_check():\n    check(median_trapezium)\n\ntest_check()\n", "sample_io": ["assert median_trapezium(15, 25, 35) == 20"], "source_codes": ["def median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides. Its length equals the average of the lengths \n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium (not used in calculation)\n        \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2.0"], "responses": ["\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    \"\"\"\n    Find the median length of a trapezium.\n    \n    The median of a trapezium is the line segment that connects the midpoints \n    of the non-parallel sides. Its length equals the average of the lengths \n    of the parallel sides (bases).\n    \n    Args:\n        base1 (int): Length of the first base\n        base2 (int): Length of the second base\n        height (int): Height of the trapezium (not used in calculation)\n        \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2.0\n\n\n"], "prompt_tokens": [2167], "completion_tokens": [1192], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_432_median_trapezium"}
{"name": "mbpp_161_remove_elements", "language": "Python3", "prompt": "from typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to remove all elements from a given list present in another list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_elements", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]\n\ndef test_check():\n    check(remove_elements)\n\ntest_check()\n", "sample_io": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"], "source_codes": ["def remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    # Convert list2 to a set for O(1) lookup\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [item for item in list1 if item not in set2]"], "responses": ["\nfrom typing import List\n\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    # Convert list2 to a set for O(1) lookup\n    set2 = set(list2)\n    \n    # Use list comprehension to filter out elements present in set2\n    return [item for item in list1 if item not in set2]\n\n\n"], "prompt_tokens": [2138], "completion_tokens": [1067], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_161_remove_elements"}
{"name": "mbpp_597_find_kth", "language": "Python3", "prompt": "from typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    \"\"\"\n\tWrite a function to find kth element from the given two sorted arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_kth", "test": "def check(candidate):\n    assert candidate([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    assert candidate([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256\n    assert candidate([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8\n\ndef test_check():\n    check(find_kth)\n\ntest_check()\n", "sample_io": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"], "source_codes": ["def find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Handle edge cases\n    if not arr1:\n        return arr2[k-1]\n    if not arr2:\n        return arr1[k-1]\n    \n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Initialize binary search bounds\n    low = max(0, k - len(arr2))\n    high = min(len(arr1), k)\n    \n    while low <= high:\n        # Partition points for both arrays\n        partition1 = (low + high) // 2\n        partition2 = k - partition1\n        \n        # Get max of left parts and min of right parts\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            high = partition1 - 1\n        else:\n            low = partition1 + 1\n    \n    # This should never be reached with valid inputs\n    raise ValueError(\"Invalid input\")"], "responses": ["\nfrom typing import List\n\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    # Handle edge cases\n    if not arr1:\n        return arr2[k-1]\n    if not arr2:\n        return arr1[k-1]\n    \n    # Ensure arr1 is the smaller array for optimization\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Initialize binary search bounds\n    low = max(0, k - len(arr2))\n    high = min(len(arr1), k)\n    \n    while low <= high:\n        # Partition points for both arrays\n        partition1 = (low + high) // 2\n        partition2 = k - partition1\n        \n        # Get max of left parts and min of right parts\n        max_left1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == len(arr1) else arr1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == len(arr2) else arr2[partition2]\n        \n        # Check if we found the correct partition\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            high = partition1 - 1\n        else:\n            low = partition1 + 1\n    \n    # This should never be reached with valid inputs\n    raise ValueError(\"Invalid input\")\n\n\n"], "prompt_tokens": [2154], "completion_tokens": [1671], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_597_find_kth"}
{"name": "mbpp_226_odd_values_string", "language": "Python3", "prompt": "def odd_values_string(str: str) -> str:\n    \"\"\"\n\tWrite a python function to remove the characters which have odd index values of a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_values_string", "test": "def check(candidate):\n    assert candidate('abcdef') == 'ace'\n    assert candidate('python') == 'pto'\n    assert candidate('data') == 'dt'\n    assert candidate('lambs') == 'lms'\n\ndef test_check():\n    check(odd_values_string)\n\ntest_check()\n", "sample_io": ["assert odd_values_string('abcdef') == 'ace'"], "source_codes": ["def odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]"], "responses": ["\ndef odd_values_string(str: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return str[::2]\n\n\n"], "prompt_tokens": [1524], "completion_tokens": [836], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_226_odd_values_string"}
{"name": "mbpp_278_count_first_elements", "language": "Python3", "prompt": "from typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n\tWrite a function to find the number of elements that occurs before the list element in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_first_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, (4, 6), 10]) == 3\n    assert candidate([2, 9, (5, 7), 11]) == 2\n    assert candidate([11, 15, 5, 8, (2, 3), 8]) == 4\n\ndef test_check():\n    check(count_first_elements)\n\ntest_check()\n", "sample_io": ["assert count_first_elements([1, 5, 7, (4, 6), 10]) == 3"], "source_codes": ["def count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 0 immediately\n    if not test_tup:\n        return 0\n    \n    # Iterate through the list using enumerate to get both index and element\n    for index, element in enumerate(test_tup):\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # Return the current index (number of elements before the tuple)\n            return index\n    \n    # If no tuple is found, return the total length of the list\n    return len(test_tup)"], "responses": ["\nfrom typing import List, Union, Tuple\n\ndef count_first_elements(test_tup: List[Union[int, Tuple[int, int]]]) -> int:\n    \"\"\"\n    Write a function to find the number of elements that occurs before the list element in the given tuple.\n    \"\"\"\n    # Handle edge case: if input list is empty, return 0 immediately\n    if not test_tup:\n        return 0\n    \n    # Iterate through the list using enumerate to get both index and element\n    for index, element in enumerate(test_tup):\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # Return the current index (number of elements before the tuple)\n            return index\n    \n    # If no tuple is found, return the total length of the list\n    return len(test_tup)\n\n\n"], "prompt_tokens": [1929], "completion_tokens": [979], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_278_count_first_elements"}
{"name": "mbpp_269_ascii_value", "language": "Python3", "prompt": "def ascii_value(k: str) -> int:\n    \"\"\"\n\tWrite a function to find the ascii value of a character.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "ascii_value", "test": "def check(candidate):\n    assert candidate('A') == 65\n    assert candidate('R') == 82\n    assert candidate('S') == 83\n\ndef test_check():\n    check(ascii_value)\n\ntest_check()\n", "sample_io": ["assert ascii_value('A') == 65"], "source_codes": ["def ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \n    Args:\n        k (str): A single character string\n        \n    Returns:\n        int: The ASCII value of the character\n        \n    Raises:\n        ValueError: If input is not a single character\n    \"\"\"\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string\")\n        \n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n        \n    return ord(k)"], "responses": ["\ndef ascii_value(k: str) -> int:\n    \"\"\"\n    Write a function to find the ascii value of a character.\n    \n    Args:\n        k (str): A single character string\n        \n    Returns:\n        int: The ASCII value of the character\n        \n    Raises:\n        ValueError: If input is not a single character\n    \"\"\"\n    if not isinstance(k, str):\n        raise TypeError(\"Input must be a string\")\n        \n    if len(k) != 1:\n        raise ValueError(\"Input must be a single character\")\n        \n    return ord(k)\n\n\n"], "prompt_tokens": [1533], "completion_tokens": [979], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_269_ascii_value"}
{"name": "mbpp_739_find_Index", "language": "Python3", "prompt": "def find_Index(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Index", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 14\n    assert candidate(4) == 45\n\ndef test_check():\n    check(find_Index)\n\ntest_check()\n", "sample_io": ["assert find_Index(2) == 4"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_739_find_Index"}
{"name": "mbpp_19_test_duplicate", "language": "Python3", "prompt": "from typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to find whether a given array of integers contains any duplicate element.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_duplicate", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 4]) == True\n    assert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True\n\ndef test_check():\n    check(test_duplicate)\n\ntest_check()\n", "sample_io": ["assert test_duplicate([1, 2, 3, 4, 5]) == False"], "source_codes": ["def test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Handle edge cases\n    if len(arraynums) <= 1:\n        return False\n    \n    # Initialize set to track seen elements\n    seen = set()\n    \n    # Iterate through each element\n    for num in arraynums:\n        # Check if element already seen\n        if num in seen:\n            return True\n        # Add element to seen set\n        seen.add(num)\n    \n    # No duplicates found\n    return False"], "responses": ["\nfrom typing import List\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Handle edge cases\n    if len(arraynums) <= 1:\n        return False\n    \n    # Initialize set to track seen elements\n    seen = set()\n    \n    # Iterate through each element\n    for num in arraynums:\n        # Check if element already seen\n        if num in seen:\n            return True\n        # Add element to seen set\n        seen.add(num)\n    \n    # No duplicates found\n    return False\n\n\n"], "prompt_tokens": [1725], "completion_tokens": [868], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_19_test_duplicate"}
{"name": "mbpp_62_smallest_num", "language": "Python3", "prompt": "from typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find smallest number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "smallest_num", "test": "def check(candidate):\n    assert candidate([10, 20, 1, 45, 99]) == 1\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([45, 46, 50, 60]) == 45\n\ndef test_check():\n    check(smallest_num)\n\ntest_check()\n", "sample_io": ["assert smallest_num([10, 20, 1, 45, 99]) == 1"], "source_codes": ["def smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for i in range(1, len(xs)):\n        if xs[i] < min_val:\n            min_val = xs[i]\n    \n    return min_val"], "responses": ["\nfrom typing import List\n\ndef smallest_num(xs: List[int]) -> int:\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n        xs: A list of integers\n        \n    Returns:\n        The smallest integer in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not xs:\n        raise ValueError(\"List cannot be empty\")\n    \n    min_val = xs[0]\n    for i in range(1, len(xs)):\n        if xs[i] < min_val:\n            min_val = xs[i]\n    \n    return min_val\n\n\n"], "prompt_tokens": [1921], "completion_tokens": [1090], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_62_smallest_num"}
{"name": "mbpp_746_sector_area", "language": "Python3", "prompt": "from typing import Optional\n\ndef sector_area(r: int, a: int) -> Optional[float]:\n    \"\"\"\n\tWrite a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sector_area", "test": "def check(candidate):\n    assert candidate(4, 45) == 6.283185307179586\n    assert candidate(9, 45) == 31.808625617596654\n    assert candidate(9, 361) == None\n\ndef test_check():\n    check(sector_area)\n\ntest_check()\n", "sample_io": ["assert sector_area(4, 45) == 6.283185307179586"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_746_sector_area"}
{"name": "mbpp_142_count_samepair", "language": "Python3", "prompt": "from typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n\tWrite a function to count number items that are identical in the same position of three given lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_samepair", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 4\n    assert candidate([1, 2, 3, 4, 2, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 8], [2, 1, 3, 1, 2, 6, 7, 8]) == 5\n\ndef test_check():\n    check(count_samepair)\n\ntest_check()\n", "sample_io": ["assert count_samepair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9], [2, 1, 3, 1, 2, 6, 7, 9]) == 3"], "source_codes": ["def count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    # Find the minimum length among the three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter for identical elements\n    count = 0\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at position i are identical\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count"], "responses": ["\nfrom typing import List\n\ndef count_samepair(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    \"\"\"\n    Count number of items that are identical in the same position of three given lists.\n    \"\"\"\n    # Find the minimum length among the three lists\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Initialize counter for identical elements\n    count = 0\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if all three elements at position i are identical\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [2058], "completion_tokens": [1090], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_142_count_samepair"}
{"name": "mbpp_400_extract_freq", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to extract the number of unique tuples in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_freq", "test": "def check(candidate):\n    assert candidate([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    assert candidate([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    assert candidate([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n\ndef test_check():\n    check(extract_freq)\n\ntest_check()\n", "sample_io": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"], "source_codes": ["def extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    # Convert each tuple to its canonical form by sorting\n    canonical_tuples = [tuple(sorted(t)) for t in test_list]\n    # Return count of unique canonical tuples\n    return len(set(canonical_tuples))"], "responses": ["\ndef extract_freq(test_list: List[Tuple[int, int]]) -> int:\n    # Convert each tuple to its canonical form by sorting\n    canonical_tuples = [tuple(sorted(t)) for t in test_list]\n    # Return count of unique canonical tuples\n    return len(set(canonical_tuples))\n\n\n"], "prompt_tokens": [5152], "completion_tokens": [2833], "no_of_try": 1, "api_calls": 10, "is_solved": true, "task_id": "mbpp_400_extract_freq"}
{"name": "mbpp_595_min_Swaps", "language": "Python3", "prompt": "from typing import Any\n\ndef min_Swaps(str1: str, str2: str) -> Any:\n    \"\"\"\n\tWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_Swaps", "test": "def check(candidate):\n    assert candidate('1101', '1110') == 1\n    assert candidate('111', '000') == 'Not Possible'\n    assert candidate('111', '110') == 'Not Possible'\n\ndef test_check():\n    check(min_Swaps)\n\ntest_check()\n", "sample_io": ["assert min_Swaps('1101', '1110') == 1"], "source_codes": ["def min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Initialize counters for mismatches\n    count_01 = 0  # str1 has '0', str2 has '1'\n    count_10 = 0  # str1 has '1', str2 has '0'\n    \n    # Iterate through both strings\n    for i in range(len(str1)):\n        if str1[i] == '0' and str2[i] == '1':\n            count_01 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_10 += 1\n    \n    # Check if conversion is possible\n    if count_01 != count_10:\n        return -1\n    \n    # Return the number of swaps needed\n    return count_01"], "responses": ["\ndef min_Swaps(str1: str, str2: str) -> Any:\n    # Check if lengths are equal\n    if len(str1) != len(str2):\n        return -1\n    \n    # Initialize counters for mismatches\n    count_01 = 0  # str1 has '0', str2 has '1'\n    count_10 = 0  # str1 has '1', str2 has '0'\n    \n    # Iterate through both strings\n    for i in range(len(str1)):\n        if str1[i] == '0' and str2[i] == '1':\n            count_01 += 1\n        elif str1[i] == '1' and str2[i] == '0':\n            count_10 += 1\n    \n    # Check if conversion is possible\n    if count_01 != count_10:\n        return -1\n    \n    # Return the number of swaps needed\n    return count_01\n\n\n"], "prompt_tokens": [2278], "completion_tokens": [1418], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_595_min_Swaps"}
{"name": "mbpp_135_hexagonal_num", "language": "Python3", "prompt": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth hexagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "hexagonal_num", "test": "def check(candidate):\n    assert candidate(10) == 190\n    assert candidate(5) == 45\n    assert candidate(7) == 91\n\ndef test_check():\n    check(hexagonal_num)\n\ntest_check()\n", "sample_io": ["assert hexagonal_num(10) == 190"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_135_hexagonal_num"}
{"name": "mbpp_800_remove_all_spaces", "language": "Python3", "prompt": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n\tWrite a function to remove all whitespaces from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_all_spaces", "test": "def check(candidate):\n    assert candidate('python  program') == 'pythonprogram'\n    assert candidate('python   programming    language') == 'pythonprogramminglanguage'\n    assert candidate('python                     program') == 'pythonprogram'\n    assert candidate('   python                     program') == 'pythonprogram'\n\ndef test_check():\n    check(remove_all_spaces)\n\ntest_check()\n", "sample_io": ["assert remove_all_spaces('python  program') == 'pythonprogram'"], "source_codes": ["def remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return ''.join(char for char in text if not char.isspace())"], "responses": ["\ndef remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return ''.join(char for char in text if not char.isspace())\n\n\n"], "prompt_tokens": [1579], "completion_tokens": [858], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_800_remove_all_spaces"}
{"name": "mbpp_127_multiply_int", "language": "Python3", "prompt": "def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n\tWrite a function to multiply two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_int", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(5, 10) == 50\n    assert candidate(4, 8) == 32\n\ndef test_check():\n    check(multiply_int)\n\ntest_check()\n", "sample_io": ["assert multiply_int(10, 20) == 200"], "source_codes": ["def multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y"], "responses": ["\ndef multiply_int(x: int, y: int) -> int:\n    \"\"\"\n    Write a function to multiply two integers.\n    \"\"\"\n    return x * y\n\n\n"], "prompt_tokens": [1675], "completion_tokens": [735], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_127_multiply_int"}
{"name": "mbpp_764_number_ctr", "language": "Python3", "prompt": "def number_ctr(str: str) -> int:\n    \"\"\"\n\tWrite a python function to count number of digits in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "number_ctr", "test": "def check(candidate):\n    assert candidate('program2bedone') == 1\n    assert candidate('3wonders') == 1\n    assert candidate('123') == 3\n    assert candidate('3wond-1ers2') == 3\n\ndef test_check():\n    check(number_ctr)\n\ntest_check()\n", "sample_io": ["assert number_ctr('program2bedone') == 1"], "source_codes": ["def number_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    \"\"\"\n    # Initialize counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    # Return the total count of digits\n    return count"], "responses": ["\ndef number_ctr(str: str) -> int:\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    \"\"\"\n    # Initialize counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    # Return the total count of digits\n    return count\n\n\n"], "prompt_tokens": [1770], "completion_tokens": [1069], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_764_number_ctr"}
{"name": "mbpp_767_get_pairs_count", "language": "Python3", "prompt": "from typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_pairs_count", "test": "def check(candidate):\n    assert candidate([1, 1, 1, 1], 2) == 6\n    assert candidate([1, 5, 7, -1, 5], 6) == 3\n    assert candidate([1, -2, 3], 1) == 1\n    assert candidate([-1, -2, 3], -3) == 1\n\ndef test_check():\n    check(get_pairs_count)\n\ntest_check()\n", "sample_io": ["assert get_pairs_count([1, 1, 1, 1], 2) == 6"], "source_codes": ["def get_pairs_count(arr: List[int], sum: int) -> int:\n    # Handle edge cases\n    if len(arr) < 2:\n        return 0\n    \n    # Create frequency map\n    freq_map = {}\n    for num in arr:\n        freq_map[num] = freq_map.get(num, 0) + 1\n    \n    pair_count = 0\n    \n    # Process each unique element\n    for num in freq_map:\n        complement = sum - num\n        \n        if complement == num:\n            # Special case: when number complements itself\n            # Use combination formula C(n,2) = n*(n-1)/2\n            count = freq_map[num]\n            pair_count += count * (count - 1) // 2\n        elif complement in freq_map and num < complement:\n            # To avoid double counting, only process when num < complement\n            pair_count += freq_map[num] * freq_map[complement]\n    \n    return pair_count"], "responses": ["\nfrom typing import List\n\ndef get_pairs_count(arr: List[int], sum: int) -> int:\n    # Handle edge cases\n    if len(arr) < 2:\n        return 0\n    \n    # Create frequency map\n    freq_map = {}\n    for num in arr:\n        freq_map[num] = freq_map.get(num, 0) + 1\n    \n    pair_count = 0\n    \n    # Process each unique element\n    for num in freq_map:\n        complement = sum - num\n        \n        if complement == num:\n            # Special case: when number complements itself\n            # Use combination formula C(n,2) = n*(n-1)/2\n            count = freq_map[num]\n            pair_count += count * (count - 1) // 2\n        elif complement in freq_map and num < complement:\n            # To avoid double counting, only process when num < complement\n            pair_count += freq_map[num] * freq_map[complement]\n    \n    return pair_count\n\n\n"], "prompt_tokens": [2053], "completion_tokens": [1102], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_767_get_pairs_count"}
{"name": "mbpp_99_decimal_to_binary", "language": "Python3", "prompt": "def decimal_to_binary(n: int) -> str:\n    \"\"\"\n\tWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(8) == '1000'\n    assert candidate(18) == '10010'\n    assert candidate(7) == '111'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "sample_io": ["assert decimal_to_binary(8) == '1000'"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_99_decimal_to_binary"}
{"name": "mbpp_119_search", "language": "Python3", "prompt": "from typing import List\n\ndef search(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the element that appears only once in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "search", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8\n    assert candidate([1, 2, 2, 3, 3, 4, 4]) == 1\n\ndef test_check():\n    check(search)\n\ntest_check()\n", "sample_io": ["assert search([1, 1, 2, 2, 3]) == 3"], "source_codes": ["def search(arr: List[int]) -> int:\n    left, right = 0, len(arr) - 1\n    \n    # Handle single element array\n    if len(arr) == 1:\n        return arr[0]\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd and compare with adjacent elements\n        if (mid % 2 == 0 and mid + 1 < len(arr) and arr[mid] == arr[mid + 1]) or \\\n           (mid % 2 == 1 and mid - 1 >= 0 and arr[mid] == arr[mid - 1]):\n            # Unique element is in the right half\n            left = mid + 1\n        else:\n            # Unique element is in the left half (including mid)\n            right = mid\n    \n    return arr[left]"], "responses": ["\ndef search(arr: List[int]) -> int:\n    left, right = 0, len(arr) - 1\n    \n    # Handle single element array\n    if len(arr) == 1:\n        return arr[0]\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd and compare with adjacent elements\n        if (mid % 2 == 0 and mid + 1 < len(arr) and arr[mid] == arr[mid + 1]) or \\\n           (mid % 2 == 1 and mid - 1 >= 0 and arr[mid] == arr[mid - 1]):\n            # Unique element is in the right half\n            left = mid + 1\n        else:\n            # Unique element is in the left half (including mid)\n            right = mid\n    \n    return arr[left]\n\n\n"], "prompt_tokens": [2135], "completion_tokens": [1335], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_119_search"}
{"name": "mbpp_92_is_undulating", "language": "Python3", "prompt": "def is_undulating(n: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is undulating or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_undulating", "test": "def check(candidate):\n    assert candidate(1212121) == True\n    assert candidate(1991) == False\n    assert candidate(121) == True\n\ndef test_check():\n    check(is_undulating)\n\ntest_check()\n", "sample_io": ["assert is_undulating(1212121) == True"], "source_codes": ["def is_undulating(n: int) -> bool:\n    # Convert the number to a string to work with individual digits\n    s = str(n)\n    \n    # A number must have at least 2 digits to be undulating\n    if len(s) < 2:\n        return False\n    \n    # Get the first two digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # The first two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check the entire string follows the alternating pattern\n    for i, digit in enumerate(s):\n        if i % 2 == 0:  # Even index positions should have the first digit\n            if digit != first_digit:\n                return False\n        else:  # Odd index positions should have the second digit\n            if digit != second_digit:\n                return False\n                \n    return True"], "responses": ["\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to work with individual digits\n    s = str(n)\n    \n    # A number must have at least 2 digits to be undulating\n    if len(s) < 2:\n        return False\n    \n    # Get the first two digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # The first two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check the entire string follows the alternating pattern\n    for i, digit in enumerate(s):\n        if i % 2 == 0:  # Even index positions should have the first digit\n            if digit != first_digit:\n                return False\n        else:  # Odd index positions should have the second digit\n            if digit != second_digit:\n                return False\n                \n    return True\n\n\n"], "prompt_tokens": [1797], "completion_tokens": [1022], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_92_is_undulating"}
{"name": "mbpp_105_count", "language": "Python3", "prompt": "from typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n\tWrite a python function to count true booleans in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count", "test": "def check(candidate):\n    assert candidate([True, False, True]) == 2\n    assert candidate([False, False]) == 0\n    assert candidate([True, True, True]) == 3\n\ndef test_check():\n    check(count)\n\ntest_check()\n", "sample_io": ["assert count([True, False, True]) == 2"], "source_codes": ["def count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return sum(lst)"], "responses": ["\nfrom typing import List\n\ndef count(lst: List[bool]) -> int:\n    \"\"\"\n    Write a python function to count true booleans in the given list.\n    \"\"\"\n    return sum(lst)\n\n\n"], "prompt_tokens": [1513], "completion_tokens": [651], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_105_count"}
{"name": "mbpp_766_pair_wise", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to return a list of all pairs of consecutive items in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_wise", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    assert candidate([1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)]\n    assert candidate([5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n\ndef test_check():\n    check(pair_wise)\n\ntest_check()\n", "sample_io": ["assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"], "source_codes": ["def pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    # Handle edge cases: if list has fewer than 2 elements, return empty list\n    if len(l1) < 2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and create pairs of consecutive elements\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    \n    return result"], "responses": ["\nfrom typing import List, Tuple\n\ndef pair_wise(l1: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    # Handle edge cases: if list has fewer than 2 elements, return empty list\n    if len(l1) < 2:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through the list and create pairs of consecutive elements\n    for i in range(len(l1) - 1):\n        result.append((l1[i], l1[i + 1]))\n    \n    return result\n\n\n"], "prompt_tokens": [1826], "completion_tokens": [946], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_766_pair_wise"}
{"name": "mbpp_464_check_value", "language": "Python3", "prompt": "from typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n\tWrite a function to check if all values are same in a dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_value", "test": "def check(candidate):\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 12) == True\n    assert candidate({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 5) == False\n\ndef test_check():\n    check(check_value)\n\ntest_check()\n", "sample_io": ["assert check_value({ 'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12 }, 10) == False"], "source_codes": ["def check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Handle edge case: If dictionary is empty, return True immediately\n    if not dict:\n        return True\n    \n    # Check if all values in the dictionary are equal to n\n    for value in dict.values():\n        if value != n:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import Dict\n\ndef check_value(dict: Dict[str, int], n: int) -> bool:\n    \"\"\"\n    Write a function to check if all values are same in a dictionary.\n    \"\"\"\n    # Handle edge case: If dictionary is empty, return True immediately\n    if not dict:\n        return True\n    \n    # Check if all values in the dictionary are equal to n\n    for value in dict.values():\n        if value != n:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [1935], "completion_tokens": [1183], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_464_check_value"}
{"name": "mbpp_443_largest_neg", "language": "Python3", "prompt": "from typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest negative number from the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "largest_neg", "test": "def check(candidate):\n    assert candidate([1, 2, 3, -4, -6]) == -6\n    assert candidate([1, 2, 3, -8, -9]) == -9\n    assert candidate([1, 2, 3, 4, -1]) == -1\n\ndef test_check():\n    check(largest_neg)\n\ntest_check()\n", "sample_io": ["assert largest_neg([1, 2, 3, -4, -6]) == -6"], "source_codes": ["def largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest negative number from the given list.\n    \"\"\"\n    largest_negative = None\n    \n    for num in list1:\n        if num < 0:\n            if largest_negative is None or abs(num) > abs(largest_negative):\n                largest_negative = num\n            elif abs(num) == abs(largest_negative) and num > largest_negative:\n                largest_negative = num\n    \n    return largest_negative"], "responses": ["\nfrom typing import List\n\ndef largest_neg(list1: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the largest negative number from the given list.\n    \"\"\"\n    largest_negative = None\n    \n    for num in list1:\n        if num < 0:\n            if largest_negative is None or abs(num) > abs(largest_negative):\n                largest_negative = num\n            elif abs(num) == abs(largest_negative) and num > largest_negative:\n                largest_negative = num\n    \n    return largest_negative\n\n\n"], "prompt_tokens": [5024], "completion_tokens": [4604], "no_of_try": 1, "api_calls": 10, "is_solved": true, "task_id": "mbpp_443_largest_neg"}
{"name": "mbpp_602_first_repeated_char", "language": "Python3", "prompt": "from typing import Optional\n\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n\tWrite a python function to find the first repeated character in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "first_repeated_char", "test": "def check(candidate):\n    assert candidate('abcabc') == 'a'\n    assert candidate('abc') == None\n    assert candidate('123123') == '1'\n\ndef test_check():\n    check(first_repeated_char)\n\ntest_check()\n", "sample_io": ["assert first_repeated_char('abcabc') == 'a'"], "source_codes": ["def first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Set to track characters we've already seen\n    seen = set()\n    \n    # Iterate through each character in the string\n    for char in str1:\n        # If we've seen this character before, it's our first repeat\n        if char in seen:\n            return char\n        # Otherwise, add it to our seen set and continue\n        seen.add(char)\n    \n    # If we get through the whole string without finding repeats\n    return None"], "responses": ["\ndef first_repeated_char(str1: str) -> Optional[str]:\n    \"\"\"\n    Find the first repeated character in a given string.\n    \n    Args:\n        str1: Input string to search for repeated characters\n        \n    Returns:\n        The first repeated character, or None if no repeats found\n    \"\"\"\n    # Handle edge case: empty string\n    if not str1:\n        return None\n    \n    # Set to track characters we've already seen\n    seen = set()\n    \n    # Iterate through each character in the string\n    for char in str1:\n        # If we've seen this character before, it's our first repeat\n        if char in seen:\n            return char\n        # Otherwise, add it to our seen set and continue\n        seen.add(char)\n    \n    # If we get through the whole string without finding repeats\n    return None\n\n\n"], "prompt_tokens": [1674], "completion_tokens": [891], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_602_first_repeated_char"}
{"name": "mbpp_770_odd_num_sum", "language": "Python3", "prompt": "def odd_num_sum(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of fourth power of first n odd natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_num_sum", "test": "def check(candidate):\n    assert candidate(2) == 82\n    assert candidate(3) == 707\n    assert candidate(4) == 3108\n\ndef test_check():\n    check(odd_num_sum)\n\ntest_check()\n", "sample_io": ["assert odd_num_sum(2) == 82"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_770_odd_num_sum"}
{"name": "mbpp_424_extract_rear", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n\tWrite a function to extract only the rear index element of each string in the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_rear", "test": "def check(candidate):\n    assert candidate(('Mers', 'for', 'Vers')) == ['s', 'r', 's']\n    assert candidate(('Avenge', 'for', 'People')) == ['e', 'r', 'e']\n    assert candidate(('Gotta', 'get', 'go')) == ['a', 't', 'o']\n\ndef test_check():\n    check(extract_rear)\n\ntest_check()\n", "sample_io": ["assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"], "source_codes": ["def extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in test_tuple]"], "responses": ["\nfrom typing import Tuple, List\n\ndef extract_rear(test_tuple: Tuple[str, str, str]) -> List[str]:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in test_tuple]\n\n\n"], "prompt_tokens": [1867], "completion_tokens": [1144], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_424_extract_rear"}
{"name": "mbpp_133_sum_negativenum", "language": "Python3", "prompt": "from typing import List\n\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of the negative numbers of a given list of numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_negativenum", "test": "def check(candidate):\n    assert candidate([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32\n    assert candidate([10, 15, -14, 13, -18, 12, -20]) == -52\n    assert candidate([19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894\n\ndef test_check():\n    check(sum_negativenum)\n\ntest_check()\n", "sample_io": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"], "source_codes": ["def sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of the negative numbers of a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The sum of all negative numbers in the list\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total"], "responses": ["\ndef sum_negativenum(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of the negative numbers of a given list of numbers.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The sum of all negative numbers in the list\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total\n\n\n"], "prompt_tokens": [1299], "completion_tokens": [792], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_133_sum_negativenum"}
{"name": "mbpp_760_unique_Element", "language": "Python3", "prompt": "from typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether a list of numbers contains only one distinct element or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "unique_Element", "test": "def check(candidate):\n    assert candidate([1, 1, 1]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == False\n\ndef test_check():\n    check(unique_Element)\n\ntest_check()\n", "sample_io": ["assert unique_Element([1, 1, 1]) == True"], "source_codes": ["def unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        bool: True if the list contains only one distinct element or is empty, False otherwise\n    \"\"\"\n    # Handle edge case: empty list\n    if not arr:\n        return True\n    \n    # Convert to set to get unique elements\n    unique_elements = set(arr)\n    \n    # Check if there's exactly one distinct element\n    return len(unique_elements) == 1"], "responses": ["\nfrom typing import List\n\ndef unique_Element(arr: List[int]) -> bool:\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        arr: A list of integers\n        \n    Returns:\n        bool: True if the list contains only one distinct element or is empty, False otherwise\n    \"\"\"\n    # Handle edge case: empty list\n    if not arr:\n        return True\n    \n    # Convert to set to get unique elements\n    unique_elements = set(arr)\n    \n    # Check if there's exactly one distinct element\n    return len(unique_elements) == 1\n\n\n"], "prompt_tokens": [1571], "completion_tokens": [848], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_760_unique_Element"}
{"name": "mbpp_281_all_unique", "language": "Python3", "prompt": "from typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check if the elements of a given list are unique or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_unique", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == True\n    assert candidate([1, 2, 1, 2]) == False\n    assert candidate([1, 2, 3, 4, 5]) == True\n\ndef test_check():\n    check(all_unique)\n\ntest_check()\n", "sample_io": ["assert all_unique([1, 2, 3]) == True"], "source_codes": ["def all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    # Convert list to set to remove duplicates\n    unique_elements = set(test_list)\n    \n    # Compare lengths to determine if all elements were unique\n    return len(test_list) == len(unique_elements)"], "responses": ["\nfrom typing import List\n\ndef all_unique(test_list: List[int]) -> bool:\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    \"\"\"\n    # Convert list to set to remove duplicates\n    unique_elements = set(test_list)\n    \n    # Compare lengths to determine if all elements were unique\n    return len(test_list) == len(unique_elements)\n\n\n"], "prompt_tokens": [1660], "completion_tokens": [784], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_281_all_unique"}
{"name": "mbpp_406_find_Parity", "language": "Python3", "prompt": "def find_Parity(x: int) -> bool:\n    \"\"\"\n\tWrite a python function to find whether the parity of a given number is odd.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Parity", "test": "def check(candidate):\n    assert candidate(12) == False\n    assert candidate(7) == True\n    assert candidate(10) == False\n\ndef test_check():\n    check(find_Parity)\n\ntest_check()\n", "sample_io": ["assert find_Parity(12) == False"], "source_codes": ["def find_Parity(x: int) -> bool:\n    \"\"\"\n    Write a python function to find whether the parity of a given number is odd.\n    \"\"\"\n    # Get the absolute value to handle negative numbers\n    x = abs(x)\n    \n    # Count the number of 1-bits in the binary representation\n    count_of_ones = bin(x).count('1')\n    \n    # Check if the count is odd\n    return count_of_ones % 2 == 1"], "responses": ["\ndef find_Parity(x: int) -> bool:\n    \"\"\"\n    Write a python function to find whether the parity of a given number is odd.\n    \"\"\"\n    # Get the absolute value to handle negative numbers\n    x = abs(x)\n    \n    # Count the number of 1-bits in the binary representation\n    count_of_ones = bin(x).count('1')\n    \n    # Check if the count is odd\n    return count_of_ones % 2 == 1\n\n\n"], "prompt_tokens": [2415], "completion_tokens": [1470], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_406_find_Parity"}
{"name": "mbpp_562_Find_Max_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 4], [5, 6, 7, 8]]) == 4\n    assert candidate([[0, 1], [2, 2], [3, 2, 1]]) == 3\n    assert candidate([[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5\n\ndef test_check():\n    check(Find_Max_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"], "source_codes": ["def Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n    if not lst:\n        return 0\n    \n    return max(len(sublist) for sublist in lst)"], "responses": ["\nfrom typing import List\n\ndef Find_Max_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest sublists.\n\t\"\"\"\n    if not lst:\n        return 0\n    \n    return max(len(sublist) for sublist in lst)\n\n\n"], "prompt_tokens": [1652], "completion_tokens": [876], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_562_Find_Max_Length"}
{"name": "mbpp_87_merge_dictionaries_three", "language": "Python3", "prompt": "from typing import Dict\n\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to merge three dictionaries into a single dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_dictionaries_three", "test": "def check(candidate):\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'L': 'lavender', 'B': 'Blue' }) == { 'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender' }\n    assert candidate({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'L': 'lavender', 'B': 'Blue' }, { 'G': 'Green', 'W': 'White' }) == { 'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White' }\n\ndef test_check():\n    check(merge_dictionaries_three)\n\ntest_check()\n", "sample_io": ["assert merge_dictionaries_three({ 'R': 'Red', 'B': 'Black', 'P': 'Pink' }, { 'G': 'Green', 'W': 'White' }, { 'O': 'Orange', 'W': 'White', 'B': 'Black' }) == { 'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange' }"], "source_codes": ["def merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Merge three dictionaries into a single dictionary.\n    If there are duplicate keys, values from later dictionaries override earlier ones.\n    \n    Args:\n        dict1: First dictionary with string keys and values\n        dict2: Second dictionary with string keys and values\n        dict3: Third dictionary with string keys and values\n        \n    Returns:\n        A merged dictionary containing all key-value pairs from all three input dictionaries\n    \"\"\"\n    return {**dict1, **dict2, **dict3}"], "responses": ["\ndef merge_dictionaries_three(dict1: Dict[str, str], dict2: Dict[str, str], dict3: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"\n    Merge three dictionaries into a single dictionary.\n    If there are duplicate keys, values from later dictionaries override earlier ones.\n    \n    Args:\n        dict1: First dictionary with string keys and values\n        dict2: Second dictionary with string keys and values\n        dict3: Third dictionary with string keys and values\n        \n    Returns:\n        A merged dictionary containing all key-value pairs from all three input dictionaries\n    \"\"\"\n    return {**dict1, **dict2, **dict3}\n\n\n"], "prompt_tokens": [2164], "completion_tokens": [1098], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_87_merge_dictionaries_three"}
{"name": "mbpp_11_remove_Occ", "language": "Python3", "prompt": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n\tWrite a python function to remove first and last occurrence of a given character from the string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_Occ", "test": "def check(candidate):\n    assert candidate('hello', 'l') == 'heo'\n    assert candidate('abcda', 'a') == 'bcd'\n    assert candidate('PHP', 'P') == 'H'\n\ndef test_check():\n    check(remove_Occ)\n\ntest_check()\n", "sample_io": ["assert remove_Occ('hello', 'l') == 'heo'"], "source_codes": ["def remove_Occ(s: str, ch: str) -> str:\n    # Find the first and last occurrence of the character\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    # If character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    # Remove last first to keep the first index valid\n    result = s[:last_index] + s[last_index + 1:]\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result"], "responses": ["\ndef remove_Occ(s: str, ch: str) -> str:\n    # Find the first and last occurrence of the character\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    # If character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    # Remove last first to keep the first index valid\n    result = s[:last_index] + s[last_index + 1:]\n    result = result[:first_index] + result[first_index + 1:]\n    \n    return result\n\n\n"], "prompt_tokens": [1846], "completion_tokens": [1180], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_11_remove_Occ"}
{"name": "mbpp_751_check_min_heap", "language": "Python3", "prompt": "from typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n\tWrite a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_min_heap", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([2, 3, 4, 5, 10, 15]) == True\n    assert candidate([2, 10, 4, 5, 3, 15]) == False\n\ndef test_check():\n    check(check_min_heap)\n\ntest_check()\n", "sample_io": ["assert check_min_heap([1, 2, 3, 4, 5, 6]) == True"], "source_codes": ["def check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    Args:\n        arr: List of integers representing a binary tree in level order\n        \n    Returns:\n        bool: True if array represents a min heap, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return True\n    \n    # Calculate the index of the last non-leaf node\n    last_non_leaf = len(arr) // 2 - 1\n    \n    # Check min heap property for all non-leaf nodes\n    for i in range(last_non_leaf + 1):\n        # Check left child (index 2*i + 1)\n        if 2 * i + 1 < len(arr) and arr[i] > arr[2 * i + 1]:\n            return False\n            \n        # Check right child (index 2*i + 2)\n        if 2 * i + 2 < len(arr) and arr[i] > arr[2 * i + 2]:\n            return False\n    \n    return True"], "responses": ["\nfrom typing import List\n\ndef check_min_heap(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    Args:\n        arr: List of integers representing a binary tree in level order\n        \n    Returns:\n        bool: True if array represents a min heap, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if len(arr) <= 1:\n        return True\n    \n    # Calculate the index of the last non-leaf node\n    last_non_leaf = len(arr) // 2 - 1\n    \n    # Check min heap property for all non-leaf nodes\n    for i in range(last_non_leaf + 1):\n        # Check left child (index 2*i + 1)\n        if 2 * i + 1 < len(arr) and arr[i] > arr[2 * i + 1]:\n            return False\n            \n        # Check right child (index 2*i + 2)\n        if 2 * i + 2 < len(arr) and arr[i] > arr[2 * i + 2]:\n            return False\n    \n    return True\n\n\n"], "prompt_tokens": [2125], "completion_tokens": [1199], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_751_check_min_heap"}
{"name": "mbpp_410_min_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 2\n    assert candidate(['Python', 15, 20, 25]) == 15\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 20\n\ndef test_check():\n    check(min_val)\n\ntest_check()\n", "sample_io": ["assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"], "source_codes": ["def min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    valid_integers = []\n    \n    for item in listval:\n        if isinstance(item, int):\n            valid_integers.append(item)\n        elif isinstance(item, str):\n            try:\n                num = int(item)\n                valid_integers.append(num)\n            except ValueError:\n                # Skip non-numeric strings\n                continue\n    \n    return min(valid_integers)"], "responses": ["\nfrom typing import List, Union\n\ndef min_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n    \"\"\"\n    valid_integers = []\n    \n    for item in listval:\n        if isinstance(item, int):\n            valid_integers.append(item)\n        elif isinstance(item, str):\n            try:\n                num = int(item)\n                valid_integers.append(num)\n            except ValueError:\n                # Skip non-numeric strings\n                continue\n    \n    return min(valid_integers)\n\n\n"], "prompt_tokens": [1728], "completion_tokens": [1059], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_410_min_val"}
{"name": "mbpp_578_interleave_lists", "language": "Python3", "prompt": "from typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to interleave 3 lists of the same length into a single flat list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "interleave_lists", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    assert candidate([10, 20], [15, 2], [5, 10]) == [10, 15, 5, 20, 2, 10]\n    assert candidate([11, 44], [10, 15], [20, 5]) == [11, 10, 20, 44, 15, 5]\n\ndef test_check():\n    check(interleave_lists)\n\ntest_check()\n", "sample_io": ["assert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"], "source_codes": ["def interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n        list1: First list of integers\n        list2: Second list of integers\n        list3: Third list of integers\n        \n    Returns:\n        A single list with elements interleaved from the three input lists\n    \"\"\"\n    # Handle edge case of empty lists\n    if not list1 and not list2 and not list3:\n        return []\n    \n    # Use zip to combine the lists element-wise and flatten with list comprehension\n    result = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n        list1: First list of integers\n        list2: Second list of integers\n        list3: Third list of integers\n        \n    Returns:\n        A single list with elements interleaved from the three input lists\n    \"\"\"\n    # Handle edge case of empty lists\n    if not list1 and not list2 and not list3:\n        return []\n    \n    # Use zip to combine the lists element-wise and flatten with list comprehension\n    result = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return result\n\n\n"], "prompt_tokens": [2255], "completion_tokens": [1441], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_578_interleave_lists"}
{"name": "mbpp_90_len_log", "language": "Python3", "prompt": "from typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the longest word.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "len_log", "test": "def check(candidate):\n    assert candidate(['python', 'PHP', 'bigdata']) == 7\n    assert candidate(['a', 'ab', 'abc']) == 3\n    assert candidate(['small', 'big', 'tall']) == 5\n\ndef test_check():\n    check(len_log)\n\ntest_check()\n", "sample_io": ["assert len_log(['python', 'PHP', 'bigdata']) == 7"], "source_codes": ["def len_log(list1: List[str]) -> int:\n    \"\"\"\n    Find the length of the longest word in a list of strings.\n    \n    Args:\n        list1: A list of strings\n        \n    Returns:\n        The length of the longest string in the list, or 0 if the list is empty\n    \"\"\"\n    # Handle edge case for empty list\n    if not list1:\n        return 0\n    \n    # Initialize maximum length tracker\n    max_length = 0\n    \n    # Iterate through each string in the list\n    for word in list1:\n        # Get the length of current word\n        current_length = len(word)\n        \n        # Update maximum length if current word is longer\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length"], "responses": ["\nfrom typing import List\n\ndef len_log(list1: List[str]) -> int:\n    \"\"\"\n    Find the length of the longest word in a list of strings.\n    \n    Args:\n        list1: A list of strings\n        \n    Returns:\n        The length of the longest string in the list, or 0 if the list is empty\n    \"\"\"\n    # Handle edge case for empty list\n    if not list1:\n        return 0\n    \n    # Initialize maximum length tracker\n    max_length = 0\n    \n    # Iterate through each string in the list\n    for word in list1:\n        # Get the length of current word\n        current_length = len(word)\n        \n        # Update maximum length if current word is longer\n        if current_length > max_length:\n            max_length = current_length\n    \n    return max_length\n\n\n"], "prompt_tokens": [1578], "completion_tokens": [843], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_90_len_log"}
{"name": "mbpp_452_loss_amount", "language": "Python3", "prompt": "def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n\tWrite a function that gives loss amount on a sale if the given amount has loss else return 0.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "loss_amount", "test": "def check(candidate):\n    assert candidate(1500, 1200) == 0\n    assert candidate(100, 200) == 100\n    assert candidate(2000, 5000) == 3000\n\ndef test_check():\n    check(loss_amount)\n\ntest_check()\n", "sample_io": ["assert loss_amount(1500, 1200) == 0"], "source_codes": ["def loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return 0"], "responses": ["\ndef loss_amount(actual_cost: int, sale_amount: int) -> int:\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n    \"\"\"\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return 0\n\n\n"], "prompt_tokens": [3687], "completion_tokens": [1679], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_452_loss_amount"}
{"name": "mbpp_798__sum", "language": "Python3", "prompt": "from typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([15, 12, 13, 10]) == 50\n    assert candidate([0, 1, 2]) == 3\n\ndef test_check():\n    check(_sum)\n\ntest_check()\n", "sample_io": ["assert _sum([1, 2, 3]) == 6"], "source_codes": ["def _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Initialize running sum\n    total = 0\n    \n    # Iterate through each element and add to sum\n    for element in arr:\n        total += element\n    \n    # Return the final sum\n    return total"], "responses": ["\nfrom typing import List\n\ndef _sum(arr: List[int]) -> int:\n    \"\"\"\n    Write a python function to find the sum of an array.\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Initialize running sum\n    total = 0\n    \n    # Iterate through each element and add to sum\n    for element in arr:\n        total += element\n    \n    # Return the final sum\n    return total\n\n\n"], "prompt_tokens": [1467], "completion_tokens": [698], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_798__sum"}
{"name": "mbpp_393_max_length_list", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    \"\"\"\n\tWrite a function to find the list with maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_length_list", "test": "def check(candidate):\n    assert candidate([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    assert candidate([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5])\n    assert candidate([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9])\n\ndef test_check():\n    check(max_length_list)\n\ntest_check()\n", "sample_io": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"], "source_codes": ["def max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not input_list:\n        return (0, [])\n    \n    # Initialize with first element\n    max_len = len(input_list[0])\n    max_list = input_list[0]\n    \n    # Iterate through remaining sublists\n    for sublist in input_list[1:]:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    \n    return (max_len, max_list)"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_length_list(input_list: List[List[int]]) -> Tuple[int, List[int]]:\n    # Handle edge case: empty input list\n    if not input_list:\n        return (0, [])\n    \n    # Initialize with first element\n    max_len = len(input_list[0])\n    max_list = input_list[0]\n    \n    # Iterate through remaining sublists\n    for sublist in input_list[1:]:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    \n    return (max_len, max_list)\n\n\n"], "prompt_tokens": [1697], "completion_tokens": [988], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_393_max_length_list"}
{"name": "mbpp_272_rear_extract", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rear_extract", "test": "def check(candidate):\n    assert candidate([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n    assert candidate([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]\n    assert candidate([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]\n\ndef test_check():\n    check(rear_extract)\n\ntest_check()\n", "sample_io": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"], "source_codes": ["def rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]"], "responses": ["\nfrom typing import List, Tuple\n\ndef rear_extract(test_list: List[Tuple[int, str, int]]) -> List[int]:\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in test_list]\n\n\n"], "prompt_tokens": [1759], "completion_tokens": [797], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_272_rear_extract"}
{"name": "mbpp_564_count_Pairs", "language": "Python3", "prompt": "from typing import List\n\ndef count_Pairs(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_Pairs", "test": "def check(candidate):\n    assert candidate([1, 2, 1], 3) == 2\n    assert candidate([1, 1, 1, 1], 4) == 0\n    assert candidate([1, 2, 3, 4, 5], 5) == 10\n\ndef test_check():\n    check(count_Pairs)\n\ntest_check()\n", "sample_io": ["assert count_Pairs([1, 2, 1], 3) == 2"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_564_count_Pairs"}
{"name": "mbpp_438_count_bidirectional", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef count_bidirectional(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to count bidirectional tuple pairs.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_bidirectional", "test": "def check(candidate):\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3\n    assert candidate([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2\n    assert candidate([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4\n\ndef test_check():\n    check(count_bidirectional)\n\ntest_check()\n", "sample_io": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_438_count_bidirectional"}
{"name": "mbpp_640_remove_parenthesis", "language": "Python3", "prompt": "from typing import List\n\ndef remove_parenthesis(items: List[str]) -> str:\n    \"\"\"\n\tWrite a function to remove the parenthesis and what is inbetween them from a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_parenthesis", "test": "def check(candidate):\n    assert candidate(['python (chrome)']) == 'python'\n    assert candidate(['string(.abc)']) == 'string'\n    assert candidate(['alpha(num)']) == 'alpha'\n\ndef test_check():\n    check(remove_parenthesis)\n\ntest_check()\n", "sample_io": ["assert remove_parenthesis(['python (chrome)']) == 'python'"], "source_codes": ["def remove_parenthesis(items: List[str]) -> str:\n    result = []\n    \n    for item in items:\n        # Process each string to remove parentheses and their contents\n        while '(' in item and ')' in item:\n            # Find the last opening parenthesis (to handle nesting correctly)\n            open_pos = item.rfind('(')\n            # Find the first closing parenthesis after the last opening one\n            close_pos = item.find(')', open_pos)\n            \n            if open_pos != -1 and close_pos != -1 and open_pos < close_pos:\n                # Remove the substring including the parentheses\n                item = item[:open_pos] + item[close_pos + 1:]\n            else:\n                # If no valid pair found, break to avoid infinite loop\n                break\n        \n        # Remove any remaining unmatched parentheses\n        item = item.replace('(', '').replace(')', '')\n        \n        # Strip trailing and leading whitespace that might have been left behind\n        item = item.strip()\n        \n        result.append(item)\n    \n    return ' '.join(result)"], "responses": ["\ndef remove_parenthesis(items: List[str]) -> str:\n    result = []\n    \n    for item in items:\n        # Process each string to remove parentheses and their contents\n        while '(' in item and ')' in item:\n            # Find the last opening parenthesis (to handle nesting correctly)\n            open_pos = item.rfind('(')\n            # Find the first closing parenthesis after the last opening one\n            close_pos = item.find(')', open_pos)\n            \n            if open_pos != -1 and close_pos != -1 and open_pos < close_pos:\n                # Remove the substring including the parentheses\n                item = item[:open_pos] + item[close_pos + 1:]\n            else:\n                # If no valid pair found, break to avoid infinite loop\n                break\n        \n        # Remove any remaining unmatched parentheses\n        item = item.replace('(', '').replace(')', '')\n        \n        # Strip trailing and leading whitespace that might have been left behind\n        item = item.strip()\n        \n        result.append(item)\n    \n    return ' '.join(result)\n\n\n"], "prompt_tokens": [4360], "completion_tokens": [2060], "no_of_try": 1, "api_calls": 8, "is_solved": true, "task_id": "mbpp_640_remove_parenthesis"}
{"name": "mbpp_72_dif_Square", "language": "Python3", "prompt": "def dif_Square(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dif_Square", "test": "def check(candidate):\n    assert candidate(5) == True\n    assert candidate(10) == False\n    assert candidate(15) == True\n\ndef test_check():\n    check(dif_Square)\n\ntest_check()\n", "sample_io": ["assert dif_Square(5) == True"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_72_dif_Square"}
{"name": "mbpp_448_cal_sum", "language": "Python3", "prompt": "def cal_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the sum of perrin numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cal_sum", "test": "def check(candidate):\n    assert candidate(9) == 49\n    assert candidate(10) == 66\n    assert candidate(11) == 88\n\ndef test_check():\n    check(cal_sum)\n\ntest_check()\n", "sample_io": ["assert cal_sum(9) == 49"], "source_codes": ["def cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    \n    # Base cases for Perrin sequence\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 5  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = 5  # Sum of first three terms\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum"], "responses": ["\ndef cal_sum(n: int) -> int:\n    if n < 0:\n        return 0\n    \n    # Base cases for Perrin sequence\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3  # P(0) + P(1) = 3 + 0 = 3\n    elif n == 2:\n        return 5  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n    \n    # Initialize first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    total_sum = 5  # Sum of first three terms\n    \n    # Calculate remaining Perrin numbers and add to sum\n    for i in range(3, n + 1):\n        next_perrin = p1 + p0\n        total_sum += next_perrin\n        # Shift values for next iteration\n        p0, p1, p2 = p1, p2, next_perrin\n    \n    return total_sum\n\n\n"], "prompt_tokens": [1296], "completion_tokens": [1505], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_448_cal_sum"}
{"name": "mbpp_96_divisor", "language": "Python3", "prompt": "def divisor(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of divisors of a given integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "divisor", "test": "def check(candidate):\n    assert candidate(15) == 4\n    assert candidate(12) == 6\n    assert candidate(9) == 3\n\ndef test_check():\n    check(divisor)\n\ntest_check()\n", "sample_io": ["assert divisor(15) == 4"], "source_codes": ["def divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The number of divisors of n\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through numbers from 1 to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                # Perfect square case - add only 1\n                count += 1\n            else:\n                # Add 2 for both divisors (i and n//i)\n                count += 2\n        i += 1\n    \n    return count"], "responses": ["\ndef divisor(n: int) -> int:\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        The number of divisors of n\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return 0\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through numbers from 1 to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                # Perfect square case - add only 1\n                count += 1\n            else:\n                # Add 2 for both divisors (i and n//i)\n                count += 2\n        i += 1\n    \n    return count\n\n\n"], "prompt_tokens": [2334], "completion_tokens": [1680], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_96_divisor"}
{"name": "mbpp_296_get_Inv_Count", "language": "Python3", "prompt": "from typing import List\n\ndef get_Inv_Count(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to count inversions in an array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Inv_Count", "test": "def check(candidate):\n    assert candidate([1, 20, 6, 4, 5]) == 5\n    assert candidate([1, 2, 1]) == 1\n    assert candidate([1, 2, 5, 6, 1]) == 3\n\ndef test_check():\n    check(get_Inv_Count)\n\ntest_check()\n", "sample_io": ["assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_296_get_Inv_Count"}
{"name": "mbpp_57_find_Max_Num", "language": "Python3", "prompt": "from typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the largest number that can be formed with the given list of digits.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Max_Num", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 321\n    assert candidate([4, 5, 6, 1]) == 6541\n    assert candidate([1, 2, 3, 9]) == 9321\n\ndef test_check():\n    check(find_Max_Num)\n\ntest_check()\n", "sample_io": ["assert find_Max_Num([1, 2, 3]) == 321"], "source_codes": ["def find_Max_Num(arr: List[int]) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Convert all digits to strings for concatenation\n    str_digits = [str(digit) for digit in arr]\n    \n    # Join the sorted string digits to form the largest possible number string\n    max_num_str = ''.join(str_digits)\n    \n    # Convert the result back to integer\n    max_num = int(max_num_str)\n    \n    # Handle special case where all digits are zero\n    # This is automatically handled by the above logic since \"000\" becomes 0 when converted to int\n    \n    return max_num"], "responses": ["\nfrom typing import List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    # Handle edge case of empty array\n    if not arr:\n        return 0\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Convert all digits to strings for concatenation\n    str_digits = [str(digit) for digit in arr]\n    \n    # Join the sorted string digits to form the largest possible number string\n    max_num_str = ''.join(str_digits)\n    \n    # Convert the result back to integer\n    max_num = int(max_num_str)\n    \n    # Handle special case where all digits are zero\n    # This is automatically handled by the above logic since \"000\" becomes 0 when converted to int\n    \n    return max_num\n\n\n"], "prompt_tokens": [1832], "completion_tokens": [1228], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_57_find_Max_Num"}
{"name": "mbpp_614_cummulative_sum", "language": "Python3", "prompt": "from typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a function to find the cumulative sum of all the values that are present in the given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "cummulative_sum", "test": "def check(candidate):\n    assert candidate([[1, 3], [5, 6, 7], [2, 6]]) == 30\n    assert candidate([[2, 4], [6, 7, 8], [3, 7]]) == 37\n    assert candidate([[3, 5], [7, 8, 9], [4, 8]]) == 44\n\ndef test_check():\n    check(cummulative_sum)\n\ntest_check()\n", "sample_io": ["assert cummulative_sum([[1, 3], [5, 6, 7], [2, 6]]) == 30"], "source_codes": ["def cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Find the cumulative sum of all the values that are present in the given list of lists.\n    \n    Args:\n        test_list: A list of lists containing integers\n        \n    Returns:\n        The cumulative sum of all integers in all sublists\n    \"\"\"\n    total = 0\n    \n    for sublist in test_list:\n        for element in sublist:\n            total += element\n            \n    return total"], "responses": ["\nfrom typing import List\n\ndef cummulative_sum(test_list: List[List[int]]) -> int:\n    \"\"\"\n    Find the cumulative sum of all the values that are present in the given list of lists.\n    \n    Args:\n        test_list: A list of lists containing integers\n        \n    Returns:\n        The cumulative sum of all integers in all sublists\n    \"\"\"\n    total = 0\n    \n    for sublist in test_list:\n        for element in sublist:\n            total += element\n            \n    return total\n\n\n"], "prompt_tokens": [1923], "completion_tokens": [1117], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_614_cummulative_sum"}
{"name": "mbpp_623_nth_nums", "language": "Python3", "prompt": "from typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function to compute the n-th power of each number in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "nth_nums", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    assert candidate([10, 20, 30], 3) == [1000, 8000, 27000]\n    assert candidate([12, 15], 5) == [248832, 759375]\n\ndef test_check():\n    check(nth_nums)\n\ntest_check()\n", "sample_io": ["assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"], "source_codes": ["def nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function to compute the n-th power of each number in a list.\n    \"\"\"\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not nums:\n        return []\n    \n    # Handle edge case: if n=0, return a list of 1s with same length as input list\n    if n == 0:\n        return [1] * len(nums)\n    \n    # Use list comprehension to iterate through each number in the input list\n    # Apply the power operation (**) to raise each number to the n-th power\n    return [num ** n for num in nums]"], "responses": ["\nfrom typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Write a function to compute the n-th power of each number in a list.\n    \"\"\"\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not nums:\n        return []\n    \n    # Handle edge case: if n=0, return a list of 1s with same length as input list\n    if n == 0:\n        return [1] * len(nums)\n    \n    # Use list comprehension to iterate through each number in the input list\n    # Apply the power operation (**) to raise each number to the n-th power\n    return [num ** n for num in nums]\n\n\n"], "prompt_tokens": [1907], "completion_tokens": [994], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_623_nth_nums"}
{"name": "mbpp_799_left_rotate", "language": "Python3", "prompt": "def left_rotate(n: int, d: int) -> int:\n    \"\"\"\n\tWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_rotate", "test": "def check(candidate):\n    assert candidate(16, 2) == 64\n    assert candidate(10, 2) == 40\n    assert candidate(99, 3) == 792\n    assert candidate(99, 3) == 792\n    assert candidate(1, 3) == 8\n    assert candidate(5, 3) == 40\n    assert candidate(29, 3) == 232\n\ndef test_check():\n    check(left_rotate)\n\ntest_check()\n", "sample_io": ["assert left_rotate(16, 2) == 64"], "source_codes": ["def left_rotate(n: int, d: int) -> int:\n    # Handle case where d is greater than 32\n    d = d % 32\n    \n    # If d is 0, no rotation needed\n    if d == 0:\n        return n\n    \n    # Create a mask to isolate the leftmost d bits\n    mask = (1 << d) - 1\n    \n    # Extract the leftmost d bits that will be rotated to the right\n    rotated_bits = (n >> (32 - d)) & mask\n    \n    # Shift the number left by d positions and mask to keep within 32 bits\n    shifted = (n << d) & 0xFFFFFFFF\n    \n    # Combine the shifted number with the rotated bits\n    result = shifted | rotated_bits\n    \n    return result"], "responses": ["\ndef left_rotate(n: int, d: int) -> int:\n    # Handle case where d is greater than 32\n    d = d % 32\n    \n    # If d is 0, no rotation needed\n    if d == 0:\n        return n\n    \n    # Create a mask to isolate the leftmost d bits\n    mask = (1 << d) - 1\n    \n    # Extract the leftmost d bits that will be rotated to the right\n    rotated_bits = (n >> (32 - d)) & mask\n    \n    # Shift the number left by d positions and mask to keep within 32 bits\n    shifted = (n << d) & 0xFFFFFFFF\n    \n    # Combine the shifted number with the rotated bits\n    result = shifted | rotated_bits\n    \n    return result\n\n\n"], "prompt_tokens": [1448], "completion_tokens": [1233], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_799_left_rotate"}
{"name": "mbpp_247_lps", "language": "Python3", "prompt": "def lps(str: str) -> int:\n    \"\"\"\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "lps", "test": "def check(candidate):\n    assert candidate('TENS FOR TENS') == 5\n    assert candidate('CARDIO FOR CARDS') == 7\n    assert candidate('PART OF THE JOURNEY IS PART') == 9\n\ndef test_check():\n    check(lps)\n\ntest_check()\n", "sample_io": ["assert lps('TENS FOR TENS') == 5"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_247_lps"}
{"name": "mbpp_735_toggle_middle_bits", "language": "Python3", "prompt": "def toggle_middle_bits(n: int) -> int:\n    \"\"\"\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "toggle_middle_bits", "test": "def check(candidate):\n    assert candidate(9) == 15\n    assert candidate(10) == 12\n    assert candidate(11) == 13\n    assert candidate(65) == 127\n    assert candidate(77) == 115\n\ndef test_check():\n    check(toggle_middle_bits)\n\ntest_check()\n", "sample_io": ["assert toggle_middle_bits(9) == 15"], "source_codes": ["def toggle_middle_bits(n: int) -> int:\n    # Handle edge cases where there are no middle bits\n    if n <= 1 or (n & (n - 1)) == 0 or n == 2:  # 0, 1, or power of 2 (only one bit set) or 2\n        return n\n    \n    # Find the position of the most significant bit\n    temp = n\n    msb_pos = 0\n    while temp > 0:\n        temp >>= 1\n        msb_pos += 1\n    msb_pos -= 1\n    \n    # Create a mask with all bits set from position 1 to msb_pos-1\n    # This will have 1s in all positions except the first and last bits\n    if msb_pos <= 1:\n        return n\n    \n    # Create mask: all 1s from bit 1 to bit (msb_pos - 1)\n    mask = ((1 << msb_pos) - 1) ^ 1  # All 1s up to msb_pos, then XOR with 1 to clear bit 0\n    \n    # Toggle the middle bits using XOR\n    return n ^ mask"], "responses": ["\ndef toggle_middle_bits(n: int) -> int:\n    # Handle edge cases where there are no middle bits\n    if n <= 1 or (n & (n - 1)) == 0 or n == 2:  # 0, 1, or power of 2 (only one bit set) or 2\n        return n\n    \n    # Find the position of the most significant bit\n    temp = n\n    msb_pos = 0\n    while temp > 0:\n        temp >>= 1\n        msb_pos += 1\n    msb_pos -= 1\n    \n    # Create a mask with all bits set from position 1 to msb_pos-1\n    # This will have 1s in all positions except the first and last bits\n    if msb_pos <= 1:\n        return n\n    \n    # Create mask: all 1s from bit 1 to bit (msb_pos - 1)\n    mask = ((1 << msb_pos) - 1) ^ 1  # All 1s up to msb_pos, then XOR with 1 to clear bit 0\n    \n    # Toggle the middle bits using XOR\n    return n ^ mask\n\n\n"], "prompt_tokens": [1465], "completion_tokens": [1273], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_735_toggle_middle_bits"}
{"name": "mbpp_132_tup_string", "language": "Python3", "prompt": "from typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n\tWrite a function to convert a list to a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tup_string", "test": "def check(candidate):\n    assert candidate(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n']) == 'python'\n    assert candidate(['p', 'r', 'o', 'g', 'r', 'a', 'm']) == 'program'\n\ndef test_check():\n    check(tup_string)\n\ntest_check()\n", "sample_io": ["assert tup_string(['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's']) == 'exercises'"], "source_codes": ["def tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return \"\".join(tup1)"], "responses": ["\nfrom typing import List\n\ndef tup_string(tup1: List[str]) -> str:\n    \"\"\"\n    Write a function to convert a list to a string.\n    \"\"\"\n    return \"\".join(tup1)\n\n\n"], "prompt_tokens": [3163], "completion_tokens": [1090], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_132_tup_string"}
{"name": "mbpp_460_Extract", "language": "Python3", "prompt": "from typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n\tWrite a python function to get the first element of each sublist.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Extract", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    assert candidate([[1, 2, 3], [4, 5]]) == [1, 4]\n    assert candidate([[9, 8, 1], [1, 2]]) == [9, 1]\n\ndef test_check():\n    check(Extract)\n\ntest_check()\n", "sample_io": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"], "source_codes": ["def Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    # Handle edge case: empty input list\n    if not lst:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Check if sublist is not empty before accessing first element\n        if sublist:\n            result.append(sublist[0])\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef Extract(lst: List[List[int]]) -> List[int]:\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    \"\"\"\n    # Handle edge case: empty input list\n    if not lst:\n        return []\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Check if sublist is not empty before accessing first element\n        if sublist:\n            result.append(sublist[0])\n    \n    return result\n\n\n"], "prompt_tokens": [1659], "completion_tokens": [1063], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_460_Extract"}
{"name": "mbpp_606_radian_degree", "language": "Python3", "prompt": "def radian_degree(degree: int) -> float:\n    \"\"\"\n\tWrite a function to convert degrees to radians.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "radian_degree", "test": "def check(candidate):\n    assert candidate(90) == 1.5707963267948966\n    assert candidate(60) == 1.0471975511965976\n    assert candidate(120) == 2.0943951023931953\n\ndef test_check():\n    check(radian_degree)\n\ntest_check()\n", "sample_io": ["assert radian_degree(90) == 1.5707963267948966"], "source_codes": ["import math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Convert degrees to radians.\n    \n    Args:\n        degree (int): The angle in degrees\n        \n    Returns:\n        float: The angle in radians\n    \"\"\"\n    return degree * (math.pi / 180)"], "responses": ["\nimport math\n\ndef radian_degree(degree: int) -> float:\n    \"\"\"\n    Convert degrees to radians.\n    \n    Args:\n        degree (int): The angle in degrees\n        \n    Returns:\n        float: The angle in radians\n    \"\"\"\n    return degree * (math.pi / 180)\n\n\n"], "prompt_tokens": [1934], "completion_tokens": [1017], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_606_radian_degree"}
{"name": "mbpp_167_next_power_of_2", "language": "Python3", "prompt": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest power of 2 greater than or equal to n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_power_of_2", "test": "def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 8\n    assert candidate(17) == 32\n\ndef test_check():\n    check(next_power_of_2)\n\ntest_check()\n", "sample_io": ["assert next_power_of_2(0) == 1"], "source_codes": ["def next_power_of_2(n: int) -> int:\n    # Handle edge cases\n    if n <= 0:\n        return 1\n    \n    # Check if n is already a power of 2\n    if (n & (n - 1)) == 0:\n        return n\n    \n    # Find the next power of 2 using bit manipulation\n    # Shift right and set all bits to the right of MSB to 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    \n    # Add 1 to get the next power of 2\n    return n + 1"], "responses": ["\ndef next_power_of_2(n: int) -> int:\n    # Handle edge cases\n    if n <= 0:\n        return 1\n    \n    # Check if n is already a power of 2\n    if (n & (n - 1)) == 0:\n        return n\n    \n    # Find the next power of 2 using bit manipulation\n    # Shift right and set all bits to the right of MSB to 1\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For 64-bit integers\n    \n    # Add 1 to get the next power of 2\n    return n + 1\n\n\n"], "prompt_tokens": [1549], "completion_tokens": [1045], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_167_next_power_of_2"}
{"name": "mbpp_756_text_match_zero_one", "language": "Python3", "prompt": "def text_match_zero_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_zero_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abbbba') == True\n    assert candidate('dsabbbba') == True\n    assert candidate('asbbbba') == False\n    assert candidate('abaaa') == True\n\ndef test_check():\n    check(text_match_zero_one)\n\ntest_check()\n", "sample_io": ["assert text_match_zero_one('ac') == False"], "source_codes": ["import re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r\"ab+\"\n    return bool(re.search(pattern, text))"], "responses": ["\nimport re\n\ndef text_match_zero_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an 'a' followed by one or more 'b's.\n    \"\"\"\n    pattern = r\"ab+\"\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1799], "completion_tokens": [821], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_756_text_match_zero_one"}
{"name": "mbpp_633_pair_xor_Sum", "language": "Python3", "prompt": "from typing import List\n\ndef pair_xor_Sum(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of xor of all pairs of numbers in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pair_xor_Sum", "test": "def check(candidate):\n    assert candidate([5, 9, 7, 6], 4) == 47\n    assert candidate([7, 3, 5], 3) == 12\n    assert candidate([7, 3], 2) == 4\n\ndef test_check():\n    check(pair_xor_Sum)\n\ntest_check()\n", "sample_io": ["assert pair_xor_Sum([5, 9, 7, 6], 4) == 47"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_633_pair_xor_Sum"}
{"name": "mbpp_458_rectangle_area", "language": "Python3", "prompt": "def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n\tWrite a function to find the area of a rectangle.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rectangle_area", "test": "def check(candidate):\n    assert candidate(10, 20) == 200\n    assert candidate(10, 5) == 50\n    assert candidate(4, 2) == 8\n\ndef test_check():\n    check(rectangle_area)\n\ntest_check()\n", "sample_io": ["assert rectangle_area(10, 20) == 200"], "source_codes": ["def rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b"], "responses": ["\ndef rectangle_area(l: int, b: int) -> int:\n    \"\"\"\n    Write a function to find the area of a rectangle.\n    \"\"\"\n    return l * b\n\n\n"], "prompt_tokens": [1492], "completion_tokens": [717], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_458_rectangle_area"}
