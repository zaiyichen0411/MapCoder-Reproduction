{"name": "mbpp_738_geometric_sum", "language": "Python3", "prompt": "def geometric_sum(n: int) -> float:\n    \"\"\"\n\tWrite a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "geometric_sum", "test": "def check(candidate):\n    assert candidate(7) == 1.9921875\n    assert candidate(4) == 1.9375\n    assert candidate(8) == 1.99609375\n\ndef test_check():\n    check(geometric_sum)\n\ntest_check()\n", "sample_io": ["assert geometric_sum(7) == 1.9921875"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_738_geometric_sum"}
{"name": "mbpp_426_filter_oddnumbers", "language": "Python3", "prompt": "from typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to filter odd numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_oddnumbers", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 20, 45, 67, 84, 93]) == [45, 67, 93]\n    assert candidate([5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3]\n\ndef test_check():\n    check(filter_oddnumbers)\n\ntest_check()\n", "sample_io": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"], "source_codes": ["def filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 == 1]"], "responses": ["\nfrom typing import List\n\ndef filter_oddnumbers(nums: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to filter odd numbers.\n    \"\"\"\n    return [num for num in nums if num % 2 == 1]\n\n\n"], "prompt_tokens": [1862], "completion_tokens": [896], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_426_filter_oddnumbers"}
{"name": "mbpp_437_remove_odd", "language": "Python3", "prompt": "def remove_odd(str1: str) -> str:\n    \"\"\"\n\tWrite a function to remove odd characters in a string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_odd", "test": "def check(candidate):\n    assert candidate('python') == 'yhn'\n    assert candidate('program') == 'rga'\n    assert candidate('language') == 'agae'\n\ndef test_check():\n    check(remove_odd)\n\ntest_check()\n", "sample_io": ["assert remove_odd('python') == 'yhn'"], "source_codes": ["def remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return str1[1::2]"], "responses": ["\ndef remove_odd(str1: str) -> str:\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \"\"\"\n    return str1[1::2]\n\n\n"], "prompt_tokens": [2923], "completion_tokens": [1179], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_437_remove_odd"}
{"name": "mbpp_227_min_of_three", "language": "Python3", "prompt": "def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find minimum of three numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_of_three", "test": "def check(candidate):\n    assert candidate(10, 20, 0) == 0\n    assert candidate(19, 15, 18) == 15\n    assert candidate(-10, -20, -30) == -30\n\ndef test_check():\n    check(min_of_three)\n\ntest_check()\n", "sample_io": ["assert min_of_three(10, 20, 0) == 0"], "source_codes": ["def min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)"], "responses": ["\ndef min_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Write a function to find minimum of three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n\n"], "prompt_tokens": [1629], "completion_tokens": [846], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_227_min_of_three"}
{"name": "mbpp_172_count_occurance", "language": "Python3", "prompt": "def count_occurance(s: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of occurence of the string 'std' in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_occurance", "test": "def check(candidate):\n    assert candidate('letstdlenstdporstd') == 3\n    assert candidate('truststdsolensporsd') == 1\n    assert candidate('makestdsostdworthit') == 2\n    assert candidate('stds') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(count_occurance)\n\ntest_check()\n", "sample_io": ["assert count_occurance('letstdlenstdporstd') == 3"], "source_codes": ["def count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count"], "responses": ["\ndef count_occurance(s: str) -> int:\n    \"\"\"\n    Write a function to count the number of occurence of the string 'std' in a given string.\n    \"\"\"\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1546], "completion_tokens": [689], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_172_count_occurance"}
{"name": "mbpp_434_text_match_one", "language": "Python3", "prompt": "def text_match_one(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a string that has an a followed by one or more b's.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_one", "test": "def check(candidate):\n    assert candidate('ac') == False\n    assert candidate('dc') == False\n    assert candidate('abba') == True\n\ndef test_check():\n    check(text_match_one)\n\ntest_check()\n", "sample_io": ["assert text_match_one('ac') == False"], "source_codes": ["import re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    if not text:\n        return False\n    \n    pattern = r'ab+'\n    return bool(re.search(pattern, text))"], "responses": ["\nimport re\n\ndef text_match_one(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a string that has an a followed by one or more b's.\n    \"\"\"\n    if not text:\n        return False\n    \n    pattern = r'ab+'\n    return bool(re.search(pattern, text))\n\n\n"], "prompt_tokens": [1601], "completion_tokens": [718], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_434_text_match_one"}
{"name": "mbpp_291_count_no_of_ways", "language": "Python3", "prompt": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_no_of_ways", "test": "def check(candidate):\n    assert candidate(2, 4) == 16\n    assert candidate(3, 2) == 6\n    assert candidate(4, 4) == 228\n\ndef test_check():\n    check(count_no_of_ways)\n\ntest_check()\n", "sample_io": ["assert count_no_of_ways(2, 4) == 16"], "source_codes": ["def count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 1:\n        if n <= 2:\n            return 1\n        else:\n            return 0\n    \n    # Initialize base cases\n    # same[i] represents number of ways where post i has same color as post i-1\n    # diff[i] represents number of ways where post i has different color from post i-1\n    same = [0] * (n + 1)\n    diff = [0] * (n + 1)\n    \n    # Base cases for first post\n    same[1] = 0\n    diff[1] = k\n    \n    # Base cases for second post\n    same[2] = k\n    diff[2] = k * (k - 1)\n    \n    # Fill the arrays using recurrence relations\n    for i in range(3, n + 1):\n        same[i] = diff[i - 1]\n        diff[i] = (same[i - 1] + diff[i - 1]) * (k - 1)\n    \n    # Return total number of valid ways\n    return same[n] + diff[n]"], "responses": ["\ndef count_no_of_ways(n: int, k: int) -> int:\n    # Handle edge cases\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 1:\n        if n <= 2:\n            return 1\n        else:\n            return 0\n    \n    # Initialize base cases\n    # same[i] represents number of ways where post i has same color as post i-1\n    # diff[i] represents number of ways where post i has different color from post i-1\n    same = [0] * (n + 1)\n    diff = [0] * (n + 1)\n    \n    # Base cases for first post\n    same[1] = 0\n    diff[1] = k\n    \n    # Base cases for second post\n    same[2] = k\n    diff[2] = k * (k - 1)\n    \n    # Fill the arrays using recurrence relations\n    for i in range(3, n + 1):\n        same[i] = diff[i - 1]\n        diff[i] = (same[i - 1] + diff[i - 1]) * (k - 1)\n    \n    # Return total number of valid ways\n    return same[n] + diff[n]\n\n\n"], "prompt_tokens": [2226], "completion_tokens": [1400], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_291_count_no_of_ways"}
{"name": "mbpp_471_find_remainder", "language": "Python3", "prompt": "from typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the product of the array multiplication modulo n.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_remainder", "test": "def check(candidate):\n    assert candidate([100, 10, 5, 25, 35, 14], 11) == 9\n    assert candidate([1, 1, 1], 1) == 0\n    assert candidate([1, 2, 1], 2) == 0\n\ndef test_check():\n    check(find_remainder)\n\ntest_check()\n", "sample_io": ["assert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"], "source_codes": ["def find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        The remainder of the product when divided by n\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 1\n    \n    result = 1\n    for num in arr:\n        # If any element is 0, product will be 0\n        if num == 0:\n            return 0\n        # Multiply and take modulo at each step to prevent overflow\n        result = (result * num) % n\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef find_remainder(arr: List[int], n: int) -> int:\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n    \n    Args:\n        arr: List of integers\n        n: Modulo value\n    \n    Returns:\n        The remainder of the product when divided by n\n    \"\"\"\n    # Handle edge case of empty array\n    if not arr:\n        return 1\n    \n    result = 1\n    for num in arr:\n        # If any element is 0, product will be 0\n        if num == 0:\n            return 0\n        # Multiply and take modulo at each step to prevent overflow\n        result = (result * num) % n\n    \n    return result\n\n\n"], "prompt_tokens": [1731], "completion_tokens": [949], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_471_find_remainder"}
{"name": "mbpp_808_check_K", "language": "Python3", "prompt": "from typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuples contain the k or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_K", "test": "def check(candidate):\n    assert candidate([10, 4, 5, 6, 8], 6) == True\n    assert candidate([1, 2, 3, 4, 5, 6], 7) == False\n    assert candidate([7, 8, 9, 44, 11, 12], 11) == True\n\ndef test_check():\n    check(check_K)\n\ntest_check()\n", "sample_io": ["assert check_K([10, 4, 5, 6, 8], 6) == True"], "source_codes": ["def check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup"], "responses": ["\nfrom typing import List\n\ndef check_K(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n    \"\"\"\n    return K in test_tup\n\n\n"], "prompt_tokens": [1850], "completion_tokens": [854], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_808_check_K"}
{"name": "mbpp_68_is_Monotonic", "language": "Python3", "prompt": "from typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given array is monotonic or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_Monotonic", "test": "def check(candidate):\n    assert candidate([6, 5, 4, 4]) == True\n    assert candidate([1, 2, 2, 3]) == True\n    assert candidate([1, 3, 2]) == False\n\ndef test_check():\n    check(is_Monotonic)\n\ntest_check()\n", "sample_io": ["assert is_Monotonic([6, 5, 4, 4]) == True"], "source_codes": ["def is_Monotonic(A: List[int]) -> bool:\n    # Handle edge cases: empty or single element arrays are monotonic\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is non-decreasing\n    is_non_decreasing = all(A[i] >= A[i-1] for i in range(1, len(A)))\n    \n    # Check if array is non-increasing\n    is_non_increasing = all(A[i] <= A[i-1] for i in range(1, len(A)))\n    \n    # Array is monotonic if it's either non-decreasing or non-increasing\n    return is_non_decreasing or is_non_increasing"], "responses": ["\nfrom typing import List\n\ndef is_Monotonic(A: List[int]) -> bool:\n    # Handle edge cases: empty or single element arrays are monotonic\n    if len(A) <= 1:\n        return True\n    \n    # Check if array is non-decreasing\n    is_non_decreasing = all(A[i] >= A[i-1] for i in range(1, len(A)))\n    \n    # Check if array is non-increasing\n    is_non_increasing = all(A[i] <= A[i-1] for i in range(1, len(A)))\n    \n    # Array is monotonic if it's either non-decreasing or non-increasing\n    return is_non_decreasing or is_non_increasing\n\n\n"], "prompt_tokens": [1535], "completion_tokens": [1034], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_68_is_Monotonic"}
{"name": "mbpp_430_parabola_directrix", "language": "Python3", "prompt": "def parabola_directrix(a: int, b: int, c: int) -> int:\n    \"\"\"\n\tWrite a function to find the directrix of a parabola.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parabola_directrix", "test": "def check(candidate):\n    assert candidate(5, 3, 2) == -198\n    assert candidate(9, 8, 4) == -2336\n    assert candidate(2, 4, 6) == -130\n\ndef test_check():\n    check(parabola_directrix)\n\ntest_check()\n", "sample_io": ["assert parabola_directrix(5, 3, 2) == -198"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_430_parabola_directrix"}
{"name": "mbpp_618_div_list", "language": "Python3", "prompt": "from typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    \"\"\"\n\tWrite a function to divide two lists element wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "div_list", "test": "def check(candidate):\n    assert candidate([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    assert candidate([3, 2], [1, 4]) == [3.0, 0.5]\n    assert candidate([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n\ndef test_check():\n    check(div_list)\n\ntest_check()\n", "sample_io": ["assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"], "source_codes": ["def div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    # Handle empty lists\n    if not nums1 and not nums2:\n        return []\n    \n    # Check if lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Perform element-wise division\n    result = []\n    for i in range(len(nums1)):\n        if nums2[i] == 0:\n            result.append(float('inf') if nums1[i] >= 0 else float('-inf'))\n        else:\n            result.append(float(nums1[i]) / nums2[i])\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef div_list(nums1: List[int], nums2: List[int]) -> List[float]:\n    # Handle empty lists\n    if not nums1 and not nums2:\n        return []\n    \n    # Check if lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Perform element-wise division\n    result = []\n    for i in range(len(nums1)):\n        if nums2[i] == 0:\n            result.append(float('inf') if nums1[i] >= 0 else float('-inf'))\n        else:\n            result.append(float(nums1[i]) / nums2[i])\n    \n    return result\n\n\n"], "prompt_tokens": [2038], "completion_tokens": [1207], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_618_div_list"}
{"name": "mbpp_421_concatenate_tuple", "language": "Python3", "prompt": "from typing import Tuple\n\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    \"\"\"\n\tWrite a function to concatenate each element of tuple by the delimiter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "concatenate_tuple", "test": "def check(candidate):\n    assert candidate(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'\n    assert candidate(('QWE', 'is', 4, 'RTY')) == 'QWE-is-4-RTY'\n    assert candidate(('ZEN', 'is', 4, 'OP')) == 'ZEN-is-4-OP'\n\ndef test_check():\n    check(concatenate_tuple)\n\ntest_check()\n", "sample_io": ["assert concatenate_tuple(('ID', 'is', 4, 'UTS')) == 'ID-is-4-UTS'"], "source_codes": ["def concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    return '-'.join(str(item) for item in test_tup)"], "responses": ["\ndef concatenate_tuple(test_tup: Tuple[str, str, int, str]) -> str:\n    return '-'.join(str(item) for item in test_tup)\n\n\n"], "prompt_tokens": [3042], "completion_tokens": [1084], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_421_concatenate_tuple"}
{"name": "mbpp_750_add_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, int]) -> List[int]:\n    \"\"\"\n\tWrite a function to add the given tuple to the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add_tuple", "test": "def check(candidate):\n    assert candidate([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    assert candidate([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]\n    assert candidate([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]\n\ndef test_check():\n    check(add_tuple)\n\ntest_check()\n", "sample_io": ["assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"], "source_codes": ["def add_tuple(test_list: List[int], test_tup: Tuple[int, ...]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert tuple to list and concatenate with the original list\n    return test_list + list(test_tup)"], "responses": ["\nfrom typing import List, Tuple\n\ndef add_tuple(test_list: List[int], test_tup: Tuple[int, ...]) -> List[int]:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    \"\"\"\n    # Convert tuple to list and concatenate with the original list\n    return test_list + list(test_tup)\n\n\n"], "prompt_tokens": [1992], "completion_tokens": [1195], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_750_add_tuple"}
{"name": "mbpp_304_find_Element", "language": "Python3", "prompt": "from typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    \"\"\"\n\tWrite a python function to find element at a given index after number of rotations.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_Element", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3\n    assert candidate([1, 2, 3, 4], [[0, 1], [0, 2]], 1, 2) == 3\n    assert candidate([1, 2, 3, 4, 5, 6], [[0, 1], [0, 2]], 1, 1) == 1\n\ndef test_check():\n    check(find_Element)\n\ntest_check()\n", "sample_io": ["assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 2, 1) == 3"], "source_codes": ["def find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    n = len(arr)\n    \n    # Handle empty array case\n    if n == 0:\n        return None\n        \n    # Process range rotations to track where our target index moves\n    current_index = index\n    \n    # Process ranges in reverse order to trace back where the element at final index came from\n    for r in reversed(ranges):\n        start, end = r[0], r[1]\n        \n        # Check if current_index is within this rotation range\n        if start <= current_index <= end:\n            # In a left rotation, elements move one position left cyclically\n            # So to trace backwards, elements move one position right cyclically\n            # Element at end came from start\n            # Element at i (where i < end) came from i+1\n            if current_index == end:\n                current_index = start\n            else:\n                current_index = current_index + 1\n    \n    # Now account for full array rotations\n    # After range rotations, we do 'rotations' more full array left rotations\n    # This means our element at current_index moved 'rotations' positions left\n    # To find where it originally was, we need to move 'rotations' positions right\n    original_index = (current_index + rotations) % n\n    \n    return arr[original_index]"], "responses": ["\nfrom typing import List\n\ndef find_Element(arr: List[int], ranges: List[List[int]], rotations: int, index: int) -> int:\n    n = len(arr)\n    \n    # Handle empty array case\n    if n == 0:\n        return None\n        \n    # Process range rotations to track where our target index moves\n    current_index = index\n    \n    # Process ranges in reverse order to trace back where the element at final index came from\n    for r in reversed(ranges):\n        start, end = r[0], r[1]\n        \n        # Check if current_index is within this rotation range\n        if start <= current_index <= end:\n            # In a left rotation, elements move one position left cyclically\n            # So to trace backwards, elements move one position right cyclically\n            # Element at end came from start\n            # Element at i (where i < end) came from i+1\n            if current_index == end:\n                current_index = start\n            else:\n                current_index = current_index + 1\n    \n    # Now account for full array rotations\n    # After range rotations, we do 'rotations' more full array left rotations\n    # This means our element at current_index moved 'rotations' positions left\n    # To find where it originally was, we need to move 'rotations' positions right\n    original_index = (current_index + rotations) % n\n    \n    return arr[original_index]\n\n\n"], "prompt_tokens": [4693], "completion_tokens": [3217], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_304_find_Element"}
{"name": "mbpp_740_tuple_to_dict", "language": "Python3", "prompt": "from typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n\tWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tuple_to_dict", "test": "def check(candidate):\n    assert candidate((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }\n    assert candidate((1, 2, 3, 4, 5, 6)) == { 1: 2, 3: 4, 5: 6 }\n    assert candidate((7, 8, 9, 10, 11, 12)) == { 7: 8, 9: 10, 11: 12 }\n\ndef test_check():\n    check(tuple_to_dict)\n\ntest_check()\n", "sample_io": ["assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == { 1: 5, 7: 10, 13: 5 }"], "source_codes": ["def tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    # Extract keys (even indices) and values (odd indices)\n    keys = test_tup[::2]\n    values = test_tup[1::2]\n    \n    # Zip keys and values together and convert to dictionary\n    return dict(zip(keys, values))"], "responses": ["\nfrom typing import Tuple, Dict\n\ndef tuple_to_dict(test_tup: Tuple[int, int, int, int, int, int]) -> Dict[int, int]:\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    # Extract keys (even indices) and values (odd indices)\n    keys = test_tup[::2]\n    values = test_tup[1::2]\n    \n    # Zip keys and values together and convert to dictionary\n    return dict(zip(keys, values))\n\n\n"], "prompt_tokens": [2035], "completion_tokens": [1147], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_740_tuple_to_dict"}
{"name": "mbpp_627_find_First_Missing", "language": "Python3", "prompt": "from typing import List\n\ndef find_First_Missing(array: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the smallest missing number from a sorted list of natural numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_First_Missing", "test": "def check(candidate):\n    assert candidate([0, 1, 2, 3]) == 4\n    assert candidate([0, 1, 2, 6, 9]) == 3\n    assert candidate([2, 3, 5, 8, 9]) == 0\n\ndef test_check():\n    check(find_First_Missing)\n\ntest_check()\n", "sample_io": ["assert find_First_Missing([0, 1, 2, 3]) == 4"], "source_codes": ["def find_First_Missing(array: List[int]) -> int:\n    # Handle edge case: empty array\n    if not array:\n        return 0\n    \n    # Binary search implementation\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the element at mid equals mid, then the missing number is in the right half\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If the element at mid doesn't equal mid, the missing number is in the left half (including mid)\n            right = mid - 1\n    \n    # When the loop ends, left will be the first missing number\n    return left"], "responses": ["\ndef find_First_Missing(array: List[int]) -> int:\n    # Handle edge case: empty array\n    if not array:\n        return 0\n    \n    # Binary search implementation\n    left, right = 0, len(array) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the element at mid equals mid, then the missing number is in the right half\n        if array[mid] == mid:\n            left = mid + 1\n        else:\n            # If the element at mid doesn't equal mid, the missing number is in the left half (including mid)\n            right = mid - 1\n    \n    # When the loop ends, left will be the first missing number\n    return left\n\n\n"], "prompt_tokens": [1934], "completion_tokens": [1077], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_627_find_First_Missing"}
{"name": "mbpp_294_max_val", "language": "Python3", "prompt": "from typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum value in a given heterogeneous list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_val", "test": "def check(candidate):\n    assert candidate(['Python', 3, 2, 4, 5, 'version']) == 5\n    assert candidate(['Python', 15, 20, 25]) == 25\n    assert candidate(['Python', 30, 20, 40, 50, 'version']) == 50\n\ndef test_check():\n    check(max_val)\n\ntest_check()\n", "sample_io": ["assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"], "source_codes": ["def max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"List is empty\")\n    \n    numeric_values = []\n    \n    for item in listval:\n        try:\n            # Try to convert to int directly if it's already an int or a numeric string\n            numeric_values.append(int(item))\n        except (ValueError, TypeError):\n            # Skip non-numeric values\n            continue\n    \n    if not numeric_values:\n        raise ValueError(\"No numeric values found in the list\")\n    \n    return max(numeric_values)"], "responses": ["\nfrom typing import List, Union\n\ndef max_val(listval: List[Union[str, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n    \"\"\"\n    if not listval:\n        raise ValueError(\"List is empty\")\n    \n    numeric_values = []\n    \n    for item in listval:\n        try:\n            # Try to convert to int directly if it's already an int or a numeric string\n            numeric_values.append(int(item))\n        except (ValueError, TypeError):\n            # Skip non-numeric values\n            continue\n    \n    if not numeric_values:\n        raise ValueError(\"No numeric values found in the list\")\n    \n    return max(numeric_values)\n\n\n"], "prompt_tokens": [1677], "completion_tokens": [1058], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_294_max_val"}
{"name": "mbpp_165_count_char_position", "language": "Python3", "prompt": "def count_char_position(str1: str) -> int:\n    \"\"\"\n\tWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_char_position", "test": "def check(candidate):\n    assert candidate('xbcefg') == 2\n    assert candidate('ABcED') == 3\n    assert candidate('AbgdeF') == 5\n\ndef test_check():\n    check(count_char_position)\n\ntest_check()\n", "sample_io": ["assert count_char_position('xbcefg') == 2"], "source_codes": ["def count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i, char in enumerate(str1):\n        if char.isalpha():\n            # Calculate position in alphabet (1-based)\n            alphabet_pos = ord(char) - ord('a') + 1\n            # Calculate position in string (1-based)\n            string_pos = i + 1\n            \n            if alphabet_pos == string_pos:\n                count += 1\n    \n    return count"], "responses": ["\ndef count_char_position(str1: str) -> int:\n    \"\"\"\n    Write a function to count the number of characters in a string that occur at the same position \n    in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    str1 = str1.lower()\n    \n    for i, char in enumerate(str1):\n        if char.isalpha():\n            # Calculate position in alphabet (1-based)\n            alphabet_pos = ord(char) - ord('a') + 1\n            # Calculate position in string (1-based)\n            string_pos = i + 1\n            \n            if alphabet_pos == string_pos:\n                count += 1\n    \n    return count\n\n\n"], "prompt_tokens": [1986], "completion_tokens": [1284], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_165_count_char_position"}
{"name": "mbpp_589_perfect_squares", "language": "Python3", "prompt": "from typing import List\n\ndef perfect_squares(a: int, b: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find perfect squares between two given numbers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "perfect_squares", "test": "def check(candidate):\n    assert candidate(1, 30) == [1, 4, 9, 16, 25]\n    assert candidate(50, 100) == [64, 81, 100]\n    assert candidate(100, 200) == [100, 121, 144, 169, 196]\n\ndef test_check():\n    check(perfect_squares)\n\ntest_check()\n", "sample_io": ["assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_589_perfect_squares"}
{"name": "mbpp_744_check_none", "language": "Python3", "prompt": "from typing import Any\n\ndef check_none(test_tup: Any) -> bool:\n    \"\"\"\n\tWrite a function to check if the given tuple has any none value or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_none", "test": "def check(candidate):\n    assert candidate((10, 4, 5, 6, None)) == True\n    assert candidate((7, 8, 9, 11, 14)) == False\n    assert candidate((1, 2, 3, 4, None)) == True\n\ndef test_check():\n    check(check_none)\n\ntest_check()\n", "sample_io": ["assert check_none((10, 4, 5, 6, None)) == True"], "source_codes": ["def check_none(test_tup: Any) -> bool:\n    # First check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check for empty tuple\n    if len(test_tup) == 0:\n        return False\n    \n    # Iterate through each element in the tuple\n    for element in test_tup:\n        # If any element is None, return True immediately\n        if element is None:\n            return True\n    \n    # If no None values were found, return False\n    return False"], "responses": ["\ndef check_none(test_tup: Any) -> bool:\n    # First check if the input is a tuple\n    if not isinstance(test_tup, tuple):\n        return False\n    \n    # Check for empty tuple\n    if len(test_tup) == 0:\n        return False\n    \n    # Iterate through each element in the tuple\n    for element in test_tup:\n        # If any element is None, return True immediately\n        if element is None:\n            return True\n    \n    # If no None values were found, return False\n    return False\n\n\n"], "prompt_tokens": [1881], "completion_tokens": [1140], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_744_check_none"}
{"name": "mbpp_726_multiply_elements", "language": "Python3", "prompt": "from typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    \"\"\"\n\tWrite a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "multiply_elements", "test": "def check(candidate):\n    assert candidate([1, 5, 7, 8, 10]) == [5, 35, 56, 80]\n    assert candidate([2, 4, 5, 6, 7]) == [8, 20, 30, 42]\n    assert candidate([12, 13, 14, 9, 15]) == [156, 182, 126, 135]\n    assert candidate([12]) == []\n\ndef test_check():\n    check(multiply_elements)\n\ntest_check()\n", "sample_io": ["assert multiply_elements([1, 5, 7, 8, 10]) == [5, 35, 56, 80]"], "source_codes": ["def multiply_elements(test_tup: List[int]) -> List[Any]:\n    # If the list has fewer than 2 elements, return an empty list\n    if len(test_tup) < 2:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through the list and multiply adjacent elements\n    for i in range(len(test_tup) - 1):\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef multiply_elements(test_tup: List[int]) -> List[Any]:\n    # If the list has fewer than 2 elements, return an empty list\n    if len(test_tup) < 2:\n        return []\n    \n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through the list and multiply adjacent elements\n    for i in range(len(test_tup) - 1):\n        product = test_tup[i] * test_tup[i + 1]\n        result.append(product)\n    \n    return result\n\n\n"], "prompt_tokens": [1768], "completion_tokens": [815], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_726_multiply_elements"}
{"name": "mbpp_736_left_insertion", "language": "Python3", "prompt": "from typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "left_insertion", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 5], 6) == 4\n    assert candidate([1, 2, 4, 5], 3) == 2\n    assert candidate([1, 2, 4, 5], 7) == 4\n\ndef test_check():\n    check(left_insertion)\n\ntest_check()\n", "sample_io": ["assert left_insertion([1, 2, 4, 5], 6) == 4"], "source_codes": ["def left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"], "responses": ["\nfrom typing import List\n\ndef left_insertion(a: List[int], x: int) -> int:\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \"\"\"\n    left, right = 0, len(a)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n\n"], "prompt_tokens": [1993], "completion_tokens": [937], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_736_left_insertion"}
{"name": "mbpp_63_max_difference", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between available pairs in the given tuple list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_difference", "test": "def check(candidate):\n    assert candidate([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    assert candidate([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    assert candidate([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n\ndef test_check():\n    check(max_difference)\n\ntest_check()\n", "sample_io": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"], "source_codes": ["def max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff"], "responses": ["\nfrom typing import List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Write a function to find the maximum difference between available pairs in the given tuple list.\n    \"\"\"\n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\n\n"], "prompt_tokens": [1871], "completion_tokens": [1022], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_63_max_difference"}
{"name": "mbpp_264_dog_age", "language": "Python3", "prompt": "def dog_age(h_age: int) -> int:\n    \"\"\"\n\tWrite a function to calculate a dog's age in dog's years.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "dog_age", "test": "def check(candidate):\n    assert candidate(12) == 61\n    assert candidate(15) == 73\n    assert candidate(24) == 109\n\ndef test_check():\n    check(dog_age)\n\ntest_check()\n", "sample_io": ["assert dog_age(12) == 61"], "source_codes": ["def dog_age(h_age: int) -> int:\n    if not isinstance(h_age, int) or h_age < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if h_age == 0:\n        return 0\n    \n    dog_years = 0\n    \n    # First year: 15 dog years\n    if h_age >= 1:\n        dog_years += 15\n    \n    # Second year: 9 more dog years (total 24)\n    if h_age >= 2:\n        dog_years += 9\n    \n    # Additional years: 5 dog years each\n    if h_age > 2:\n        dog_years += (h_age - 2) * 5\n    \n    return dog_years"], "responses": ["\ndef dog_age(h_age: int) -> int:\n    if not isinstance(h_age, int) or h_age < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if h_age == 0:\n        return 0\n    \n    dog_years = 0\n    \n    # First year: 15 dog years\n    if h_age >= 1:\n        dog_years += 15\n    \n    # Second year: 9 more dog years (total 24)\n    if h_age >= 2:\n        dog_years += 9\n    \n    # Additional years: 5 dog years each\n    if h_age > 2:\n        dog_years += (h_age - 2) * 5\n    \n    return dog_years\n\n\n"], "prompt_tokens": [2676], "completion_tokens": [1283], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_264_dog_age"}
{"name": "mbpp_273_substract_elements", "language": "Python3", "prompt": "from typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n\tWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "substract_elements", "test": "def check(candidate):\n    assert candidate((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    assert candidate((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    assert candidate((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n\ndef test_check():\n    check(substract_elements)\n\ntest_check()\n", "sample_io": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"], "source_codes": ["def substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (\n        test_tup1[0] - test_tup2[0],\n        test_tup1[1] - test_tup2[1],\n        test_tup1[2] - test_tup2[2]\n    )"], "responses": ["\nfrom typing import Tuple\n\ndef substract_elements(test_tup1: Tuple[int, int, int], test_tup2: Tuple[int, int, int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n    \"\"\"\n    return (\n        test_tup1[0] - test_tup2[0],\n        test_tup1[1] - test_tup2[1],\n        test_tup1[2] - test_tup2[2]\n    )\n\n\n"], "prompt_tokens": [2015], "completion_tokens": [978], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_273_substract_elements"}
{"name": "mbpp_83_get_Char", "language": "Python3", "prompt": "def get_Char(strr: str) -> str:\n    \"\"\"\n\tWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_Char", "test": "def check(candidate):\n    assert candidate('abc') == 'f'\n    assert candidate('gfg') == 't'\n    assert candidate('ab') == 'c'\n\ndef test_check():\n    check(get_Char)\n\ntest_check()\n", "sample_io": ["assert get_Char('abc') == 'f'"], "source_codes": ["def get_Char(strr: str) -> str:\n    total = sum((ord(char) - ord('a')) for char in strr.lower())\n    return chr((total % 26) + ord('a'))"], "responses": ["\ndef get_Char(strr: str) -> str:\n    total = sum((ord(char) - ord('a')) for char in strr.lower())\n    return chr((total % 26) + ord('a'))\n\n\n"], "prompt_tokens": [3573], "completion_tokens": [2484], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_83_get_Char"}
{"name": "mbpp_91_find_substring", "language": "Python3", "prompt": "from typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string is present as a substring in a given list of string values.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_substring", "test": "def check(candidate):\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ack') == True\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'abc') == False\n    assert candidate(['red', 'black', 'white', 'green', 'orange'], 'ange') == True\n\ndef test_check():\n    check(find_substring)\n\ntest_check()\n", "sample_io": ["assert find_substring(['red', 'black', 'white', 'green', 'orange'], 'ack') == True"], "source_codes": ["def find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Check if substring exists in any string in the list\n    for string in str1:\n        if sub_str in string:\n            return True\n    \n    # Substring not found in any string\n    return False"], "responses": ["\nfrom typing import List\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n    \"\"\"\n    Write a function to check if a string is present as a substring in a given list of string values.\n    \"\"\"\n    # Handle edge case: empty list\n    if not str1:\n        return False\n    \n    # Check if substring exists in any string in the list\n    for string in str1:\n        if sub_str in string:\n            return True\n    \n    # Substring not found in any string\n    return False\n\n\n"], "prompt_tokens": [1905], "completion_tokens": [934], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_91_find_substring"}
{"name": "mbpp_100_next_smallest_palindrome", "language": "Python3", "prompt": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "next_smallest_palindrome", "test": "def check(candidate):\n    assert candidate(99) == 101\n    assert candidate(1221) == 1331\n    assert candidate(120) == 121\n\ndef test_check():\n    check(next_smallest_palindrome)\n\ntest_check()\n", "sample_io": ["assert next_smallest_palindrome(99) == 101"], "source_codes": ["def next_smallest_palindrome(num: int) -> int:\n    def is_palindrome(n: int) -> bool:\n        s = str(n)\n        return s == s[::-1]\n    \n    # Start checking from num + 1\n    candidate = num + 1\n    \n    # Keep incrementing until we find a palindrome\n    while not is_palindrome(candidate):\n        candidate += 1\n    \n    return candidate"], "responses": ["\ndef next_smallest_palindrome(num: int) -> int:\n    def is_palindrome(n: int) -> bool:\n        s = str(n)\n        return s == s[::-1]\n    \n    # Start checking from num + 1\n    candidate = num + 1\n    \n    # Keep incrementing until we find a palindrome\n    while not is_palindrome(candidate):\n        candidate += 1\n    \n    return candidate\n\n\n"], "prompt_tokens": [1205], "completion_tokens": [985], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_100_next_smallest_palindrome"}
{"name": "mbpp_282_sub_list", "language": "Python3", "prompt": "from typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to subtract two lists element-wise.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sub_list", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\n    assert candidate([1, 2], [3, 4]) == [-2, -2]\n    assert candidate([90, 120], [50, 70]) == [40, 50]\n\ndef test_check():\n    check(sub_list)\n\ntest_check()\n", "sample_io": ["assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"], "source_codes": ["def sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    # Check if both lists are empty\n    if len(nums1) == 0 and len(nums2) == 0:\n        return []\n    \n    # Verify both lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through indices and subtract elements\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef sub_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Write a function to subtract two lists element-wise.\n    \"\"\"\n    # Check if both lists are empty\n    if len(nums1) == 0 and len(nums2) == 0:\n        return []\n    \n    # Verify both lists have the same length\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through indices and subtract elements\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result\n\n\n"], "prompt_tokens": [1892], "completion_tokens": [1003], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_282_sub_list"}
{"name": "mbpp_790_even_position", "language": "Python3", "prompt": "from typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n\tWrite a python function to check whether every even index contains even numbers of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "even_position", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == False\n    assert candidate([1, 2, 3]) == False\n    assert candidate([2, 1, 4]) == True\n\ndef test_check():\n    check(even_position)\n\ntest_check()\n", "sample_io": ["assert even_position([3, 2, 1]) == False"], "source_codes": ["def even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Iterate through even indices only\n    for i in range(0, len(nums), 2):\n        # Check if the number at even index is odd\n        if nums[i] % 2 != 0:\n            return False\n    return True"], "responses": ["\nfrom typing import List\n\ndef even_position(nums: List[int]) -> bool:\n    \"\"\"\n    Check whether every even index contains even numbers of a given list.\n    \"\"\"\n    # Iterate through even indices only\n    for i in range(0, len(nums), 2):\n        # Check if the number at even index is odd\n        if nums[i] % 2 != 0:\n            return False\n    return True\n\n\n"], "prompt_tokens": [1885], "completion_tokens": [923], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_790_even_position"}
{"name": "mbpp_411_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert the given snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('android_tv') == 'AndroidTv'\n    assert candidate('google_pixel') == 'GooglePixel'\n    assert candidate('apple_watch') == 'AppleWatch'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('android_tv') == 'AndroidTv'"], "source_codes": ["def snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Check if original string started with underscore\n    starts_with_underscore = word.startswith('_')\n    \n    if len(words) == 1:\n        if starts_with_underscore:\n            return words[0].capitalize()\n        else:\n            return words[0].lower()\n    \n    # For multiple words: \n    # If starts with underscore: PascalCase (all words capitalized)\n    # Otherwise: camelCase (first word lowercase, rest capitalized)\n    if starts_with_underscore:\n        return ''.join(w.capitalize() for w in words)\n    else:\n        return words[0].lower() + ''.join(w.capitalize() for w in words[1:])"], "responses": ["\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Check if original string started with underscore\n    starts_with_underscore = word.startswith('_')\n    \n    if len(words) == 1:\n        if starts_with_underscore:\n            return words[0].capitalize()\n        else:\n            return words[0].lower()\n    \n    # For multiple words: \n    # If starts with underscore: PascalCase (all words capitalized)\n    # Otherwise: camelCase (first word lowercase, rest capitalized)\n    if starts_with_underscore:\n        return ''.join(w.capitalize() for w in words)\n    else:\n        return words[0].lower() + ''.join(w.capitalize() for w in words[1:])\n\n\n"], "prompt_tokens": [5567], "completion_tokens": [4241], "no_of_try": 1, "api_calls": 10, "is_solved": false, "task_id": "mbpp_411_snake_to_camel"}
{"name": "mbpp_754_extract_index_list", "language": "Python3", "prompt": "from typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    \"\"\"\n\tWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "extract_index_list", "test": "def check(candidate):\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]\n    assert candidate([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 6, 5], [0, 1, 2, 3, 4, 6, 7]) == [1, 6]\n    assert candidate([1, 1, 3, 4, 6, 5, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 5]\n    assert candidate([1, 2, 3, 4, 6, 6, 6], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == []\n\ndef test_check():\n    check(extract_index_list)\n\ntest_check()\n", "sample_io": ["assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"], "source_codes": ["def extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    # Determine the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through indices from 0 to min_length - 1\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to the result list\n            result.append(l1[i])\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[Any]:\n    # Determine the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through indices from 0 to min_length - 1\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to the result list\n            result.append(l1[i])\n    \n    return result\n\n\n"], "prompt_tokens": [2386], "completion_tokens": [1223], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_754_extract_index_list"}
{"name": "mbpp_56_checks", "language": "Python3", "prompt": "def checks(n: int) -> bool:\n    \"\"\"\n\tWrite a python function to check if a given number is one less than twice its reverse.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "checks", "test": "def check(candidate):\n    assert candidate(70) == False\n    assert candidate(23) == False\n    assert candidate(73) == True\n\ndef test_check():\n    check(checks)\n\ntest_check()\n", "sample_io": ["assert checks(70) == False"], "source_codes": ["def checks(n: int) -> bool:\n    # Handle negative numbers\n    if n < 0:\n        return False\n    \n    # Convert to string, reverse it, then convert back to integer\n    reversed_n = int(str(n)[::-1])\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1"], "responses": ["\ndef checks(n: int) -> bool:\n    # Handle negative numbers\n    if n < 0:\n        return False\n    \n    # Convert to string, reverse it, then convert back to integer\n    reversed_n = int(str(n)[::-1])\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1\n\n\n"], "prompt_tokens": [1575], "completion_tokens": [1063], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_56_checks"}
{"name": "mbpp_724_power_base_sum", "language": "Python3", "prompt": "def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n\tWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "power_base_sum", "test": "def check(candidate):\n    assert candidate(2, 100) == 115\n    assert candidate(8, 10) == 37\n    assert candidate(8, 15) == 62\n    assert candidate(3, 3) == 9\n\ndef test_check():\n    check(power_base_sum)\n\ntest_check()\n", "sample_io": ["assert power_base_sum(2, 100) == 115"], "source_codes": ["def power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base: The base number\n        power: The exponent\n        \n    Returns:\n        The sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = 0\n    for digit_char in result_str:\n        digit_sum += int(digit_char)\n    \n    return digit_sum"], "responses": ["\ndef power_base_sum(base: int, power: int) -> int:\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n    \n    Args:\n        base: The base number\n        power: The exponent\n        \n    Returns:\n        The sum of all digits in base^power\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = 0\n    for digit_char in result_str:\n        digit_sum += int(digit_char)\n    \n    return digit_sum\n\n\n"], "prompt_tokens": [1650], "completion_tokens": [1003], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_724_power_base_sum"}
{"name": "mbpp_268_find_star_num", "language": "Python3", "prompt": "def find_star_num(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th star number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_star_num", "test": "def check(candidate):\n    assert candidate(3) == 37\n    assert candidate(4) == 73\n    assert candidate(5) == 121\n\ndef test_check():\n    check(find_star_num)\n\ntest_check()\n", "sample_io": ["assert find_star_num(3) == 37"], "source_codes": ["def find_star_num(n: int) -> int:\n    \"\"\"\n    Find the n'th star number using the formula Sn = 6n(n-1) + 1\n    \n    Args:\n        n: A positive integer representing the position in the star number sequence\n        \n    Returns:\n        The n'th star number\n        \n    Raises:\n        ValueError: If n is not a positive integer\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    return 6 * n * (n - 1) + 1"], "responses": ["\ndef find_star_num(n: int) -> int:\n    \"\"\"\n    Find the n'th star number using the formula Sn = 6n(n-1) + 1\n    \n    Args:\n        n: A positive integer representing the position in the star number sequence\n        \n    Returns:\n        The n'th star number\n        \n    Raises:\n        ValueError: If n is not a positive integer\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    return 6 * n * (n - 1) + 1\n\n\n"], "prompt_tokens": [2017], "completion_tokens": [1375], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_268_find_star_num"}
{"name": "mbpp_251_insert_element", "language": "Python3", "prompt": "from typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n\tWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "insert_element", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    assert candidate(['python', 'java'], 'program') == ['program', 'python', 'program', 'java']\n    assert candidate(['happy', 'sad'], 'laugh') == ['laugh', 'happy', 'laugh', 'sad']\n\ndef test_check():\n    check(insert_element)\n\ntest_check()\n", "sample_io": ["assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"], "source_codes": ["def insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    if not list:\n        return []\n    \n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef insert_element(list: List[str], element: str) -> List[str]:\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    \"\"\"\n    if not list:\n        return []\n    \n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    \n    return result\n\n\n"], "prompt_tokens": [2710], "completion_tokens": [1762], "no_of_try": 1, "api_calls": 6, "is_solved": true, "task_id": "mbpp_251_insert_element"}
{"name": "mbpp_428_shell_sort", "language": "Python3", "prompt": "from typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to sort the given array by using shell sort.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "shell_sort", "test": "def check(candidate):\n    assert candidate([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n    assert candidate([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]\n    assert candidate([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]\n\ndef test_check():\n    check(shell_sort)\n\ntest_check()\n", "sample_io": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"], "source_codes": ["def shell_sort(my_list: List[int]) -> List[int]:\n    n = len(my_list)\n    \n    # Handle edge cases\n    if n <= 1:\n        return my_list\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Perform gapped insertion sort\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save the current element\n            temp = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put temp (the original my_list[i]) in its correct location\n            my_list[j] = temp\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return my_list"], "responses": ["\nfrom typing import List\n\ndef shell_sort(my_list: List[int]) -> List[int]:\n    n = len(my_list)\n    \n    # Handle edge cases\n    if n <= 1:\n        return my_list\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Perform gapped insertion sort\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save the current element\n            temp = my_list[i]\n            \n            # Shift earlier gap-sorted elements up until the correct location for my_list[i] is found\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            \n            # Put temp (the original my_list[i]) in its correct location\n            my_list[j] = temp\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return my_list\n\n\n"], "prompt_tokens": [2412], "completion_tokens": [1475], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_428_shell_sort"}
{"name": "mbpp_476_big_sum", "language": "Python3", "prompt": "from typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the largest and smallest value in a given array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "big_sum", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 4\n    assert candidate([-1, 2, 3, 4]) == 3\n    assert candidate([2, 3, 6]) == 8\n\ndef test_check():\n    check(big_sum)\n\ntest_check()\n", "sample_io": ["assert big_sum([1, 2, 3]) == 4"], "source_codes": ["def big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The sum of the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    if len(nums) == 1:\n        return nums[0] * 2\n    \n    min_val = min(nums)\n    max_val = max(nums)\n    \n    return min_val + max_val"], "responses": ["\nfrom typing import List\n\ndef big_sum(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n        nums: A list of integers\n        \n    Returns:\n        The sum of the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the input list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    if len(nums) == 1:\n        return nums[0] * 2\n    \n    min_val = min(nums)\n    max_val = max(nums)\n    \n    return min_val + max_val\n\n\n"], "prompt_tokens": [1705], "completion_tokens": [1040], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_476_big_sum"}
{"name": "mbpp_465_drop_empty", "language": "Python3", "prompt": "from typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n\tWrite a function to drop empty items from a given dictionary.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "drop_empty", "test": "def check(candidate):\n    assert candidate({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }\n    assert candidate({ 'c1': 'Red', 'c2': None, 'c3': None }) == { 'c1': 'Red' }\n    assert candidate({ 'c1': None, 'c2': 'Green', 'c3': None }) == { 'c2': 'Green' }\n\ndef test_check():\n    check(drop_empty)\n\ntest_check()\n", "sample_io": ["assert drop_empty({ 'c1': 'Red', 'c2': 'Green', 'c3': None }) == { 'c1': 'Red', 'c2': 'Green' }"], "source_codes": ["def drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}"], "responses": ["\nfrom typing import Dict, Optional\n\ndef drop_empty(dict1: Dict[str, Optional[str]]) -> Dict[str, str]:\n    \"\"\"\n    Write a function to drop empty items from a given dictionary.\n    \"\"\"\n    return {k: v for k, v in dict1.items() if v is not None and v != \"\"}\n\n\n"], "prompt_tokens": [1996], "completion_tokens": [961], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_465_drop_empty"}
{"name": "mbpp_454_text_match_wordz", "language": "Python3", "prompt": "def text_match_wordz(text: str) -> bool:\n    \"\"\"\n\tWrite a function that matches a word containing 'z'.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "text_match_wordz", "test": "def check(candidate):\n    assert candidate('pythonz.') == True\n    assert candidate('xyz.') == True\n    assert candidate('  lang  .') == False\n\ndef test_check():\n    check(text_match_wordz)\n\ntest_check()\n", "sample_io": ["assert text_match_wordz('pythonz.') == True"], "source_codes": ["import re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Pattern to match words containing 'z' (case insensitive)\n    # \\b ensures word boundaries\n    # \\w* allows any word characters before and after 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text (case insensitive)\n    return bool(re.search(pattern, text, re.IGNORECASE))"], "responses": ["\nimport re\n\ndef text_match_wordz(text: str) -> bool:\n    \"\"\"\n    Write a function that matches a word containing 'z'.\n    \"\"\"\n    # Pattern to match words containing 'z' (case insensitive)\n    # \\b ensures word boundaries\n    # \\w* allows any word characters before and after 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text (case insensitive)\n    return bool(re.search(pattern, text, re.IGNORECASE))\n\n\n"], "prompt_tokens": [1601], "completion_tokens": [773], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_454_text_match_wordz"}
{"name": "mbpp_605_prime_num", "language": "Python3", "prompt": "def prime_num(num: int) -> bool:\n    \"\"\"\n\tWrite a function to check if the given integer is a prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "prime_num", "test": "def check(candidate):\n    assert candidate(13) == True\n    assert candidate(7) == True\n    assert candidate(-1010) == False\n\ndef test_check():\n    check(prime_num)\n\ntest_check()\n", "sample_io": ["assert prime_num(13) == True"], "source_codes": ["def prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if num < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if num == 2:\n        return True\n    \n    # All other even numbers are not prime\n    if num % 2 == 0:\n        return False\n    \n    # Check odd divisors from 3 up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    \n    # If no divisors found, the number is prime\n    return True"], "responses": ["\ndef prime_num(num: int) -> bool:\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if num < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if num == 2:\n        return True\n    \n    # All other even numbers are not prime\n    if num % 2 == 0:\n        return False\n    \n    # Check odd divisors from 3 up to sqrt(num)\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    \n    # If no divisors found, the number is prime\n    return True\n\n\n"], "prompt_tokens": [1900], "completion_tokens": [1016], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_605_prime_num"}
{"name": "mbpp_108_merge_sorted_list", "language": "Python3", "prompt": "from typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to merge three lists into a single sorted list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "merge_sorted_list", "test": "def check(candidate):\n    assert candidate([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    assert candidate([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert candidate([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], [25, 35, 22, 85, 14, 65, 75, 25, 58], [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n\ndef test_check():\n    check(merge_sorted_list)\n\ntest_check()\n", "sample_io": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"], "source_codes": ["def merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Combine all elements from the three lists\n    combined = num1 + num2 + num3\n    \n    # Sort the combined list\n    combined.sort()\n    \n    return combined"], "responses": ["\nfrom typing import List\n\ndef merge_sorted_list(num1: List[int], num2: List[int], num3: List[int]) -> List[int]:\n    # Combine all elements from the three lists\n    combined = num1 + num2 + num3\n    \n    # Sort the combined list\n    combined.sort()\n    \n    return combined\n\n\n"], "prompt_tokens": [5660], "completion_tokens": [2920], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_108_merge_sorted_list"}
{"name": "mbpp_639_sample_nam", "language": "Python3", "prompt": "from typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    \"\"\"\n\tWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sample_nam", "test": "def check(candidate):\n    assert candidate(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n    assert candidate(['php', 'res', 'Python', 'abcd', 'Java', 'aaa']) == 10\n    assert candidate(['abcd', 'Python', 'abba', 'aba']) == 6\n\ndef test_check():\n    check(sample_nam)\n\ntest_check()\n", "sample_io": ["assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"], "source_codes": ["def sample_nam(sample_names: List[str]) -> int:\n    # Filter names that start with an uppercase letter\n    filtered_names = [name for name in sample_names if name and name[0].isupper()]\n    \n    # Calculate the sum of the lengths of the filtered names\n    total_length = sum(len(name) for name in filtered_names)\n    \n    return total_length"], "responses": ["\nfrom typing import List\n\ndef sample_nam(sample_names: List[str]) -> int:\n    # Filter names that start with an uppercase letter\n    filtered_names = [name for name in sample_names if name and name[0].isupper()]\n    \n    # Calculate the sum of the lengths of the filtered names\n    total_length = sum(len(name) for name in filtered_names)\n    \n    return total_length\n\n\n"], "prompt_tokens": [2335], "completion_tokens": [1189], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_639_sample_nam"}
{"name": "mbpp_409_min_product_tuple", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    \"\"\"\n\tWrite a function to find the minimum product from the pairs of tuples within a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_product_tuple", "test": "def check(candidate):\n    assert candidate([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8\n    assert candidate([(10, 20), (15, 2), (5, 10)]) == 30\n    assert candidate([(11, 44), (10, 15), (20, 5), (12, 9)]) == 100\n\ndef test_check():\n    check(min_product_tuple)\n\ntest_check()\n", "sample_io": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"], "source_codes": ["def min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through all tuples to find the minimum product\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_product_tuple(list1: List[Tuple[int, int]]) -> int:\n    if not list1:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Initialize with the product of the first tuple\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through all tuples to find the minimum product\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n\n\n"], "prompt_tokens": [1947], "completion_tokens": [1171], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_409_min_product_tuple"}
{"name": "mbpp_791_remove_nested", "language": "Python3", "prompt": "from typing import Any, Tuple\n\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to remove tuples from the given tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "remove_nested", "test": "def check(candidate):\n    assert candidate((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n    assert candidate((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)\n    assert candidate((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)\n    assert candidate((3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12)\n\ndef test_check():\n    check(remove_nested)\n\ntest_check()\n", "sample_io": ["assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"], "source_codes": ["def remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)"], "responses": ["\ndef remove_nested(test_tup: Any) -> Tuple[int, int, int, int]:\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n\n\n"], "prompt_tokens": [4517], "completion_tokens": [1893], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_791_remove_nested"}
{"name": "mbpp_591_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"], "source_codes": ["def swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n    # Handle edge cases: empty list or single element\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using simultaneous assignment\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last elements in a list.\n\t\"\"\"\n    # Handle edge cases: empty list or single element\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using simultaneous assignment\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "prompt_tokens": [1697], "completion_tokens": [814], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_591_swap_List"}
{"name": "mbpp_419_round_and_sum", "language": "Python3", "prompt": "from typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    \"\"\"\n\tWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "round_and_sum", "test": "def check(candidate):\n    assert candidate([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243\n    assert candidate([5, 2, 9, 24.3, 29]) == 345\n    assert candidate([25.0, 56.7, 89.2]) == 513\n\ndef test_check():\n    check(round_and_sum)\n\ntest_check()\n", "sample_io": ["assert round_and_sum([22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]) == 243"], "source_codes": ["def round_and_sum(list1: List[Union[float, int]]) -> int:\n    if not list1:\n        return 0\n    \n    rounded_sum = sum(round(num) for num in list1)\n    result = rounded_sum * len(list1)\n    \n    return result"], "responses": ["\nfrom typing import List, Union\n\ndef round_and_sum(list1: List[Union[float, int]]) -> int:\n    if not list1:\n        return 0\n    \n    rounded_sum = sum(round(num) for num in list1)\n    result = rounded_sum * len(list1)\n    \n    return result\n\n\n"], "prompt_tokens": [1871], "completion_tokens": [927], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_419_round_and_sum"}
{"name": "mbpp_84_sequence", "language": "Python3", "prompt": "def sequence(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth number in the newman conway sequence.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sequence", "test": "def check(candidate):\n    assert candidate(10) == 6\n    assert candidate(2) == 1\n    assert candidate(3) == 2\n\ndef test_check():\n    check(sequence)\n\ntest_check()\n", "sample_io": ["assert sequence(10) == 6"], "source_codes": ["def sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n-P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n        \n    Raises:\n        ValueError: If n <= 0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to store previously calculated values\n    # dp[i] represents the ith number in the sequence\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Calculate values iteratively from 3 to n\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]"], "responses": ["\ndef sequence(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n-P(n-1)) for n > 2\n    \n    Args:\n        n: Position in the sequence (1-indexed)\n        \n    Returns:\n        The nth number in the Newman-Conway sequence\n        \n    Raises:\n        ValueError: If n <= 0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use dynamic programming to store previously calculated values\n    # dp[i] represents the ith number in the sequence\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    # Calculate values iteratively from 3 to n\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n\n\n"], "prompt_tokens": [1211], "completion_tokens": [1161], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_84_sequence"}
{"name": "mbpp_260_newman_prime", "language": "Python3", "prompt": "def newman_prime(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "newman_prime", "test": "def check(candidate):\n    assert candidate(3) == 7\n    assert candidate(4) == 17\n    assert candidate(5) == 41\n\ndef test_check():\n    check(newman_prime)\n\ntest_check()\n", "sample_io": ["assert newman_prime(3) == 7"], "source_codes": ["def newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Initialize NSW sequence\n    nsw_prev2, nsw_prev1 = 1, 1\n    count = 0\n    \n    i = 2\n    while True:\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        nsw_prev2, nsw_prev1 = nsw_prev1, nsw_current\n        i += 1"], "responses": ["\ndef newman_prime(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Initialize NSW sequence\n    nsw_prev2, nsw_prev1 = 1, 1\n    count = 0\n    \n    i = 2\n    while True:\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        nsw_prev2, nsw_prev1 = nsw_prev1, nsw_current\n        i += 1\n\n\n"], "prompt_tokens": [3528], "completion_tokens": [2880], "no_of_try": 1, "api_calls": 7, "is_solved": false, "task_id": "mbpp_260_newman_prime"}
{"name": "mbpp_418_Find_Max", "language": "Python3", "prompt": "from typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n\tWrite a python function to find the element of a list having maximum length.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Max", "test": "def check(candidate):\n    assert candidate([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']\n    assert candidate([[1], [1, 2], [1, 2, 3]]) == [1, 2, 3]\n    assert candidate([[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1]\n\ndef test_check():\n    check(Find_Max)\n\ntest_check()\n", "sample_io": ["assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"], "source_codes": ["def Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    # Handle edge case: empty input list\n    if not lst:\n        return []\n    \n    # Initialize with first element\n    max_length = len(lst[0])\n    max_element = lst[0]\n    \n    # Iterate through remaining elements\n    for sublist in lst[1:]:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_element = sublist\n    \n    return max_element"], "responses": ["\nfrom typing import List, Any\n\ndef Find_Max(lst: List[List[Any]]) -> List[Any]:\n    \"\"\"\n    Write a python function to find the element of a list having maximum length.\n    \"\"\"\n    # Handle edge case: empty input list\n    if not lst:\n        return []\n    \n    # Initialize with first element\n    max_length = len(lst[0])\n    max_element = lst[0]\n    \n    # Iterate through remaining elements\n    for sublist in lst[1:]:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_element = sublist\n    \n    return max_element\n\n\n"], "prompt_tokens": [1823], "completion_tokens": [1095], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_418_Find_Max"}
{"name": "mbpp_565_split", "language": "Python3", "prompt": "from typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n\tWrite a python function to split a string into characters.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split", "test": "def check(candidate):\n    assert candidate('python') == ['p', 'y', 't', 'h', 'o', 'n']\n    assert candidate('Name') == ['N', 'a', 'm', 'e']\n    assert candidate('program') == ['p', 'r', 'o', 'g', 'r', 'a', 'm']\n\ndef test_check():\n    check(split)\n\ntest_check()\n", "sample_io": ["assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"], "source_codes": ["def split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)"], "responses": ["\nfrom typing import List\n\ndef split(word: str) -> List[str]:\n    \"\"\"\n    Write a python function to split a string into characters.\n    \"\"\"\n    return list(word)\n\n\n"], "prompt_tokens": [1502], "completion_tokens": [672], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_565_split"}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "Python3", "prompt": "from typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    \"\"\"\n\tWrite a function to pack consecutive duplicates of a given list elements into sublists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "pack_consecutive_duplicates", "test": "def check(candidate):\n    assert candidate([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    assert candidate([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n    assert candidate(['a', 'a', 'b', 'c', 'd', 'd']) == [['a', 'a'], ['b'], ['c'], ['d', 'd']]\n\ndef test_check():\n    check(pack_consecutive_duplicates)\n\ntest_check()\n", "sample_io": ["assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"], "source_codes": ["def pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    # Handle edge case: empty list\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]  # Start with the first element\n    previous_element = list1[0]\n    \n    # Iterate through the rest of the elements\n    for i in range(1, len(list1)):\n        current_element = list1[i]\n        if current_element == previous_element:\n            # Same as previous, add to current group\n            current_group.append(current_element)\n        else:\n            # Different from previous, finalize current group and start new one\n            result.append(current_group)\n            current_group = [current_element]\n        previous_element = current_element\n    \n    # Add the last group\n    result.append(current_group)\n    \n    return result"], "responses": ["\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(list1: List[Any]) -> List[List[Any]]:\n    # Handle edge case: empty list\n    if not list1:\n        return []\n    \n    result = []\n    current_group = [list1[0]]  # Start with the first element\n    previous_element = list1[0]\n    \n    # Iterate through the rest of the elements\n    for i in range(1, len(list1)):\n        current_element = list1[i]\n        if current_element == previous_element:\n            # Same as previous, add to current group\n            current_group.append(current_element)\n        else:\n            # Different from previous, finalize current group and start new one\n            result.append(current_group)\n            current_group = [current_element]\n        previous_element = current_element\n    \n    # Add the last group\n    result.append(current_group)\n    \n    return result\n\n\n"], "prompt_tokens": [2214], "completion_tokens": [1306], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_778_pack_consecutive_duplicates"}
{"name": "mbpp_753_min_k", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    \"\"\"\n\tWrite a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "min_k", "test": "def check(candidate):\n    assert candidate([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    assert candidate([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    assert candidate([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n\ndef test_check():\n    check(min_k)\n\ntest_check()\n", "sample_io": ["assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"], "source_codes": ["def min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort the list based on the integer value (second element of tuple)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # If K is greater than the length of the list, return the entire sorted list\n    if K >= len(sorted_list):\n        return sorted_list\n    \n    # Return the first K elements\n    return sorted_list[:K]"], "responses": ["\nfrom typing import List, Tuple\n\ndef min_k(test_list: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]:\n    # Handle edge cases\n    if not test_list or K <= 0:\n        return []\n    \n    # Sort the list based on the integer value (second element of tuple)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    \n    # If K is greater than the length of the list, return the entire sorted list\n    if K >= len(sorted_list):\n        return sorted_list\n    \n    # Return the first K elements\n    return sorted_list[:K]\n\n\n"], "prompt_tokens": [2442], "completion_tokens": [1258], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_753_min_k"}
{"name": "mbpp_113_check_integer", "language": "Python3", "prompt": "def check_integer(text: str) -> bool:\n    \"\"\"\n\tWrite a function to check if a string represents an integer or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_integer", "test": "def check(candidate):\n    assert candidate('python') == False\n    assert candidate('1') == True\n    assert candidate('12345') == True\n\ndef test_check():\n    check(check_integer)\n\ntest_check()\n", "sample_io": ["assert check_integer('python') == False"], "source_codes": ["def check_integer(text: str) -> bool:\n    # Handle edge cases: None, empty, or whitespace-only strings\n    if not text or not text.strip():\n        return False\n    \n    # Strip leading and trailing whitespace\n    text = text.strip()\n    \n    # Check for optional sign at the beginning\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not a valid integer\n        if len(text) == 1:\n            return False\n    \n    # Check that all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    # If we've gotten here and we have at least one digit, it's valid\n    return len(text) > start_index"], "responses": ["\ndef check_integer(text: str) -> bool:\n    # Handle edge cases: None, empty, or whitespace-only strings\n    if not text or not text.strip():\n        return False\n    \n    # Strip leading and trailing whitespace\n    text = text.strip()\n    \n    # Check for optional sign at the beginning\n    start_index = 0\n    if text[0] in '+-':\n        start_index = 1\n        # If string is only a sign, it's not a valid integer\n        if len(text) == 1:\n            return False\n    \n    # Check that all remaining characters are digits\n    for i in range(start_index, len(text)):\n        if not text[i].isdigit():\n            return False\n    \n    # If we've gotten here and we have at least one digit, it's valid\n    return len(text) > start_index\n\n\n"], "prompt_tokens": [1825], "completion_tokens": [961], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_113_check_integer"}
{"name": "mbpp_743_rotate_right", "language": "Python3", "prompt": "from typing import List\n\ndef rotate_right(list: List[int], m: int) -> List[int]:\n    \"\"\"\n\tWrite a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rotate_right", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n\ndef test_check():\n    check(rotate_right)\n\ntest_check()\n", "sample_io": ["assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"], "source_codes": ["def rotate_right(lst: List[int], m: int) -> List[int]:\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not lst:\n        return []\n    \n    # Normalize rotation amount using modular arithmetic\n    m = m % len(lst)\n    \n    # Handle special case: if m is 0 after normalization, return the original list\n    if m == 0:\n        return lst\n    \n    # Perform rotation using list slicing: take last m elements and concatenate with remaining elements\n    return lst[-m:] + lst[:-m]"], "responses": ["\nfrom typing import List\n\ndef rotate_right(lst: List[int], m: int) -> List[int]:\n    # Handle edge case: if input list is empty, return empty list immediately\n    if not lst:\n        return []\n    \n    # Normalize rotation amount using modular arithmetic\n    m = m % len(lst)\n    \n    # Handle special case: if m is 0 after normalization, return the original list\n    if m == 0:\n        return lst\n    \n    # Perform rotation using list slicing: take last m elements and concatenate with remaining elements\n    return lst[-m:] + lst[:-m]\n\n\n"], "prompt_tokens": [2066], "completion_tokens": [1069], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_743_rotate_right"}
{"name": "mbpp_598_armstrong_number", "language": "Python3", "prompt": "def armstrong_number(number: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given number is armstrong or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "armstrong_number", "test": "def check(candidate):\n    assert candidate(153) == True\n    assert candidate(259) == False\n    assert candidate(4458) == False\n\ndef test_check():\n    check(armstrong_number)\n\ntest_check()\n", "sample_io": ["assert armstrong_number(153) == True"], "source_codes": ["def armstrong_number(number: int) -> bool:\n    # Handle negative numbers\n    if number < 0:\n        return False\n    \n    # Convert number to string to get individual digits\n    num_str = str(number)\n    n = len(num_str)\n    \n    # Calculate sum of each digit raised to the power n\n    total = sum(int(digit) ** n for digit in num_str)\n    \n    # Check if total equals the original number\n    return total == number"], "responses": ["\ndef armstrong_number(number: int) -> bool:\n    # Handle negative numbers\n    if number < 0:\n        return False\n    \n    # Convert number to string to get individual digits\n    num_str = str(number)\n    n = len(num_str)\n    \n    # Calculate sum of each digit raised to the power n\n    total = sum(int(digit) ** n for digit in num_str)\n    \n    # Check if total equals the original number\n    return total == number\n\n\n"], "prompt_tokens": [1936], "completion_tokens": [1278], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_598_armstrong_number"}
{"name": "mbpp_398_sum_of_digits", "language": "Python3", "prompt": "from typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to compute the sum of digits of each number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_of_digits", "test": "def check(candidate):\n    assert candidate([10, 2, 56]) == 14\n    assert candidate([[10, 20, 4, 5, 'b', 70, 'a']]) == 19\n    assert candidate([10, 20, -4, 5, -70]) == 19\n\ndef test_check():\n    check(sum_of_digits)\n\ntest_check()\n", "sample_io": ["assert sum_of_digits([10, 2, 56]) == 14"], "source_codes": ["def sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    \n    for num in nums:\n        try:\n            # Convert to string representation\n            if isinstance(num, (int, float)):\n                str_num = str(abs(num))  # Remove negative sign if present\n                # Remove decimal point for floats\n                str_num = str_num.replace('.', '')\n            elif isinstance(num, str):\n                str_num = num\n            else:\n                # Skip non-numeric types\n                continue\n                \n            # Sum up all digit characters\n            for char in str_num:\n                if char.isdigit():\n                    total_sum += int(char)\n                    \n        except (ValueError, TypeError):\n            # Skip any problematic elements\n            continue\n            \n    return total_sum"], "responses": ["\nfrom typing import List, Any\n\ndef sum_of_digits(nums: List[Any]) -> int:\n    total_sum = 0\n    \n    for num in nums:\n        try:\n            # Convert to string representation\n            if isinstance(num, (int, float)):\n                str_num = str(abs(num))  # Remove negative sign if present\n                # Remove decimal point for floats\n                str_num = str_num.replace('.', '')\n            elif isinstance(num, str):\n                str_num = num\n            else:\n                # Skip non-numeric types\n                continue\n                \n            # Sum up all digit characters\n            for char in str_num:\n                if char.isdigit():\n                    total_sum += int(char)\n                    \n        except (ValueError, TypeError):\n            # Skip any problematic elements\n            continue\n            \n    return total_sum\n\n\n"], "prompt_tokens": [2236], "completion_tokens": [1428], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_398_sum_of_digits"}
{"name": "mbpp_229_re_arrange_array", "language": "Python3", "prompt": "from typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    \"\"\"\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "re_arrange_array", "test": "def check(candidate):\n    assert candidate([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n    assert candidate([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]\n    assert candidate([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]\n\ndef test_check():\n    check(re_arrange_array)\n\ntest_check()\n", "sample_io": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"], "source_codes": ["def re_arrange_array(arr: List[int], n: int) -> List[int]:\n    if n <= 0 or n > len(arr):\n        return arr\n    \n    # Extract first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements (including zero with positives)\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Concatenate negatives and positives\n    rearranged = negatives + positives\n    \n    # Combine with remaining elements\n    return rearranged + arr[n:]"], "responses": ["\nfrom typing import List\n\ndef re_arrange_array(arr: List[int], n: int) -> List[int]:\n    if n <= 0 or n > len(arr):\n        return arr\n    \n    # Extract first n elements\n    first_n = arr[:n]\n    \n    # Separate negative and positive elements (including zero with positives)\n    negatives = [x for x in first_n if x < 0]\n    positives = [x for x in first_n if x >= 0]\n    \n    # Concatenate negatives and positives\n    rearranged = negatives + positives\n    \n    # Combine with remaining elements\n    return rearranged + arr[n:]\n\n\n"], "prompt_tokens": [5637], "completion_tokens": [4699], "no_of_try": 1, "api_calls": 9, "is_solved": false, "task_id": "mbpp_229_re_arrange_array"}
{"name": "mbpp_638_wind_chill", "language": "Python3", "prompt": "def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n\tWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "wind_chill", "test": "def check(candidate):\n    assert candidate(120, 35) == 40\n    assert candidate(40, 20) == 19\n    assert candidate(10, 8) == 6\n\ndef test_check():\n    check(wind_chill)\n\ntest_check()\n", "sample_io": ["assert wind_chill(120, 35) == 40"], "source_codes": ["def wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Wind chill formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the nearest integer\n    return round(wci)"], "responses": ["\ndef wind_chill(v: int, t: int) -> int:\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    # Wind chill formula: WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the nearest integer\n    return round(wci)\n\n\n"], "prompt_tokens": [1281], "completion_tokens": [1764], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_638_wind_chill"}
{"name": "mbpp_608_bell_Number", "language": "Python3", "prompt": "def bell_Number(n: int) -> int:\n    \"\"\"\n\tWrite a python function to find nth bell number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bell_Number", "test": "def check(candidate):\n    assert candidate(2) == 2\n    assert candidate(3) == 5\n    assert candidate(4) == 15\n\ndef test_check():\n    check(bell_Number)\n\ntest_check()\n", "sample_io": ["assert bell_Number(2) == 2"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_608_bell_Number"}
{"name": "mbpp_295_sum_div", "language": "Python3", "prompt": "def sum_div(number: int) -> int:\n    \"\"\"\n\tWrite a function to return the sum of all divisors of a number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sum_div", "test": "def check(candidate):\n    assert candidate(8) == 7\n    assert candidate(12) == 16\n    assert candidate(7) == 1\n\ndef test_check():\n    check(sum_div)\n\ntest_check()\n", "sample_io": ["assert sum_div(8) == 7"], "source_codes": ["def sum_div(number: int) -> int:\n    if number == 0:\n        return 0\n    \n    number = abs(number)\n    divisors = set()\n    \n    for i in range(1, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.add(i)\n            divisors.add(number // i)\n    \n    return sum(divisors)"], "responses": ["\ndef sum_div(number: int) -> int:\n    if number == 0:\n        return 0\n    \n    number = abs(number)\n    divisors = set()\n    \n    for i in range(1, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.add(i)\n            divisors.add(number // i)\n    \n    return sum(divisors)\n\n\n"], "prompt_tokens": [2657], "completion_tokens": [1281], "no_of_try": 1, "api_calls": 6, "is_solved": false, "task_id": "mbpp_295_sum_div"}
{"name": "mbpp_630_get_coordinates", "language": "Python3", "prompt": "from typing import Tuple, List\n\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_coordinates", "test": "def check(candidate):\n    assert candidate((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    assert candidate((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    assert candidate((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n\ndef test_check():\n    check(get_coordinates)\n\ntest_check()\n", "sample_io": ["assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"], "source_codes": ["def get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    x, y = test_tup\n    return [\n        [x-1, y-1], [x-1, y], [x-1, y+1],\n        [x, y-1], [x, y], [x, y+1],\n        [x+1, y-1], [x+1, y], [x+1, y+1]\n    ]"], "responses": ["\ndef get_coordinates(test_tup: Tuple[int, int]) -> List[List[int]]:\n    x, y = test_tup\n    return [\n        [x-1, y-1], [x-1, y], [x-1, y+1],\n        [x, y-1], [x, y], [x, y+1],\n        [x+1, y-1], [x+1, y], [x+1, y+1]\n    ]\n\n\n"], "prompt_tokens": [4269], "completion_tokens": [2185], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_630_get_coordinates"}
{"name": "mbpp_579_find_dissimilar", "language": "Python3", "prompt": "from typing import Tuple\n\ndef find_dissimilar(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to find the dissimilar elements in the given two tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_dissimilar", "test": "def check(candidate):\n    assert candidate((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n    assert candidate((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)\n    assert candidate((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)\n\ndef test_check():\n    check(find_dissimilar)\n\ntest_check()\n", "sample_io": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_579_find_dissimilar"}
{"name": "mbpp_125_find_length", "language": "Python3", "prompt": "def find_length(string: str) -> int:\n    \"\"\"\n\tWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_length", "test": "def check(candidate):\n    assert candidate('11000010001') == 6\n    assert candidate('10111') == 1\n    assert candidate('11011101100101') == 2\n\ndef test_check():\n    check(find_length)\n\ntest_check()\n", "sample_io": ["assert find_length('11000010001') == 6"], "source_codes": ["def find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    max_sum = 0\n    current_sum = 0\n    \n    for char in string:\n        # Transform '0' to +1 and '1' to -1\n        value = 1 if char == '0' else -1\n        \n        # Kadane's algorithm: either extend the existing subarray or start a new one\n        current_sum = max(value, current_sum + value)\n        \n        # Update maximum sum found so far\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"], "responses": ["\ndef find_length(string: str) -> int:\n    if not string:\n        return 0\n    \n    max_sum = 0\n    current_sum = 0\n    \n    for char in string:\n        # Transform '0' to +1 and '1' to -1\n        value = 1 if char == '0' else -1\n        \n        # Kadane's algorithm: either extend the existing subarray or start a new one\n        current_sum = max(value, current_sum + value)\n        \n        # Update maximum sum found so far\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n\n"], "prompt_tokens": [1767], "completion_tokens": [1123], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_125_find_length"}
{"name": "mbpp_262_split_two_parts", "language": "Python3", "prompt": "from typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    \"\"\"\n\tWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "split_two_parts", "test": "def check(candidate):\n    assert candidate([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\n    assert candidate(['a', 'b', 'c', 'd'], 2) == (['a', 'b'], ['c', 'd'])\n    assert candidate(['p', 'y', 't', 'h', 'o', 'n'], 4) == (['p', 'y', 't', 'h'], ['o', 'n'])\n\ndef test_check():\n    check(split_two_parts)\n\ntest_check()\n", "sample_io": ["assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"], "source_codes": ["def split_two_parts(list1: List[Any], L: int) -> Any:\n    # Handle negative L by treating it as 0\n    if L < 0:\n        L = 0\n    \n    # Split the list using slicing\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return (first_part, second_part)"], "responses": ["\nfrom typing import List, Any\n\ndef split_two_parts(list1: List[Any], L: int) -> Any:\n    # Handle negative L by treating it as 0\n    if L < 0:\n        L = 0\n    \n    # Split the list using slicing\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return (first_part, second_part)\n\n\n"], "prompt_tokens": [2064], "completion_tokens": [1196], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_262_split_two_parts"}
{"name": "mbpp_771_check_expression", "language": "Python3", "prompt": "def check_expression(exp: str) -> bool:\n    \"\"\"\n\tWrite a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_expression", "test": "def check(candidate):\n    assert candidate('{()}[{}]') == True\n    assert candidate('{()}[{]') == False\n    assert candidate('{()}[{}][]({})') == True\n\ndef test_check():\n    check(check_expression)\n\ntest_check()\n", "sample_io": ["assert check_expression('{()}[{}]') == True"], "source_codes": ["def check_expression(exp: str) -> bool:\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in exp:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0"], "responses": ["\ndef check_expression(exp: str) -> bool:\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in exp:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n\n"], "prompt_tokens": [1765], "completion_tokens": [830], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_771_check_expression"}
{"name": "mbpp_801_test_three_equal", "language": "Python3", "prompt": "def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n\tWrite a python function to count the number of equal numbers from three given integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "test_three_equal", "test": "def check(candidate):\n    assert candidate(1, 1, 1) == 3\n    assert candidate(-1, -2, -3) == 0\n    assert candidate(1, 2, 2) == 2\n\ndef test_check():\n    check(test_three_equal)\n\ntest_check()\n", "sample_io": ["assert test_three_equal(1, 1, 1) == 3"], "source_codes": ["def test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    Returns:\n        0 if all numbers are different\n        2 if exactly two numbers are equal\n        3 if all three numbers are equal\n    \"\"\"\n    # Count how many pairs are equal\n    equal_pairs = 0\n    \n    if x == y:\n        equal_pairs += 1\n    if y == z:\n        equal_pairs += 1\n    if x == z:\n        equal_pairs += 1\n    \n    # If all three are equal, we have 3 equal pairs, but we want to return 3\n    # If exactly two are equal, we have 1 equal pair, but we want to return 2\n    # If none are equal, we have 0 equal pairs, and we want to return 0\n    \n    # Simpler approach: just check the conditions directly\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0"], "responses": ["\ndef test_three_equal(x: int, y: int, z: int) -> int:\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    Returns:\n        0 if all numbers are different\n        2 if exactly two numbers are equal\n        3 if all three numbers are equal\n    \"\"\"\n    # Count how many pairs are equal\n    equal_pairs = 0\n    \n    if x == y:\n        equal_pairs += 1\n    if y == z:\n        equal_pairs += 1\n    if x == z:\n        equal_pairs += 1\n    \n    # If all three are equal, we have 3 equal pairs, but we want to return 3\n    # If exactly two are equal, we have 1 equal pair, but we want to return 2\n    # If none are equal, we have 0 equal pairs, and we want to return 0\n    \n    # Simpler approach: just check the conditions directly\n    if x == y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 0\n\n\n"], "prompt_tokens": [1995], "completion_tokens": [1147], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_801_test_three_equal"}
{"name": "mbpp_389_find_lucas", "language": "Python3", "prompt": "def find_lucas(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the n'th lucas number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lucas", "test": "def check(candidate):\n    assert candidate(9) == 76\n    assert candidate(4) == 7\n    assert candidate(3) == 4\n\ndef test_check():\n    check(find_lucas)\n\ntest_check()\n", "sample_io": ["assert find_lucas(9) == 76"], "source_codes": ["def find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th lucas number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Lucas numbers\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    # Calculate Lucas numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"], "responses": ["\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Write a function to find the n'th lucas number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Lucas numbers\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    # Calculate Lucas numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n\n"], "prompt_tokens": [1856], "completion_tokens": [1076], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_389_find_lucas"}
{"name": "mbpp_102_snake_to_camel", "language": "Python3", "prompt": "def snake_to_camel(word: str) -> str:\n    \"\"\"\n\tWrite a function to convert a snake case string to camel case string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "snake_to_camel", "test": "def check(candidate):\n    assert candidate('python_program') == 'PythonProgram'\n    assert candidate('python_language') == 'PythonLanguage'\n    assert candidate('programming_language') == 'ProgrammingLanguage'\n\ndef test_check():\n    check(snake_to_camel)\n\ntest_check()\n", "sample_io": ["assert snake_to_camel('python_program') == 'PythonProgram'"], "source_codes": ["def snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of all words and join them\n    return ''.join(w.capitalize() for w in words)"], "responses": ["\ndef snake_to_camel(word: str) -> str:\n    if not word:\n        return \"\"\n    \n    # Split by underscore and filter out empty strings\n    words = [w for w in word.split('_') if w]\n    \n    if not words:\n        return \"\"\n    \n    # Capitalize the first letter of all words and join them\n    return ''.join(w.capitalize() for w in words)\n\n\n"], "prompt_tokens": [3203], "completion_tokens": [1536], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_102_snake_to_camel"}
{"name": "mbpp_604_reverse_words", "language": "Python3", "prompt": "def reverse_words(s: str) -> str:\n    \"\"\"\n\tWrite a function to reverse words seperated by spaces in a given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "reverse_words", "test": "def check(candidate):\n    assert candidate('python program') == 'program python'\n    assert candidate('java language') == 'language java'\n    assert candidate('indian man') == 'man indian'\n\ndef test_check():\n    check(reverse_words)\n\ntest_check()\n", "sample_io": ["assert reverse_words('python program') == 'program python'"], "source_codes": ["def reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Handle edge case for empty string\n    if not s:\n        return \"\"\n    \n    # Split the string by spaces and filter out empty strings\n    words = s.split()\n    \n    # If no words found (empty or whitespace-only string)\n    if not words:\n        return \"\"\n    \n    # Reverse the order of words and join them back with single spaces\n    return \" \".join(reversed(words))"], "responses": ["\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    # Handle edge case for empty string\n    if not s:\n        return \"\"\n    \n    # Split the string by spaces and filter out empty strings\n    words = s.split()\n    \n    # If no words found (empty or whitespace-only string)\n    if not words:\n        return \"\"\n    \n    # Reverse the order of words and join them back with single spaces\n    return \" \".join(reversed(words))\n\n\n"], "prompt_tokens": [1538], "completion_tokens": [781], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_604_reverse_words"}
{"name": "mbpp_624_is_upper", "language": "Python3", "prompt": "def is_upper(string: str) -> str:\n    \"\"\"\n\tWrite a python function to convert a given string to uppercase.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_upper", "test": "def check(candidate):\n    assert candidate('person') == 'PERSON'\n    assert candidate('final') == 'FINAL'\n    assert candidate('Valid') == 'VALID'\n\ndef test_check():\n    check(is_upper)\n\ntest_check()\n", "sample_io": ["assert is_upper('person') == 'PERSON'"], "source_codes": ["def is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()"], "responses": ["\ndef is_upper(string: str) -> str:\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n    \"\"\"\n    return string.upper()\n\n\n"], "prompt_tokens": [1523], "completion_tokens": [810], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_624_is_upper"}
{"name": "mbpp_558_digit_distance_nums", "language": "Python3", "prompt": "def digit_distance_nums(n1: int, n2: int) -> int:\n    \"\"\"\n\tWrite a python function to find the sum of the per-digit difference between two integers.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "digit_distance_nums", "test": "def check(candidate):\n    assert candidate(1, 2) == 1\n    assert candidate(23, 56) == 6\n    assert candidate(123, 256) == 7\n\ndef test_check():\n    check(digit_distance_nums)\n\ntest_check()\n", "sample_io": ["assert digit_distance_nums(1, 2) == 1"], "source_codes": ["def digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_length = max(len(str_n1), len(str_n2))\n    \n    # Pad the shorter string with leading zeros\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    \n    # Calculate the sum of per-digit differences\n    total_distance = 0\n    for i in range(max_length):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_distance += digit_diff\n    \n    return total_distance"], "responses": ["\ndef digit_distance_nums(n1: int, n2: int) -> int:\n    # Convert both numbers to strings\n    str_n1 = str(n1)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_length = max(len(str_n1), len(str_n2))\n    \n    # Pad the shorter string with leading zeros\n    str_n1 = str_n1.zfill(max_length)\n    str_n2 = str_n2.zfill(max_length)\n    \n    # Calculate the sum of per-digit differences\n    total_distance = 0\n    for i in range(max_length):\n        digit_diff = abs(int(str_n1[i]) - int(str_n2[i]))\n        total_distance += digit_diff\n    \n    return total_distance\n\n\n"], "prompt_tokens": [1750], "completion_tokens": [1066], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_558_digit_distance_nums"}
{"name": "mbpp_143_find_lists", "language": "Python3", "prompt": "from typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n\tWrite a function to find number of lists present in the given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_lists", "test": "def check(candidate):\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2\n    assert candidate([[1, 2], [3, 4], [5, 6]]) == 3\n    assert candidate([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\ndef test_check():\n    check(find_lists)\n\ntest_check()\n", "sample_io": ["assert find_lists([[1, 2, 3, 4], [5, 6, 7, 8]]) == 2"], "source_codes": ["def find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1  # Count the current list\n            count += find_lists(element)  # Recursively count lists within this list\n    \n    return count"], "responses": ["\nfrom typing import List, Any\n\ndef find_lists(Input: List[Any]) -> int:\n    \"\"\"\n    Write a function to find number of lists present in the given list.\n    \"\"\"\n    count = 0\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1  # Count the current list\n            count += find_lists(element)  # Recursively count lists within this list\n    \n    return count\n\n\n"], "prompt_tokens": [1655], "completion_tokens": [807], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_143_find_lists"}
{"name": "mbpp_615_average_tuple", "language": "Python3", "prompt": "from typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    \"\"\"\n\tWrite a function which takes a lists of lists and returns the average value for each sublist as a list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "average_tuple", "test": "def check(candidate):\n    assert candidate([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]\n    assert candidate([[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75]\n    assert candidate([[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5]\n\ndef test_check():\n    check(average_tuple)\n\ntest_check()\n", "sample_io": ["assert average_tuple([[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25]"], "source_codes": ["def average_tuple(nums: List[List[int]]) -> List[float]:\n    return [sum(sublist) / len(sublist) if sublist else 0.0 for sublist in nums]"], "responses": ["\nfrom typing import List\n\ndef average_tuple(nums: List[List[int]]) -> List[float]:\n    return [sum(sublist) / len(sublist) if sublist else 0.0 for sublist in nums]\n\n\n"], "prompt_tokens": [5186], "completion_tokens": [2844], "no_of_try": 1, "api_calls": 9, "is_solved": false, "task_id": "mbpp_615_average_tuple"}
{"name": "mbpp_166_find_even_pair", "language": "Python3", "prompt": "from typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n\tWrite a function that counts the number of pairs of integers in a list that xor to an even number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_even_pair", "test": "def check(candidate):\n    assert candidate([5, 4, 7, 2, 1]) == 4\n    assert candidate([7, 2, 8, 1, 0, 5, 11]) == 9\n    assert candidate([1, 2, 3]) == 1\n\ndef test_check():\n    check(find_even_pair)\n\ntest_check()\n", "sample_io": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4"], "source_codes": ["def find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Two numbers XOR to an even number when they have the same parity (both even or both odd).\n    So we count pairs of even numbers and pairs of odd numbers.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: n*(n-1)/2 for both even and odd numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs"], "responses": ["\nfrom typing import List\n\ndef find_even_pair(A: List[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Two numbers XOR to an even number when they have the same parity (both even or both odd).\n    So we count pairs of even numbers and pairs of odd numbers.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: n*(n-1)/2 for both even and odd numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n\n"], "prompt_tokens": [1800], "completion_tokens": [982], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_166_find_even_pair"}
{"name": "mbpp_58_opposite_Signs", "language": "Python3", "prompt": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the given two integers have opposite sign or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "opposite_Signs", "test": "def check(candidate):\n    assert candidate(1, -2) == True\n    assert candidate(3, 2) == False\n    assert candidate(-10, -10) == False\n    assert candidate(-2, 2) == True\n\ndef test_check():\n    check(opposite_Signs)\n\ntest_check()\n", "sample_io": ["assert opposite_Signs(1, -2) == True"], "source_codes": ["def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \n    Args:\n        x: First integer\n        y: Second integer\n        \n    Returns:\n        bool: True if x and y have opposite signs, False otherwise\n    \"\"\"\n    # If either number is zero, they don't have opposite signs\n    if x == 0 or y == 0:\n        return False\n    \n    # Use XOR to check if signs are different\n    # If x and y have opposite signs, x ^ y will be negative\n    return (x ^ y) < 0"], "responses": ["\ndef opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \n    Args:\n        x: First integer\n        y: Second integer\n        \n    Returns:\n        bool: True if x and y have opposite signs, False otherwise\n    \"\"\"\n    # If either number is zero, they don't have opposite signs\n    if x == 0 or y == 0:\n        return False\n    \n    # Use XOR to check if signs are different\n    # If x and y have opposite signs, x ^ y will be negative\n    return (x ^ y) < 0\n\n\n"], "prompt_tokens": [1933], "completion_tokens": [1329], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_58_opposite_Signs"}
{"name": "mbpp_569_sort_sublists", "language": "Python3", "prompt": "from typing import List\n\ndef sort_sublists(list1: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n\tWrite a function to sort each sublist of strings in a given list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "sort_sublists", "test": "def check(candidate):\n    assert candidate([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    assert candidate([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]) == [['green', 'orange'], ['black'], ['green', 'orange'], ['white']]\n    assert candidate([['a', 'b'], ['d', 'c'], ['g', 'h'], ['f', 'e']]) == [['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]\n\ndef test_check():\n    check(sort_sublists)\n\ntest_check()\n", "sample_io": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_569_sort_sublists"}
{"name": "mbpp_255_combinations_colors", "language": "Python3", "prompt": "from typing import List\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n\tWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "combinations_colors", "test": "def check(candidate):\n    assert candidate(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    assert candidate(['Red', 'Green', 'Blue'], 3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n\ndef test_check():\n    check(combinations_colors)\n\ntest_check()\n", "sample_io": ["assert combinations_colors(['Red', 'Green', 'Blue'], 1) == [['Red'], ['Green'], ['Blue']]"], "source_codes": ["import itertools\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    # Handle edge cases\n    if n < 0:\n        return []\n    if n == 0:\n        return [[]]\n    if not l:\n        return []\n    \n    # Use itertools.product to generate all combinations with repetition\n    # product(l, repeat=n) generates the cartesian product of l repeated n times\n    result = []\n    for combo in itertools.product(l, repeat=n):\n        result.append(list(combo))\n    \n    return result"], "responses": ["\nfrom typing import List\nimport itertools\n\ndef combinations_colors(l: List[str], n: int) -> List[List[str]]:\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations \n    (with repetition) of the elements of the list and returns a list with a list for each combination.\n    \"\"\"\n    # Handle edge cases\n    if n < 0:\n        return []\n    if n == 0:\n        return [[]]\n    if not l:\n        return []\n    \n    # Use itertools.product to generate all combinations with repetition\n    # product(l, repeat=n) generates the cartesian product of l repeated n times\n    result = []\n    for combo in itertools.product(l, repeat=n):\n        result.append(list(combo))\n    \n    return result\n\n\n"], "prompt_tokens": [2165], "completion_tokens": [1276], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_255_combinations_colors"}
{"name": "mbpp_619_move_num", "language": "Python3", "prompt": "def move_num(test_str: str) -> str:\n    \"\"\"\n\tWrite a function to move all the numbers to the end of the given string.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "move_num", "test": "def check(candidate):\n    assert candidate('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n    assert candidate('Avengers124Assemble') == 'AvengersAssemble124'\n    assert candidate('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'\n\ndef test_check():\n    check(move_num)\n\ntest_check()\n", "sample_io": ["assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"], "source_codes": ["def move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    return ''.join(non_digits + digits)"], "responses": ["\ndef move_num(test_str: str) -> str:\n    \"\"\"\n    Write a function to move all the numbers to the end of the given string.\n    \"\"\"\n    non_digits = []\n    digits = []\n    \n    for char in test_str:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    return ''.join(non_digits + digits)\n\n\n"], "prompt_tokens": [1724], "completion_tokens": [822], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_619_move_num"}
{"name": "mbpp_249_intersection_array", "language": "Python3", "prompt": "from typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a function to find the intersection of two arrays.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "intersection_array", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [3, 5, 7, 9]) == [3, 5, 7, 9]\n    assert candidate([1, 2, 3, 5, 7, 8, 9, 10], [10, 20, 30, 40]) == [10]\n\ndef test_check():\n    check(intersection_array)\n\ntest_check()\n", "sample_io": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"], "source_codes": ["def intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    # Handle edge cases: if either array is empty, return empty list\n    if not array_nums1 or not array_nums2:\n        return []\n    \n    # Convert second array to set for efficient lookup\n    set2 = set(array_nums2)\n    \n    # Use a set to track already added elements to avoid duplicates\n    seen = set()\n    result = []\n    \n    # Iterate through first array to maintain order\n    for num in array_nums1:\n        # Check if element is in second array and not already added\n        if num in set2 and num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef intersection_array(array_nums1: List[int], array_nums2: List[int]) -> List[int]:\n    # Handle edge cases: if either array is empty, return empty list\n    if not array_nums1 or not array_nums2:\n        return []\n    \n    # Convert second array to set for efficient lookup\n    set2 = set(array_nums2)\n    \n    # Use a set to track already added elements to avoid duplicates\n    seen = set()\n    result = []\n    \n    # Iterate through first array to maintain order\n    for num in array_nums1:\n        # Check if element is in second array and not already added\n        if num in set2 and num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\n\n"], "prompt_tokens": [4319], "completion_tokens": [1757], "no_of_try": 1, "api_calls": 7, "is_solved": true, "task_id": "mbpp_249_intersection_array"}
{"name": "mbpp_250_count_X", "language": "Python3", "prompt": "from typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "count_X", "test": "def check(candidate):\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 10) == 3\n    assert candidate([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 8) == 4\n\ndef test_check():\n    check(count_X)\n\ntest_check()\n", "sample_io": ["assert count_X([10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], 4) == 0"], "source_codes": ["def count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count"], "responses": ["\nfrom typing import List\n\ndef count_X(tup: List[int], x: int) -> int:\n    \"\"\"\n    Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n\n\n"], "prompt_tokens": [1782], "completion_tokens": [834], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_250_count_X"}
{"name": "mbpp_622_get_median", "language": "Python3", "prompt": "from typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n\tWrite a function to find the median of two sorted lists of same size.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_median", "test": "def check(candidate):\n    assert candidate([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n    assert candidate([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5\n    assert candidate([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0\n\ndef test_check():\n    check(get_median)\n\ntest_check()\n", "sample_io": ["assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"], "source_codes": ["def get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \n    Args:\n        arr1: First sorted list\n        arr2: Second sorted list\n        n: Size of each list\n    \n    Returns:\n        float: The median of the combined lists\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while both have elements\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median\n    total_length = 2 * n\n    mid = total_length // 2\n    \n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[mid-1] + merged[mid]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[mid])"], "responses": ["\nfrom typing import List\n\ndef get_median(arr1: List[int], arr2: List[int], n: int) -> float:\n    \"\"\"\n    Find the median of two sorted lists of same size.\n    \n    Args:\n        arr1: First sorted list\n        arr2: Second sorted list\n        n: Size of each list\n    \n    Returns:\n        float: The median of the combined lists\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    \n    # Merge arrays while both have elements\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # Add remaining elements\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Find median\n    total_length = 2 * n\n    mid = total_length // 2\n    \n    if total_length % 2 == 0:\n        # Even number of elements - average of two middle elements\n        return (merged[mid-1] + merged[mid]) / 2.0\n    else:\n        # Odd number of elements - middle element\n        return float(merged[mid])\n\n\n"], "prompt_tokens": [1243], "completion_tokens": [1508], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_622_get_median"}
{"name": "mbpp_80_tetrahedral_number", "language": "Python3", "prompt": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth tetrahedral number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "tetrahedral_number", "test": "def check(candidate):\n    assert candidate(5) == 35\n    assert candidate(6) == 56\n    assert candidate(7) == 84\n\ndef test_check():\n    check(tetrahedral_number)\n\ntest_check()\n", "sample_io": ["assert tetrahedral_number(5) == 35"], "source_codes": ["def tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number using the formula T(n) = n(n+1)(n+2)/6\n    \"\"\"\n    # Handle edge case\n    if n == 0:\n        return 0\n    \n    # Validate input\n    if n < 0 or not isinstance(n, int):\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Apply the direct formula and return result\n    return n * (n + 1) * (n + 2) // 6"], "responses": ["\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Find the nth tetrahedral number using the formula T(n) = n(n+1)(n+2)/6\n    \"\"\"\n    # Handle edge case\n    if n == 0:\n        return 0\n    \n    # Validate input\n    if n < 0 or not isinstance(n, int):\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Apply the direct formula and return result\n    return n * (n + 1) * (n + 2) // 6\n\n\n"], "prompt_tokens": [1686], "completion_tokens": [1104], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_80_tetrahedral_number"}
{"name": "mbpp_780_find_combinations", "language": "Python3", "prompt": "from typing import List, Tuple\n\ndef find_combinations(test_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n\tWrite a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_combinations", "test": "def check(candidate):\n    assert candidate([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    assert candidate([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n    assert candidate([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n\ndef test_check():\n    check(find_combinations)\n\ntest_check()\n", "sample_io": ["assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_780_find_combinations"}
{"name": "mbpp_733_find_first_occurrence", "language": "Python3", "prompt": "from typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    \"\"\"\n\tWrite a function to find the index of the first occurrence of a given number in a sorted array.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "find_first_occurrence", "test": "def check(candidate):\n    assert candidate([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n    assert candidate([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2\n    assert candidate([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4\n\ndef test_check():\n    check(find_first_occurrence)\n\ntest_check()\n", "sample_io": ["assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"], "source_codes": ["def find_first_occurrence(A: List[int], x: int) -> int:\n    # Handle edge case: empty array\n    if not A:\n        return -1\n    \n    # Initialize binary search variables\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    # Perform modified binary search\n    while left <= right:\n        # Calculate mid index\n        mid = left + (right - left) // 2\n        \n        # If element found, update result and continue searching in left half\n        if A[mid] == x:\n            result = mid\n            right = mid - 1\n        # If element is less than target, search right half\n        elif A[mid] < x:\n            left = mid + 1\n        # If element is greater than target, search left half\n        else:\n            right = mid - 1\n    \n    return result"], "responses": ["\nfrom typing import List\n\ndef find_first_occurrence(A: List[int], x: int) -> int:\n    # Handle edge case: empty array\n    if not A:\n        return -1\n    \n    # Initialize binary search variables\n    left, right = 0, len(A) - 1\n    result = -1\n    \n    # Perform modified binary search\n    while left <= right:\n        # Calculate mid index\n        mid = left + (right - left) // 2\n        \n        # If element found, update result and continue searching in left half\n        if A[mid] == x:\n            result = mid\n            right = mid - 1\n        # If element is less than target, search right half\n        elif A[mid] < x:\n            left = mid + 1\n        # If element is greater than target, search left half\n        else:\n            right = mid - 1\n    \n    return result\n\n\n"], "prompt_tokens": [2296], "completion_tokens": [1235], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_733_find_first_occurrence"}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "Python3", "prompt": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n\tWrite a python function to check whether the two numbers differ at one bit position only or not.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "differ_At_One_Bit_Pos", "test": "def check(candidate):\n    assert candidate(13, 9) == True\n    assert candidate(15, 8) == False\n    assert candidate(2, 4) == False\n    assert candidate(2, 3) == True\n    assert candidate(5, 1) == True\n    assert candidate(1, 5) == True\n\ndef test_check():\n    check(differ_At_One_Bit_Pos)\n\ntest_check()\n", "sample_io": ["assert differ_At_One_Bit_Pos(13, 9) == True"], "source_codes": ["def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # Compute XOR to find bit differences\n    xor_result = a ^ b\n    \n    # If XOR is 0, numbers are identical\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has exactly one bit set)\n    # A number is a power of 2 if (n & (n-1)) == 0 and n != 0\n    return (xor_result & (xor_result - 1)) == 0"], "responses": ["\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    # Compute XOR to find bit differences\n    xor_result = a ^ b\n    \n    # If XOR is 0, numbers are identical\n    if xor_result == 0:\n        return False\n    \n    # Check if xor_result is a power of 2 (has exactly one bit set)\n    # A number is a power of 2 if (n & (n-1)) == 0 and n != 0\n    return (xor_result & (xor_result - 1)) == 0\n\n\n"], "prompt_tokens": [2051], "completion_tokens": [1333], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_6_differ_At_One_Bit_Pos"}
{"name": "mbpp_762_check_monthnumber_number", "language": "Python3", "prompt": "def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n\tWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_monthnumber_number", "test": "def check(candidate):\n    assert candidate(6) == True\n    assert candidate(2) == False\n    assert candidate(12) == False\n\ndef test_check():\n    check(check_monthnumber_number)\n\ntest_check()\n", "sample_io": ["assert check_monthnumber_number(6) == True"], "source_codes": ["def check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n    \"\"\"\n    # Validate the input month number to ensure it's within the valid range (1-12)\n    if monthnum3 < 1 or monthnum3 > 12:\n        return False\n    \n    # Create a set of month numbers that have exactly 30 days\n    months_with_30_days = {4, 6, 9, 11}  # April, June, September, November\n    \n    # Check if the input month number is in the set of months with 30 days\n    return monthnum3 in months_with_30_days"], "responses": ["\ndef check_monthnumber_number(monthnum3: int) -> bool:\n    \"\"\"\n    Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n    \"\"\"\n    # Validate the input month number to ensure it's within the valid range (1-12)\n    if monthnum3 < 1 or monthnum3 > 12:\n        return False\n    \n    # Create a set of month numbers that have exactly 30 days\n    months_with_30_days = {4, 6, 9, 11}  # April, June, September, November\n    \n    # Check if the input month number is in the set of months with 30 days\n    return monthnum3 in months_with_30_days\n\n\n"], "prompt_tokens": [2097], "completion_tokens": [1088], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_762_check_monthnumber_number"}
{"name": "mbpp_625_swap_List", "language": "Python3", "prompt": "from typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n\tWrite a python function to interchange the first and last element in a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "swap_List", "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == [3, 2, 1]\n    assert candidate([1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1]\n    assert candidate([4, 5, 6]) == [6, 5, 4]\n\ndef test_check():\n    check(swap_List)\n\ntest_check()\n", "sample_io": ["assert swap_List([1, 2, 3]) == [3, 2, 1]"], "source_codes": ["def swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList"], "responses": ["\nfrom typing import List\n\ndef swap_List(newList: List[int]) -> List[int]:\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(newList) <= 1:\n        return newList\n    \n    # Swap first and last elements using tuple unpacking\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n\n\n"], "prompt_tokens": [1669], "completion_tokens": [807], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_625_swap_List"}
{"name": "mbpp_407_rearrange_bigger", "language": "Python3", "prompt": "from typing import Any\n\ndef rearrange_bigger(n: int) -> Any:\n    \"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "rearrange_bigger", "test": "def check(candidate):\n    assert candidate(12) == 21\n    assert candidate(10) == False\n    assert candidate(102) == 120\n\ndef test_check():\n    check(rearrange_bigger)\n\ntest_check()\n", "sample_io": ["assert rearrange_bigger(12) == 21"], "source_codes": ["def rearrange_bigger(n: int) -> Any:\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the largest index i such that digits[i] < digits[i+1]\n    i = -1\n    for idx in range(length - 2, -1, -1):\n        if digits[idx] < digits[idx + 1]:\n            i = idx\n            break\n    \n    # If no such index exists, return None\n    if i == -1:\n        return None\n    \n    # Find the largest index j such that digits[i] < digits[j]\n    j = -1\n    for idx in range(length - 1, i, -1):\n        if digits[idx] > digits[i]:\n            j = idx\n            break\n    \n    # Swap digits[i] and digits[j]\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the suffix starting at digits[i+1]\n    digits[i+1:] = reversed(digits[i+1:])\n    \n    # Convert back to integer and return\n    return int(''.join(digits))"], "responses": ["\ndef rearrange_bigger(n: int) -> Any:\n    # Convert the number to a list of digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the largest index i such that digits[i] < digits[i+1]\n    i = -1\n    for idx in range(length - 2, -1, -1):\n        if digits[idx] < digits[idx + 1]:\n            i = idx\n            break\n    \n    # If no such index exists, return None\n    if i == -1:\n        return None\n    \n    # Find the largest index j such that digits[i] < digits[j]\n    j = -1\n    for idx in range(length - 1, i, -1):\n        if digits[idx] > digits[i]:\n            j = idx\n            break\n    \n    # Swap digits[i] and digits[j]\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the suffix starting at digits[i+1]\n    digits[i+1:] = reversed(digits[i+1:])\n    \n    # Convert back to integer and return\n    return int(''.join(digits))\n\n\n"], "prompt_tokens": [2211], "completion_tokens": [1680], "no_of_try": 1, "api_calls": 4, "is_solved": false, "task_id": "mbpp_407_rearrange_bigger"}
{"name": "mbpp_392_get_max_sum", "language": "Python3", "prompt": "def get_max_sum(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "get_max_sum", "test": "def check(candidate):\n    assert candidate(60) == 106\n    assert candidate(10) == 12\n    assert candidate(2) == 2\n\ndef test_check():\n    check(get_max_sum)\n\ntest_check()\n", "sample_io": ["assert get_max_sum(60) == 106"], "source_codes": ["def get_max_sum(n: int) -> int:\n    # Memoization dictionary to store computed values\n    memo = {}\n    \n    def f(num):\n        # Base cases\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n            \n        # Check if already computed\n        if num in memo:\n            return memo[num]\n            \n        # Calculate the sum of subproblems\n        result = max(\n            f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5),\n            num\n        )\n        \n        # Store in memoization table\n        memo[num] = result\n        return result\n    \n    return f(n)"], "responses": ["\ndef get_max_sum(n: int) -> int:\n    # Memoization dictionary to store computed values\n    memo = {}\n    \n    def f(num):\n        # Base cases\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n            \n        # Check if already computed\n        if num in memo:\n            return memo[num]\n            \n        # Calculate the sum of subproblems\n        result = max(\n            f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5),\n            num\n        )\n        \n        # Store in memoization table\n        memo[num] = result\n        return result\n    \n    return f(n)\n\n\n"], "prompt_tokens": [2185], "completion_tokens": [1264], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_392_get_max_sum"}
{"name": "mbpp_784_mul_even_odd", "language": "Python3", "prompt": "from typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n\tWrite a function to find the product of first even and odd number of a given list.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "mul_even_odd", "test": "def check(candidate):\n    assert candidate([1, 3, 5, 7, 4, 1, 6, 8]) == 4\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([1, 5, 7, 9, 10]) == 10\n\ndef test_check():\n    check(mul_even_odd)\n\ntest_check()\n", "sample_io": ["assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"], "source_codes": ["def mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 == 1:\n            first_odd = num\n            \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"], "responses": ["\nfrom typing import List\n\ndef mul_even_odd(list1: List[int]) -> int:\n    \"\"\"\n    Write a function to find the product of first even and odd number of a given list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 == 1:\n            first_odd = num\n            \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0\n\n\n"], "prompt_tokens": [1935], "completion_tokens": [1009], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_784_mul_even_odd"}
{"name": "mbpp_109_odd_Equivalent", "language": "Python3", "prompt": "def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n\tWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "odd_Equivalent", "test": "def check(candidate):\n    assert candidate('011001', 6) == 3\n    assert candidate('11011', 5) == 4\n    assert candidate('1010', 4) == 2\n\ndef test_check():\n    check(odd_Equivalent)\n\ntest_check()\n", "sample_io": ["assert odd_Equivalent('011001', 6) == 3"], "source_codes": ["def odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \n    Args:\n        s: A binary string\n        n: Number of rotations\n        \n    Returns:\n        The count of rotations that result in an odd number (ending with '1')\n    \"\"\"\n    # Handle edge cases\n    if not s or n <= 0:\n        return 0\n    \n    # Count the number of '1's in the string\n    # Each '1' in the string will be the last digit of some rotation\n    # and thus make that rotation an odd number\n    count = 0\n    for char in s:\n        if char == '1':\n            count += 1\n            \n    return count"], "responses": ["\ndef odd_Equivalent(s: str, n: int) -> int:\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n    \n    Args:\n        s: A binary string\n        n: Number of rotations\n        \n    Returns:\n        The count of rotations that result in an odd number (ending with '1')\n    \"\"\"\n    # Handle edge cases\n    if not s or n <= 0:\n        return 0\n    \n    # Count the number of '1's in the string\n    # Each '1' in the string will be the last digit of some rotation\n    # and thus make that rotation an odd number\n    count = 0\n    for char in s:\n        if char == '1':\n            count += 1\n            \n    return count\n\n\n"], "prompt_tokens": [2003], "completion_tokens": [1539], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_109_odd_Equivalent"}
{"name": "mbpp_95_Find_Min_Length", "language": "Python3", "prompt": "from typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n\tWrite a python function to find the length of the smallest list in a list of lists.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "Find_Min_Length", "test": "def check(candidate):\n    assert candidate([[1], [1, 2]]) == 1\n    assert candidate([[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2\n    assert candidate([[3, 3, 3], [4, 4, 4, 4]]) == 3\n\ndef test_check():\n    check(Find_Min_Length)\n\ntest_check()\n", "sample_io": ["assert Find_Min_Length([[1], [1, 2]]) == 1"], "source_codes": ["def Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    # Handle edge case: empty outer list\n    if not lst:\n        return 0\n    \n    # Find minimum length using min() with key parameter\n    return min(len(inner_list) for inner_list in lst)"], "responses": ["\nfrom typing import List\n\ndef Find_Min_Length(lst: List[List[int]]) -> int:\n    \"\"\"\n    Write a python function to find the length of the smallest list in a list of lists.\n    \"\"\"\n    # Handle edge case: empty outer list\n    if not lst:\n        return 0\n    \n    # Find minimum length using min() with key parameter\n    return min(len(inner_list) for inner_list in lst)\n\n\n"], "prompt_tokens": [1778], "completion_tokens": [891], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_95_Find_Min_Length"}
{"name": "mbpp_399_bitwise_xor", "language": "Python3", "prompt": "from typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n\tWrite a function to perform the mathematical bitwise xor operation across the given tuples.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "bitwise_xor", "test": "def check(candidate):\n    assert candidate((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    assert candidate((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    assert candidate((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n\ndef test_check():\n    check(bitwise_xor)\n\ntest_check()\n", "sample_io": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)"], "source_codes": ["def bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    # Perform element-wise XOR operation\n    result = (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n    \n    return result"], "responses": ["\nfrom typing import Tuple\n\ndef bitwise_xor(test_tup1: Tuple[int, int, int, int], test_tup2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n    \"\"\"\n    # Perform element-wise XOR operation\n    result = (\n        test_tup1[0] ^ test_tup2[0],\n        test_tup1[1] ^ test_tup2[1],\n        test_tup1[2] ^ test_tup2[2],\n        test_tup1[3] ^ test_tup2[3]\n    )\n    \n    return result\n\n\n"], "prompt_tokens": [1513], "completion_tokens": [1409], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_399_bitwise_xor"}
{"name": "mbpp_641_is_nonagonal", "language": "Python3", "prompt": "def is_nonagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth nonagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_nonagonal", "test": "def check(candidate):\n    assert candidate(10) == 325\n    assert candidate(15) == 750\n    assert candidate(18) == 1089\n\ndef test_check():\n    check(is_nonagonal)\n\ntest_check()\n", "sample_io": ["assert is_nonagonal(10) == 325"], "source_codes": ["def is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number using the formula: N(n) = n(7n - 5)/2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n        \n    Raises:\n        ValueError: If n is not a positive integer\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    return n * (7 * n - 5) // 2"], "responses": ["\ndef is_nonagonal(n: int) -> int:\n    \"\"\"\n    Find the nth nonagonal number using the formula: N(n) = n(7n - 5)/2\n    \n    Args:\n        n: A positive integer representing the position in the sequence\n        \n    Returns:\n        The nth nonagonal number\n        \n    Raises:\n        ValueError: If n is not a positive integer\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    return n * (7 * n - 5) // 2\n\n\n"], "prompt_tokens": [1941], "completion_tokens": [1357], "no_of_try": 1, "api_calls": 4, "is_solved": true, "task_id": "mbpp_641_is_nonagonal"}
{"name": "mbpp_59_is_octagonal", "language": "Python3", "prompt": "def is_octagonal(n: int) -> int:\n    \"\"\"\n\tWrite a function to find the nth octagonal number.\n\t\"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "is_octagonal", "test": "def check(candidate):\n    assert candidate(5) == 65\n    assert candidate(10) == 280\n    assert candidate(15) == 645\n\ndef test_check():\n    check(is_octagonal)\n\ntest_check()\n", "sample_io": ["assert is_octagonal(5) == 65"], "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "task_id": "mbpp_59_is_octagonal"}
