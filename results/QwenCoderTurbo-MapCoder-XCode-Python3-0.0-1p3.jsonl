{"description": "Buses run between the cities A and B, the first one is at 05:00 AM and the last one departs not later than at 11:59 PM. A bus from the city A departs every a minutes and arrives to the city B in a ta minutes, and a bus from the city B departs every b minutes and arrives to the city A in a tb minutes.The driver Simion wants to make his job diverse, so he counts the buses going towards him. Simion doesn't count the buses he meet at the start and finish.You know the time when Simion departed from the city A to the city B. Calculate the number of buses Simion will meet to be sure in his counting.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers a,\u2009ta (1\u2009\u2264\u2009a,\u2009ta\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city A to the city B and the travel time. Both values are given in minutes. The second line contains two integers b,\u2009tb (1\u2009\u2264\u2009b,\u2009tb\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city B to the city A and the travel time. Both values are given in minutes. The last line contains the departure time of Simion from the city A in the format hh:mm. It is guaranteed that there are a bus from the city A at that time. Note that the hours and the minutes are given with exactly two digits.", "output_spec": "Print the only integer z \u2014 the number of buses Simion will meet on the way. Note that you should not count the encounters in cities A and B.", "notes": "NoteIn the first example Simion departs form the city A at 05:20 AM and arrives to the city B at 05:50 AM. He will meet the first 5 buses from the city B that departed in the period [05:00 AM - 05:40 AM]. Also Simion will meet a bus in the city B at 05:50 AM, but he will not count it.Also note that the first encounter will be between 05:26 AM and 05:27 AM (if we suggest that the buses are go with the sustained speed).", "sample_inputs": ["10 30\n10 35\n05:20", "60 120\n24 100\n13:00"], "sample_outputs": ["5", "9"], "tags": ["implementation"], "src_uid": "1c4cf1c3cb464a483511a8a61f8685a7", "difficulty": 1600, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "1c4cf1c3cb464a483511a8a61f8685a7"}
{"description": "There are three friend living on the straight line Ox in Lineland. The first friend lives at the point x1, the second friend lives at the point x2, and the third friend lives at the point x3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?It's guaranteed that the optimal answer is always integer.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains three distinct integers x1, x2 and x3 (1\u2009\u2264\u2009x1,\u2009x2,\u2009x3\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the houses of the first, the second and the third friends respectively. ", "output_spec": "Print one integer\u00a0\u2014 the minimum total distance the friends need to travel in order to meet together.", "notes": "NoteIn the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.", "sample_inputs": ["7 1 4", "30 20 10"], "sample_outputs": ["6", "20"], "tags": ["math", "implementation", "sortings"], "src_uid": "7bffa6e8d2d21bbb3b7f4aec109b3319", "difficulty": 800, "source_codes": ["# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort them\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The optimal meeting point is the median (middle value)\nmedian = coordinates[1]\n\n# Calculate total distance\ntotal_distance = abs(x1 - median) + abs(x2 - median) + abs(x3 - median)\n\n# Output the result\nprint(total_distance)"], "responses": ["\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort them\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The optimal meeting point is the median (middle value)\nmedian = coordinates[1]\n\n# Calculate total distance\ntotal_distance = abs(x1 - median) + abs(x2 - median) + abs(x3 - median)\n\n# Output the result\nprint(total_distance)\n\n\n"], "prompt_tokens": [8210], "completion_tokens": [1762], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "7bffa6e8d2d21bbb3b7f4aec109b3319"}
{"description": "A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.   \u00a0It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one\u00a0\u2014 in seat 'c'. Assume that all seats are occupied.Vasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of input contains a description of Vasya's seat in the format ns, where n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.", "output_spec": "Print one integer\u00a0\u2014 the number of seconds Vasya has to wait until he gets his lunch.", "notes": "NoteIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6\u2009+\u20091\u2009+\u20093\u2009=\u200910.", "sample_inputs": ["1f", "2d", "4a", "5e"], "sample_outputs": ["1", "10", "11", "18"], "tags": ["math", "implementation"], "src_uid": "069d0cb9b7c798a81007fb5b63fa0f45", "difficulty": 1200, "source_codes": ["import sys\n\ndef solve():\n    line = input().strip()\n    n = int(line[:-1])\n    s = line[-1]\n    \n    # Serving order per row: f(1), e(2), d(3), a(4), b(5), c(6)\n    seat_time = {'f': 1, 'e': 2, 'd': 3, 'a': 4, 'b': 5, 'c': 6}\n    \n    # Determine which round serves row n\n    # Pattern: rounds serve pairs (1,3), (2,4), (5,7), (6,8), (9,11), (10,12), ...\n    # Group these pairs: [(1,3),(2,4)], [(5,7),(6,8)], [(9,11),(10,12)], ...\n    # So groups of 2 rounds, starting at rows 1, 5, 9, ... (4k+1)\n    \n    # For any row n, find which round serves it\n    # Round numbering starts from 0\n    \n    # Let's think of it this way:\n    # Round 0: rows 1,3\n    # Round 1: rows 2,4  \n    # Round 2: rows 5,7\n    # Round 3: rows 6,8\n    # Round 4: rows 9,11\n    # Round 5: rows 10,12\n    # ...\n    \n    # Pattern of round starting positions:\n    # Rounds 0,1: start at rows 1,2\n    # Rounds 2,3: start at rows 5,6  \n    # Rounds 4,5: start at rows 9,10\n    # Generally: rounds 2k,2k+1 start at rows 4k+1, 4k+2\n    \n    def get_starting_rows(round_num):\n        k = round_num // 2\n        if round_num % 2 == 0:\n            return 4 * k + 1\n        else:\n            return 4 * k + 2\n    \n    # Find which round serves row n\n    round_num = 0\n    while True:\n        start_row = get_starting_rows(round_num)\n        if round_num % 2 == 0:\n            rows_served = (start_row, start_row + 2)  # (row, row+2)\n        else:\n            rows_served = (start_row, start_row + 2)  # (row, row+2)\n            \n        if n in rows_served:\n            attendant = 1 if n == rows_served[0] else 2\n            break\n        round_num += 1\n    \n    # Calculate time before this round starts\n    # Each round takes 6 seconds to serve (3 seats each attendant)\n    # Movement times: after round 0: 1, after round 1: 3, after round 2: 1, after round 3: 1, ...\n    # Pattern: 1, 3, 1, 1, 3, 1, 1, 3, ... starting from after round 0\n    \n    def get_movement_after_round(r):\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        pos_in_pattern = (r - 1) % 3\n        if pos_in_pattern == 2:  # 0-indexed, so this corresponds to positions 2,5,8,...\n            return 3\n        else:\n            return 1\n    \n    total_time = 0\n    for r in range(round_num):\n        total_time += 6  # serving time\n        total_time += get_movement_after_round(r)  # movement time\n    \n    # Add time within the round until Vasya's seat\n    total_time += seat_time[s]\n    \n    # If Vasya is served by attendant 2, we need to add time for attendant 1 to finish\n    if attendant == 2:\n        total_time += 3\n    \n    print(total_time)\n\nsolve()"], "responses": ["\nimport sys\n\ndef solve():\n    line = input().strip()\n    n = int(line[:-1])\n    s = line[-1]\n    \n    # Serving order per row: f(1), e(2), d(3), a(4), b(5), c(6)\n    seat_time = {'f': 1, 'e': 2, 'd': 3, 'a': 4, 'b': 5, 'c': 6}\n    \n    # Determine which round serves row n\n    # Pattern: rounds serve pairs (1,3), (2,4), (5,7), (6,8), (9,11), (10,12), ...\n    # Group these pairs: [(1,3),(2,4)], [(5,7),(6,8)], [(9,11),(10,12)], ...\n    # So groups of 2 rounds, starting at rows 1, 5, 9, ... (4k+1)\n    \n    # For any row n, find which round serves it\n    # Round numbering starts from 0\n    \n    # Let's think of it this way:\n    # Round 0: rows 1,3\n    # Round 1: rows 2,4  \n    # Round 2: rows 5,7\n    # Round 3: rows 6,8\n    # Round 4: rows 9,11\n    # Round 5: rows 10,12\n    # ...\n    \n    # Pattern of round starting positions:\n    # Rounds 0,1: start at rows 1,2\n    # Rounds 2,3: start at rows 5,6  \n    # Rounds 4,5: start at rows 9,10\n    # Generally: rounds 2k,2k+1 start at rows 4k+1, 4k+2\n    \n    def get_starting_rows(round_num):\n        k = round_num // 2\n        if round_num % 2 == 0:\n            return 4 * k + 1\n        else:\n            return 4 * k + 2\n    \n    # Find which round serves row n\n    round_num = 0\n    while True:\n        start_row = get_starting_rows(round_num)\n        if round_num % 2 == 0:\n            rows_served = (start_row, start_row + 2)  # (row, row+2)\n        else:\n            rows_served = (start_row, start_row + 2)  # (row, row+2)\n            \n        if n in rows_served:\n            attendant = 1 if n == rows_served[0] else 2\n            break\n        round_num += 1\n    \n    # Calculate time before this round starts\n    # Each round takes 6 seconds to serve (3 seats each attendant)\n    # Movement times: after round 0: 1, after round 1: 3, after round 2: 1, after round 3: 1, ...\n    # Pattern: 1, 3, 1, 1, 3, 1, 1, 3, ... starting from after round 0\n    \n    def get_movement_after_round(r):\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        pos_in_pattern = (r - 1) % 3\n        if pos_in_pattern == 2:  # 0-indexed, so this corresponds to positions 2,5,8,...\n            return 3\n        else:\n            return 1\n    \n    total_time = 0\n    for r in range(round_num):\n        total_time += 6  # serving time\n        total_time += get_movement_after_round(r)  # movement time\n    \n    # Add time within the round until Vasya's seat\n    total_time += seat_time[s]\n    \n    # If Vasya is served by attendant 2, we need to add time for attendant 1 to finish\n    if attendant == 2:\n        total_time += 3\n    \n    print(total_time)\n\nsolve()\n\n\n"], "prompt_tokens": [9507], "completion_tokens": [6717], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "069d0cb9b7c798a81007fb5b63fa0f45"}
{"description": "The year 2015 is almost over.Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system\u00a0\u2014 201510\u2009=\u2009111110111112. Note that he doesn't care about the number of zeros in the decimal representation.Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?Assume that all positive integers are always written without leading zeros.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains two integers a and b (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u20091018)\u00a0\u2014 the first year and the last year in Limak's interval respectively.", "output_spec": "Print one integer\u00a0\u2013 the number of years Limak will count in his chosen interval.", "notes": "NoteIn the first sample Limak's interval contains numbers 510\u2009=\u20091012, 610\u2009=\u20091102, 710\u2009=\u20091112, 810\u2009=\u200910002, 910\u2009=\u200910012 and 1010\u2009=\u200910102. Two of them (1012 and 1102) have the described property.", "sample_inputs": ["5 10", "2015 2015", "100 105", "72057594000000000 72057595000000000"], "sample_outputs": ["2", "1", "0", "26"], "tags": ["brute force", "bitmasks", "implementation"], "src_uid": "581f61b1f50313bf4c75833cefd4d022", "difficulty": 1300, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "581f61b1f50313bf4c75833cefd4d022"}
{"description": "Your friend recently gave you some slimes for your birthday. You have n slimes all initially with value 1.You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other n\u2009-\u20091 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value v, you combine them together to create a slime with value v\u2009+\u20091.You would like to see what the final state of the row is after you've added all n slimes. Please print the values of the slimes in the row from left to right.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input will contain a single integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000).", "output_spec": "Output a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.", "notes": "NoteIn the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.In the second sample, we perform the following steps:Initially we place a single slime in a row by itself. Thus, row is initially 1.Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.In the last sample, the steps look as follows:   1  2  2 1  3  3 1  3 2  3 2 1  4 ", "sample_inputs": ["1", "2", "3", "8"], "sample_outputs": ["1", "2", "2 1", "4"], "tags": ["implementation"], "src_uid": "757cd804aba01dc4bc108cb0722f68dc", "difficulty": 800, "source_codes": ["n = int(input())\nslimes = []\n\nfor _ in range(n):\n    slimes.append(1)\n    while len(slimes) >= 2 and slimes[-1] == slimes[-2]:\n        val = slimes.pop()\n        slimes.pop()\n        slimes.append(val + 1)\n\nprint(' '.join(map(str, slimes)))"], "responses": ["\nn = int(input())\nslimes = []\n\nfor _ in range(n):\n    slimes.append(1)\n    while len(slimes) >= 2 and slimes[-1] == slimes[-2]:\n        val = slimes.pop()\n        slimes.pop()\n        slimes.append(val + 1)\n\nprint(' '.join(map(str, slimes)))\n\n\n"], "prompt_tokens": [6039], "completion_tokens": [1274], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "757cd804aba01dc4bc108cb0722f68dc"}
{"description": "You are given an alphabet consisting of n letters, your task is to make a string of the maximum possible length so that the following conditions are satisfied:   the i-th letter occurs in the string no more than ai times;  the number of occurrences of each letter in the string must be distinct for all the letters that occurred in the string at least once. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains a single integer n (2\u2009\u2009\u2264\u2009\u2009n\u2009\u2009\u2264\u2009\u200926)\u00a0\u2014 the number of letters in the alphabet. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109)\u00a0\u2014 i-th of these integers gives the limitation on the number of occurrences of the i-th character in the string.", "output_spec": "Print a single integer \u2014 the maximum length of the string that meets all the requirements.", "notes": "NoteFor convenience let's consider an alphabet consisting of three letters: \"a\", \"b\", \"c\". In the first sample, some of the optimal strings are: \"cccaabbccbb\", \"aabcbcbcbcb\". In the second sample some of the optimal strings are: \"acc\", \"cbc\".", "sample_inputs": ["3\n2 5 5", "3\n1 1 2"], "sample_outputs": ["11", "3"], "tags": ["greedy", "sortings"], "src_uid": "3c4b2d1c9440515bc3002eddd2b89f6f", "difficulty": 1100, "source_codes": ["n = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\ntotal_length = 0\nprev_freq = float('inf')\n\nfor freq_limit in a:\n    # Assign the maximum possible frequency that is less than previous\n    # and within the limit\n    assigned_freq = min(freq_limit, prev_freq - 1)\n    \n    if assigned_freq > 0:\n        total_length += assigned_freq\n        prev_freq = assigned_freq\n    else:\n        # No more valid assignments possible\n        break\n\nprint(total_length)"], "responses": ["\nn = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\ntotal_length = 0\nprev_freq = float('inf')\n\nfor freq_limit in a:\n    # Assign the maximum possible frequency that is less than previous\n    # and within the limit\n    assigned_freq = min(freq_limit, prev_freq - 1)\n    \n    if assigned_freq > 0:\n        total_length += assigned_freq\n        prev_freq = assigned_freq\n    else:\n        # No more valid assignments possible\n        break\n\nprint(total_length)\n\n\n"], "prompt_tokens": [6978], "completion_tokens": [1792], "no_of_try": 1, "api_calls": 9, "is_solved": false, "language": "Python3", "task_id": "3c4b2d1c9440515bc3002eddd2b89f6f"}
{"description": "Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091018)\u00a0\u2014 the number of players to participate in the tournament.", "output_spec": "Print the maximum number of games in which the winner of the tournament can take part.", "notes": "NoteIn all samples we consider that player number 1 is the winner.In the first sample, there would be only one game so the answer is 1.In the second sample, player 1 can consequently beat players 2 and 3. In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1,\u20092) and (3,\u20094) and then clash the winners.", "sample_inputs": ["2", "3", "4", "10"], "sample_outputs": ["1", "2", "2", "4"], "tags": ["greedy", "combinatorics", "constructive algorithms", "dp", "math", "dfs and similar"], "src_uid": "3d3432b4f7c6a3b901161fa24b415b14", "difficulty": 1600, "source_codes": ["def max_games(n):\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    \n    # Generate Fibonacci numbers\n    a, b = 1, 1\n    k = 1\n    while b < n:\n        a, b = b, a + b\n        k += 1\n    \n    if b == n:\n        return k - 1\n    else:\n        return k - 2\n\nn = int(input())\nprint(max_games(n))"], "responses": ["\ndef max_games(n):\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    \n    # Generate Fibonacci numbers\n    a, b = 1, 1\n    k = 1\n    while b < n:\n        a, b = b, a + b\n        k += 1\n    \n    if b == n:\n        return k - 1\n    else:\n        return k - 2\n\nn = int(input())\nprint(max_games(n))\n\n\n"], "prompt_tokens": [5355], "completion_tokens": [1122], "no_of_try": 1, "api_calls": 6, "is_solved": true, "language": "Python3", "task_id": "3d3432b4f7c6a3b901161fa24b415b14"}
{"description": "Calvin the robot lies in an infinite rectangular grid. Calvin's source code contains a list of n commands, each either 'U', 'R', 'D', or 'L'\u00a0\u2014 instructions to move a single square up, right, down, or left, respectively. How many ways can Calvin execute a non-empty contiguous substrings of commands and return to the same square he starts in? Two substrings are considered different if they have different starting or ending indices.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains a single positive integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009200)\u00a0\u2014 the number of commands. The next line contains n characters, each either 'U', 'R', 'D', or 'L'\u00a0\u2014 Calvin's source code.", "output_spec": "Print a single integer\u00a0\u2014 the number of contiguous substrings that Calvin can execute and return to his starting square.", "notes": "NoteIn the first case, the entire source code works, as well as the \"RL\" substring in the second and third characters.Note that, in the third case, the substring \"LR\" appears three times, and is therefore counted three times to the total result.", "sample_inputs": ["6\nURLLDR", "4\nDLUU", "7\nRLRLRLR"], "sample_outputs": ["2", "0", "12"], "tags": ["brute force", "implementation"], "src_uid": "7bd5521531950e2de9a7b0904353184d", "difficulty": 1000, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "7bd5521531950e2de9a7b0904353184d"}
{"description": "Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a,\u2009b)?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains two integers s and x (2\u2009\u2264\u2009s\u2009\u2264\u20091012, 0\u2009\u2264\u2009x\u2009\u2264\u20091012), the sum and bitwise xor of the pair of positive integers, respectively.", "output_spec": "Print a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.", "notes": "NoteIn the first sample, we have the following solutions: (2,\u20097), (3,\u20096), (6,\u20093), (7,\u20092).In the second sample, the only solutions are (1,\u20092) and (2,\u20091).", "sample_inputs": ["9 5", "3 3", "5 2"], "sample_outputs": ["4", "2", "0"], "tags": ["math", "constructive algorithms", "dp", "implementation"], "src_uid": "18410980789b14c128dd6adfa501aea5", "difficulty": 1700, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "18410980789b14c128dd6adfa501aea5"}
{"description": "For his computer science class, Jacob builds a model tree with sticks and balls containing n nodes in the shape of a tree. Jacob has spent ai minutes building the i-th ball in the tree.Jacob's teacher will evaluate his model and grade Jacob based on the effort he has put in. However, she does not have enough time to search his whole tree to determine this; Jacob knows that she will examine the first k nodes in a DFS-order traversal of the tree. She will then assign Jacob a grade equal to the minimum ai she finds among those k nodes.Though Jacob does not have enough time to rebuild his model, he can choose the root node that his teacher starts from. Furthermore, he can rearrange the list of neighbors of each node in any order he likes. Help Jacob find the best grade he can get on this assignment.A DFS-order traversal is an ordering of the nodes of a rooted tree, built by a recursive DFS-procedure initially called on the root of the tree. When called on a given node v, the procedure does the following:   Print v.  Traverse the list of neighbors of the node v in order and iteratively call DFS-procedure on each one. Do not call DFS-procedure on node u if you came to node v directly from u. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "7 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains two positive integers, n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000, 1\u2009\u2264\u2009k\u2009\u2264\u2009n)\u00a0\u2014 the number of balls in Jacob's tree and the number of balls the teacher will inspect. The second line contains n integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091\u2009000\u2009000), the time Jacob used to build the i-th ball. Each of the next n\u2009-\u20091 lines contains two integers ui, vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n, ui\u2009\u2260\u2009vi) representing a connection in Jacob's tree between balls ui and vi.", "output_spec": "Print a single integer\u00a0\u2014 the maximum grade Jacob can get by picking the right root of the tree and rearranging the list of neighbors.", "notes": "NoteIn the first sample, Jacob can root the tree at node 2 and order 2's neighbors in the order 4, 1, 5 (all other nodes have at most two neighbors). The resulting preorder traversal is 2, 4, 1, 3, 5, and the minimum ai of the first 3 nodes is 3.In the second sample, it is clear that any preorder traversal will contain node 1 as either its first or second node, so Jacob cannot do better than a grade of 1.", "sample_inputs": ["5 3\n3 6 1 4 2\n1 2\n2 4\n2 5\n1 3", "4 2\n1 5 5 5\n1 2\n1 3\n1 4"], "sample_outputs": ["3", "1"], "tags": ["dfs and similar", "graphs", "greedy", "binary search"], "src_uid": "4fb83b890e472f86045981e1743ddaac", "difficulty": 2600, "source_codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    import threading\n    \n    def solve():\n        n, k = map(int, sys.stdin.readline().split())\n        a = [0] + list(map(int, sys.stdin.readline().split()))\n        \n        adj = [[] for _ in range(n+1)]\n        for _ in range(n-1):\n            u, v = map(int, sys.stdin.readline().split())\n            adj[u].append(v)\n            adj[v].append(u)\n            \n        max_grade = 0\n        \n        # Try each node as root\n        for root in range(1, n+1):\n            # For each node, we want to order neighbors optimally\n            # The strategy is to prioritize subtrees with higher values\n            \n            def dfs_collect(start_node, max_visits):\n                visited = [False] * (n + 1)\n                result = []\n                \n                def dfs(u):\n                    if len(result) >= max_visits:\n                        return\n                    visited[u] = True\n                    result.append(a[u])\n                    \n                    # Collect unvisited neighbors and their max potential values\n                    neighbors_info = []\n                    for v in adj[u]:\n                        if not visited[v]:\n                            # Estimate the best we can get from this subtree\n                            # Simple heuristic: use the node value itself\n                            neighbors_info.append((a[v], v))\n                    \n                    # Sort by descending order of values (greedy)\n                    neighbors_info.sort(reverse=True)\n                    \n                    for _, v in neighbors_info:\n                        if len(result) < max_visits:\n                            dfs(v)\n                \n                dfs(start_node)\n                return result\n            \n            traversal = dfs_collect(root, k)\n            if len(traversal) >= k:\n                current_min = min(traversal[:k])\n                max_grade = max(max_grade, current_min)\n                \n        print(max_grade)\n    \n    threading.Thread(target=solve).start()\n\ndef main_improved():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    \n    n, k = map(int, sys.stdin.readline().split())\n    a = [0] + list(map(int, sys.stdin.readline().split()))\n    \n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        \n    max_grade = 0\n    \n    # Precompute subtree information\n    def preprocess_subtree(root):\n        # BFS to get subtree sizes and structure info\n        subtree_max = [0] * (n + 1)\n        \n        def dfs(u, parent):\n            subtree_max[u] = a[u]\n            for v in adj[u]:\n                if v != parent:\n                    dfs(v, u)\n                    subtree_max[u] = max(subtree_max[u], subtree_max[v])\n        \n        dfs(root, -1)\n        return subtree_max\n    \n    # Try each node as root\n    for root in range(1, n+1):\n        subtree_max = preprocess_subtree(root)\n        \n        def dfs_with_ordering(start_node, max_visits):\n            visited = [False] * (n + 1)\n            result = []\n            \n            def dfs(u):\n                if len(result) >= max_visits:\n                    return\n                visited[u] = True\n                result.append(a[u])\n                \n                # Collect unvisited neighbors\n                unvisited_neighbors = []\n                for v in adj[u]:\n                    if not visited[v]:\n                        unvisited_neighbors.append(v)\n                \n                # Sort neighbors by the maximum value achievable in their subtree\n                unvisited_neighbors.sort(key=lambda x: -subtree_max[x])\n                \n                for v in unvisited_neighbors:\n                    if len(result) < max_visits:\n                        dfs(v)\n            \n            dfs(start_node)\n            return result\n        \n        traversal = dfs_with_ordering(root, k)\n        if len(traversal) >= k:\n            current_min = min(traversal[:k])\n            max_grade = max(max_grade, current_min)\n            \n    print(max_grade)\n\nif __name__ == \"__main__\":\n    main_improved()"], "responses": ["\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    import threading\n    \n    def solve():\n        n, k = map(int, sys.stdin.readline().split())\n        a = [0] + list(map(int, sys.stdin.readline().split()))\n        \n        adj = [[] for _ in range(n+1)]\n        for _ in range(n-1):\n            u, v = map(int, sys.stdin.readline().split())\n            adj[u].append(v)\n            adj[v].append(u)\n            \n        max_grade = 0\n        \n        # Try each node as root\n        for root in range(1, n+1):\n            # For each node, we want to order neighbors optimally\n            # The strategy is to prioritize subtrees with higher values\n            \n            def dfs_collect(start_node, max_visits):\n                visited = [False] * (n + 1)\n                result = []\n                \n                def dfs(u):\n                    if len(result) >= max_visits:\n                        return\n                    visited[u] = True\n                    result.append(a[u])\n                    \n                    # Collect unvisited neighbors and their max potential values\n                    neighbors_info = []\n                    for v in adj[u]:\n                        if not visited[v]:\n                            # Estimate the best we can get from this subtree\n                            # Simple heuristic: use the node value itself\n                            neighbors_info.append((a[v], v))\n                    \n                    # Sort by descending order of values (greedy)\n                    neighbors_info.sort(reverse=True)\n                    \n                    for _, v in neighbors_info:\n                        if len(result) < max_visits:\n                            dfs(v)\n                \n                dfs(start_node)\n                return result\n            \n            traversal = dfs_collect(root, k)\n            if len(traversal) >= k:\n                current_min = min(traversal[:k])\n                max_grade = max(max_grade, current_min)\n                \n        print(max_grade)\n    \n    threading.Thread(target=solve).start()\n\ndef main_improved():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    \n    n, k = map(int, sys.stdin.readline().split())\n    a = [0] + list(map(int, sys.stdin.readline().split()))\n    \n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        \n    max_grade = 0\n    \n    # Precompute subtree information\n    def preprocess_subtree(root):\n        # BFS to get subtree sizes and structure info\n        subtree_max = [0] * (n + 1)\n        \n        def dfs(u, parent):\n            subtree_max[u] = a[u]\n            for v in adj[u]:\n                if v != parent:\n                    dfs(v, u)\n                    subtree_max[u] = max(subtree_max[u], subtree_max[v])\n        \n        dfs(root, -1)\n        return subtree_max\n    \n    # Try each node as root\n    for root in range(1, n+1):\n        subtree_max = preprocess_subtree(root)\n        \n        def dfs_with_ordering(start_node, max_visits):\n            visited = [False] * (n + 1)\n            result = []\n            \n            def dfs(u):\n                if len(result) >= max_visits:\n                    return\n                visited[u] = True\n                result.append(a[u])\n                \n                # Collect unvisited neighbors\n                unvisited_neighbors = []\n                for v in adj[u]:\n                    if not visited[v]:\n                        unvisited_neighbors.append(v)\n                \n                # Sort neighbors by the maximum value achievable in their subtree\n                unvisited_neighbors.sort(key=lambda x: -subtree_max[x])\n                \n                for v in unvisited_neighbors:\n                    if len(result) < max_visits:\n                        dfs(v)\n            \n            dfs(start_node)\n            return result\n        \n        traversal = dfs_with_ordering(root, k)\n        if len(traversal) >= k:\n            current_min = min(traversal[:k])\n            max_grade = max(max_grade, current_min)\n            \n    print(max_grade)\n\nif __name__ == \"__main__\":\n    main_improved()\n\n\n"], "prompt_tokens": [14801], "completion_tokens": [5396], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "4fb83b890e472f86045981e1743ddaac"}
{"description": "The numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.Lucky number is a number that consists of digits 7 and 8 only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than n digits.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u200955) \u2014 the maximum length of a number that a door-plate can hold.", "output_spec": "Output one integer \u2014 the maximum number of offices, than can have unique lucky numbers not longer than n digits.", "notes": null, "sample_inputs": ["2"], "sample_outputs": ["6"], "tags": ["combinatorics", "math"], "src_uid": "f1b43baa14d4c262ba616d892525dfde", "difficulty": 1100, "source_codes": ["n = int(input())\nresult = (2 ** (n + 1)) - 2\nprint(result)"], "responses": ["\nn = int(input())\nresult = (2 ** (n + 1)) - 2\nprint(result)\n\n\n"], "prompt_tokens": [4045], "completion_tokens": [936], "no_of_try": 1, "api_calls": 7, "is_solved": true, "language": "Python3", "task_id": "f1b43baa14d4c262ba616d892525dfde"}
{"description": "Vasya started working in a machine vision company of IT City. Vasya's team creates software and hardware for identification of people by their face.One of the project's know-how is a camera rotating around its optical axis on shooting. People see an eye-catching gadget \u2014 a rotating camera \u2014 come up to it to see it better, look into it. And the camera takes their photo at that time. What could be better for high quality identification?But not everything is so simple. The pictures from camera appear rotated too (on clockwise camera rotation frame the content becomes rotated counter-clockwise). But the identification algorithm can work only with faces that are just slightly deviated from vertical.Vasya was entrusted to correct the situation \u2014 to rotate a captured image so that image would be minimally deviated from vertical. Requirements were severe. Firstly, the picture should be rotated only on angle divisible by 90 degrees to not lose a bit of information about the image. Secondly, the frames from the camera are so huge and FPS is so big that adequate rotation speed is provided by hardware FPGA solution only. And this solution can rotate only by 90 degrees clockwise. Of course, one can apply 90 degrees turn several times but for the sake of performance the number of turns should be minimized.Help Vasya implement the program that by the given rotation angle of the camera can determine the minimum number of 90 degrees clockwise turns necessary to get a picture in which up direction deviation from vertical is minimum.The next figure contains frames taken from an unrotated camera, then from rotated 90 degrees clockwise, then from rotated 90 degrees counter-clockwise. Arrows show direction to \"true up\".  The next figure shows 90 degrees clockwise turn by FPGA hardware.  ", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of the input contains one integer x (\u2009-\u20091018\u2009\u2264\u2009x\u2009\u2264\u20091018) \u2014 camera angle in degrees. Positive value denotes clockwise camera rotation, negative \u2014 counter-clockwise.", "output_spec": "Output one integer \u2014 the minimum required number of 90 degrees clockwise turns.", "notes": "NoteWhen the camera is rotated 60 degrees counter-clockwise (the second example), an image from it is rotated 60 degrees clockwise. One 90 degrees clockwise turn of the image result in 150 degrees clockwise total rotation and deviation from \"true up\" for one turn is 150 degrees. Two 90 degrees clockwise turns of the image result in 240 degrees clockwise total rotation and deviation from \"true up\" for two turns is 120 degrees because 240 degrees clockwise equal to 120 degrees counter-clockwise. Three 90 degrees clockwise turns of the image result in 330 degrees clockwise total rotation and deviation from \"true up\" for three turns is 30 degrees because 330 degrees clockwise equal to 30 degrees counter-clockwise.From 60, 150, 120 and 30 degrees deviations the smallest is 30, and it it achieved in three 90 degrees clockwise turns.", "sample_inputs": ["60", "-60"], "sample_outputs": ["1", "3"], "tags": ["geometry", "math"], "src_uid": "509db9cb6156b692557ba874a09f150e", "difficulty": 1800, "source_codes": ["x = int(input())\n\n# Normalize the image rotation to [0, 360)\n# If camera rotates x degrees clockwise, image appears rotated -x degrees\nimage_rotation = (-x) % 360\n\n# Try all possible numbers of 90-degree clockwise turns (0 to 3)\nmin_deviation = float('inf')\nbest_turns = 0\n\nfor turns in range(4):\n    # Each 90-degree clockwise turn adds 90 degrees to the image rotation\n    final_rotation = (image_rotation + 90 * turns) % 360\n    \n    # Calculate deviation from vertical (0 degrees)\n    # Deviation is the minimum between clockwise and counter-clockwise distance\n    deviation = min(final_rotation, 360 - final_rotation)\n    \n    if deviation < min_deviation:\n        min_deviation = deviation\n        best_turns = turns\n\nprint(best_turns)"], "responses": ["\nx = int(input())\n\n# Normalize the image rotation to [0, 360)\n# If camera rotates x degrees clockwise, image appears rotated -x degrees\nimage_rotation = (-x) % 360\n\n# Try all possible numbers of 90-degree clockwise turns (0 to 3)\nmin_deviation = float('inf')\nbest_turns = 0\n\nfor turns in range(4):\n    # Each 90-degree clockwise turn adds 90 degrees to the image rotation\n    final_rotation = (image_rotation + 90 * turns) % 360\n    \n    # Calculate deviation from vertical (0 degrees)\n    # Deviation is the minimum between clockwise and counter-clockwise distance\n    deviation = min(final_rotation, 360 - final_rotation)\n    \n    if deviation < min_deviation:\n        min_deviation = deviation\n        best_turns = turns\n\nprint(best_turns)\n\n\n"], "prompt_tokens": [11785], "completion_tokens": [4321], "no_of_try": 1, "api_calls": 10, "is_solved": true, "language": "Python3", "task_id": "509db9cb6156b692557ba874a09f150e"}
{"description": "There are n people, sitting in a line at the table. For each person we know that he always tells either the truth or lies.Little Serge asked them: how many of you always tell the truth? Each of the people at the table knows everything (who is an honest person and who is a liar) about all the people at the table. The honest people are going to say the correct answer, the liars are going to say any integer from 1 to n, which is not the correct answer. Every liar chooses his answer, regardless of the other liars, so two distinct liars may give distinct answer.Serge does not know any information about the people besides their answers to his question. He took a piece of paper and wrote n integers a1,\u2009a2,\u2009...,\u2009an, where ai is the answer of the i-th person in the row. Given this sequence, Serge determined that exactly k people sitting at the table apparently lie.Serge wonders, how many variants of people's answers (sequences of answers a of length n) there are where one can say that exactly k people sitting at the table apparently lie. As there can be rather many described variants of answers, count the remainder of dividing the number of the variants by 777777777.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n, k, (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200928). It is guaranteed that n \u2014 is the power of number 2.", "output_spec": "Print a single integer \u2014 the answer to the problem modulo 777777777.", "notes": null, "sample_inputs": ["1 1", "2 1"], "sample_outputs": ["0", "2"], "tags": ["dp"], "src_uid": "cfe19131644e5925e32084a581e23286", "difficulty": 2700, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "cfe19131644e5925e32084a581e23286"}
{"description": "There have recently been elections in the zoo. Overall there were 7 main political parties: one of them is the Little Elephant Political Party, 6 other parties have less catchy names.Political parties find their number in the ballot highly important. Overall there are m possible numbers: 1,\u20092,\u2009...,\u2009m. Each of these 7 parties is going to be assigned in some way to exactly one number, at that, two distinct parties cannot receive the same number.The Little Elephant Political Party members believe in the lucky digits 4 and 7. They want to evaluate their chances in the elections. For that, they need to find out, how many correct assignments are there, such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties. Help the Little Elephant Political Party, calculate this number. As the answer can be rather large, print the remainder from dividing it by 1000000007 (109\u2009+\u20097).", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "A single line contains a single positive integer m (7\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 the number of possible numbers in the ballot.", "output_spec": "In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["7", "8"], "sample_outputs": ["0", "1440"], "tags": ["brute force", "math", "combinatorics", "dp"], "src_uid": "656ed7b1b80de84d65a253e5d14d62a9", "difficulty": 1900, "source_codes": [""], "responses": [""], "prompt_tokens": [2704], "completion_tokens": [1384], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "656ed7b1b80de84d65a253e5d14d62a9"}
{"description": "Dima and Anya love playing different games. Now Dima has imagined a new game that he wants to play with Anya.Dima writes n pairs of integers on a piece of paper (li,\u2009ri) (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009p). Then players take turns. On his turn the player can do the following actions:  choose the number of the pair i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), such that ri\u2009-\u2009li\u2009&gt;\u20092;  replace pair number i by pair  or by pair . Notation \u230ax\u230b means rounding down to the closest integer. The player who can't make a move loses.Of course, Dima wants Anya, who will move first, to win. That's why Dima should write out such n pairs of integers (li,\u2009ri) (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009p), that if both players play optimally well, the first one wins. Count the number of ways in which Dima can do it. Print the remainder after dividing the answer by number 1000000007\u00a0(109\u2009+\u20097).Two ways are considered distinct, if the ordered sequences of the written pairs are distinct.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n, p (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009p\u2009\u2264\u2009109). The numbers are separated by a single space.", "output_spec": "In a single line print the remainder after dividing the answer to the problem by number 1000000007\u00a0(109\u2009+\u20097).", "notes": null, "sample_inputs": ["2 2", "4 4", "100 1000"], "sample_outputs": ["0", "520", "269568947"], "tags": ["games", "dp"], "src_uid": "c03b6379e9d186874ac3d97c6968fbd0", "difficulty": 2600, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "c03b6379e9d186874ac3d97c6968fbd0"}
{"description": "Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.  The figure shows a 4-output splitter Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.4 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091018, 2\u2009\u2264\u2009k\u2009\u2264\u2009109). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.", "output_spec": "Print a single integer \u2014 the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.", "notes": null, "sample_inputs": ["4 3", "5 5", "8 4"], "sample_outputs": ["2", "1", "-1"], "tags": ["math", "binary search"], "src_uid": "83bcfe32db302fbae18e8a95d89cf411", "difficulty": 1700, "source_codes": ["def min_splitters(n, k):\n    if n == 1:\n        return 0\n    \n    max_pipes = 1 + k * (k - 1) // 2\n    if n > max_pipes:\n        return -1\n    \n    remaining = n - 1\n    splitters_used = 0\n    current_k = k\n    \n    while remaining > 0:\n        if current_k - 1 <= remaining:\n            remaining -= (current_k - 1)\n            splitters_used += 1\n        current_k -= 1\n        \n        if current_k < 2:\n            if remaining > 0:\n                return -1\n            break\n    \n    return splitters_used\n\nn, k = map(int, input().split())\nprint(min_splitters(n, k))"], "responses": ["\ndef min_splitters(n, k):\n    if n == 1:\n        return 0\n    \n    max_pipes = 1 + k * (k - 1) // 2\n    if n > max_pipes:\n        return -1\n    \n    remaining = n - 1\n    splitters_used = 0\n    current_k = k\n    \n    while remaining > 0:\n        if current_k - 1 <= remaining:\n            remaining -= (current_k - 1)\n            splitters_used += 1\n        current_k -= 1\n        \n        if current_k < 2:\n            if remaining > 0:\n                return -1\n            break\n    \n    return splitters_used\n\nn, k = map(int, input().split())\nprint(min_splitters(n, k))\n\n\n"], "prompt_tokens": [6062], "completion_tokens": [2138], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "83bcfe32db302fbae18e8a95d89cf411"}
{"description": "Special Agent Smart Beaver works in a secret research department of ABBYY. He's been working there for a long time and is satisfied with his job, as it allows him to eat out in the best restaurants and order the most expensive and exotic wood types there. The content special agent has got an important task: to get the latest research by British scientists on the English Language. These developments are encoded and stored in a large safe. The Beaver's teeth are strong enough, so the authorities assured that upon arriving at the place the beaver won't have any problems with opening the safe.And he finishes his aspen sprig and leaves for this important task. Of course, the Beaver arrived at the location without any problems, but alas. He can't open the safe with his strong and big teeth. At this point, the Smart Beaver get a call from the headquarters and learns that opening the safe with the teeth is not necessary, as a reliable source has sent the following information: the safe code consists of digits and has no leading zeroes. There also is a special hint, which can be used to open the safe. The hint is string s with the following structure:  if si = \"?\", then the digit that goes i-th in the safe code can be anything (between 0 to 9, inclusively);  if si is a digit (between 0 to 9, inclusively), then it means that there is digit si on position i in code;  if the string contains letters from \"A\" to \"J\", then all positions with the same letters must contain the same digits and the positions with distinct letters must contain distinct digits.  The length of the safe code coincides with the length of the hint. For example, hint \"?JGJ9\" has such matching safe code variants: \"51919\", \"55959\", \"12329\", \"93539\" and so on, and has wrong variants such as: \"56669\", \"00111\", \"03539\" and \"13666\".After receiving such information, the authorities change the plan and ask the special agents to work quietly and gently and not to try to open the safe by mechanical means, and try to find the password using the given hint.At a special agent school the Smart Beaver was the fastest in his platoon finding codes for such safes, but now he is not in that shape: the years take their toll ... Help him to determine the number of possible variants of the code to the safe, matching the given hint. After receiving this information, and knowing his own speed of entering codes, the Smart Beaver will be able to determine whether he will have time for tonight's show \"Beavers are on the trail\" on his favorite TV channel, or he should work for a sleepless night...", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains string s \u2014 the hint to the safe code. String s consists of the following characters: ?, 0-9, A-J. It is guaranteed that the first character of string s doesn't equal to character 0. The input limits for scoring 30 points are (subproblem A1):    1\u2009\u2264\u2009|s|\u2009\u2264\u20095.  The input limits for scoring 100 points are (subproblems A1+A2):    1\u2009\u2264\u2009|s|\u2009\u2264\u2009105.  Here |s| means the length of string s.", "output_spec": "Print the number of codes that match the given hint.", "notes": null, "sample_inputs": ["AJ", "1?AA"], "sample_outputs": ["81", "100"], "tags": ["greedy"], "src_uid": "d3c10d1b1a17ad018359e2dab80d2b82", "difficulty": 1100, "source_codes": ["def count_safe_codes(s):\n    # Mapping for letters to digits\n    letter_to_digit = {}\n    # Set of used digits\n    used_digits = set()\n    # Total combinations\n    total = 1\n    \n    # Available digits for new assignments (0-9)\n    available_digits = 10\n    \n    # Process the first character specially to avoid leading zero\n    first_char = s[0]\n    if first_char == '?':\n        # Cannot be '0'\n        total *= 9\n        available_digits -= 1\n    elif first_char.isdigit():\n        # Fixed digit\n        pass\n    else:\n        # First letter, cannot be '0'\n        letter_to_digit[first_char] = True\n        used_digits.add(0)  # Reserve '0' to prevent others from using it\n        total *= 9\n        available_digits -= 1\n    \n    # Process remaining characters\n    for i in range(1, len(s)):\n        char = s[i]\n        if char == '?':\n            total *= (10 - len(used_digits))\n        elif char.isdigit():\n            continue\n        else:\n            if char in letter_to_digit:\n                # Already assigned\n                continue\n            else:\n                # New letter\n                letter_to_digit[char] = True\n                total *= (10 - len(used_digits))\n                used_digits.add(-1)  # Placeholder to reduce available count\n                \n    return str(total)\n\n# Read input and solve\ns = input().strip()\nprint(count_safe_codes(s))"], "responses": ["\ndef count_safe_codes(s):\n    # Mapping for letters to digits\n    letter_to_digit = {}\n    # Set of used digits\n    used_digits = set()\n    # Total combinations\n    total = 1\n    \n    # Available digits for new assignments (0-9)\n    available_digits = 10\n    \n    # Process the first character specially to avoid leading zero\n    first_char = s[0]\n    if first_char == '?':\n        # Cannot be '0'\n        total *= 9\n        available_digits -= 1\n    elif first_char.isdigit():\n        # Fixed digit\n        pass\n    else:\n        # First letter, cannot be '0'\n        letter_to_digit[first_char] = True\n        used_digits.add(0)  # Reserve '0' to prevent others from using it\n        total *= 9\n        available_digits -= 1\n    \n    # Process remaining characters\n    for i in range(1, len(s)):\n        char = s[i]\n        if char == '?':\n            total *= (10 - len(used_digits))\n        elif char.isdigit():\n            continue\n        else:\n            if char in letter_to_digit:\n                # Already assigned\n                continue\n            else:\n                # New letter\n                letter_to_digit[char] = True\n                total *= (10 - len(used_digits))\n                used_digits.add(-1)  # Placeholder to reduce available count\n                \n    return str(total)\n\n# Read input and solve\ns = input().strip()\nprint(count_safe_codes(s))\n\n\n"], "prompt_tokens": [8084], "completion_tokens": [3693], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "d3c10d1b1a17ad018359e2dab80d2b82"}
{"description": "Smart Beaver is careful about his appearance and pays special attention to shoes so he has a huge number of pairs of shoes from the most famous brands of the forest. He's trying to handle his shoes carefully so that each pair stood side by side. But by the end of the week because of his very active lifestyle in his dressing room becomes a mess.Smart Beaver from ABBYY is not only the brightest beaver in the area, but he also is the most domestically oriented. For example, on Mondays the Smart Beaver cleans everything in his home.It's Monday morning. Smart Beaver does not want to spend the whole day cleaning, besides, there is much in to do and it\u2019s the gym day, so he wants to clean up as soon as possible. Now the floors are washed, the dust is wiped off \u2014 it\u2019s time to clean up in the dressing room. But as soon as the Smart Beaver entered the dressing room, all plans for the day were suddenly destroyed: chaos reigned there and it seemed impossible to handle, even in a week. Give our hero some hope: tell him what is the minimum number of shoes need to change the position to make the dressing room neat.The dressing room is rectangular and is divided into n\u2009\u00d7\u2009m equal squares, each square contains exactly one shoe. Each pair of shoes has a unique number that is integer from 1 to , more formally, a square with coordinates (i,\u2009j) contains an integer number of the pair which is lying on it. The Smart Beaver believes that the dressing room is neat only when each pair of sneakers lies together. We assume that the pair of sneakers in squares (i1,\u2009j1) and (i2,\u2009j2) lies together if |i1\u2009-\u2009i2|\u2009+\u2009|j1\u2009-\u2009j2|\u2009=\u20091.", "input_from": "standard input", "output_to": "standard output", "time_limit": "4 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and m. They correspond to the dressing room size. Next n lines contain m space-separated integers each. Those numbers describe the dressing room. Each number corresponds to a snicker.  It is guaranteed that:    n\u00b7m is even.  All numbers, corresponding to the numbers of pairs of shoes in the dressing room, will lie between 1 and .  Each number from 1 to  will occur exactly twice.  The input limits for scoring 30 points are (subproblem C1):    2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20098.  The input limits for scoring 100 points are (subproblems C1+C2):    2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200980. ", "output_spec": "Print exactly one integer \u2014 the minimum number of the sneakers that need to change their location.", "notes": "Note   The second sample.  ", "sample_inputs": ["2 3\n1 1 2\n2 3 3", "3 4\n1 3 2 6\n2 1 5 6\n4 4 5 3"], "sample_outputs": ["2", "4"], "tags": ["flows"], "src_uid": "1f0e8bbd5bf4fcdea927fbb505a8949b", "difficulty": 2200, "source_codes": ["def min_shoe_moves():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    grid = []\n    index = 2\n    for i in range(n):\n        row = list(map(int, data[index:index+m]))\n        grid.append(row)\n        index += m\n    \n    # Find positions of each pair\n    pos = {}\n    for i in range(n):\n        for j in range(m):\n            num = grid[i][j]\n            if num not in pos:\n                pos[num] = []\n            pos[num].append((i, j))\n    \n    # Find non-adjacent pairs\n    non_adjacent = []\n    for num in pos:\n        p1, p2 = pos[num]\n        # Check if adjacent (Manhattan distance = 1)\n        if abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) != 1:\n            non_adjacent.append((p1, p2))\n    \n    # For each non-adjacent pair, we need to move at least one shoe\n    # The minimum is the size of minimum vertex cover\n    # In this case, it's simply the number of non-adjacent pairs * 1 \n    # (we need to move at least one shoe from each non-adjacent pair)\n    \n    # Actually, let's think differently:\n    # Each non-adjacent pair needs exactly 1 move (move one shoe to be adjacent to the other)\n    # But we need to be more careful about overlapping moves\n    \n    # Simpler approach: count how many pairs are not adjacent\n    # For each such pair, we need to move one shoe\n    print(len(non_adjacent))\n\nmin_shoe_moves()"], "responses": ["\ndef min_shoe_moves():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    grid = []\n    index = 2\n    for i in range(n):\n        row = list(map(int, data[index:index+m]))\n        grid.append(row)\n        index += m\n    \n    # Find positions of each pair\n    pos = {}\n    for i in range(n):\n        for j in range(m):\n            num = grid[i][j]\n            if num not in pos:\n                pos[num] = []\n            pos[num].append((i, j))\n    \n    # Find non-adjacent pairs\n    non_adjacent = []\n    for num in pos:\n        p1, p2 = pos[num]\n        # Check if adjacent (Manhattan distance = 1)\n        if abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) != 1:\n            non_adjacent.append((p1, p2))\n    \n    # For each non-adjacent pair, we need to move at least one shoe\n    # The minimum is the size of minimum vertex cover\n    # In this case, it's simply the number of non-adjacent pairs * 1 \n    # (we need to move at least one shoe from each non-adjacent pair)\n    \n    # Actually, let's think differently:\n    # Each non-adjacent pair needs exactly 1 move (move one shoe to be adjacent to the other)\n    # But we need to be more careful about overlapping moves\n    \n    # Simpler approach: count how many pairs are not adjacent\n    # For each such pair, we need to move one shoe\n    print(len(non_adjacent))\n\nmin_shoe_moves()\n\n\n"], "prompt_tokens": [9564], "completion_tokens": [5486], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "1f0e8bbd5bf4fcdea927fbb505a8949b"}
{"description": "Iahub got bored, so he invented a game to be played on paper. He writes n integers a1,\u2009a2,\u2009...,\u2009an. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices i and j (1\u2009\u2264\u2009i\u2009\u2264\u2009j\u2009\u2264\u2009n) and flips all values ak for which their positions are in range [i,\u2009j] (that is i\u2009\u2264\u2009k\u2009\u2264\u2009j). Flip the value of x means to apply operation x\u2009=\u20091 - x.The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). In the second line of the input there are n integers: a1,\u2009a2,\u2009...,\u2009an. It is guaranteed that each of those n values is either 0 or 1.", "output_spec": "Print an integer \u2014 the maximal number of 1s that can be obtained after exactly one move. ", "notes": "NoteIn the first case, flip the segment from 2 to 5 (i\u2009=\u20092,\u2009j\u2009=\u20095). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].In the second case, flipping only the second and the third element (i\u2009=\u20092,\u2009j\u2009=\u20093) will turn all numbers into 1.", "sample_inputs": ["5\n1 0 0 1 0", "4\n1 0 0 1"], "sample_outputs": ["4", "4"], "tags": ["brute force", "dp", "implementation"], "src_uid": "9b543e07e805fe1dd8fa869d5d7c8b99", "difficulty": 1200, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "9b543e07e805fe1dd8fa869d5d7c8b99"}
{"description": "Gerald is very particular to eight point sets. He thinks that any decent eight point set must consist of all pairwise intersections of three distinct integer vertical straight lines and three distinct integer horizontal straight lines, except for the average of these nine points. In other words, there must be three integers x1,\u2009x2,\u2009x3 and three more integers y1,\u2009y2,\u2009y3, such that x1\u2009&lt;\u2009x2\u2009&lt;\u2009x3, y1\u2009&lt;\u2009y2\u2009&lt;\u2009y3 and the eight point set consists of all points (xi,\u2009yj) (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u20093), except for point (x2,\u2009y2).You have a set of eight points. Find out if Gerald can use this set?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input consists of eight lines, the i-th line contains two space-separated integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106). You do not have any other conditions for these points.", "output_spec": "In a single line print word \"respectable\", if the given set of points corresponds to Gerald's decency rules, and \"ugly\" otherwise.", "notes": null, "sample_inputs": ["0 0\n0 1\n0 2\n1 0\n1 2\n2 0\n2 1\n2 2", "0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0", "1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2"], "sample_outputs": ["respectable", "ugly", "ugly"], "tags": ["sortings"], "src_uid": "f3c96123334534056f26b96f90886807", "difficulty": 1400, "source_codes": ["points = []\nfor _ in range(8):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Check if all points are unique\npoint_set = set(points)\nif len(point_set) != 8:\n    print(\"ugly\")\n    exit()\n\n# Extract unique coordinates\nx_coords = sorted(list(set(p[0] for p in points)))\ny_coords = sorted(list(set(p[1] for p in points)))\n\n# Check if we have exactly 3 of each coordinate type\nif len(x_coords) != 3 or len(y_coords) != 3:\n    print(\"ugly\")\n    exit()\n\n# Create expected set of points (3x3 grid)\nexpected_points = set()\nfor x in x_coords:\n    for y in y_coords:\n        expected_points.add((x, y))\n\n# Check if exactly one point is missing\nif len(expected_points) - len(point_set) != 1:\n    print(\"ugly\")\n    exit()\n\n# Find the missing point\nmissing_point = expected_points - point_set\n\n# The missing point should be the center point\ncenter_point = (x_coords[1], y_coords[1])\n\nif missing_point == {center_point}:\n    print(\"respectable\")\nelse:\n    print(\"ugly\")"], "responses": ["\npoints = []\nfor _ in range(8):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Check if all points are unique\npoint_set = set(points)\nif len(point_set) != 8:\n    print(\"ugly\")\n    exit()\n\n# Extract unique coordinates\nx_coords = sorted(list(set(p[0] for p in points)))\ny_coords = sorted(list(set(p[1] for p in points)))\n\n# Check if we have exactly 3 of each coordinate type\nif len(x_coords) != 3 or len(y_coords) != 3:\n    print(\"ugly\")\n    exit()\n\n# Create expected set of points (3x3 grid)\nexpected_points = set()\nfor x in x_coords:\n    for y in y_coords:\n        expected_points.add((x, y))\n\n# Check if exactly one point is missing\nif len(expected_points) - len(point_set) != 1:\n    print(\"ugly\")\n    exit()\n\n# Find the missing point\nmissing_point = expected_points - point_set\n\n# The missing point should be the center point\ncenter_point = (x_coords[1], y_coords[1])\n\nif missing_point == {center_point}:\n    print(\"respectable\")\nelse:\n    print(\"ugly\")\n\n\n"], "prompt_tokens": [9065], "completion_tokens": [3219], "no_of_try": 1, "api_calls": 9, "is_solved": false, "language": "Python3", "task_id": "f3c96123334534056f26b96f90886807"}
{"description": "Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. Iahub has the following scheme of painting: he skips x\u2009-\u20091 consecutive bricks, then he paints the x-th one. That is, he'll paint bricks x, 2\u00b7x, 3\u00b7x and so on red. Similarly, Floyd skips y\u2009-\u20091 consecutive bricks, then he paints the y-th one. Hence he'll paint bricks y, 2\u00b7y, 3\u00b7y and so on pink.After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number a and Floyd has a lucky number b. Boys wonder how many bricks numbered no less than a and no greater than b are painted both red and pink. This is exactly your task: compute and print the answer to the question. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input will have a single line containing four integers in this order: x, y, a, b. (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20091000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u20092\u00b7109, a\u2009\u2264\u2009b).", "output_spec": "Output a single integer \u2014 the number of bricks numbered no less than a and no greater than b that are painted both red and pink.", "notes": "NoteLet's look at the bricks from a to b (a\u2009=\u20096,\u2009b\u2009=\u200918). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18. ", "sample_inputs": ["2 3 6 18"], "sample_outputs": ["3"], "tags": ["math"], "src_uid": "c7aa8a95d5f8832015853cffa1374c48", "difficulty": 1200, "source_codes": ["import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\ndef count_bricks(x, y, a, b):\n    l = lcm(x, y)\n    return b // l - (a - 1) // l\n\nline = input().strip()\nx, y, a, b = map(int, line.split())\n\nresult = count_bricks(x, y, a, b)\nprint(result)"], "responses": ["\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\ndef count_bricks(x, y, a, b):\n    l = lcm(x, y)\n    return b // l - (a - 1) // l\n\nline = input().strip()\nx, y, a, b = map(int, line.split())\n\nresult = count_bricks(x, y, a, b)\nprint(result)\n\n\n"], "prompt_tokens": [6219], "completion_tokens": [1429], "no_of_try": 1, "api_calls": 6, "is_solved": true, "language": "Python3", "task_id": "c7aa8a95d5f8832015853cffa1374c48"}
{"description": "Mad scientist Mike is busy carrying out experiments in chemistry. Today he will attempt to join three atoms into one molecule.A molecule consists of atoms, with some pairs of atoms connected by atomic bonds. Each atom has a valence number \u2014 the number of bonds the atom must form with other atoms. An atom can form one or multiple bonds with any other atom, but it cannot form a bond with itself. The number of bonds of an atom in the molecule must be equal to its valence number.  Mike knows valence numbers of the three atoms. Find a molecule that can be built from these atoms according to the stated rules, or determine that it is impossible.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains three space-separated integers a, b and c (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009106) \u2014 the valence numbers of the given atoms.", "output_spec": "If such a molecule can be built, print three space-separated integers \u2014 the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).", "notes": "NoteThe first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.", "sample_inputs": ["1 1 2", "3 4 5", "4 1 1"], "sample_outputs": ["0 1 1", "1 3 2", "Impossible"], "tags": ["brute force", "math", "graphs"], "src_uid": "b3b986fddc3770fed64b878fa42ab1bc", "difficulty": 1200, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "b3b986fddc3770fed64b878fa42ab1bc"}
{"description": "In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "512 megabytes", "input_spec": "The input contains three strings in three separate lines: s1, s2 and virus (1\u2009\u2264\u2009|s1|,\u2009|s2|,\u2009|virus|\u2009\u2264\u2009100). Each string consists only of uppercase English letters.", "output_spec": "Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted.  If there is no valid common subsequence, output 0.", "notes": null, "sample_inputs": ["AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ", "AA\nA\nA"], "sample_outputs": ["ORZ", "0"], "tags": ["dp", "strings"], "src_uid": "391c2abbe862139733fcb997ba1629b8", "difficulty": 2000, "source_codes": ["def compute_lps(pattern):\n    m = len(pattern)\n    lps = [0] * m\n    length = 0\n    i = 1\n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\ndef find_longest_common_subsequence_without_virus(s1, s2, virus):\n    n1, n2, nv = len(s1), len(s2), len(virus)\n    \n    # Handle edge cases\n    if n1 == 0 or n2 == 0 or nv == 0:\n        return \"0\"\n    \n    # If virus is longer than possible LCS, then any LCS is valid\n    if nv > min(n1, n2):\n        # Find regular LCS\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if s1[i-1] == s2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        \n        # Reconstruct LCS\n        if dp[n1][n2] == 0:\n            return \"0\"\n            \n        result = []\n        i, j = n1, n2\n        while i > 0 and j > 0:\n            if s1[i-1] == s2[j-1]:\n                result.append(s1[i-1])\n                i -= 1\n                j -= 1\n            elif dp[i-1][j] > dp[i][j-1]:\n                i -= 1\n            else:\n                j -= 1\n        return ''.join(reversed(result))\n    \n    # Precompute KMP failure function for virus\n    lps = compute_lps(virus)\n    \n    # dp[i][j][k] represents the length of longest common subsequence\n    # using first i chars of s1, j chars of s2, and having matched first k chars of virus\n    dp = [[[-1 for _ in range(nv + 1)] for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n    \n    def solve(i, j, k):\n        # Base cases\n        if i == n1 or j == n2:\n            return 0\n        \n        # Check memo\n        if dp[i][j][k] != -1:\n            return dp[i][j][k]\n        \n        # Option 1: Skip character from s1\n        result = solve(i + 1, j, k)\n        \n        # Option 2: Skip character from s2\n        result = max(result, solve(i, j + 1, k))\n        \n        # Option 3: Match characters if they are equal\n        if s1[i] == s2[j]:\n            char = s1[i]\n            # Update virus matching state using KMP logic\n            new_k = k\n            while new_k > 0 and char != virus[new_k]:\n                new_k = lps[new_k - 1]\n            if char == virus[new_k]:\n                new_k += 1\n            \n            # If we haven't completed the virus pattern\n            if new_k < nv:\n                result = max(result, 1 + solve(i + 1, j + 1, new_k))\n        \n        # Store in memo and return\n        dp[i][j][k] = result\n        return result\n    \n    def reconstruct(i, j, k):\n        # Base cases\n        if i == n1 or j == n2:\n            return \"\"\n        \n        # Option 1: Skip character from s1\n        if solve(i, j, k) == solve(i + 1, j, k):\n            return reconstruct(i + 1, j, k)\n        \n        # Option 2: Skip character from s2\n        if solve(i, j, k) == solve(i, j + 1, k):\n            return reconstruct(i, j + 1, k)\n        \n        # Option 3: Match characters if they are equal\n        if s1[i] == s2[j]:\n            char = s1[i]\n            # Update virus matching state using KMP logic\n            new_k = k\n            while new_k > 0 and char != virus[new_k]:\n                new_k = lps[new_k - 1]\n            if char == virus[new_k]:\n                new_k += 1\n            \n            # If we haven't completed the virus pattern\n            if new_k < nv:\n                if solve(i, j, k) == 1 + solve(i + 1, j + 1, new_k):\n                    return char + reconstruct(i + 1, j + 1, new_k)\n        \n        return \"\"  # Should not reach here\n    \n    length = solve(0, 0, 0)\n    \n    if length == 0:\n        return \"0\"\n    \n    return reconstruct(0, 0, 0)\n\n# Read inputs\ns1 = input().strip()\ns2 = input().strip()\nvirus = input().strip()\n\n# Solve and print result\nprint(find_longest_common_subsequence_without_virus(s1, s2, virus))"], "responses": ["\ndef compute_lps(pattern):\n    m = len(pattern)\n    lps = [0] * m\n    length = 0\n    i = 1\n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\ndef find_longest_common_subsequence_without_virus(s1, s2, virus):\n    n1, n2, nv = len(s1), len(s2), len(virus)\n    \n    # Handle edge cases\n    if n1 == 0 or n2 == 0 or nv == 0:\n        return \"0\"\n    \n    # If virus is longer than possible LCS, then any LCS is valid\n    if nv > min(n1, n2):\n        # Find regular LCS\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if s1[i-1] == s2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        \n        # Reconstruct LCS\n        if dp[n1][n2] == 0:\n            return \"0\"\n            \n        result = []\n        i, j = n1, n2\n        while i > 0 and j > 0:\n            if s1[i-1] == s2[j-1]:\n                result.append(s1[i-1])\n                i -= 1\n                j -= 1\n            elif dp[i-1][j] > dp[i][j-1]:\n                i -= 1\n            else:\n                j -= 1\n        return ''.join(reversed(result))\n    \n    # Precompute KMP failure function for virus\n    lps = compute_lps(virus)\n    \n    # dp[i][j][k] represents the length of longest common subsequence\n    # using first i chars of s1, j chars of s2, and having matched first k chars of virus\n    dp = [[[-1 for _ in range(nv + 1)] for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n    \n    def solve(i, j, k):\n        # Base cases\n        if i == n1 or j == n2:\n            return 0\n        \n        # Check memo\n        if dp[i][j][k] != -1:\n            return dp[i][j][k]\n        \n        # Option 1: Skip character from s1\n        result = solve(i + 1, j, k)\n        \n        # Option 2: Skip character from s2\n        result = max(result, solve(i, j + 1, k))\n        \n        # Option 3: Match characters if they are equal\n        if s1[i] == s2[j]:\n            char = s1[i]\n            # Update virus matching state using KMP logic\n            new_k = k\n            while new_k > 0 and char != virus[new_k]:\n                new_k = lps[new_k - 1]\n            if char == virus[new_k]:\n                new_k += 1\n            \n            # If we haven't completed the virus pattern\n            if new_k < nv:\n                result = max(result, 1 + solve(i + 1, j + 1, new_k))\n        \n        # Store in memo and return\n        dp[i][j][k] = result\n        return result\n    \n    def reconstruct(i, j, k):\n        # Base cases\n        if i == n1 or j == n2:\n            return \"\"\n        \n        # Option 1: Skip character from s1\n        if solve(i, j, k) == solve(i + 1, j, k):\n            return reconstruct(i + 1, j, k)\n        \n        # Option 2: Skip character from s2\n        if solve(i, j, k) == solve(i, j + 1, k):\n            return reconstruct(i, j + 1, k)\n        \n        # Option 3: Match characters if they are equal\n        if s1[i] == s2[j]:\n            char = s1[i]\n            # Update virus matching state using KMP logic\n            new_k = k\n            while new_k > 0 and char != virus[new_k]:\n                new_k = lps[new_k - 1]\n            if char == virus[new_k]:\n                new_k += 1\n            \n            # If we haven't completed the virus pattern\n            if new_k < nv:\n                if solve(i, j, k) == 1 + solve(i + 1, j + 1, new_k):\n                    return char + reconstruct(i + 1, j + 1, new_k)\n        \n        return \"\"  # Should not reach here\n    \n    length = solve(0, 0, 0)\n    \n    if length == 0:\n        return \"0\"\n    \n    return reconstruct(0, 0, 0)\n\n# Read inputs\ns1 = input().strip()\ns2 = input().strip()\nvirus = input().strip()\n\n# Solve and print result\nprint(find_longest_common_subsequence_without_virus(s1, s2, virus))\n\n\n"], "prompt_tokens": [12950], "completion_tokens": [8313], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "391c2abbe862139733fcb997ba1629b8"}
{"description": "Jeff loves regular bracket sequences.Today Jeff is going to take a piece of paper and write out the regular bracket sequence, consisting of nm brackets. Let's number all brackets of this sequence from 0 to nm - 1 from left to right. Jeff knows that he is going to spend ai mod n liters of ink on the i-th bracket of the sequence if he paints it opened and bi mod n liters if he paints it closed.You've got sequences a, b and numbers n, m. What minimum amount of ink will Jeff need to paint a regular bracket sequence of length nm?Operation x mod y means taking the remainder after dividing number x by number y.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200920;\u00a01\u2009\u2264\u2009m\u2009\u2264\u2009107; m is even). The next line contains n integers: a0, a1, ..., an\u2009-\u20091 (1\u2009\u2264\u2009ai\u2009\u2264\u200910). The next line contains n integers: b0, b1, ..., bn\u2009-\u20091 (1\u2009\u2264\u2009bi\u2009\u2264\u200910). The numbers are separated by spaces.", "output_spec": "In a single line print the answer to the problem \u2014 the minimum required amount of ink in liters.", "notes": "NoteIn the first test the optimal sequence is: ()()()()()(), the required number of ink liters is 12.", "sample_inputs": ["2 6\n1 2\n2 1", "1 10000000\n2\n3"], "sample_outputs": ["12", "25000000"], "tags": ["dp", "matrices"], "src_uid": "f40900973f4ebeb6fdafd75ebe4e9601", "difficulty": 2500, "source_codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    b = list(map(int, data[2+n:2+2*n]))\n    \n    # Calculate the total cost for one full cycle of n positions\n    # Each cycle contributes m times to the sequence\n    total_cycles = m // 2\n    \n    # For each position in the cycle, we need to decide whether to place '(' or ')'\n    # But since we must maintain a valid sequence, we can think of it as pairing\n    # We'll use a greedy approach: for each pair of positions (i, j) in the cycle,\n    # we decide the optimal way to place one '(' and one ')'\n    \n    # However, given the constraint of valid parentheses, \n    # we can simplify: in each cycle, we need exactly half '(' and half ')'\n    # But since m can be large, and pattern repeats every n positions,\n    # we consider the cost over all positions in one cycle repeated m times\n    \n    # Actually, let's reframe:\n    # Total sequence length is n * m\n    # It's a repetition of the pattern of n positions, repeated m times\n    # In the final sequence, exactly (n*m)/2 positions will have '(' and (n*m)/2 will have ')'\n    \n    # For each position i in 0..n-1, it appears exactly m times in the full sequence\n    # So we have m copies of each position i\n    \n    # We need to assign '(' to exactly (n*m)/2 of these positions\n    # and ')' to the remaining (n*m)/2\n    \n    # For each original position i:\n    # cost of assigning '(' is a[i]\n    # cost of assigning ')' is b[i]\n    # We have m copies of position i\n    \n    # So we have m copies of each \"item\" (position)\n    # Each item can be either '(' with cost a[i] or ')' with cost b[i]\n    # We need exactly (n*m)/2 '(' and (n*m)/2 ')'\n    \n    # This becomes a selection problem:\n    # From m copies of item i, choose k_i to be '(', and (m - k_i) to be ')'\n    # Such that sum of k_i over all i = n*m/2\n    # And sum of (m - k_i) over all i = n*m/2\n    # Minimize sum of k_i * a[i] + (m - k_i) * b[i] = sum of m*b[i] + k_i*(a[i] - b[i])\n    # Since m*b[i] is constant, minimize sum of k_i * (a[i] - b[i])\n    \n    # This is equivalent to selecting exactly n*m/2 items to minimize sum of their adjusted costs\n    # where adjusted cost for choosing '(' for item i is (a[i] - b[i])\n    # and adjusted cost for choosing ')' for item i is 0 (since we're counting how many '(' we pick)\n    \n    # Wait, let's think differently:\n    # Total cost = sum over all positions of cost of bracket placed there\n    # Each position i (in 0..n-1) appears m times\n    # If we place k_i '(' and (m - k_i) ')' at position i, \n    # the contribution to cost is k_i * a[i] + (m - k_i) * b[i] \n    # = m * b[i] + k_i * (a[i] - b[i])\n    \n    # Total cost = sum over i of [m * b[i] + k_i * (a[i] - b[i])]\n    # = m * sum(b[i]) + sum(k_i * (a[i] - b[i]))\n    \n    # We want to minimize this subject to:\n    # sum of k_i = n * m / 2  (total number of '(' needed)\n    # 0 <= k_i <= m for all i\n    \n    # Since sum(b[i]) is constant, we just need to minimize sum(k_i * (a[i] - b[i]))\n    # subject to sum k_i = n*m/2 and 0 <= k_i <= m\n    \n    # This is a classic optimization: select exactly S items (with repetition up to limit)\n    # to minimize weighted sum\n    \n    # We have n types of items, m copies of each type\n    # Weight of item of type i is (a[i] - b[i])\n    # Need to select exactly n*m/2 items\n    # Goal: minimize sum of weights of selected items\n    \n    S = n * m // 2\n    weights = [a[i] - b[i] for i in range(n)]\n    \n    # Create a list of all possible items with their weights\n    # But since we have m copies of each, we can think of selecting up to m items of each type\n    # We sort by weight and select the smallest weights first\n    \n    # To handle multiple copies efficiently:\n    # We create a list of (weight, max_count) pairs and sort by weight\n    items = [(weights[i], m) for i in range(n)]\n    items.sort()\n    \n    total_cost = sum(b[i]) * m  # This is the constant part\n    selected = 0\n    additional_cost = 0\n    \n    for weight, max_count in items:\n        if selected >= S:\n            break\n        take = min(max_count, S - selected)\n        additional_cost += take * weight\n        selected += take\n        \n    result = total_cost + additional_cost\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    b = list(map(int, data[2+n:2+2*n]))\n    \n    # Calculate the total cost for one full cycle of n positions\n    # Each cycle contributes m times to the sequence\n    total_cycles = m // 2\n    \n    # For each position in the cycle, we need to decide whether to place '(' or ')'\n    # But since we must maintain a valid sequence, we can think of it as pairing\n    # We'll use a greedy approach: for each pair of positions (i, j) in the cycle,\n    # we decide the optimal way to place one '(' and one ')'\n    \n    # However, given the constraint of valid parentheses, \n    # we can simplify: in each cycle, we need exactly half '(' and half ')'\n    # But since m can be large, and pattern repeats every n positions,\n    # we consider the cost over all positions in one cycle repeated m times\n    \n    # Actually, let's reframe:\n    # Total sequence length is n * m\n    # It's a repetition of the pattern of n positions, repeated m times\n    # In the final sequence, exactly (n*m)/2 positions will have '(' and (n*m)/2 will have ')'\n    \n    # For each position i in 0..n-1, it appears exactly m times in the full sequence\n    # So we have m copies of each position i\n    \n    # We need to assign '(' to exactly (n*m)/2 of these positions\n    # and ')' to the remaining (n*m)/2\n    \n    # For each original position i:\n    # cost of assigning '(' is a[i]\n    # cost of assigning ')' is b[i]\n    # We have m copies of position i\n    \n    # So we have m copies of each \"item\" (position)\n    # Each item can be either '(' with cost a[i] or ')' with cost b[i]\n    # We need exactly (n*m)/2 '(' and (n*m)/2 ')'\n    \n    # This becomes a selection problem:\n    # From m copies of item i, choose k_i to be '(', and (m - k_i) to be ')'\n    # Such that sum of k_i over all i = n*m/2\n    # And sum of (m - k_i) over all i = n*m/2\n    # Minimize sum of k_i * a[i] + (m - k_i) * b[i] = sum of m*b[i] + k_i*(a[i] - b[i])\n    # Since m*b[i] is constant, minimize sum of k_i * (a[i] - b[i])\n    \n    # This is equivalent to selecting exactly n*m/2 items to minimize sum of their adjusted costs\n    # where adjusted cost for choosing '(' for item i is (a[i] - b[i])\n    # and adjusted cost for choosing ')' for item i is 0 (since we're counting how many '(' we pick)\n    \n    # Wait, let's think differently:\n    # Total cost = sum over all positions of cost of bracket placed there\n    # Each position i (in 0..n-1) appears m times\n    # If we place k_i '(' and (m - k_i) ')' at position i, \n    # the contribution to cost is k_i * a[i] + (m - k_i) * b[i] \n    # = m * b[i] + k_i * (a[i] - b[i])\n    \n    # Total cost = sum over i of [m * b[i] + k_i * (a[i] - b[i])]\n    # = m * sum(b[i]) + sum(k_i * (a[i] - b[i]))\n    \n    # We want to minimize this subject to:\n    # sum of k_i = n * m / 2  (total number of '(' needed)\n    # 0 <= k_i <= m for all i\n    \n    # Since sum(b[i]) is constant, we just need to minimize sum(k_i * (a[i] - b[i]))\n    # subject to sum k_i = n*m/2 and 0 <= k_i <= m\n    \n    # This is a classic optimization: select exactly S items (with repetition up to limit)\n    # to minimize weighted sum\n    \n    # We have n types of items, m copies of each type\n    # Weight of item of type i is (a[i] - b[i])\n    # Need to select exactly n*m/2 items\n    # Goal: minimize sum of weights of selected items\n    \n    S = n * m // 2\n    weights = [a[i] - b[i] for i in range(n)]\n    \n    # Create a list of all possible items with their weights\n    # But since we have m copies of each, we can think of selecting up to m items of each type\n    # We sort by weight and select the smallest weights first\n    \n    # To handle multiple copies efficiently:\n    # We create a list of (weight, max_count) pairs and sort by weight\n    items = [(weights[i], m) for i in range(n)]\n    items.sort()\n    \n    total_cost = sum(b[i]) * m  # This is the constant part\n    selected = 0\n    additional_cost = 0\n    \n    for weight, max_count in items:\n        if selected >= S:\n            break\n        take = min(max_count, S - selected)\n        additional_cost += take * weight\n        selected += take\n        \n    result = total_cost + additional_cost\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [6681], "completion_tokens": [5500], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "f40900973f4ebeb6fdafd75ebe4e9601"}
{"description": "Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8\u2009\u00d7\u20098 table. A field is represented by a pair of integers (r,\u2009c) \u2014 the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:  A rook moves any number of fields horizontally or vertically.  A bishop moves any number of fields diagonally.  A king moves one field in any direction \u2014 horizontally, vertically or diagonally.     The pieces move like that Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (r1,\u2009c1) to field (r2,\u2009c2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input contains four integers r1,\u2009c1,\u2009r2,\u2009c2 (1\u2009\u2264\u2009r1,\u2009c1,\u2009r2,\u2009c2\u2009\u2264\u20098) \u2014 the coordinates of the starting and the final field. The starting field doesn't coincide with the final one. You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.", "output_spec": "Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (r1,\u2009c1) to field (r2,\u2009c2). If a piece cannot make such a move, print a 0 instead of the corresponding number.", "notes": null, "sample_inputs": ["4 3 1 6", "5 5 5 6"], "sample_outputs": ["2 1 3", "1 0 1"], "tags": ["math", "shortest paths", "graphs"], "src_uid": "7dbf58806db185f0fe70c00b60973f4b", "difficulty": 1100, "source_codes": ["r1, c1, r2, c2 = map(int, input().split())\n\n# Rook moves\nif r1 == r2 or c1 == c2:\n    rook_moves = 1\nelse:\n    rook_moves = 2\n\n# Bishop moves\nif (r1 + c1) % 2 != (r2 + c2) % 2:\n    bishop_moves = 0\nelif abs(r1 - r2) == abs(c1 - c2):\n    bishop_moves = 1\nelse:\n    bishop_moves = 2\n\n# King moves\nking_moves = max(abs(r1 - r2), abs(c1 - c2))\n\nprint(rook_moves, bishop_moves, king_moves)"], "responses": ["\nr1, c1, r2, c2 = map(int, input().split())\n\n# Rook moves\nif r1 == r2 or c1 == c2:\n    rook_moves = 1\nelse:\n    rook_moves = 2\n\n# Bishop moves\nif (r1 + c1) % 2 != (r2 + c2) % 2:\n    bishop_moves = 0\nelif abs(r1 - r2) == abs(c1 - c2):\n    bishop_moves = 1\nelse:\n    bishop_moves = 2\n\n# King moves\nking_moves = max(abs(r1 - r2), abs(c1 - c2))\n\nprint(rook_moves, bishop_moves, king_moves)\n\n\n"], "prompt_tokens": [6093], "completion_tokens": [1528], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "7dbf58806db185f0fe70c00b60973f4b"}
{"description": "Cucumber boy is fan of Kyubeat, a famous music game.Kyubeat has 16 panels for playing arranged in 4\u2009\u00d7\u20094 table. When a panel lights up, he has to press that panel.Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most k panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer k (1\u2009\u2264\u2009k\u2009\u2264\u20095) \u2014 the number of panels Cucumber boy can press with his one hand. Next 4 lines contain 4 characters each (digits from 1 to 9, or period) \u2014 table of panels. If a digit i was written on the panel, it means the boy has to press that panel in time i. If period was written on the panel, he doesn't have to press that panel.", "output_spec": "Output \"YES\" (without quotes), if he is able to press all the panels in perfect timing. If not, output \"NO\" (without quotes).", "notes": "NoteIn the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.", "sample_inputs": ["1\n.135\n1247\n3468\n5789", "5\n..1.\n1111\n..1.\n..1.", "1\n....\n12.1\n.2..\n.2.."], "sample_outputs": ["YES", "YES", "NO"], "tags": ["implementation"], "src_uid": "5fdaf8ee7763cb5815f49c0c38398f16", "difficulty": 900, "source_codes": ["def solve():\n    k = int(input())\n    grid = [input().strip() for _ in range(4)]\n    \n    # Count how many panels need to be pressed at each time\n    time_count = Counter()\n    for row in grid:\n        for char in row:\n            if char != '.':\n                time_count[char] += 1\n    \n    # Check if any time step requires more presses than 2*k\n    max_presses = 2 * k\n    for count in time_count.values():\n        if count > max_presses:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nsolve()"], "responses": ["\nfrom collections import Counter\n\ndef solve():\n    k = int(input())\n    grid = [input().strip() for _ in range(4)]\n    \n    # Count how many panels need to be pressed at each time\n    time_count = Counter()\n    for row in grid:\n        for char in row:\n            if char != '.':\n                time_count[char] += 1\n    \n    # Check if any time step requires more presses than 2*k\n    max_presses = 2 * k\n    for count in time_count.values():\n        if count > max_presses:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nsolve()\n\n\n"], "prompt_tokens": [6398], "completion_tokens": [1839], "no_of_try": 1, "api_calls": 6, "is_solved": false, "language": "Python3", "task_id": "5fdaf8ee7763cb5815f49c0c38398f16"}
{"description": "Our bear's forest has a checkered field. The checkered field is an n\u2009\u00d7\u2009n table, the rows are numbered from 1 to n from top to bottom, the columns are numbered from 1 to n from left to right. Let's denote a cell of the field on the intersection of row x and column y by record (x,\u2009y). Each cell of the field contains growing raspberry, at that, the cell (x,\u2009y) of the field contains x\u2009+\u2009y raspberry bushes.The bear came out to walk across the field. At the beginning of the walk his speed is (dx,\u2009dy). Then the bear spends exactly t seconds on the field. Each second the following takes place:  Let's suppose that at the current moment the bear is in cell (x,\u2009y).  First the bear eats the raspberry from all the bushes he has in the current cell. After the bear eats the raspberry from k bushes, he increases each component of his speed by k. In other words, if before eating the k bushes of raspberry his speed was (dx,\u2009dy), then after eating the berry his speed equals (dx\u2009+\u2009k,\u2009dy\u2009+\u2009k).  Let's denote the current speed of the bear (dx,\u2009dy) (it was increased after the previous step). Then the bear moves from cell (x,\u2009y) to cell (((x\u2009+\u2009dx\u2009-\u20091)\u00a0mod\u00a0n)\u2009+\u20091,\u2009((y\u2009+\u2009dy\u2009-\u20091)\u00a0mod\u00a0n)\u2009+\u20091).  Then one additional raspberry bush grows in each cell of the field. You task is to predict the bear's actions. Find the cell he ends up in if he starts from cell (sx,\u2009sy). Assume that each bush has infinitely much raspberry and the bear will never eat all of it.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains six space-separated integers: n, sx, sy, dx, dy, t (1\u2009\u2264\u2009n\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009sx,\u2009sy\u2009\u2264\u2009n;\u00a0\u2009-\u2009100\u2009\u2264\u2009dx,\u2009dy\u2009\u2264\u2009100;\u00a00\u2009\u2264\u2009t\u2009\u2264\u20091018).", "output_spec": "Print two integers \u2014 the coordinates of the cell the bear will end up in after t seconds.", "notes": "NoteOperation a\u00a0mod\u00a0b means taking the remainder after dividing a by b. Note that the result of the operation is always non-negative. For example, (\u2009-\u20091)\u00a0mod\u00a03\u2009=\u20092.In the first sample before the first move the speed vector will equal (3,4) and the bear will get to cell (4,1). Before the second move the speed vector will equal (9,10) and he bear will get to cell (3,1). Don't forget that at the second move, the number of berry bushes increased by 1.In the second sample before the first move the speed vector will equal (1,1) and the bear will get to cell (1,1). Before the second move, the speed vector will equal (4,4) and the bear will get to cell (1,1). Don't forget that at the second move, the number of berry bushes increased by 1.", "sample_inputs": ["5 1 2 0 1 2", "1 1 1 -1 -1 2"], "sample_outputs": ["3 1", "1 1"], "tags": ["math", "matrices"], "src_uid": "ee9fa8be2ae05a4e831a4f608c0cc785", "difficulty": 2300, "source_codes": ["def solve():\n    n, sx, sy, dx, dy, t = map(int, input().split())\n    \n    if t == 0:\n        print(sx, sy)\n        return\n    \n    if n == 1:\n        print(1, 1)\n        return\n    \n    x, y = sx, sy\n    speed_history = {}  # (dx, dy) -> time when first seen\n    \n    current_dx, current_dy = dx, dy\n    time = 0\n    \n    # Simulate until we find a cycle or reach t\n    while time < t:\n        # Position at current time (before movement)\n        pos_x = x\n        pos_y = y\n        \n        # Number of bushes in current cell at time 'time'\n        bushes = pos_x + pos_y + time\n        \n        # Eat berries and update speed\n        current_dx += bushes\n        current_dy += bushes\n        \n        # Move to new position\n        x = ((x + current_dx - 1) % n) + 1\n        y = ((y + current_dy - 1) % n) + 1\n        \n        time += 1\n        \n        if time == t:\n            print(x, y)\n            return\n            \n        # Check for cycle in speed\n        speed_key = (current_dx, current_dy)\n        if speed_key in speed_history:\n            # Cycle detected\n            cycle_start = speed_history[speed_key]\n            cycle_length = time - cycle_start\n            \n            remaining_time = t - time\n            full_cycles = remaining_time // cycle_length\n            remainder = remaining_time % cycle_length\n            \n            # Simulate one complete cycle to get displacement\n            cycle_displacement_x = 0\n            cycle_displacement_y = 0\n            \n            temp_x, temp_y = x, y\n            temp_dx, temp_dy = current_dx, current_dy\n            temp_time = time\n            \n            for _ in range(cycle_length):\n                pos_x_temp = temp_x\n                pos_y_temp = temp_y\n                bushes_temp = pos_x_temp + pos_y_temp + temp_time\n                temp_dx += bushes_temp\n                temp_dy += bushes_temp\n                cycle_displacement_x += temp_dx\n                cycle_displacement_y += temp_dy\n                temp_x = ((temp_x + temp_dx - 1) % n) + 1\n                temp_y = ((temp_y + temp_dy - 1) % n) + 1\n                temp_time += 1\n            \n            # Apply full cycles\n            if full_cycles > 0:\n                # For large n, we can't just multiply displacement\n                # We need to apply the modular arithmetic properly\n                total_dx_add = 0\n                total_dy_add = 0\n                \n                # Recalculate cycle effect properly\n                cycle_states = []\n                temp_x2, temp_y2 = x, y\n                temp_dx2, temp_dy2 = current_dx, current_dy\n                temp_time2 = time\n                \n                for _ in range(cycle_length):\n                    pos_x_cycle = temp_x2\n                    pos_y_cycle = temp_y2\n                    bushes_cycle = pos_x_cycle + pos_y_cycle + temp_time2\n                    cycle_states.append(((temp_dx2, temp_dy2), bushes_cycle))\n                    temp_dx2 += bushes_cycle\n                    temp_dy2 += bushes_cycle\n                    temp_x2 = ((temp_x2 + temp_dx2 - 1) % n) + 1\n                    temp_y2 = ((temp_y2 + temp_dy2 - 1) % n) + 1\n                    temp_time2 += 1\n                \n                # Apply full cycles\n                for _ in range(full_cycles):\n                    for speed_state, berry_count in cycle_states:\n                        total_dx_add += speed_state[0]\n                        total_dy_add += speed_state[1]\n                \n                x = ((x - 1 + total_dx_add) % n) + 1\n                y = ((y - 1 + total_dy_add) % n) + 1\n                time += full_cycles * cycle_length\n                current_dx = temp_dx2\n                current_dy = temp_dy2\n            \n            # Simulate remaining steps\n            for _ in range(remainder):\n                pos_x_final = x\n                pos_y_final = y\n                bushes_final = pos_x_final + pos_y_final + time\n                current_dx += bushes_final\n                current_dy += bushes_final\n                x = ((x + current_dx - 1) % n) + 1\n                y = ((y + current_dy - 1) % n) + 1\n                time += 1\n            \n            print(x, y)\n            return\n        else:\n            speed_history[speed_key] = time\n    \n    print(x, y)\n\nsolve()"], "responses": ["\ndef solve():\n    n, sx, sy, dx, dy, t = map(int, input().split())\n    \n    if t == 0:\n        print(sx, sy)\n        return\n    \n    if n == 1:\n        print(1, 1)\n        return\n    \n    x, y = sx, sy\n    speed_history = {}  # (dx, dy) -> time when first seen\n    \n    current_dx, current_dy = dx, dy\n    time = 0\n    \n    # Simulate until we find a cycle or reach t\n    while time < t:\n        # Position at current time (before movement)\n        pos_x = x\n        pos_y = y\n        \n        # Number of bushes in current cell at time 'time'\n        bushes = pos_x + pos_y + time\n        \n        # Eat berries and update speed\n        current_dx += bushes\n        current_dy += bushes\n        \n        # Move to new position\n        x = ((x + current_dx - 1) % n) + 1\n        y = ((y + current_dy - 1) % n) + 1\n        \n        time += 1\n        \n        if time == t:\n            print(x, y)\n            return\n            \n        # Check for cycle in speed\n        speed_key = (current_dx, current_dy)\n        if speed_key in speed_history:\n            # Cycle detected\n            cycle_start = speed_history[speed_key]\n            cycle_length = time - cycle_start\n            \n            remaining_time = t - time\n            full_cycles = remaining_time // cycle_length\n            remainder = remaining_time % cycle_length\n            \n            # Simulate one complete cycle to get displacement\n            cycle_displacement_x = 0\n            cycle_displacement_y = 0\n            \n            temp_x, temp_y = x, y\n            temp_dx, temp_dy = current_dx, current_dy\n            temp_time = time\n            \n            for _ in range(cycle_length):\n                pos_x_temp = temp_x\n                pos_y_temp = temp_y\n                bushes_temp = pos_x_temp + pos_y_temp + temp_time\n                temp_dx += bushes_temp\n                temp_dy += bushes_temp\n                cycle_displacement_x += temp_dx\n                cycle_displacement_y += temp_dy\n                temp_x = ((temp_x + temp_dx - 1) % n) + 1\n                temp_y = ((temp_y + temp_dy - 1) % n) + 1\n                temp_time += 1\n            \n            # Apply full cycles\n            if full_cycles > 0:\n                # For large n, we can't just multiply displacement\n                # We need to apply the modular arithmetic properly\n                total_dx_add = 0\n                total_dy_add = 0\n                \n                # Recalculate cycle effect properly\n                cycle_states = []\n                temp_x2, temp_y2 = x, y\n                temp_dx2, temp_dy2 = current_dx, current_dy\n                temp_time2 = time\n                \n                for _ in range(cycle_length):\n                    pos_x_cycle = temp_x2\n                    pos_y_cycle = temp_y2\n                    bushes_cycle = pos_x_cycle + pos_y_cycle + temp_time2\n                    cycle_states.append(((temp_dx2, temp_dy2), bushes_cycle))\n                    temp_dx2 += bushes_cycle\n                    temp_dy2 += bushes_cycle\n                    temp_x2 = ((temp_x2 + temp_dx2 - 1) % n) + 1\n                    temp_y2 = ((temp_y2 + temp_dy2 - 1) % n) + 1\n                    temp_time2 += 1\n                \n                # Apply full cycles\n                for _ in range(full_cycles):\n                    for speed_state, berry_count in cycle_states:\n                        total_dx_add += speed_state[0]\n                        total_dy_add += speed_state[1]\n                \n                x = ((x - 1 + total_dx_add) % n) + 1\n                y = ((y - 1 + total_dy_add) % n) + 1\n                time += full_cycles * cycle_length\n                current_dx = temp_dx2\n                current_dy = temp_dy2\n            \n            # Simulate remaining steps\n            for _ in range(remainder):\n                pos_x_final = x\n                pos_y_final = y\n                bushes_final = pos_x_final + pos_y_final + time\n                current_dx += bushes_final\n                current_dy += bushes_final\n                x = ((x + current_dx - 1) % n) + 1\n                y = ((y + current_dy - 1) % n) + 1\n                time += 1\n            \n            print(x, y)\n            return\n        else:\n            speed_history[speed_key] = time\n    \n    print(x, y)\n\nsolve()\n\n\n"], "prompt_tokens": [18807], "completion_tokens": [8653], "no_of_try": 1, "api_calls": 10, "is_solved": false, "language": "Python3", "task_id": "ee9fa8be2ae05a4e831a4f608c0cc785"}
{"description": "As you may know, MemSQL has American offices in both San Francisco and Seattle. Being a manager in the company, you travel a lot between the two cities, always by plane.You prefer flying from Seattle to San Francisco than in the other direction, because it's warmer in San Francisco. You are so busy that you don't remember the number of flights you have made in either direction. However, for each of the last n days you know whether you were in San Francisco office or in Seattle office. You always fly at nights, so you never were at both offices on the same day. Given this information, determine if you flew more times from Seattle to San Francisco during the last n days, or not.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of input contains single integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of days. The second line contains a string of length n consisting of only capital 'S' and 'F' letters. If the i-th letter is 'S', then you were in Seattle office on that day. Otherwise you were in San Francisco. The days are given in chronological order, i.e. today is the last day in this sequence.", "output_spec": "Print \"YES\" if you flew more times from Seattle to San Francisco, and \"NO\" otherwise. You can print each letter in any case (upper or lower).", "notes": "NoteIn the first example you were initially at San Francisco, then flew to Seattle, were there for two days and returned to San Francisco. You made one flight in each direction, so the answer is \"NO\".In the second example you just flew from Seattle to San Francisco, so the answer is \"YES\".In the third example you stayed the whole period in San Francisco, so the answer is \"NO\".In the fourth example if you replace 'S' with ones, and 'F' with zeros, you'll get the first few digits of \u03c0 in binary representation. Not very useful information though.", "sample_inputs": ["4\nFSSF", "2\nSF", "10\nFFFFFFFFFF", "10\nSSFFSFFSFF"], "sample_outputs": ["NO", "YES", "NO", "YES"], "tags": ["implementation"], "src_uid": "ab8a2070ea758d118b3c09ee165d9517", "difficulty": 800, "source_codes": ["import sys\n\ndef count_flights(seq: str) -> str:\n    \"\"\"\n    Return 'YES' if there are more S->F transitions than F->S transitions.\n    \"\"\"\n    sf = 0  # Seattle -> San Francisco\n    fs = 0  # San Francisco -> Seattle\n\n    # compare each consecutive pair of days\n    for i in range(1, len(seq)):\n        if seq[i - 1] == 'S' and seq[i] == 'F':\n            sf += 1\n        elif seq[i - 1] == 'F' and seq[i] == 'S':\n            fs += 1\n\n    return \"YES\" if sf > fs else \"NO\"\n\n\ndef main() -> None:\n    # read n and the sequence string\n    line = sys.stdin.readline()\n    if not line:\n        return\n    n = int(line.strip())\n\n    s = sys.stdin.readline().strip()\n    # the problem guarantees len(s) == n, but we trim just in case\n    if len(s) > n:\n        s = s[:n]\n\n    print(count_flights(s))\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\n\ndef count_flights(seq: str) -> str:\n    \"\"\"\n    Return 'YES' if there are more S->F transitions than F->S transitions.\n    \"\"\"\n    sf = 0  # Seattle -> San Francisco\n    fs = 0  # San Francisco -> Seattle\n\n    # compare each consecutive pair of days\n    for i in range(1, len(seq)):\n        if seq[i - 1] == 'S' and seq[i] == 'F':\n            sf += 1\n        elif seq[i - 1] == 'F' and seq[i] == 'S':\n            fs += 1\n\n    return \"YES\" if sf > fs else \"NO\"\n\n\ndef main() -> None:\n    # read n and the sequence string\n    line = sys.stdin.readline()\n    if not line:\n        return\n    n = int(line.strip())\n\n    s = sys.stdin.readline().strip()\n    # the problem guarantees len(s) == n, but we trim just in case\n    if len(s) > n:\n        s = s[:n]\n\n    print(count_flights(s))\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "ab8a2070ea758d118b3c09ee165d9517"}
{"description": "You are given two lists of non-zero digits.Let's call an integer pretty if its (base 10) representation has at least one digit from the first list and at least one digit from the second list. What is the smallest positive pretty integer?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20099) \u2014 the lengths of the first and the second lists, respectively. The second line contains n distinct digits a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20099) \u2014 the elements of the first list. The third line contains m distinct digits b1,\u2009b2,\u2009...,\u2009bm (1\u2009\u2264\u2009bi\u2009\u2264\u20099) \u2014 the elements of the second list.", "output_spec": "Print the smallest pretty integer.", "notes": "NoteIn the first example 25, 46, 24567 are pretty, as well as many other integers. The smallest among them is 25. 42 and 24 are not pretty because they don't have digits from the second list.In the second example all integers that have at least one digit different from 9 are pretty. It's obvious that the smallest among them is 1, because it's the smallest positive integer.", "sample_inputs": ["2 3\n4 2\n5 7 6", "8 8\n1 2 3 4 5 6 7 8\n8 7 6 5 4 3 2 1"], "sample_outputs": ["25", "1"], "tags": ["brute force", "implementation"], "src_uid": "3a0c1b6d710fd8f0b6daf420255d76ee", "difficulty": 900, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the problem data and prints the smallest pretty integer.\n    \"\"\"\n    # Read all tokens, regardless of line breaks\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    it = iter(data)\n\n    # First line: n and m\n    n = int(next(it))\n    m = int(next(it))\n\n    # Next n digits belong to set A\n    A = [int(next(it)) for _ in range(n)]\n\n    # Next m digits belong to set B\n    B = [int(next(it)) for _ in range(m)]\n\n    # If there is a common digit, the answer is the smallest such digit\n    common = set(A) & set(B)\n    if common:\n        print(min(common))\n        return\n\n    # No common digit \u2192 the answer is a two\u2011digit number\n    a_min = min(A)\n    b_min = min(B)\n    ans = min(10 * a_min + b_min, 10 * b_min + a_min)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the problem data and prints the smallest pretty integer.\n    \"\"\"\n    # Read all tokens, regardless of line breaks\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    it = iter(data)\n\n    # First line: n and m\n    n = int(next(it))\n    m = int(next(it))\n\n    # Next n digits belong to set A\n    A = [int(next(it)) for _ in range(n)]\n\n    # Next m digits belong to set B\n    B = [int(next(it)) for _ in range(m)]\n\n    # If there is a common digit, the answer is the smallest such digit\n    common = set(A) & set(B)\n    if common:\n        print(min(common))\n        return\n\n    # No common digit \u2192 the answer is a two\u2011digit number\n    a_min = min(A)\n    b_min = min(B)\n    ans = min(10 * a_min + b_min, 10 * b_min + a_min)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "3a0c1b6d710fd8f0b6daf420255d76ee"}
{"description": "Unlucky year in Berland is such a year that its number n can be represented as n\u2009=\u2009xa\u2009+\u2009yb, where a and b are non-negative integer numbers. For example, if x\u2009=\u20092 and y\u2009=\u20093 then the years 4 and 17 are unlucky (4\u2009=\u200920\u2009+\u200931, 17\u2009=\u200923\u2009+\u200932\u2009=\u200924\u2009+\u200930) and year 18 isn't unlucky as there is no such representation for it.Such interval of years that there are no unlucky years in it is called The Golden Age.You should write a program which will find maximum length of The Golden Age which starts no earlier than the year l and ends no later than the year r. If all years in the interval [l,\u2009r] are unlucky then the answer is 0.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains four integer numbers x, y, l and r (2\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20091018, 1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018).", "output_spec": "Print the maximum length of The Golden Age within the interval [l,\u2009r]. If all years in the interval [l,\u2009r] are unlucky then print 0.", "notes": "NoteIn the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1,\u20091], [6,\u20096] and [8,\u20098].In the second example the longest Golden Age is the interval [15,\u200922].", "sample_inputs": ["2 3 1 10", "3 5 10 22", "2 3 3 5"], "sample_outputs": ["1", "8", "0"], "tags": ["brute force", "math"], "src_uid": "68ca8a8730db27ac2230f9fe9b120f5f", "difficulty": 1800, "source_codes": ["cur = l                     # first year still not examined\nans = 0\nfor each unlucky value v in increasing order:\n        gap = v - cur               # years cur \u2026 v-1 are free\n        ans = max(ans, gap)\n        cur = v + 1                 # next possible start\n# after the loop handle the tail\nif cur \u2264 r:\n        gap = r - cur + 1\n        ans = max(ans, gap)"], "responses": ["\ncur = l                     # first year still not examined\nans = 0\nfor each unlucky value v in increasing order:\n        gap = v - cur               # years cur \u2026 v-1 are free\n        ans = max(ans, gap)\n        cur = v + 1                 # next possible start\n# after the loop handle the tail\nif cur \u2264 r:\n        gap = r - cur + 1\n        ans = max(ans, gap)\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "68ca8a8730db27ac2230f9fe9b120f5f"}
{"description": "Captain Bill the Hummingbird and his crew recieved an interesting challenge offer. Some stranger gave them a map, potion of teleportation and said that only this potion might help them to reach the treasure. Bottle with potion has two values x and y written on it. These values define four moves which can be performed using the potion:         Map shows that the position of Captain Bill the Hummingbird is (x1,\u2009y1) and the position of the treasure is (x2,\u2009y2).You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline. If it is possible for Captain to reach the treasure using the potion then output \"YES\", otherwise \"NO\" (without quotes).The potion can be used infinite amount of times.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains four integer numbers x1,\u2009y1,\u2009x2,\u2009y2 (\u2009-\u2009105\u2009\u2264\u2009x1,\u2009y1,\u2009x2,\u2009y2\u2009\u2264\u2009105) \u2014 positions of Captain Bill the Hummingbird and treasure respectively. The second line contains two integer numbers x,\u2009y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009105) \u2014 values on the potion bottle.", "output_spec": "Print \"YES\" if it is possible for Captain to reach the treasure using the potion, otherwise print \"NO\" (without quotes).", "notes": "NoteIn the first example there exists such sequence of moves:   \u2014 the first type of move   \u2014 the third type of move ", "sample_inputs": ["0 0 0 6\n2 3", "1 1 3 6\n1 5"], "sample_outputs": ["YES", "NO"], "tags": ["math", "number theory", "implementation"], "src_uid": "1c80040104e06c9f24abfcfe654a851f", "difficulty": 1200, "source_codes": ["can_reach(x1, y1, x2, y2, dx, dy):\n    diff_x = x2 - x1\n    diff_y = y2 - y1\n    if diff_x % dx != 0 or diff_y % dy != 0:\n        return False\n    sx = diff_x // dx          # integer number of x\u2011steps\n    sy = diff_y // dy          # integer number of y\u2011steps\n    return (sx & 1) == (sy & 1)    # same parity?\n\nsolve():\n    read all integers into a list data\n    for i = 0,6,12,\u2026 while i+5 < len(data):\n        read the six numbers of the i\u2011th case\n        output \"YES\" if can_reach(...) else \"NO\""], "responses": ["\ncan_reach(x1, y1, x2, y2, dx, dy):\n    diff_x = x2 - x1\n    diff_y = y2 - y1\n    if diff_x % dx != 0 or diff_y % dy != 0:\n        return False\n    sx = diff_x // dx          # integer number of x\u2011steps\n    sy = diff_y // dy          # integer number of y\u2011steps\n    return (sx & 1) == (sy & 1)    # same parity?\n\nsolve():\n    read all integers into a list data\n    for i = 0,6,12,\u2026 while i+5 < len(data):\n        read the six numbers of the i\u2011th case\n        output \"YES\" if can_reach(...) else \"NO\"\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "1c80040104e06c9f24abfcfe654a851f"}
{"description": "Okabe needs bananas for one of his experiments for some strange reason. So he decides to go to the forest and cut banana trees.Consider the point (x,\u2009y) in the 2D plane such that x and y are integers and 0\u2009\u2264\u2009x,\u2009y. There is a tree in such a point, and it has x\u2009+\u2009y bananas. There are no trees nor bananas in other points. Now, Okabe draws a line with equation . Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas. Okabe's rectangle can be degenerate; that is, it can be a line segment or even a point.Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely.Okabe is sure that the answer does not exceed 1018. You can trust him.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of input contains two space-separated integers m and b (1\u2009\u2264\u2009m\u2009\u2264\u20091000, 1\u2009\u2264\u2009b\u2009\u2264\u200910000).", "output_spec": "Print the maximum number of bananas Okabe can get from the trees he cuts.", "notes": "Note  The graph above corresponds to sample test 1. The optimal rectangle is shown in red and has 30 bananas.", "sample_inputs": ["1 5", "2 3"], "sample_outputs": ["30", "25"], "tags": ["brute force", "math"], "src_uid": "9300f1c07dd36e0cf7e6cb7911df4cf2", "difficulty": 1300, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "9300f1c07dd36e0cf7e6cb7911df4cf2"}
{"description": "Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vi\u010dkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vi\u010dkopolis. He almost even fell into a depression from boredom!Leha came up with a task for himself to relax a little. He chooses two integers A and B and then calculates the greatest common divisor of integers \"A factorial\" and \"B factorial\". Formally the hacker wants to find out GCD(A!,\u2009B!). It's well known that the factorial of an integer x is a product of all positive integers less than or equal to x. Thus x!\u2009=\u20091\u00b72\u00b73\u00b7...\u00b7(x\u2009-\u20091)\u00b7x. For example 4!\u2009=\u20091\u00b72\u00b73\u00b74\u2009=\u200924. Recall that GCD(x,\u2009y) is the largest positive integer q that divides (without a remainder) both x and y.Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first and single line contains two integers A and B (1\u2009\u2264\u2009A,\u2009B\u2009\u2264\u2009109,\u2009min(A,\u2009B)\u2009\u2264\u200912).", "output_spec": "Print a single integer denoting the greatest common divisor of integers A! and B!.", "notes": "NoteConsider the sample.4!\u2009=\u20091\u00b72\u00b73\u00b74\u2009=\u200924. 3!\u2009=\u20091\u00b72\u00b73\u2009=\u20096. The greatest common divisor of integers 24 and 6 is exactly 6.", "sample_inputs": ["4 3"], "sample_outputs": ["6"], "tags": ["math", "number theory", "implementation"], "src_uid": "7bf30ceb24b66d91382e97767f9feeb6", "difficulty": 800, "source_codes": ["import sys\nimport math\n\ndef solve() -> int:\n    \"\"\"\n    Reads two integers A and B from standard input\n    and returns gcd(A!, B!) = min(A, B)!.\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return 0\n    a, b = map(int, data[:2])\n    m = a if a < b else b\n    # Since m \u2264 12 we can safely use math.factorial\n    return math.factorial(m)\n\n\ndef main() -> None:\n    print(solve())\n\n\nif __name__ == \"__main__\":\n    main()"], "responses": ["\nimport sys\nimport math\n\ndef solve() -> int:\n    \"\"\"\n    Reads two integers A and B from standard input\n    and returns gcd(A!, B!) = min(A, B)!.\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return 0\n    a, b = map(int, data[:2])\n    m = a if a < b else b\n    # Since m \u2264 12 we can safely use math.factorial\n    return math.factorial(m)\n\n\ndef main() -> None:\n    print(solve())\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "7bf30ceb24b66d91382e97767f9feeb6"}
{"description": "One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of n positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter k, so now his function contains the following code:int fast_max(int n, int a[]) {     int ans = 0;    int offset = 0;    for (int i = 0; i &lt; n; ++i)        if (ans &lt; a[i]) {            ans = a[i];            offset = 0;        } else {            offset = offset + 1;            if (offset == k)                return ans;        }    return ans;}That way the function iteratively checks array elements, storing the intermediate maximum, and if after k consecutive iterations that maximum has not changed, it is returned as the answer.Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from 1 to n such that the return value of his function on those permutations is not equal to n. Since this number could be very big, output the answer modulo 109\u2009+\u20097.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009106), separated by a space\u00a0\u2014 the length of the permutations and the parameter k.", "output_spec": "Output the answer to the problem modulo 109\u2009+\u20097.", "notes": "NotePermutations from second example: [4,\u20091,\u20092,\u20093,\u20095], [4,\u20091,\u20093,\u20092,\u20095], [4,\u20092,\u20091,\u20093,\u20095], [4,\u20092,\u20093,\u20091,\u20095], [4,\u20093,\u20091,\u20092,\u20095], [4,\u20093,\u20092,\u20091,\u20095].", "sample_inputs": ["5 2", "5 3", "6 3"], "sample_outputs": ["22", "6", "84"], "tags": ["dp", "combinatorics", "math"], "src_uid": "0644605611a2cd10ab3a9f12f18d7ae4", "difficulty": 2400, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "0644605611a2cd10ab3a9f12f18d7ae4"}
{"description": "Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0,\u20090). The robot can process commands. There are four types of commands it can perform:  U \u2014 move from the cell (x,\u2009y) to (x,\u2009y\u2009+\u20091);  D \u2014 move from (x,\u2009y) to (x,\u2009y\u2009-\u20091);  L \u2014 move from (x,\u2009y) to (x\u2009-\u20091,\u2009y);  R \u2014 move from (x,\u2009y) to (x\u2009+\u20091,\u2009y). Ivan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0,\u20090), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains one number n \u2014 the length of sequence of commands entered by Ivan (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains the sequence itself \u2014 a string consisting of n characters. Each character can be U, D, L or R.", "output_spec": "Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.", "notes": null, "sample_inputs": ["4\nLDUR", "5\nRRRUU", "6\nLLRRRR"], "sample_outputs": ["4", "0", "4"], "tags": ["greedy"], "src_uid": "b9fa2bb8001bd064ede531a5281cfd8a", "difficulty": 1000, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the input, computes and prints the maximum number of commands that\n    could have been performed correctly while still ending at (0, 0).\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    i = 0\n    results = []\n    # Process possibly several independent test cases.\n    while i < len(data):\n        n = int(data[i])\n        i += 1\n\n        # Reassemble the command string; it may be split by spaces.\n        s = ''\n        while len(s) < n and i < len(data):\n            s += data[i]\n            i += 1\n        s = s[:n]                     # keep only the first n characters\n\n        cntU = s.count('U')\n        cntD = s.count('D')\n        cntL = s.count('L')\n        cntR = s.count('R')\n\n        ans = 2 * (min(cntU, cntD) + min(cntL, cntR))\n        results.append(str(ans))\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the input, computes and prints the maximum number of commands that\n    could have been performed correctly while still ending at (0, 0).\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    i = 0\n    results = []\n    # Process possibly several independent test cases.\n    while i < len(data):\n        n = int(data[i])\n        i += 1\n\n        # Reassemble the command string; it may be split by spaces.\n        s = ''\n        while len(s) < n and i < len(data):\n            s += data[i]\n            i += 1\n        s = s[:n]                     # keep only the first n characters\n\n        cntU = s.count('U')\n        cntD = s.count('D')\n        cntL = s.count('L')\n        cntR = s.count('R')\n\n        ans = 2 * (min(cntU, cntD) + min(cntL, cntR))\n        results.append(str(ans))\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "b9fa2bb8001bd064ede531a5281cfd8a"}
{"description": "You are given an array a consisting of n integers, and additionally an integer m. You have to choose some sequence of indices b1,\u2009b2,\u2009...,\u2009bk (1\u2009\u2264\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bk\u2009\u2264\u2009n) in such a way that the value of  is maximized. Chosen sequence can be empty.Print the maximum possible value of .", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200935, 1\u2009\u2264\u2009m\u2009\u2264\u2009109). The second line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109).", "output_spec": "Print the maximum possible value of .", "notes": "NoteIn the first example you can choose a sequence b\u2009=\u2009{1,\u20092}, so the sum  is equal to 7 (and that's 3 after taking it modulo 4).In the second example you can choose a sequence b\u2009=\u2009{3}.", "sample_inputs": ["4 4\n5 2 4 1", "3 20\n199 41 299"], "sample_outputs": ["3", "19"], "tags": ["bitmasks", "meet-in-the-middle", "divide and conquer"], "src_uid": "d3a8a3e69a55936ee33aedd66e5b7f4a", "difficulty": 1800, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "d3a8a3e69a55936ee33aedd66e5b7f4a"}
{"description": "Amr loves Geometry. One day he came up with a very interesting problem.Amr has a circle of radius r and center in point (x,\u2009y). He wants the circle center to be in new position (x',\u2009y').In one step Amr can put a pin to the border of the circle in a certain point, then rotate the circle around that pin by any angle and finally remove the pin.Help Amr to achieve his goal in minimum number of steps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "Input consists of 5 space-separated integers r, x, y, x' y' (1\u2009\u2264\u2009r\u2009\u2264\u2009105, \u2009-\u2009105\u2009\u2264\u2009x,\u2009y,\u2009x',\u2009y'\u2009\u2264\u2009105), circle radius, coordinates of original center of the circle and coordinates of destination center of the circle respectively.", "output_spec": "Output a single integer \u2014 minimum number of steps required to move the center of the circle to the destination point.", "notes": "NoteIn the first sample test the optimal way is to put a pin at point (0,\u20092) and rotate the circle by 180 degrees counter-clockwise (or clockwise, no matter).", "sample_inputs": ["2 0 0 0 4", "1 1 1 4 4", "4 5 6 5 6"], "sample_outputs": ["1", "3", "0"], "tags": ["geometry", "math"], "src_uid": "698da80c7d24252b57cca4e4f0ca7031", "difficulty": 1400, "source_codes": ["import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # input: r x y x' y'\n    r, x, y, x2, y2 = map(int, data[:5])\n\n    dx = x - x2\n    dy = y - y2\n    dist2 = dx * dx + dy * dy          # squared distance\n\n    if dist2 == 0:\n        print(0)\n        return\n\n    M = 2 * r                         # maximal distance per step\n    a = math.isqrt(dist2)              # floor(sqrt(dist2))\n\n    if a * a == dist2:                 # perfect square\n        ans = (a + M - 1) // M          # ceil(a / M)\n    else:                               # non\u2011perfect square\n        ans = (a // M) + 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # input: r x y x' y'\n    r, x, y, x2, y2 = map(int, data[:5])\n\n    dx = x - x2\n    dy = y - y2\n    dist2 = dx * dx + dy * dy          # squared distance\n\n    if dist2 == 0:\n        print(0)\n        return\n\n    M = 2 * r                         # maximal distance per step\n    a = math.isqrt(dist2)              # floor(sqrt(dist2))\n\n    if a * a == dist2:                 # perfect square\n        ans = (a + M - 1) // M          # ceil(a / M)\n    else:                               # non\u2011perfect square\n        ans = (a // M) + 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "698da80c7d24252b57cca4e4f0ca7031"}
{"description": "Drazil is playing a math game with Varda.Let's define  for positive integer x as a product of factorials of its digits. For example, .First, they choose a decimal number a consisting of n digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number x satisfying following two conditions:1. x doesn't contain neither digit 0 nor digit 1.2.  = .Help friends find such number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200915) \u2014 the number of digits in a. The second line contains n digits of a. There is at least one digit in a that is larger than 1. Number a may possibly contain leading zeroes.", "output_spec": "Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.", "notes": "NoteIn the first case, ", "sample_inputs": ["4\n1234", "3\n555"], "sample_outputs": ["33222", "555"], "tags": ["greedy", "math", "sortings", "dp", "implementation"], "src_uid": "60dbfc7a65702ae8bd4a587db1e06398", "difficulty": 1400, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the number a, builds the greatest integer x without 0 and 1\n    such that product of factorials of digits of x equals that of a,\n    and prints x.\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    n = int(data[0])                     # number of digits (not needed further)\n    # concatenate all remaining tokens and keep only the first n digits\n    a = ''.join(data[1:])[:n]\n\n    # replacement table \u2013 see Lemma 1\n    repl = {\n        '2': '2',\n        '3': '3',\n        '4': '322',\n        '5': '5',\n        '6': '53',\n        '7': '7',\n        '8': '7222',\n        '9': '7332',\n    }\n\n    parts = []\n    for ch in a:\n        if ch not in ('0', '1'):\n            parts.extend(repl[ch])\n\n    parts.sort(reverse=True)   # largest possible number\n    sys.stdout.write(''.join(parts))\n\nif __name__ == '__main__':\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the number a, builds the greatest integer x without 0 and 1\n    such that product of factorials of digits of x equals that of a,\n    and prints x.\n    \"\"\"\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    n = int(data[0])                     # number of digits (not needed further)\n    # concatenate all remaining tokens and keep only the first n digits\n    a = ''.join(data[1:])[:n]\n\n    # replacement table \u2013 see Lemma 1\n    repl = {\n        '2': '2',\n        '3': '3',\n        '4': '322',\n        '5': '5',\n        '6': '53',\n        '7': '7',\n        '8': '7222',\n        '9': '7332',\n    }\n\n    parts = []\n    for ch in a:\n        if ch not in ('0', '1'):\n            parts.extend(repl[ch])\n\n    parts.sort(reverse=True)   # largest possible number\n    sys.stdout.write(''.join(parts))\n\nif __name__ == '__main__':\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "60dbfc7a65702ae8bd4a587db1e06398"}
{"description": "Let's define the permutation of length n as an array p\u2009=\u2009[p1,\u2009p2,\u2009...,\u2009pn] consisting of n distinct integers from range from 1 to n. We say that this permutation maps value 1 into the value p1, value 2 into the value p2 and so on.Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of p as a collection of cycles forming p. For example, permutation p\u2009=\u2009[4,\u20091,\u20096,\u20092,\u20095,\u20093] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,\u20091,\u20096,\u20092,\u20095,\u20093] is (421)(5)(63).Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,\u20091,\u20096,\u20092,\u20095,\u20093] will become [4,\u20092,\u20091,\u20095,\u20096,\u20093].Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length n that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers n and k, print the permutation that was k-th on Kyoya's list.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line will contain two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950, 1\u2009\u2264\u2009k\u2009\u2264\u2009min{1018,\u2009l} where l is the length of the Kyoya's list).", "output_spec": "Print n space-separated integers, representing the permutation that is the answer for the question. ", "notes": "NoteThe standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1,\u20092,\u20093,\u20094], while the second permutation would be [1,\u20092,\u20094,\u20093].", "sample_inputs": ["4 3", "10 1"], "sample_outputs": ["1 3 2 4", "1 2 3 4 5 6 7 8 9 10"], "tags": ["greedy", "combinatorics", "binary search", "constructive algorithms", "math", "implementation"], "src_uid": "e03c6d3bb8cf9119530668765691a346", "difficulty": 1900, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "e03c6d3bb8cf9119530668765691a346"}
{"description": "You are given three sticks with positive integer lengths of a,\u2009b, and c centimeters. You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters. In particular, it is allowed not to increase the length of any stick.Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of centimeters in them.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains 4 integers a,\u2009b,\u2009c,\u2009l (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20093\u00b7105, 0\u2009\u2264\u2009l\u2009\u2264\u20093\u00b7105).", "output_spec": "Print a single integer \u2014 the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.", "notes": "NoteIn the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.", "sample_inputs": ["1 1 1 2", "1 2 3 1", "10 2 1 7"], "sample_outputs": ["4", "2", "0"], "tags": ["math", "combinatorics", "brute force", "dp", "implementation"], "src_uid": "185ff90a8b0ae0e2b75605f772589410", "difficulty": 2100, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "185ff90a8b0ae0e2b75605f772589410"}
{"description": "One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.", "output_spec": "Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.", "notes": "NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.", "sample_inputs": ["3 1", "2 3", "7 3"], "sample_outputs": ["1 1", "2 0", "3 2"], "tags": ["math", "implementation"], "src_uid": "775766790e91e539c1cfaa5030e5b955", "difficulty": 800, "source_codes": ["def solve(a: int, b: int):\n    \"\"\"\n    Returns the maximum number of days Vasya can wear different coloured socks\n    and the maximum subsequent days he can wear the same coloured socks.\n\n    Parameters\n    ----------\n    a : int\n        Number of red socks.\n    b : int\n        Number of blue socks.\n\n    Returns\n    -------\n    tuple[int, int]\n        (days with different colours, days with same colour)\n    \"\"\"\n    # Days when one red and one blue can be worn together.\n    different_days = min(a, b)\n\n    # After using the different pairs, only one colour may remain.\n    # Count how many pairs can be formed from the leftovers.\n    remaining = max(a, b) - different_days\n    same_days = remaining // 2\n\n    return different_days, same_days\n\n\nif __name__ == \"__main__\":\n    # Read the two integers from standard input.\n    a, b = map(int, input().split())\n\n    # Compute and output the answer.\n    d, s = solve(a, b)\n    print(d, s)"], "responses": ["\ndef solve(a: int, b: int):\n    \"\"\"\n    Returns the maximum number of days Vasya can wear different coloured socks\n    and the maximum subsequent days he can wear the same coloured socks.\n\n    Parameters\n    ----------\n    a : int\n        Number of red socks.\n    b : int\n        Number of blue socks.\n\n    Returns\n    -------\n    tuple[int, int]\n        (days with different colours, days with same colour)\n    \"\"\"\n    # Days when one red and one blue can be worn together.\n    different_days = min(a, b)\n\n    # After using the different pairs, only one colour may remain.\n    # Count how many pairs can be formed from the leftovers.\n    remaining = max(a, b) - different_days\n    same_days = remaining // 2\n\n    return different_days, same_days\n\n\nif __name__ == \"__main__\":\n    # Read the two integers from standard input.\n    a, b = map(int, input().split())\n\n    # Compute and output the answer.\n    d, s = solve(a, b)\n    print(d, s)\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "775766790e91e539c1cfaa5030e5b955"}
