{"description": "Iahub got bored, so he invented a game to be played on paper. He writes n integers a1,\u2009a2,\u2009...,\u2009an. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices i and j (1\u2009\u2264\u2009i\u2009\u2264\u2009j\u2009\u2264\u2009n) and flips all values ak for which their positions are in range [i,\u2009j] (that is i\u2009\u2264\u2009k\u2009\u2264\u2009j). Flip the value of x means to apply operation x\u2009=\u20091 - x.The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). In the second line of the input there are n integers: a1,\u2009a2,\u2009...,\u2009an. It is guaranteed that each of those n values is either 0 or 1.", "output_spec": "Print an integer \u2014 the maximal number of 1s that can be obtained after exactly one move. ", "notes": "NoteIn the first case, flip the segment from 2 to 5 (i\u2009=\u20092,\u2009j\u2009=\u20095). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].In the second case, flipping only the second and the third element (i\u2009=\u20092,\u2009j\u2009=\u20093) will turn all numbers into 1.", "sample_inputs": ["5\n1 0 0 1 0", "4\n1 0 0 1"], "sample_outputs": ["4", "4"], "tags": ["brute force", "dp", "implementation"], "src_uid": "9b543e07e805fe1dd8fa869d5d7c8b99", "difficulty": 1200, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the input, computes the maximal possible number of 1's after exactly\n    one flip, and prints the result.\n    \"\"\"\n    # read n\n    line = sys.stdin.readline()\n    if not line:\n        return\n    n = int(line.strip())\n    # read the array a\n    a_line = sys.stdin.readline()\n    a = list(map(int, a_line.strip().split()))\n    # safety: in case the input line contains fewer numbers,\n    # keep reading until we have n numbers (not needed for well\u2011formed tests)\n    while len(a) < n:\n        a += list(map(int, sys.stdin.readline().strip().split()))\n\n    total_ones = sum(a)\n\n    # transform: 0 -> +1, 1 -> -1\n    b = [1 if x == 0 else -1 for x in a]\n\n    # Kadane for non\u2011empty subarray\n    cur = max_gain = b[0]\n    for value in b[1:]:\n        cur = max(value, cur + value)\n        max_gain = max(max_gain, cur)\n\n    answer = total_ones + max_gain\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the input, computes the maximal possible number of 1's after exactly\n    one flip, and prints the result.\n    \"\"\"\n    # read n\n    line = sys.stdin.readline()\n    if not line:\n        return\n    n = int(line.strip())\n    # read the array a\n    a_line = sys.stdin.readline()\n    a = list(map(int, a_line.strip().split()))\n    # safety: in case the input line contains fewer numbers,\n    # keep reading until we have n numbers (not needed for well\u2011formed tests)\n    while len(a) < n:\n        a += list(map(int, sys.stdin.readline().strip().split()))\n\n    total_ones = sum(a)\n\n    # transform: 0 -> +1, 1 -> -1\n    b = [1 if x == 0 else -1 for x in a]\n\n    # Kadane for non\u2011empty subarray\n    cur = max_gain = b[0]\n    for value in b[1:]:\n        cur = max(value, cur + value)\n        max_gain = max(max_gain, cur)\n\n    answer = total_ones + max_gain\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "9b543e07e805fe1dd8fa869d5d7c8b99"}
{"description": "Gerald is very particular to eight point sets. He thinks that any decent eight point set must consist of all pairwise intersections of three distinct integer vertical straight lines and three distinct integer horizontal straight lines, except for the average of these nine points. In other words, there must be three integers x1,\u2009x2,\u2009x3 and three more integers y1,\u2009y2,\u2009y3, such that x1\u2009&lt;\u2009x2\u2009&lt;\u2009x3, y1\u2009&lt;\u2009y2\u2009&lt;\u2009y3 and the eight point set consists of all points (xi,\u2009yj) (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u20093), except for point (x2,\u2009y2).You have a set of eight points. Find out if Gerald can use this set?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input consists of eight lines, the i-th line contains two space-separated integers xi and yi (0\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009106). You do not have any other conditions for these points.", "output_spec": "In a single line print word \"respectable\", if the given set of points corresponds to Gerald's decency rules, and \"ugly\" otherwise.", "notes": null, "sample_inputs": ["0 0\n0 1\n0 2\n1 0\n1 2\n2 0\n2 1\n2 2", "0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0", "1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2"], "sample_outputs": ["respectable", "ugly", "ugly"], "tags": ["sortings"], "src_uid": "f3c96123334534056f26b96f90886807", "difficulty": 1400, "source_codes": ["import sys\n\ndef solve() -> None:\n    # ---------- read exactly eight points ----------\n    points = []\n    for _ in range(8):\n        line = sys.stdin.readline()\n        if not line:\n            break\n        a, b = map(int, line.split())\n        points.append((a, b))\n\n    if len(points) != 8:                     # not enough data\n        print(\"ugly\")\n        return\n\n    # ---------- basic validity ----------\n    point_set = set(points)\n    if len(point_set) != 8:                  # duplicate points -> not a set\n        print(\"ugly\")\n        return\n\n    # ---------- distinct coordinates ----------\n    xs = sorted({x for x, _ in point_set})\n    ys = sorted({y for _, y in point_set})\n    if len(xs) != 3 or len(ys) != 3:\n        print(\"ugly\")\n        return\n\n    # ---------- find the missing grid point ----------\n    missing = None\n    for x in xs:\n        for y in ys:\n            if (x, y) not in point_set:\n                missing = (x, y)\n                break\n        if missing is not None:\n            break\n\n    if missing is None:                     # all 9 points are present\n        print(\"ugly\")\n        return\n\n    # ---------- centre must be missing ----------\n    if missing[0] != xs[1] or missing[1] != ys[1]:\n        print(\"ugly\")\n        return\n\n    # ---------- all conditions satisfied ----------\n    print(\"respectable\")\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    # ---------- read exactly eight points ----------\n    points = []\n    for _ in range(8):\n        line = sys.stdin.readline()\n        if not line:\n            break\n        a, b = map(int, line.split())\n        points.append((a, b))\n\n    if len(points) != 8:                     # not enough data\n        print(\"ugly\")\n        return\n\n    # ---------- basic validity ----------\n    point_set = set(points)\n    if len(point_set) != 8:                  # duplicate points -> not a set\n        print(\"ugly\")\n        return\n\n    # ---------- distinct coordinates ----------\n    xs = sorted({x for x, _ in point_set})\n    ys = sorted({y for _, y in point_set})\n    if len(xs) != 3 or len(ys) != 3:\n        print(\"ugly\")\n        return\n\n    # ---------- find the missing grid point ----------\n    missing = None\n    for x in xs:\n        for y in ys:\n            if (x, y) not in point_set:\n                missing = (x, y)\n                break\n        if missing is not None:\n            break\n\n    if missing is None:                     # all 9 points are present\n        print(\"ugly\")\n        return\n\n    # ---------- centre must be missing ----------\n    if missing[0] != xs[1] or missing[1] != ys[1]:\n        print(\"ugly\")\n        return\n\n    # ---------- all conditions satisfied ----------\n    print(\"respectable\")\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "f3c96123334534056f26b96f90886807"}
{"description": "Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. Iahub has the following scheme of painting: he skips x\u2009-\u20091 consecutive bricks, then he paints the x-th one. That is, he'll paint bricks x, 2\u00b7x, 3\u00b7x and so on red. Similarly, Floyd skips y\u2009-\u20091 consecutive bricks, then he paints the y-th one. Hence he'll paint bricks y, 2\u00b7y, 3\u00b7y and so on pink.After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number a and Floyd has a lucky number b. Boys wonder how many bricks numbered no less than a and no greater than b are painted both red and pink. This is exactly your task: compute and print the answer to the question. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input will have a single line containing four integers in this order: x, y, a, b. (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20091000, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u20092\u00b7109, a\u2009\u2264\u2009b).", "output_spec": "Output a single integer \u2014 the number of bricks numbered no less than a and no greater than b that are painted both red and pink.", "notes": "NoteLet's look at the bricks from a to b (a\u2009=\u20096,\u2009b\u2009=\u200918). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18. ", "sample_inputs": ["2 3 6 18"], "sample_outputs": ["3"], "tags": ["math"], "src_uid": "c7aa8a95d5f8832015853cffa1374c48", "difficulty": 1200, "source_codes": ["import sys\nimport math\n\ndef count_common(x: int, y: int, a: int, b: int) -> int:\n    \"\"\"\n    Returns the number of integers in the closed interval [a, b]\n    that are divisible by both x and y.\n    \"\"\"\n    g = math.gcd(x, y)          # greatest common divisor\n    lcm = x // g * y            # least common multiple (safe order)\n    # multiples of LCM inside [a, b]\n    return b // lcm - (a - 1) // lcm\n\ndef solve() -> None:\n    \"\"\"\n    Reads four integers from standard input, computes and prints the answer.\n    The input may be on a single line or split over several lines,\n    therefore we keep reading until we have at least four numbers.\n    \"\"\"\n    data = []\n    while len(data) < 4:\n        line = input()\n        if not line:\n            break\n        data.extend(line.split())\n\n    # Take the first four integers (the problem guarantees exactly four)\n    x, y, a, b = map(int, data[:4])\n    print(count_common(x, y, a, b))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\nimport math\n\ndef count_common(x: int, y: int, a: int, b: int) -> int:\n    \"\"\"\n    Returns the number of integers in the closed interval [a, b]\n    that are divisible by both x and y.\n    \"\"\"\n    g = math.gcd(x, y)          # greatest common divisor\n    lcm = x // g * y            # least common multiple (safe order)\n    # multiples of LCM inside [a, b]\n    return b // lcm - (a - 1) // lcm\n\ndef solve() -> None:\n    \"\"\"\n    Reads four integers from standard input, computes and prints the answer.\n    The input may be on a single line or split over several lines,\n    therefore we keep reading until we have at least four numbers.\n    \"\"\"\n    data = []\n    while len(data) < 4:\n        line = input()\n        if not line:\n            break\n        data.extend(line.split())\n\n    # Take the first four integers (the problem guarantees exactly four)\n    x, y, a, b = map(int, data[:4])\n    print(count_common(x, y, a, b))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "c7aa8a95d5f8832015853cffa1374c48"}
{"description": "Mad scientist Mike is busy carrying out experiments in chemistry. Today he will attempt to join three atoms into one molecule.A molecule consists of atoms, with some pairs of atoms connected by atomic bonds. Each atom has a valence number \u2014 the number of bonds the atom must form with other atoms. An atom can form one or multiple bonds with any other atom, but it cannot form a bond with itself. The number of bonds of an atom in the molecule must be equal to its valence number.  Mike knows valence numbers of the three atoms. Find a molecule that can be built from these atoms according to the stated rules, or determine that it is impossible.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains three space-separated integers a, b and c (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009106) \u2014 the valence numbers of the given atoms.", "output_spec": "If such a molecule can be built, print three space-separated integers \u2014 the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).", "notes": "NoteThe first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.", "sample_inputs": ["1 1 2", "3 4 5", "4 1 1"], "sample_outputs": ["0 1 1", "1 3 2", "Impossible"], "tags": ["brute force", "math", "graphs"], "src_uid": "b3b986fddc3770fed64b878fa42ab1bc", "difficulty": 1200, "source_codes": ["function find_molecule(a, b, c):\n    if (a + b + c) is odd \u2192 return None\n    if a + b < c or a + c < b or b + c < a \u2192 return None\n    x = (a + b - c) // 2\n    y = (b + c - a) // 2\n    z = (a + c - b) // 2\n    return (x, y, z)\n\nmain:\n    read all integers from input\n    for every triple (a,b,c):\n        ans = find_molecule(a,b,c)\n        if ans is None \u2192 print \"Impossible\"\n        else           \u2192 print ans[0] ans[1] ans[2]"], "responses": ["\nfunction find_molecule(a, b, c):\n    if (a + b + c) is odd \u2192 return None\n    if a + b < c or a + c < b or b + c < a \u2192 return None\n    x = (a + b - c) // 2\n    y = (b + c - a) // 2\n    z = (a + c - b) // 2\n    return (x, y, z)\n\nmain:\n    read all integers from input\n    for every triple (a,b,c):\n        ans = find_molecule(a,b,c)\n        if ans is None \u2192 print \"Impossible\"\n        else           \u2192 print ans[0] ans[1] ans[2]\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "b3b986fddc3770fed64b878fa42ab1bc"}
{"description": "In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.You are given two strings s1, s2 and another string called virus. Your task is to find the longest common subsequence of s1 and s2, such that it doesn't contain virus as a substring.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "512 megabytes", "input_spec": "The input contains three strings in three separate lines: s1, s2 and virus (1\u2009\u2264\u2009|s1|,\u2009|s2|,\u2009|virus|\u2009\u2264\u2009100). Each string consists only of uppercase English letters.", "output_spec": "Output the longest common subsequence of s1 and s2 without virus as a substring. If there are multiple answers, any of them will be accepted.  If there is no valid common subsequence, output 0.", "notes": null, "sample_inputs": ["AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ", "AA\nA\nA"], "sample_outputs": ["ORZ", "0"], "tags": ["dp", "strings"], "src_uid": "391c2abbe862139733fcb997ba1629b8", "difficulty": 2000, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "391c2abbe862139733fcb997ba1629b8"}
{"description": "Jeff loves regular bracket sequences.Today Jeff is going to take a piece of paper and write out the regular bracket sequence, consisting of nm brackets. Let's number all brackets of this sequence from 0 to nm - 1 from left to right. Jeff knows that he is going to spend ai mod n liters of ink on the i-th bracket of the sequence if he paints it opened and bi mod n liters if he paints it closed.You've got sequences a, b and numbers n, m. What minimum amount of ink will Jeff need to paint a regular bracket sequence of length nm?Operation x mod y means taking the remainder after dividing number x by number y.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200920;\u00a01\u2009\u2264\u2009m\u2009\u2264\u2009107; m is even). The next line contains n integers: a0, a1, ..., an\u2009-\u20091 (1\u2009\u2264\u2009ai\u2009\u2264\u200910). The next line contains n integers: b0, b1, ..., bn\u2009-\u20091 (1\u2009\u2264\u2009bi\u2009\u2264\u200910). The numbers are separated by spaces.", "output_spec": "In a single line print the answer to the problem \u2014 the minimum required amount of ink in liters.", "notes": "NoteIn the first test the optimal sequence is: ()()()()()(), the required number of ink liters is 12.", "sample_inputs": ["2 6\n1 2\n2 1", "1 10000000\n2\n3"], "sample_outputs": ["12", "25000000"], "tags": ["dp", "matrices"], "src_uid": "f40900973f4ebeb6fdafd75ebe4e9601", "difficulty": 2500, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "f40900973f4ebeb6fdafd75ebe4e9601"}
{"description": "Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8\u2009\u00d7\u20098 table. A field is represented by a pair of integers (r,\u2009c) \u2014 the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:  A rook moves any number of fields horizontally or vertically.  A bishop moves any number of fields diagonally.  A king moves one field in any direction \u2014 horizontally, vertically or diagonally.     The pieces move like that Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (r1,\u2009c1) to field (r2,\u2009c2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input contains four integers r1,\u2009c1,\u2009r2,\u2009c2 (1\u2009\u2264\u2009r1,\u2009c1,\u2009r2,\u2009c2\u2009\u2264\u20098) \u2014 the coordinates of the starting and the final field. The starting field doesn't coincide with the final one. You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.", "output_spec": "Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (r1,\u2009c1) to field (r2,\u2009c2). If a piece cannot make such a move, print a 0 instead of the corresponding number.", "notes": null, "sample_inputs": ["4 3 1 6", "5 5 5 6"], "sample_outputs": ["2 1 3", "1 0 1"], "tags": ["math", "shortest paths", "graphs"], "src_uid": "7dbf58806db185f0fe70c00b60973f4b", "difficulty": 1100, "source_codes": ["import sys\n\ndef min_moves(r1: int, c1: int, r2: int, c2: int):\n    \"\"\"\n    Return a tuple (rook, bishop, king) with the minimal number of moves\n    for each piece to go from (r1, c1) to (r2, c2).\n    If the bishop cannot reach the target, its value is 0.\n    \"\"\"\n    # Rook\n    rook = 1 if r1 == r2 or c1 == c2 else 2\n\n    # Bishop\n    dr = abs(r1 - r2)\n    dc = abs(c1 - c2)\n    if (r1 + c1) % 2 != (r2 + c2) % 2:\n        bishop = 0                     # different colors \u2192 impossible\n    elif dr == dc:\n        bishop = 1                     # same diagonal\n    else:\n        bishop = 2                     # same color, needs two moves\n\n    # King\n    king = max(dr, dc)\n\n    return rook, bishop, king\n\n\ndef solve() -> None:\n    \"\"\"\n    Read the four coordinates from standard input and print the\n    minimal numbers of moves for rook, bishop, and king.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if len(data) < 4:\n        return\n    r1, c1, r2, c2 = map(int, data[:4])\n    rook, bishop, king = min_moves(r1, c1, r2, c2)\n    print(rook, bishop, king)\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef min_moves(r1: int, c1: int, r2: int, c2: int):\n    \"\"\"\n    Return a tuple (rook, bishop, king) with the minimal number of moves\n    for each piece to go from (r1, c1) to (r2, c2).\n    If the bishop cannot reach the target, its value is 0.\n    \"\"\"\n    # Rook\n    rook = 1 if r1 == r2 or c1 == c2 else 2\n\n    # Bishop\n    dr = abs(r1 - r2)\n    dc = abs(c1 - c2)\n    if (r1 + c1) % 2 != (r2 + c2) % 2:\n        bishop = 0                     # different colors \u2192 impossible\n    elif dr == dc:\n        bishop = 1                     # same diagonal\n    else:\n        bishop = 2                     # same color, needs two moves\n\n    # King\n    king = max(dr, dc)\n\n    return rook, bishop, king\n\n\ndef solve() -> None:\n    \"\"\"\n    Read the four coordinates from standard input and print the\n    minimal numbers of moves for rook, bishop, and king.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if len(data) < 4:\n        return\n    r1, c1, r2, c2 = map(int, data[:4])\n    rook, bishop, king = min_moves(r1, c1, r2, c2)\n    print(rook, bishop, king)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "7dbf58806db185f0fe70c00b60973f4b"}
{"description": "Cucumber boy is fan of Kyubeat, a famous music game.Kyubeat has 16 panels for playing arranged in 4\u2009\u00d7\u20094 table. When a panel lights up, he has to press that panel.Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most k panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer k (1\u2009\u2264\u2009k\u2009\u2264\u20095) \u2014 the number of panels Cucumber boy can press with his one hand. Next 4 lines contain 4 characters each (digits from 1 to 9, or period) \u2014 table of panels. If a digit i was written on the panel, it means the boy has to press that panel in time i. If period was written on the panel, he doesn't have to press that panel.", "output_spec": "Output \"YES\" (without quotes), if he is able to press all the panels in perfect timing. If not, output \"NO\" (without quotes).", "notes": "NoteIn the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.", "sample_inputs": ["1\n.135\n1247\n3468\n5789", "5\n..1.\n1111\n..1.\n..1.", "1\n....\n12.1\n.2..\n.2.."], "sample_outputs": ["YES", "YES", "NO"], "tags": ["implementation"], "src_uid": "5fdaf8ee7763cb5815f49c0c38398f16", "difficulty": 900, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads one or more test cases from standard input.\n    For each case:\n        - first line: integer k (1 \u2264 k \u2264 5)\n        - next four lines: a 4\u2011character string describing the board\n    Prints \"YES\" if every time instant needs at most 2*k panels,\n    otherwise prints \"NO\".\n    \"\"\"\n    results = []\n\n    while True:\n        # read the line containing k, skipping possible blank lines\n        try:\n            line = input()\n        except EOFError:\n            break\n        line = line.strip()\n        if not line:\n            continue          # skip empty lines\n        k = int(line)\n\n        cnt = [0] * 10        # indices 1..9 are used\n\n        # read the 4 rows of the board\n        for _ in range(4):\n            row = input().strip()\n            for ch in row:\n                if ch.isdigit():          # ignore '.' and any unexpected chars\n                    cnt[int(ch)] += 1\n\n        max_cnt = max(cnt)\n        results.append(\"YES\" if max_cnt <= 2 * k else \"NO\")\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads one or more test cases from standard input.\n    For each case:\n        - first line: integer k (1 \u2264 k \u2264 5)\n        - next four lines: a 4\u2011character string describing the board\n    Prints \"YES\" if every time instant needs at most 2*k panels,\n    otherwise prints \"NO\".\n    \"\"\"\n    results = []\n\n    while True:\n        # read the line containing k, skipping possible blank lines\n        try:\n            line = input()\n        except EOFError:\n            break\n        line = line.strip()\n        if not line:\n            continue          # skip empty lines\n        k = int(line)\n\n        cnt = [0] * 10        # indices 1..9 are used\n\n        # read the 4 rows of the board\n        for _ in range(4):\n            row = input().strip()\n            for ch in row:\n                if ch.isdigit():          # ignore '.' and any unexpected chars\n                    cnt[int(ch)] += 1\n\n        max_cnt = max(cnt)\n        results.append(\"YES\" if max_cnt <= 2 * k else \"NO\")\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "5fdaf8ee7763cb5815f49c0c38398f16"}
{"description": "Our bear's forest has a checkered field. The checkered field is an n\u2009\u00d7\u2009n table, the rows are numbered from 1 to n from top to bottom, the columns are numbered from 1 to n from left to right. Let's denote a cell of the field on the intersection of row x and column y by record (x,\u2009y). Each cell of the field contains growing raspberry, at that, the cell (x,\u2009y) of the field contains x\u2009+\u2009y raspberry bushes.The bear came out to walk across the field. At the beginning of the walk his speed is (dx,\u2009dy). Then the bear spends exactly t seconds on the field. Each second the following takes place:  Let's suppose that at the current moment the bear is in cell (x,\u2009y).  First the bear eats the raspberry from all the bushes he has in the current cell. After the bear eats the raspberry from k bushes, he increases each component of his speed by k. In other words, if before eating the k bushes of raspberry his speed was (dx,\u2009dy), then after eating the berry his speed equals (dx\u2009+\u2009k,\u2009dy\u2009+\u2009k).  Let's denote the current speed of the bear (dx,\u2009dy) (it was increased after the previous step). Then the bear moves from cell (x,\u2009y) to cell (((x\u2009+\u2009dx\u2009-\u20091)\u00a0mod\u00a0n)\u2009+\u20091,\u2009((y\u2009+\u2009dy\u2009-\u20091)\u00a0mod\u00a0n)\u2009+\u20091).  Then one additional raspberry bush grows in each cell of the field. You task is to predict the bear's actions. Find the cell he ends up in if he starts from cell (sx,\u2009sy). Assume that each bush has infinitely much raspberry and the bear will never eat all of it.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains six space-separated integers: n, sx, sy, dx, dy, t (1\u2009\u2264\u2009n\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009sx,\u2009sy\u2009\u2264\u2009n;\u00a0\u2009-\u2009100\u2009\u2264\u2009dx,\u2009dy\u2009\u2264\u2009100;\u00a00\u2009\u2264\u2009t\u2009\u2264\u20091018).", "output_spec": "Print two integers \u2014 the coordinates of the cell the bear will end up in after t seconds.", "notes": "NoteOperation a\u00a0mod\u00a0b means taking the remainder after dividing a by b. Note that the result of the operation is always non-negative. For example, (\u2009-\u20091)\u00a0mod\u00a03\u2009=\u20092.In the first sample before the first move the speed vector will equal (3,4) and the bear will get to cell (4,1). Before the second move the speed vector will equal (9,10) and he bear will get to cell (3,1). Don't forget that at the second move, the number of berry bushes increased by 1.In the second sample before the first move the speed vector will equal (1,1) and the bear will get to cell (1,1). Before the second move, the speed vector will equal (4,4) and the bear will get to cell (1,1). Don't forget that at the second move, the number of berry bushes increased by 1.", "sample_inputs": ["5 1 2 0 1 2", "1 1 1 -1 -1 2"], "sample_outputs": ["3 1", "1 1"], "tags": ["math", "matrices"], "src_uid": "ee9fa8be2ae05a4e831a4f608c0cc785", "difficulty": 2300, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "ee9fa8be2ae05a4e831a4f608c0cc785"}
{"description": "You will receive 3 points for solving this problem.Manao is designing the genetic code for a new type of algae to efficiently produce fuel. Specifically, Manao is focusing on a stretch of DNA that encodes one protein. The stretch of DNA is represented by a string containing only the characters 'A', 'T', 'G' and 'C'.Manao has determined that if the stretch of DNA contains a maximal sequence of consecutive identical nucleotides that is of even length, then the protein will be nonfunctional. For example, consider a protein described by DNA string \"GTTAAAG\". It contains four maximal sequences of consecutive identical nucleotides: \"G\", \"TT\", \"AAA\", and \"G\". The protein is nonfunctional because sequence \"TT\" has even length.Manao is trying to obtain a functional protein from the protein he currently has. Manao can insert additional nucleotides into the DNA stretch. Each additional nucleotide is a character from the set {'A', 'T', 'G', 'C'}. Manao wants to determine the minimum number of insertions necessary to make the DNA encode a functional protein.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The input consists of a single line, containing a string s of length n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). Each character of s will be from the set {'A', 'T', 'G', 'C'}. This problem doesn't have subproblems. You will get 3 points for the correct submission.", "output_spec": "The program should print on one line a single integer representing the minimum number of 'A', 'T', 'G', 'C' characters that are required to be inserted into the input string in order to make all runs of identical characters have odd length.", "notes": "NoteIn the first example, it is sufficient to insert a single nucleotide of any type between the two 'T's in the sequence to restore the functionality of the protein.", "sample_inputs": ["GTTAAAG", "AACCAACCAAAAC"], "sample_outputs": ["1", "5"], "tags": ["implementation", "two pointers"], "src_uid": "8b26ca1ca2b28166c3d25dceb1f3d49f", "difficulty": null, "source_codes": ["def min_insertions(s: str) -> int:\n    \"\"\"Return the minimal number of insertions required.\"\"\"\n    n = len(s)\n    i = 0\n    even_cnt = 0\n    while i < n:\n        j = i\n        # find the end of the current maximal run\n        while j < n and s[j] == s[i]:\n            j += 1\n        if (j - i) % 2 == 0:   # even length run\n            even_cnt += 1\n        i = j                  # start next run\n    return even_cnt\n\n\ndef solve() -> None:\n    # read the single DNA string\n    s = input().strip()\n    print(min_insertions(s))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\ndef min_insertions(s: str) -> int:\n    \"\"\"Return the minimal number of insertions required.\"\"\"\n    n = len(s)\n    i = 0\n    even_cnt = 0\n    while i < n:\n        j = i\n        # find the end of the current maximal run\n        while j < n and s[j] == s[i]:\n            j += 1\n        if (j - i) % 2 == 0:   # even length run\n            even_cnt += 1\n        i = j                  # start next run\n    return even_cnt\n\n\ndef solve() -> None:\n    # read the single DNA string\n    s = input().strip()\n    print(min_insertions(s))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "8b26ca1ca2b28166c3d25dceb1f3d49f"}
{"description": "The employees of the F company have lots of ways to entertain themselves. Today they invited a famous magician who shows a trick with plastic cups and a marble.The point is to trick the spectator's attention. Initially, the spectator stands in front of a line of n plastic cups. Then the magician places a small marble under one cup and shuffles the cups. Then the spectator should guess which cup hides the marble.But the head coder of the F company isn't easy to trick. When he saw the performance, he noticed several important facts:  each cup contains a mark \u2014 a number from 1 to n; all marks on the cups are distinct;  the magician shuffles the cups in m operations, each operation looks like that: take a cup marked xi, sitting at position yi in the row of cups (the positions are numbered from left to right, starting from 1) and shift it to the very beginning of the cup row (on the first position). When the head coder came home after work he wanted to re-do the trick. Unfortunately, he didn't remember the starting or the final position of the cups. He only remembered which operations the magician performed. Help the coder: given the operations in the order they were made find at least one initial permutation of the cups that can go through the described operations in the given order. Otherwise, state that such permutation doesn't exist.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106). Each of the next m lines contains a couple of integers. The i-th line contains integers xi, yi (1\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009n) \u2014 the description of the i-th operation of the magician. Note that the operations are given in the order in which the magician made them and the coder wants to make them in the same order.", "output_spec": "If the described permutation doesn't exist (the programmer remembered wrong operations), print -1. Otherwise, print n distinct integers, each from 1 to n: the i-th number should represent the mark on the cup that initially is in the row in position i. If there are multiple correct answers, you should print the lexicographically minimum one.", "notes": null, "sample_inputs": ["2 1\n2 1", "3 2\n1 2\n1 1", "3 3\n1 3\n2 3\n1 3"], "sample_outputs": ["2 1", "2 1 3", "-1"], "tags": ["data structures"], "src_uid": "a2616b1681f30ce4b2a5fdc81cf52b50", "difficulty": 2200, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "a2616b1681f30ce4b2a5fdc81cf52b50"}
{"description": "Let's assume that set S consists of m distinct intervals [l1,\u2009r1], [l2,\u2009r2], ..., [lm,\u2009rm] (1\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u2009n; li,\u2009ri are integers).Let's assume that f(S) is the maximum number of intervals that you can choose from the set S, such that every two of them do not intersect. We assume that two intervals, [l1,\u2009r1] and [l2,\u2009r2], intersect if there is an integer x, which meets two inequalities: l1\u2009\u2264\u2009x\u2009\u2264\u2009r1 and l2\u2009\u2264\u2009x\u2009\u2264\u2009r2.Sereja wonders, how many sets S are there, such that f(S)\u2009=\u2009k? Count this number modulo 1000000007 (109\u2009+\u20097).", "input_from": "standard input", "output_to": "standard output", "time_limit": "1.5 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u2009500;\u00a00\u2009\u2264\u2009k\u2009\u2264\u2009500).", "output_spec": "In a single line, print the answer to the problem modulo 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["3 1", "3 2", "2 0", "2 2"], "sample_outputs": ["23", "32", "1", "2"], "tags": ["dp"], "src_uid": "111673158df2e37ac6c019bb99225ccb", "difficulty": 2500, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "111673158df2e37ac6c019bb99225ccb"}
{"description": "Iahub is training for the IOI. What is a better way to train than playing a Zuma-like game? There are n balls put in a row. Each ball is colored in one of k colors. Initially the row doesn't contain three or more contiguous balls with the same color. Iahub has a single ball of color x. He can insert his ball at any position in the row (probably, between two other balls). If at any moment there are three or more contiguous balls of the same color in the row, they are destroyed immediately. This rule is applied multiple times, until there are no more sets of 3 or more contiguous balls of the same color. For example, if Iahub has the row of balls [black, black, white, white, black, black] and a white ball, he can insert the ball between two white balls. Thus three white balls are destroyed, and then four black balls become contiguous, so all four balls are destroyed. The row will not contain any ball in the end, so Iahub can destroy all 6 balls.Iahub wants to destroy as many balls as possible. You are given the description of the row of balls, and the color of Iahub's ball. Help Iahub train for the IOI by telling him the maximum number of balls from the row he can destroy.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of input contains three integers: n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), k (1\u2009\u2264\u2009k\u2009\u2264\u2009100) and x (1\u2009\u2264\u2009x\u2009\u2264\u2009k). The next line contains n space-separated integers c1,\u2009c2,\u2009...,\u2009cn (1\u2009\u2264\u2009ci\u2009\u2264\u2009k). Number ci means that the i-th ball in the row has color ci. It is guaranteed that the initial row of balls will never contain three or more contiguous balls of the same color. ", "output_spec": "Print a single integer \u2014 the maximum number of balls Iahub can destroy.", "notes": null, "sample_inputs": ["6 2 2\n1 1 2 2 1 1", "1 1 1\n1"], "sample_outputs": ["6", "0"], "tags": ["brute force", "two pointers"], "src_uid": "d73d9610e3800817a3109314b1e6f88c", "difficulty": 1400, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "d73d9610e3800817a3109314b1e6f88c"}
{"description": "Ann has recently started commuting by subway. We know that a one ride subway ticket costs a rubles. Besides, Ann found out that she can buy a special ticket for m rides (she can buy it several times). It costs b rubles. Ann did the math; she will need to use subway n times. Help Ann, tell her what is the minimum sum of money she will have to spend to make n rides?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains four space-separated integers n, m, a, b (1\u2009\u2264\u2009n,\u2009m,\u2009a,\u2009b\u2009\u2264\u20091000) \u2014 the number of rides Ann has planned, the number of rides covered by the m ride ticket, the price of a one ride ticket and the price of an m ride ticket. ", "output_spec": "Print a single integer \u2014 the minimum sum in rubles that Ann will need to spend.", "notes": "NoteIn the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three m ride tickets.", "sample_inputs": ["6 2 1 2", "5 2 2 3"], "sample_outputs": ["6", "8"], "tags": ["implementation"], "src_uid": "faa343ad6028c5a069857a38fa19bb24", "difficulty": 1200, "source_codes": ["def min_cost(n: int, m: int, a: int, b: int) -> int:\n    \"\"\"\n    Return the minimal amount of money needed to make exactly n rides.\n    \"\"\"\n    # 1) only single tickets\n    cost_single = n * a\n\n    # 2) full m\u2011ride tickets + possible leftovers as single tickets\n    cost_comb = (n // m) * b + (n % m) * a\n\n    # 3) enough m\u2011ride tickets to cover everything (may waste rides)\n    cost_over = ((n + m - 1) // m) * b   # ceil(n / m) * b\n\n    return min(cost_single, cost_comb, cost_over)\n\n\ndef solve() -> None:\n    # read the four integers from standard input\n    n, m, a, b = map(int, input().split())\n    # compute and output the answer\n    print(min_cost(n, m, a, b))\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\ndef min_cost(n: int, m: int, a: int, b: int) -> int:\n    \"\"\"\n    Return the minimal amount of money needed to make exactly n rides.\n    \"\"\"\n    # 1) only single tickets\n    cost_single = n * a\n\n    # 2) full m\u2011ride tickets + possible leftovers as single tickets\n    cost_comb = (n // m) * b + (n % m) * a\n\n    # 3) enough m\u2011ride tickets to cover everything (may waste rides)\n    cost_over = ((n + m - 1) // m) * b   # ceil(n / m) * b\n\n    return min(cost_single, cost_comb, cost_over)\n\n\ndef solve() -> None:\n    # read the four integers from standard input\n    n, m, a, b = map(int, input().split())\n    # compute and output the answer\n    print(min_cost(n, m, a, b))\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "faa343ad6028c5a069857a38fa19bb24"}
{"description": "Pasha has a positive integer a without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.Help Pasha count the maximum number he can get if he has the time to make at most k swaps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains two integers a and k (1\u2009\u2264\u2009a\u2009\u2264\u20091018;\u00a00\u2009\u2264\u2009k\u2009\u2264\u2009100).", "output_spec": "Print the maximum number that Pasha can get if he makes at most k swaps.", "notes": null, "sample_inputs": ["1990 1", "300 0", "1034 2", "9090000078001234 6"], "sample_outputs": ["9190", "300", "3104", "9907000008001234"], "tags": ["greedy"], "src_uid": "e56f6c343167745821f0b18dcf0d0cde", "difficulty": 1400, "source_codes": ["import sys\n\ndef solve() -> None:\n    # read the whole input, split into tokens\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    a_str = data[0]                     # keep as string, order matters\n    k = int(data[1]) if len(data) > 1 else 0\n\n    digits = list(a_str)\n    n = len(digits)\n    i = 0\n\n    # greedy placement from left to right\n    while i < n - 1 and k > 0:\n        # farthest index we can bring to position i\n        end = min(i + k, n - 1)\n\n        # find the largest reachable digit, leftmost in case of ties\n        max_pos = i\n        max_digit = digits[i]\n        for j in range(i + 1, end + 1):\n            if digits[j] > max_digit:\n                max_digit = digits[j]\n                max_pos = j\n\n        # bring the chosen digit to position i\n        if max_pos != i:\n            digit = digits.pop(max_pos)   # remove it\n            digits.insert(i, digit)       # insert at i\n            k -= (max_pos - i)            # used swaps\n\n        i += 1\n\n    # output the result (newline for safety)\n    sys.stdout.write(''.join(digits) + '\\n')\n\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    # read the whole input, split into tokens\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    a_str = data[0]                     # keep as string, order matters\n    k = int(data[1]) if len(data) > 1 else 0\n\n    digits = list(a_str)\n    n = len(digits)\n    i = 0\n\n    # greedy placement from left to right\n    while i < n - 1 and k > 0:\n        # farthest index we can bring to position i\n        end = min(i + k, n - 1)\n\n        # find the largest reachable digit, leftmost in case of ties\n        max_pos = i\n        max_digit = digits[i]\n        for j in range(i + 1, end + 1):\n            if digits[j] > max_digit:\n                max_digit = digits[j]\n                max_pos = j\n\n        # bring the chosen digit to position i\n        if max_pos != i:\n            digit = digits.pop(max_pos)   # remove it\n            digits.insert(i, digit)       # insert at i\n            k -= (max_pos - i)            # used swaps\n\n        i += 1\n\n    # output the result (newline for safety)\n    sys.stdout.write(''.join(digits) + '\\n')\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "e56f6c343167745821f0b18dcf0d0cde"}
{"description": "This winter is so cold in Nvodsk! A group of n friends decided to buy k bottles of a soft drink called \"Take-It-Light\" to warm up a bit. Each bottle has l milliliters of the drink. Also they bought c limes and cut each of them into d slices. After that they found p grams of salt.To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first and only line contains positive integers n, k, l, c, d, p, nl, np, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.", "output_spec": "Print a single integer \u2014 the number of toasts each friend can make.", "notes": "NoteA comment to the first sample: Overall the friends have 4\u2009*\u20095\u2009=\u200920 milliliters of the drink, it is enough to make 20\u2009/\u20093\u2009=\u20096 toasts. The limes are enough for 10\u2009*\u20098\u2009=\u200980 toasts and the salt is enough for 100\u2009/\u20091\u2009=\u2009100 toasts. However, there are 3 friends in the group, so the answer is min(6,\u200980,\u2009100)\u2009/\u20093\u2009=\u20092.", "sample_inputs": ["3 4 5 10 8 100 3 1", "5 100 10 1 19 90 4 3", "10 1000 1000 25 23 1 50 1"], "sample_outputs": ["2", "3", "0"], "tags": ["math", "implementation"], "src_uid": "67410b7d36b9d2e6a97ca5c7cff317c1", "difficulty": 800, "source_codes": ["import sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the single test case (or any number of test cases) from standard input.\n    Each test case consists of eight positive integers:\n    n  k  l  c  d  p  nl  np\n\n    Prints the maximum number of toasts each friend can make.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return                     # empty input\n\n    numbers = list(map(int, data))\n    results = []\n\n    # Process each block of eight integers as a separate test case\n    for i in range(0, len(numbers), 8):\n        block = numbers[i:i + 8]\n        if len(block) < 8:\n            break                  # ignore an incomplete trailing block\n        n, k, l, c, d, p, nl, np = block\n\n        # Maximum toasts limited by each ingredient\n        drink_toasts = (k * l) // nl   # drink\n        lime_toasts  = c * d           # lime slices (one slice per toast)\n        salt_toasts  = p // np         # salt\n\n        total_toasts = min(drink_toasts, lime_toasts, salt_toasts)\n        per_friend   = total_toasts // n\n\n        results.append(str(per_friend))\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()"], "responses": ["\nimport sys\n\ndef solve() -> None:\n    \"\"\"\n    Reads the single test case (or any number of test cases) from standard input.\n    Each test case consists of eight positive integers:\n    n  k  l  c  d  p  nl  np\n\n    Prints the maximum number of toasts each friend can make.\n    \"\"\"\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return                     # empty input\n\n    numbers = list(map(int, data))\n    results = []\n\n    # Process each block of eight integers as a separate test case\n    for i in range(0, len(numbers), 8):\n        block = numbers[i:i + 8]\n        if len(block) < 8:\n            break                  # ignore an incomplete trailing block\n        n, k, l, c, d, p, nl, np = block\n\n        # Maximum toasts limited by each ingredient\n        drink_toasts = (k * l) // nl   # drink\n        lime_toasts  = c * d           # lime slices (one slice per toast)\n        salt_toasts  = p // np         # salt\n\n        total_toasts = min(drink_toasts, lime_toasts, salt_toasts)\n        per_friend   = total_toasts // n\n\n        results.append(str(per_friend))\n\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()\n\n\n"], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": true, "language": "Python3", "task_id": "67410b7d36b9d2e6a97ca5c7cff317c1"}
{"description": "Lavrenty, a baker, is going to make several buns with stuffings and sell them.Lavrenty has n grams of dough as well as m different stuffing types. The stuffing types are numerated from 1 to m. Lavrenty knows that he has ai grams left of the i-th stuffing. It takes exactly bi grams of stuffing i and ci grams of dough to cook a bun with the i-th stuffing. Such bun can be sold for di tugriks.Also he can make buns without stuffings. Each of such buns requires c0 grams of dough and it can be sold for d0 tugriks. So Lavrenty can cook any number of buns with different stuffings or without it unless he runs out of dough and the stuffings. Lavrenty throws away all excess material left after baking.Find the maximum number of tugriks Lavrenty can earn.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains 4 integers n, m, c0 and d0 (1\u2009\u2264\u2009n\u2009\u2264\u20091000, 1\u2009\u2264\u2009m\u2009\u2264\u200910, 1\u2009\u2264\u2009c0,\u2009d0\u2009\u2264\u2009100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1\u2009\u2264\u2009ai,\u2009bi,\u2009ci,\u2009di\u2009\u2264\u2009100).", "output_spec": "Print the only number \u2014 the maximum number of tugriks Lavrenty can earn.", "notes": "NoteTo get the maximum number of tugriks in the first sample, you need to cook 2 buns with stuffing 1, 4 buns with stuffing 2 and a bun without any stuffing.In the second sample Lavrenty should cook 4 buns without stuffings.", "sample_inputs": ["10 2 2 1\n7 3 2 100\n12 3 1 10", "100 1 25 50\n15 5 20 10"], "sample_outputs": ["241", "200"], "tags": ["dp"], "src_uid": "4e166b8b44427b1227e0f811161d3a6f", "difficulty": 1700, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "4e166b8b44427b1227e0f811161d3a6f"}
{"description": "Little Petya loves training spiders. Petya has a board n\u2009\u00d7\u2009m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200940,\u2009n\u00b7m\u2009\u2264\u200940) \u2014 the board sizes.", "output_spec": "In the first line print the maximum number of cells without spiders.", "notes": "NoteIn the first sample the only possible answer is:sIn the second sample one of the possible solutions is: rdlruls denotes command \"stay idle\", l, r, d, u denote commands \"crawl left\", \"crawl right\", \"crawl down\", \"crawl up\", correspondingly.", "sample_inputs": ["1 1", "2 3"], "sample_outputs": ["0", "4"], "tags": ["bitmasks", "dp", "dsu"], "src_uid": "097674b4dd696b30e102938f71dd39b9", "difficulty": 2100, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "api_calls": 8, "is_solved": false, "language": "Python3", "task_id": "097674b4dd696b30e102938f71dd39b9"}
