{"description": "You are given a string $$$s$$$ consisting of lowercase Latin letters. Let the length of $$$s$$$ be $$$|s|$$$. You may perform several operations on this string.In one operation, you can choose some index $$$i$$$ and remove the $$$i$$$-th character of $$$s$$$ ($$$s_i$$$) if at least one of its adjacent characters is the previous letter in the Latin alphabet for $$$s_i$$$. For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index $$$i$$$ should satisfy the condition $$$1 \\le i \\le |s|$$$ during each operation.For the character $$$s_i$$$ adjacent characters are $$$s_{i-1}$$$ and $$$s_{i+1}$$$. The first and the last characters of $$$s$$$ both have only one adjacent character (unless $$$|s| = 1$$$).Consider the following example. Let $$$s=$$$ bacabcab.  During the first move, you can remove the first character $$$s_1=$$$ b because $$$s_2=$$$ a. Then the string becomes $$$s=$$$ acabcab.  During the second move, you can remove the fifth character $$$s_5=$$$ c because $$$s_4=$$$ b. Then the string becomes $$$s=$$$ acabab.  During the third move, you can remove the sixth character $$$s_6=$$$'b' because $$$s_5=$$$ a. Then the string becomes $$$s=$$$ acaba.  During the fourth move, the only character you can remove is $$$s_4=$$$ b, because $$$s_3=$$$ a (or $$$s_5=$$$ a). The string becomes $$$s=$$$ acaa and you cannot do anything with it. Your task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains one integer $$$|s|$$$ ($$$1 \\le |s| \\le 100$$$) \u2014 the length of $$$s$$$. The second line of the input contains one string $$$s$$$ consisting of $$$|s|$$$ lowercase Latin letters.", "output_spec": "Print one integer \u2014 the maximum possible number of characters you can remove if you choose the sequence of moves optimally.", "notes": "NoteThe first example is described in the problem statement. Note that the sequence of moves provided in the statement is not the only, but it can be shown that the maximum possible answer to this test is $$$4$$$.In the second example, you can remove all but one character of $$$s$$$. The only possible answer follows.  During the first move, remove the third character $$$s_3=$$$ d, $$$s$$$ becomes bca.  During the second move, remove the second character $$$s_2=$$$ c, $$$s$$$ becomes ba.  And during the third move, remove the first character $$$s_1=$$$ b, $$$s$$$ becomes a. ", "sample_inputs": ["8\nbacabcab", "4\nbcda", "6\nabbbbb"], "sample_outputs": ["4", "3", "5"], "tags": ["brute force", "constructive algorithms", "strings", "greedy"], "src_uid": "9ce37bc2d361f5bb8a0568fb479b8a38", "difficulty": 1600, "source_codes": ["\ndef max_removals(s):\n    # Convert string to list for easier manipulation\n    chars = list(s)\n    removed = 0\n    \n    # Keep trying to remove characters until no more removals are possible\n    changed = True\n    while changed and len(chars) > 1:\n        changed = False\n        # Try to find a character that can be removed\n        i = 0\n        while i < len(chars):\n            can_remove = False\n            # Check if character has left neighbor that is its predecessor\n            if i > 0 and ord(chars[i]) == ord(chars[i-1]) + 1:\n                can_remove = True\n            # Check if character has right neighbor that is its predecessor\n            elif i < len(chars) - 1 and ord(chars[i]) == ord(chars[i+1]) + 1:\n                can_remove = True\n            \n            if can_remove:\n                # Remove the character\n                chars.pop(i)\n                removed += 1\n                changed = True\n                # Don't increment i since we removed a character\n            else:\n                i += 1\n    \n    return removed\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Solve and print result\nresult = max_removals(s)\nprint(result)\n\n\n"], "responses": ["\ndef max_removals(s):\n    # Convert string to list for easier manipulation\n    chars = list(s)\n    removed = 0\n    \n    # Keep trying to remove characters until no more removals are possible\n    changed = True\n    while changed and len(chars) > 1:\n        changed = False\n        # Try to find a character that can be removed\n        i = 0\n        while i < len(chars):\n            can_remove = False\n            # Check if character has left neighbor that is its predecessor\n            if i > 0 and ord(chars[i]) == ord(chars[i-1]) + 1:\n                can_remove = True\n            # Check if character has right neighbor that is its predecessor\n            elif i < len(chars) - 1 and ord(chars[i]) == ord(chars[i+1]) + 1:\n                can_remove = True\n            \n            if can_remove:\n                # Remove the character\n                chars.pop(i)\n                removed += 1\n                changed = True\n                # Don't increment i since we removed a character\n            else:\n                i += 1\n    \n    return removed\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Solve and print result\nresult = max_removals(s)\nprint(result)\n\n\n"], "prompt_tokens": [5227], "completion_tokens": [1747], "no_of_try": 1, "api_calls": 4, "is_solved": false, "language": "Python3", "task_id": "9ce37bc2d361f5bb8a0568fb479b8a38"}
{"description": "You can not just take the file and send it. When Polycarp trying to send a file in the social network \"Codehorses\", he encountered an unexpected problem. If the name of the file contains three or more \"x\" (lowercase Latin letters \"x\") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.Determine the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. Print 0 if the file name does not initially contain a forbidden substring \"xxx\".You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $$$1$$$. For example, if you delete the character in the position $$$2$$$ from the string \"exxxii\", then the resulting string is \"exxii\".", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains integer $$$n$$$ $$$(3 \\le n \\le 100)$$$ \u2014 the length of the file name. The second line contains a string of length $$$n$$$ consisting of lowercase Latin letters only \u2014 the file name.", "output_spec": "Print the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. If initially the file name dost not contain a forbidden substring \"xxx\", print 0.", "notes": "NoteIn the first example Polycarp tried to send a file with name contains number $$$33$$$, written in Roman numerals. But he can not just send the file, because it name contains three letters \"x\" in a row. To send the file he needs to remove any one of this letters.", "sample_inputs": ["6\nxxxiii", "5\nxxoxx", "10\nxxxxxxxxxx"], "sample_outputs": ["1", "0", "8"], "tags": ["strings", "greedy"], "src_uid": "8de14db41d0acee116bd5d8079cb2b02", "difficulty": 800, "source_codes": ["\ndef min_removals(filename):\n    n = len(filename)\n    removals = 0\n    i = 0\n    \n    while i < n:\n        if filename[i] == 'x':\n            # Count consecutive x's\n            count = 0\n            j = i\n            while j < n and filename[j] == 'x':\n                count += 1\n                j += 1\n            \n            # If we have 3 or more consecutive x's, we need to remove (count - 2)\n            if count >= 3:\n                removals += count - 2\n            \n            # Move to the next non-x character\n            i = j\n        else:\n            i += 1\n    \n    return removals\n\n# Read input\nn = int(input())\nfilename = input().strip()\n\n# Calculate and print result\nresult = min_removals(filename)\nprint(result)\n\n\n"], "responses": ["\ndef min_removals(filename):\n    n = len(filename)\n    removals = 0\n    i = 0\n    \n    while i < n:\n        if filename[i] == 'x':\n            # Count consecutive x's\n            count = 0\n            j = i\n            while j < n and filename[j] == 'x':\n                count += 1\n                j += 1\n            \n            # If we have 3 or more consecutive x's, we need to remove (count - 2)\n            if count >= 3:\n                removals += count - 2\n            \n            # Move to the next non-x character\n            i = j\n        else:\n            i += 1\n    \n    return removals\n\n# Read input\nn = int(input())\nfilename = input().strip()\n\n# Calculate and print result\nresult = min_removals(filename)\nprint(result)\n\n\n"], "prompt_tokens": [3382], "completion_tokens": [917], "no_of_try": 1, "api_calls": 4, "is_solved": false, "language": "Python3", "task_id": "8de14db41d0acee116bd5d8079cb2b02"}
{"description": "Pak Chanek plans to build a garage. He wants the garage to consist of a square and a right triangle that are arranged like the following illustration.  Define $$$a$$$ and $$$b$$$ as the lengths of two of the sides in the right triangle as shown in the illustration. An integer $$$x$$$ is suitable if and only if we can construct a garage with assigning positive integer values for the lengths $$$a$$$ and $$$b$$$ ($$$a&lt;b$$$) so that the area of the square at the bottom is exactly $$$x$$$. As a good friend of Pak Chanek, you are asked to help him find the $$$N$$$-th smallest suitable number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "128 megabytes", "input_spec": "The only line contains a single integer $$$N$$$ ($$$1 \\leq N \\leq 10^9$$$).", "output_spec": "An integer that represents the $$$N$$$-th smallest suitable number.", "notes": "NoteThe $$$3$$$-rd smallest suitable number is $$$7$$$. A square area of $$$7$$$ can be obtained by assigning $$$a=3$$$ and $$$b=4$$$.", "sample_inputs": ["3"], "sample_outputs": ["7"], "tags": ["geometry", "math", "binary search"], "src_uid": "d0a8604b78ba19ab769fd1ec90a72e4e", "difficulty": 1500, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "d0a8604b78ba19ab769fd1ec90a72e4e"}
{"description": "A chainword is a special type of crossword. As most of the crosswords do, it has cells that you put the letters in and some sort of hints to what these letters should be.The letter cells in a chainword are put in a single row. We will consider chainwords of length $$$m$$$ in this task.A hint to a chainword is a sequence of segments such that the segments don't intersect with each other and cover all $$$m$$$ letter cells. Each segment contains a description of the word in the corresponding cells.The twist is that there are actually two hints: one sequence is the row above the letter cells and the other sequence is the row below the letter cells. When the sequences are different, they provide a way to resolve the ambiguity in the answers.You are provided with a dictionary of $$$n$$$ words, each word consists of lowercase Latin letters. All words are pairwise distinct.An instance of a chainword is the following triple:   a string of $$$m$$$ lowercase Latin letters;  the first hint: a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary;  the second hint: another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary. Note that the sequences of segments don't necessarily have to be distinct.Two instances of chainwords are considered different if they have different strings, different first hints or different second hints.Count the number of different instances of chainwords. Since the number might be pretty large, output it modulo $$$998\\,244\\,353$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 8$$$, $$$1 \\le m \\le 10^9$$$)\u00a0\u2014 the number of words in the dictionary and the number of letter cells. Each of the next $$$n$$$ lines contains a word\u00a0\u2014 a non-empty string of no more than $$$5$$$ lowercase Latin letters. All words are pairwise distinct. ", "output_spec": "Print a single integer\u00a0\u2014 the number of different instances of chainwords of length $$$m$$$ for the given dictionary modulo $$$998\\,244\\,353$$$.", "notes": "NoteHere are all the instances of the valid chainwords for the first example:   The red lines above the letters denote the segments of the first hint, the blue lines below the letters denote the segments of the second hint.In the second example the possible strings are: \"abab\", \"abcd\", \"cdab\" and \"cdcd\". All the hints are segments that cover the first two letters and the last two letters.", "sample_inputs": ["3 5\nababa\nab\na", "2 4\nab\ncd", "5 100\na\naa\naaa\naaaa\naaaaa"], "sample_outputs": ["11", "4", "142528942"], "tags": ["strings", "string suffix structures", "matrices", "data structures", "brute force", "dp"], "src_uid": "711d15e11016d0164fb2b0c3756e4857", "difficulty": 2700, "source_codes": [""], "responses": [""], "prompt_tokens": [3248], "completion_tokens": [1096], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "711d15e11016d0164fb2b0c3756e4857"}
{"description": "Little Johnny Bubbles enjoys spending hours in front of his computer playing video games. His favorite game is Bubble Strike, fast-paced bubble shooting online game for two players.Each game is set in one of the N maps, each having different terrain configuration. First phase of each game decides on which map the game will be played. The game system randomly selects three maps and shows them to the players. Each player must pick one of those three maps to be discarded. The game system then randomly selects one of the maps that were not picked by any of the players and starts the game.Johnny is deeply enthusiastic about the game and wants to spend some time studying maps, thus increasing chances to win games played on those maps. However, he also needs to do his homework, so he does not have time to study all the maps. That is why he asked himself the following question: \"What is the minimum number of maps I have to study, so that the probability to play one of those maps is at least $$$P$$$\"?Can you help Johnny find the answer for this question? You can assume Johnny's opponents do not know him, and they will randomly pick maps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers $$$N$$$ ($$$3$$$ $$$\\leq$$$ $$$N$$$ $$$\\leq$$$ $$$10^{3}$$$) and $$$P$$$ ($$$0$$$ $$$\\leq$$$ $$$P$$$ $$$\\leq$$$ $$$1$$$) \u2013 total number of maps in the game and probability to play map Johnny has studied. $$$P$$$ will have at most four digits after the decimal point.", "output_spec": "Output contains one integer number \u2013 minimum number of maps Johnny has to study.", "notes": null, "sample_inputs": ["7 1.0000"], "sample_outputs": ["6"], "tags": ["combinatorics", "binary search", "ternary search", "probabilities", "math"], "src_uid": "788ed59a964264bd0e755e155a37e14d", "difficulty": 2000, "source_codes": ["\nfrom decimal import Decimal, getcontext\nimport math\n\n# Set precision for decimal calculations\ngetcontext().prec = 20\n\ndef calculate_probability(N, k):\n    \"\"\"\n    Calculate the probability of playing a studied map when Johnny studies k maps out of N total maps.\n    \"\"\"\n    if k >= N:\n        return Decimal(1.0)\n    \n    if k == 0:\n        return Decimal(0.0)\n    \n    if N < 3:\n        return Decimal(0.0)\n    \n    total_prob = Decimal(0.0)\n    total_combinations = Decimal(0.0)\n    \n    # Iterate through all possible combinations of 3 maps selected initially\n    # Let i be the number of studied maps in the initial 3 selected maps\n    for i in range(max(0, 3 - (N - k)), min(3, k) + 1):\n        # Number of ways to choose i studied maps from k studied maps\n        if k >= i and (N-k) >= (3-i):\n            studied_ways = math.comb(k, i)\n            # Number of ways to choose (3-i) unstudied maps from (N-k) unstudied maps\n            unstudied_ways = math.comb(N - k, 3 - i)\n            # Total ways to form such a combination\n            combinations = studied_ways * unstudied_ways\n        else:\n            continue\n            \n        total_combinations += Decimal(combinations)\n        \n        # For each such combination, calculate probability of playing a studied map\n        studied_in_selection = i\n        unstudied_in_selection = 3 - i\n        \n        # Johnny's strategy: discard an unstudied map if possible\n        if unstudied_in_selection > 0:\n            # Johnny discards one unstudied map\n            # Remaining: studied_in_selection studied maps, (unstudied_in_selection - 1) unstudied maps\n            remaining_studied = studied_in_selection\n            remaining_unstudied = unstudied_in_selection - 1\n            remaining_total = 2\n            \n            # Opponent discards randomly from the remaining 2 maps\n            if remaining_total > 0:\n                # Probability of playing a studied map = remaining_studied / remaining_total\n                final_prob = Decimal(remaining_studied) / Decimal(remaining_total)\n                total_prob += Decimal(combinations) * final_prob\n        else:  # All 3 maps are studied\n            # Johnny must discard a studied map\n            # Remaining: (studied_in_selection - 1) studied maps, 1 unstudied map (but there are 0 unstudied)\n            # Actually, if all 3 are studied, remaining are both studied\n            remaining_studied = studied_in_selection - 1\n            remaining_unstudied = 0\n            remaining_total = 2\n            \n            # Both remaining maps are studied, so final map will be studied\n            final_prob = Decimal(1.0)\n            total_prob += Decimal(combinations) * final_prob\n    \n    if total_combinations == 0:\n        return Decimal(0.0)\n        \n    return total_prob / total_combinations\n\ndef solve(N, P):\n    # Binary search on the answer\n    left, right = 0, N\n    result = N\n    \n    P_decimal = Decimal(str(P))\n    \n    while left <= right:\n        mid = (left + right) // 2\n        prob = calculate_probability(N, mid)\n        \n        if prob >= P_decimal:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n            \n    return result\n\n# Read input\nline = input().strip().split()\nN = int(line[0])\nP = float(line[1])\n\n# Solve and output\nresult = solve(N, P)\nprint(result)\n\n\n"], "responses": ["\nfrom decimal import Decimal, getcontext\nimport math\n\n# Set precision for decimal calculations\ngetcontext().prec = 20\n\ndef calculate_probability(N, k):\n    \"\"\"\n    Calculate the probability of playing a studied map when Johnny studies k maps out of N total maps.\n    \"\"\"\n    if k >= N:\n        return Decimal(1.0)\n    \n    if k == 0:\n        return Decimal(0.0)\n    \n    if N < 3:\n        return Decimal(0.0)\n    \n    total_prob = Decimal(0.0)\n    total_combinations = Decimal(0.0)\n    \n    # Iterate through all possible combinations of 3 maps selected initially\n    # Let i be the number of studied maps in the initial 3 selected maps\n    for i in range(max(0, 3 - (N - k)), min(3, k) + 1):\n        # Number of ways to choose i studied maps from k studied maps\n        if k >= i and (N-k) >= (3-i):\n            studied_ways = math.comb(k, i)\n            # Number of ways to choose (3-i) unstudied maps from (N-k) unstudied maps\n            unstudied_ways = math.comb(N - k, 3 - i)\n            # Total ways to form such a combination\n            combinations = studied_ways * unstudied_ways\n        else:\n            continue\n            \n        total_combinations += Decimal(combinations)\n        \n        # For each such combination, calculate probability of playing a studied map\n        studied_in_selection = i\n        unstudied_in_selection = 3 - i\n        \n        # Johnny's strategy: discard an unstudied map if possible\n        if unstudied_in_selection > 0:\n            # Johnny discards one unstudied map\n            # Remaining: studied_in_selection studied maps, (unstudied_in_selection - 1) unstudied maps\n            remaining_studied = studied_in_selection\n            remaining_unstudied = unstudied_in_selection - 1\n            remaining_total = 2\n            \n            # Opponent discards randomly from the remaining 2 maps\n            if remaining_total > 0:\n                # Probability of playing a studied map = remaining_studied / remaining_total\n                final_prob = Decimal(remaining_studied) / Decimal(remaining_total)\n                total_prob += Decimal(combinations) * final_prob\n        else:  # All 3 maps are studied\n            # Johnny must discard a studied map\n            # Remaining: (studied_in_selection - 1) studied maps, 1 unstudied map (but there are 0 unstudied)\n            # Actually, if all 3 are studied, remaining are both studied\n            remaining_studied = studied_in_selection - 1\n            remaining_unstudied = 0\n            remaining_total = 2\n            \n            # Both remaining maps are studied, so final map will be studied\n            final_prob = Decimal(1.0)\n            total_prob += Decimal(combinations) * final_prob\n    \n    if total_combinations == 0:\n        return Decimal(0.0)\n        \n    return total_prob / total_combinations\n\ndef solve(N, P):\n    # Binary search on the answer\n    left, right = 0, N\n    result = N\n    \n    P_decimal = Decimal(str(P))\n    \n    while left <= right:\n        mid = (left + right) // 2\n        prob = calculate_probability(N, mid)\n        \n        if prob >= P_decimal:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n            \n    return result\n\n# Read input\nline = input().strip().split()\nN = int(line[0])\nP = float(line[1])\n\n# Solve and output\nresult = solve(N, P)\nprint(result)\n\n\n"], "prompt_tokens": [8801], "completion_tokens": [5421], "no_of_try": 1, "api_calls": 7, "is_solved": true, "language": "Python3", "task_id": "788ed59a964264bd0e755e155a37e14d"}
{"description": "You are given an undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. Initially there is a single integer written on every vertex: the vertex $$$i$$$ has $$$p_i$$$ written on it. All $$$p_i$$$ are distinct integers from $$$1$$$ to $$$n$$$.You have to process $$$q$$$ queries of two types:  $$$1$$$ $$$v$$$ \u2014 among all vertices reachable from the vertex $$$v$$$ using the edges of the graph (including the vertex $$$v$$$ itself), find a vertex $$$u$$$ with the largest number $$$p_u$$$ written on it, print $$$p_u$$$ and replace $$$p_u$$$ with $$$0$$$;  $$$2$$$ $$$i$$$ \u2014 delete the $$$i$$$-th edge from the graph.  Note that, in a query of the first type, it is possible that all vertices reachable from $$$v$$$ have $$$0$$$ written on them. In this case, $$$u$$$ is not explicitly defined, but since the selection of $$$u$$$ does not affect anything, you can choose any vertex reachable from $$$v$$$ and print its value (which is $$$0$$$). ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1.5 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$q$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le m \\le 3 \\cdot 10^5$$$; $$$1 \\le q \\le 5 \\cdot 10^5$$$). The second line contains $$$n$$$ distinct integers $$$p_1$$$, $$$p_2$$$, ..., $$$p_n$$$, where $$$p_i$$$ is the number initially written on vertex $$$i$$$ ($$$1 \\le p_i \\le n$$$). Then $$$m$$$ lines follow, the $$$i$$$-th of them contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$, $$$a_i \\ne b_i$$$) and means that the $$$i$$$-th edge connects vertices $$$a_i$$$ and $$$b_i$$$. It is guaranteed that the graph does not contain multi-edges. Then $$$q$$$ lines follow, which describe the queries. Each line is given by one of the following formats:   $$$1$$$ $$$v$$$ \u2014 denotes a query of the first type with a vertex $$$v$$$ ($$$1 \\le v \\le n$$$).  $$$2$$$ $$$i$$$ \u2014 denotes a query of the second type with an edge $$$i$$$ ($$$1 \\le i \\le m$$$). For each query of the second type, it is guaranteed that the corresponding edge is not deleted from the graph yet. ", "output_spec": "For every query of the first type, print the value of $$$p_u$$$ written on the chosen vertex $$$u$$$.", "notes": null, "sample_inputs": ["5 4 6\n1 2 5 4 3\n1 2\n2 3\n1 3\n4 5\n1 1\n2 1\n2 3\n1 1\n1 2\n1 2"], "sample_outputs": ["5\n1\n2\n0"], "tags": ["trees", "data structures", "graphs", "dsu", "implementation"], "src_uid": "ad014bde729222db14f38caa521e4167", "difficulty": 2600, "source_codes": ["\nimport sys\nfrom collections import defaultdict\nimport heapq\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        # For each component root, maintain a max heap of values\n        self.values = [ [] for _ in range(n) ]  # negative values for max heap\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr != yr:\n            if self.rank[xr] < self.rank[yr]:\n                xr, yr = yr, xr\n            self.parent[yr] = xr\n            if self.rank[xr] == self.rank[yr]:\n                self.rank[xr] += 1\n            # Merge the heaps\n            if len(self.values[xr]) < len(self.values[yr]):\n                self.values[xr], self.values[yr] = self.values[yr], self.values[xr]\n            while self.values[yr]:\n                val = heapq.heappop(self.values[yr])\n                heapq.heappush(self.values[xr], val)\n    \n    def add_value(self, x, val):\n        root = self.find(x)\n        if val > 0:  # Only add non-zero values\n            heapq.heappush(self.values[root], -val)  # negative for max heap\n    \n    def get_max_and_remove(self, x):\n        root = self.find(x)\n        if not self.values[root]:\n            return 0\n        max_val = -heapq.heappop(self.values[root])\n        return max_val\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    q = int(data[idx]); idx += 1\n    \n    p = [0] * (n+1)\n    for i in range(1, n+1):\n        p[i] = int(data[idx]); idx += 1\n    \n    edges = [None] * (m+1)\n    for i in range(1, m+1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        edges[i] = (a, b)\n    \n    queries = []\n    for _ in range(q):\n        t = int(data[idx]); idx += 1\n        if t == 1:\n            v = int(data[idx]); idx += 1\n            queries.append((1, v))\n        else:\n            i = int(data[idx]); idx += 1\n            queries.append((2, i))\n    \n    # Determine which edges are deleted\n    deleted = [False] * (m+1)\n    for query in queries:\n        if query[0] == 2:\n            deleted[query[1]] = True\n    \n    # Initialize DSU with edges that are never deleted\n    dsu = DSU(n+1)\n    for i in range(1, m+1):\n        if not deleted[i]:\n            u, v = edges[i]\n            dsu.union(u, v)\n    \n    # Add initial values to DSU\n    for i in range(1, n+1):\n        dsu.add_value(i, p[i])\n    \n    # Process queries in reverse\n    results = [None] * q\n    \n    # Process queries in reverse order\n    for i in range(q-1, -1, -1):\n        query = queries[i]\n        if query[0] == 1:\n            v = query[1]\n            max_val = dsu.get_max_and_remove(v)\n            results[i] = max_val\n        else:\n            edge_idx = query[1]\n            u, v = edges[edge_idx]\n            dsu.union(u, v)\n    \n    # Output results for type 1 queries\n    for i in range(q):\n        if queries[i][0] == 1:\n            print(results[i])\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["\nimport sys\nfrom collections import defaultdict\nimport heapq\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        # For each component root, maintain a max heap of values\n        self.values = [ [] for _ in range(n) ]  # negative values for max heap\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr != yr:\n            if self.rank[xr] < self.rank[yr]:\n                xr, yr = yr, xr\n            self.parent[yr] = xr\n            if self.rank[xr] == self.rank[yr]:\n                self.rank[xr] += 1\n            # Merge the heaps\n            if len(self.values[xr]) < len(self.values[yr]):\n                self.values[xr], self.values[yr] = self.values[yr], self.values[xr]\n            while self.values[yr]:\n                val = heapq.heappop(self.values[yr])\n                heapq.heappush(self.values[xr], val)\n    \n    def add_value(self, x, val):\n        root = self.find(x)\n        if val > 0:  # Only add non-zero values\n            heapq.heappush(self.values[root], -val)  # negative for max heap\n    \n    def get_max_and_remove(self, x):\n        root = self.find(x)\n        if not self.values[root]:\n            return 0\n        max_val = -heapq.heappop(self.values[root])\n        return max_val\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    q = int(data[idx]); idx += 1\n    \n    p = [0] * (n+1)\n    for i in range(1, n+1):\n        p[i] = int(data[idx]); idx += 1\n    \n    edges = [None] * (m+1)\n    for i in range(1, m+1):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        edges[i] = (a, b)\n    \n    queries = []\n    for _ in range(q):\n        t = int(data[idx]); idx += 1\n        if t == 1:\n            v = int(data[idx]); idx += 1\n            queries.append((1, v))\n        else:\n            i = int(data[idx]); idx += 1\n            queries.append((2, i))\n    \n    # Determine which edges are deleted\n    deleted = [False] * (m+1)\n    for query in queries:\n        if query[0] == 2:\n            deleted[query[1]] = True\n    \n    # Initialize DSU with edges that are never deleted\n    dsu = DSU(n+1)\n    for i in range(1, m+1):\n        if not deleted[i]:\n            u, v = edges[i]\n            dsu.union(u, v)\n    \n    # Add initial values to DSU\n    for i in range(1, n+1):\n        dsu.add_value(i, p[i])\n    \n    # Process queries in reverse\n    results = [None] * q\n    \n    # Process queries in reverse order\n    for i in range(q-1, -1, -1):\n        query = queries[i]\n        if query[0] == 1:\n            v = query[1]\n            max_val = dsu.get_max_and_remove(v)\n            results[i] = max_val\n        else:\n            edge_idx = query[1]\n            u, v = edges[edge_idx]\n            dsu.union(u, v)\n    \n    # Output results for type 1 queries\n    for i in range(q):\n        if queries[i][0] == 1:\n            print(results[i])\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "prompt_tokens": [13428], "completion_tokens": [6139], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "ad014bde729222db14f38caa521e4167"}
{"description": "Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $$$x$$$ in an array. For an array $$$a$$$ indexed from zero, and an integer $$$x$$$ the pseudocode of the algorithm is as follows:  Note that the elements of the array are indexed from zero, and the division is done in integers (rounding down).Andrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $$$x$$$!Andrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $$$n$$$ such that the algorithm finds $$$x$$$ in them. A permutation of size $$$n$$$ is an array consisting of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ in arbitrary order.Help Andrey and find the number of permutations of size $$$n$$$ which contain $$$x$$$ at position $$$pos$$$ and for which the given implementation of the binary search algorithm finds $$$x$$$ (returns true). As the result may be extremely large, print the remainder of its division by $$$10^9+7$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line of input contains integers $$$n$$$, $$$x$$$ and $$$pos$$$ ($$$1 \\le x \\le n \\le 1000$$$, $$$0 \\le pos \\le n - 1$$$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.", "output_spec": "Print a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $$$10^9+7$$$.", "notes": "NoteAll possible permutations in the first test case: $$$(2, 3, 1, 4)$$$, $$$(2, 4, 1, 3)$$$, $$$(3, 2, 1, 4)$$$, $$$(3, 4, 1, 2)$$$, $$$(4, 2, 1, 3)$$$, $$$(4, 3, 1, 2)$$$.", "sample_inputs": ["4 1 2", "123 42 24"], "sample_outputs": ["6", "824071958"], "tags": ["combinatorics", "binary search"], "src_uid": "24e2f10463f440affccc2755f4462d8a", "difficulty": 1500, "source_codes": ["\ndef solve():\n    MOD = 10**9 + 7\n    \n    # Read input\n    n, x, pos = map(int, input().split())\n    \n    # Precompute factorials\n    max_n = n\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    # Simulate binary search to find constraints\n    less_count = 0  # Number of positions that must be < x\n    greater_count = 0  # Number of positions that must be > x\n    \n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if mid == pos:\n            break\n        elif mid < pos:\n            less_count += 1\n            left = mid + 1\n        else:\n            greater_count += 1\n            right = mid\n    \n    # Count available numbers\n    available_less = x - 1  # Numbers 1 to x-1\n    available_greater = n - x  # Numbers x+1 to n\n    \n    # Check if we have enough numbers\n    if less_count > available_less or greater_count > available_greater:\n        print(0)\n        return\n    \n    # Calculate the number of ways\n    # Ways to choose and arrange less_count numbers from available_less numbers\n    ways_less = 1\n    for i in range(less_count):\n        ways_less = (ways_less * (available_less - i)) % MOD\n    \n    # Ways to choose and arrange greater_count numbers from available_greater numbers\n    ways_greater = 1\n    for i in range(greater_count):\n        ways_greater = (ways_greater * (available_greater - i)) % MOD\n    \n    # Remaining positions (excluding pos and the constrained positions)\n    remaining_positions = n - 1 - less_count - greater_count\n    # Remaining numbers\n    remaining_numbers = (available_less - less_count) + (available_greater - greater_count)\n    \n    # Ways to arrange remaining numbers in remaining positions\n    ways_remaining = 1\n    for i in range(remaining_positions):\n        ways_remaining = (ways_remaining * (remaining_numbers - i)) % MOD\n    \n    result = (ways_less * ways_greater) % MOD\n    result = (result * ways_remaining) % MOD\n    \n    print(result)\n\nsolve()\n\n\n"], "responses": ["\ndef solve():\n    MOD = 10**9 + 7\n    \n    # Read input\n    n, x, pos = map(int, input().split())\n    \n    # Precompute factorials\n    max_n = n\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    # Simulate binary search to find constraints\n    less_count = 0  # Number of positions that must be < x\n    greater_count = 0  # Number of positions that must be > x\n    \n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if mid == pos:\n            break\n        elif mid < pos:\n            less_count += 1\n            left = mid + 1\n        else:\n            greater_count += 1\n            right = mid\n    \n    # Count available numbers\n    available_less = x - 1  # Numbers 1 to x-1\n    available_greater = n - x  # Numbers x+1 to n\n    \n    # Check if we have enough numbers\n    if less_count > available_less or greater_count > available_greater:\n        print(0)\n        return\n    \n    # Calculate the number of ways\n    # Ways to choose and arrange less_count numbers from available_less numbers\n    ways_less = 1\n    for i in range(less_count):\n        ways_less = (ways_less * (available_less - i)) % MOD\n    \n    # Ways to choose and arrange greater_count numbers from available_greater numbers\n    ways_greater = 1\n    for i in range(greater_count):\n        ways_greater = (ways_greater * (available_greater - i)) % MOD\n    \n    # Remaining positions (excluding pos and the constrained positions)\n    remaining_positions = n - 1 - less_count - greater_count\n    # Remaining numbers\n    remaining_numbers = (available_less - less_count) + (available_greater - greater_count)\n    \n    # Ways to arrange remaining numbers in remaining positions\n    ways_remaining = 1\n    for i in range(remaining_positions):\n        ways_remaining = (ways_remaining * (remaining_numbers - i)) % MOD\n    \n    result = (ways_less * ways_greater) % MOD\n    result = (result * ways_remaining) % MOD\n    \n    print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [9282], "completion_tokens": [3792], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "24e2f10463f440affccc2755f4462d8a"}
{"description": "Today is the final contest of INOI (Iranian National Olympiad in Informatics). The contest room is a row with $$$n$$$ computers. All computers are numbered with integers from $$$1$$$ to $$$n$$$ from left to right. There are $$$m$$$ participants, numbered with integers from $$$1$$$ to $$$m$$$.We have an array $$$a$$$ of length $$$m$$$ where $$$a_{i}$$$ ($$$1 \\leq a_i \\leq n$$$) is the computer behind which the $$$i$$$-th participant wants to sit.Also, we have another array $$$b$$$ of length $$$m$$$ consisting of characters 'L' and 'R'. $$$b_i$$$ is the side from which the $$$i$$$-th participant enters the room. 'L' means the participant enters from the left of computer $$$1$$$ and goes from left to right, and 'R' means the participant enters from the right of computer $$$n$$$ and goes from right to left.The participants in the order from $$$1$$$ to $$$m$$$ enter the room one by one. The $$$i$$$-th of them enters the contest room in the direction $$$b_i$$$ and goes to sit behind the $$$a_i$$$-th computer. If it is occupied he keeps walking in his direction until he reaches the first unoccupied computer. After that, he sits behind it. If he doesn't find any computer he gets upset and gives up on the contest.The madness of the $$$i$$$-th participant is the distance between his assigned computer ($$$a_i$$$) and the computer he ends up sitting behind. The distance between computers $$$i$$$ and $$$j$$$ is equal to $$$|i - j|$$$.The values in the array $$$a$$$ can be equal. There exist $$$n^m \\cdot 2^m$$$ possible pairs of arrays $$$(a, b)$$$.Consider all pairs of arrays $$$(a, b)$$$ such that no person becomes upset. For each of them let's calculate the sum of participants madnesses. Find the sum of all these values.You will be given some prime modulo $$$p$$$. Find this sum by modulo $$$p$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains three integers $$$n$$$, $$$m$$$, $$$p$$$ ($$$1 \\leq m \\leq n \\leq 500, 10^8 \\leq p \\leq 10 ^ 9 + 9$$$). It is guaranteed, that the number $$$p$$$ is prime.", "output_spec": "Print only one integer\u00a0\u2014 the required sum by modulo $$$p$$$.", "notes": "NoteIn the first test, there are three possible arrays $$$a$$$: $$$\\{1\\}$$$, $$$\\{2\\}$$$, and $$$ \\{3\\}$$$ and two possible arrays $$$b$$$: $$$\\{\\mathtt{L}\\}$$$ and $$$\\{\\mathtt{R}\\}$$$. For all six pairs of arrays $$$(a, b)$$$, the only participant will sit behind the computer $$$a_1$$$, so his madness will be $$$0$$$. So the total sum of madnesses will be $$$0$$$.In the second test, all possible pairs of arrays $$$(a, b)$$$, such that no person becomes upset are:  $$$(\\{1, 1\\}, \\{\\mathtt{L}, \\mathtt{L}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{1, 1\\}, \\{\\mathtt{R}, \\mathtt{L}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{2, 2\\}, \\{\\mathtt{R}, \\mathtt{R}\\})$$$, the sum of madnesses is $$$1$$$;  $$$(\\{2, 2\\}, \\{\\mathtt{L}, \\mathtt{R}\\})$$$, the sum of madnesses is $$$1$$$;  all possible pairs of $$$a \\in \\{\\{1, 2\\}, \\{2, 1\\}\\}$$$ and $$$b \\in \\{\\{\\mathtt{L}, \\mathtt{L}\\}, \\{\\mathtt{R}, \\mathtt{L}\\}, \\{\\mathtt{L}, \\mathtt{R}\\}, \\{\\mathtt{R}, \\mathtt{R}\\}\\}$$$, the sum of madnesses is $$$0$$$. So, the answer is $$$1 + 1 + 1 + 1 + 0 \\ldots = 4$$$.", "sample_inputs": ["3 1 1000000007", "2 2 1000000009", "3 2 998244353", "20 10 1000000009"], "sample_outputs": ["0", "4", "8", "352081045"], "tags": ["fft", "dp", "combinatorics"], "src_uid": "9812de5f2d272511a63ead8765b23190", "difficulty": 3100, "source_codes": [""], "responses": [""], "prompt_tokens": [4524], "completion_tokens": [975], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "9812de5f2d272511a63ead8765b23190"}
{"description": "The map of Bertown can be represented as a set of $$$n$$$ intersections, numbered from $$$1$$$ to $$$n$$$ and connected by $$$m$$$ one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection $$$v$$$ to another intersection $$$u$$$ is the path that starts in $$$v$$$, ends in $$$u$$$ and has the minimum length among all such paths.Polycarp lives near the intersection $$$s$$$ and works in a building near the intersection $$$t$$$. Every day he gets from $$$s$$$ to $$$t$$$ by car. Today he has chosen the following path to his workplace: $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$, where $$$p_1 = s$$$, $$$p_k = t$$$, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. Note that you know Polycarp's path beforehand (it is fixed), and it is not necessarily one of the shortest paths from $$$s$$$ to $$$t$$$.Polycarp's car has a complex navigation system installed in it. Let's describe how it works. When Polycarp starts his journey at the intersection $$$s$$$, the system chooses some shortest path from $$$s$$$ to $$$t$$$ and shows it to Polycarp. Let's denote the next intersection in the chosen path as $$$v$$$. If Polycarp chooses to drive along the road from $$$s$$$ to $$$v$$$, then the navigator shows him the same shortest path (obviously, starting from $$$v$$$ as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection $$$w$$$ instead, the navigator rebuilds the path: as soon as Polycarp arrives at $$$w$$$, the navigation system chooses some shortest path from $$$w$$$ to $$$t$$$ and shows it to Polycarp. The same process continues until Polycarp arrives at $$$t$$$: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system rebuilds the path by the same rules.Here is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path $$$[1, 2, 3, 4]$$$ ($$$s = 1$$$, $$$t = 4$$$): Check the picture by the link http://tk.codeforces.com/a.png   When Polycarp starts at $$$1$$$, the system chooses some shortest path from $$$1$$$ to $$$4$$$. There is only one such path, it is $$$[1, 5, 4]$$$;  Polycarp chooses to drive to $$$2$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$2$$$, the navigator rebuilds the path by choosing some shortest path from $$$2$$$ to $$$4$$$, for example, $$$[2, 6, 4]$$$ (note that it could choose $$$[2, 3, 4]$$$);  Polycarp chooses to drive to $$$3$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$3$$$, the navigator rebuilds the path by choosing the only shortest path from $$$3$$$ to $$$4$$$, which is $$$[3, 4]$$$;  Polycarp arrives at $$$4$$$ along the road chosen by the navigator, so the system does not have to rebuild anything. Overall, we get $$$2$$$ rebuilds in this scenario. Note that if the system chose $$$[2, 3, 4]$$$ instead of $$$[2, 6, 4]$$$ during the second step, there would be only $$$1$$$ rebuild (since Polycarp goes along the path, so the system maintains the path $$$[3, 4]$$$ during the third step).The example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp's path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "512 megabytes", "input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le m \\le 2 \\cdot 10^5$$$) \u2014 the number of intersections and one-way roads in Bertown, respectively. Then $$$m$$$ lines follow, each describing a road. Each line contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$) denoting a road from intersection $$$u$$$ to intersection $$$v$$$. All roads in Bertown are pairwise distinct, which means that each ordered pair $$$(u, v)$$$ appears at most once in these $$$m$$$ lines (but if there is a road $$$(u, v)$$$, the road $$$(v, u)$$$ can also appear). The following line contains one integer $$$k$$$ ($$$2 \\le k \\le n$$$) \u2014 the number of intersections in Polycarp's path from home to his workplace. The last line contains $$$k$$$ integers $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$ ($$$1 \\le p_i \\le n$$$, all these integers are pairwise distinct) \u2014 the intersections along Polycarp's path in the order he arrived at them. $$$p_1$$$ is the intersection where Polycarp lives ($$$s = p_1$$$), and $$$p_k$$$ is the intersection where Polycarp's workplace is situated ($$$t = p_k$$$). It is guaranteed that for every $$$i \\in [1, k - 1]$$$ the road from $$$p_i$$$ to $$$p_{i + 1}$$$ exists, so the path goes along the roads of Bertown. ", "output_spec": "Print two integers: the minimum and the maximum number of rebuilds that could have happened during the journey.", "notes": null, "sample_inputs": ["6 9\n1 5\n5 4\n1 2\n2 3\n3 4\n4 1\n2 6\n6 4\n4 2\n4\n1 2 3 4", "7 7\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 1\n7\n1 2 3 4 5 6 7", "8 13\n8 7\n8 6\n7 5\n7 4\n6 5\n6 4\n5 3\n5 2\n4 3\n4 2\n3 1\n2 1\n1 8\n5\n8 7 5 2 1"], "sample_outputs": ["1 2", "0 0", "0 3"], "tags": ["shortest paths", "graphs"], "src_uid": "19a0c05eb2d1559ccfe60e210c6fcd6a", "difficulty": null, "source_codes": [""], "responses": [""], "prompt_tokens": [6661], "completion_tokens": [1825], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "19a0c05eb2d1559ccfe60e210c6fcd6a"}
{"description": "Makoto has a big blackboard with a positive integer $$$n$$$ written on it. He will perform the following action exactly $$$k$$$ times:Suppose the number currently written on the blackboard is $$$v$$$. He will randomly pick one of the divisors of $$$v$$$ (possibly $$$1$$$ and $$$v$$$) and replace $$$v$$$ with this divisor. As Makoto uses his famous random number generator (RNG) and as he always uses $$$58$$$ as his generator seed, each divisor is guaranteed to be chosen with equal probability.He now wonders what is the expected value of the number written on the blackboard after $$$k$$$ steps.It can be shown that this value can be represented as $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are coprime integers and $$$Q \\not\\equiv 0 \\pmod{10^9+7}$$$. Print the value of $$$P \\cdot Q^{-1}$$$ modulo $$$10^9+7$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 10^{15}$$$, $$$1 \\leq k \\leq 10^4$$$).", "output_spec": "Print a single integer \u2014 the expected value of the number on the blackboard after $$$k$$$ steps as $$$P \\cdot Q^{-1} \\pmod{10^9+7}$$$ for $$$P$$$, $$$Q$$$ defined above.", "notes": "NoteIn the first example, after one step, the number written on the blackboard is $$$1$$$, $$$2$$$, $$$3$$$ or $$$6$$$ \u2014 each occurring with equal probability. Hence, the answer is $$$\\frac{1+2+3+6}{4}=3$$$.In the second example, the answer is equal to $$$1 \\cdot \\frac{9}{16}+2 \\cdot \\frac{3}{16}+3 \\cdot \\frac{3}{16}+6 \\cdot \\frac{1}{16}=\\frac{15}{8}$$$.", "sample_inputs": ["6 1", "6 2", "60 5"], "sample_outputs": ["3", "875000008", "237178099"], "tags": ["math", "number theory", "probabilities", "dp"], "src_uid": "dc466d9c24b7dcb37c0e99337b4124d2", "difficulty": 2200, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "dc466d9c24b7dcb37c0e99337b4124d2"}
{"description": "Let's introduce some definitions that will be needed later.Let $$$prime(x)$$$ be the set of prime divisors of $$$x$$$. For example, $$$prime(140) = \\{ 2, 5, 7 \\}$$$, $$$prime(169) = \\{ 13 \\}$$$.Let $$$g(x, p)$$$ be the maximum possible integer $$$p^k$$$ where $$$k$$$ is an integer such that $$$x$$$ is divisible by $$$p^k$$$. For example:  $$$g(45, 3) = 9$$$ ($$$45$$$ is divisible by $$$3^2=9$$$ but not divisible by $$$3^3=27$$$),  $$$g(63, 7) = 7$$$ ($$$63$$$ is divisible by $$$7^1=7$$$ but not divisible by $$$7^2=49$$$). Let $$$f(x, y)$$$ be the product of $$$g(y, p)$$$ for all $$$p$$$ in $$$prime(x)$$$. For example:  $$$f(30, 70) = g(70, 2) \\cdot g(70, 3) \\cdot g(70, 5) = 2^1 \\cdot 3^0 \\cdot 5^1 = 10$$$,  $$$f(525, 63) = g(63, 3) \\cdot g(63, 5) \\cdot g(63, 7) = 3^2 \\cdot 5^0 \\cdot 7^1 = 63$$$. You have integers $$$x$$$ and $$$n$$$. Calculate $$$f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\bmod{(10^{9} + 7)}$$$.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The only line contains integers $$$x$$$ and $$$n$$$ ($$$2 \\le x \\le 10^{9}$$$, $$$1 \\le n \\le 10^{18}$$$)\u00a0\u2014 the numbers used in formula.", "output_spec": "Print the answer.", "notes": "NoteIn the first example, $$$f(10, 1) = g(1, 2) \\cdot g(1, 5) = 1$$$, $$$f(10, 2) = g(2, 2) \\cdot g(2, 5) = 2$$$.In the second example, actual value of formula is approximately $$$1.597 \\cdot 10^{171}$$$. Make sure you print the answer modulo $$$(10^{9} + 7)$$$.In the third example, be careful about overflow issue.", "sample_inputs": ["10 2", "20190929 1605", "947 987654321987654321"], "sample_outputs": ["2", "363165664", "593574252"], "tags": ["math", "number theory"], "src_uid": "04610fbaa746c083dda30e21fa6e1a0c", "difficulty": 1700, "source_codes": ["\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit using Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (limit + 1)\n    is_prime[0:2] = [False, False]\n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    return [i for i, val in enumerate(is_prime) if val]\n\n# Precompute primes up to sqrt(10^9) ~= 31623\nPRIMES = sieve_of_eratosthenes(31623)\n\ndef prime_factors(n):\n    \"\"\"Return the set of prime factors of n.\"\"\"\n    factors = set()\n    for p in PRIMES:\n        if p * p > n:\n            break\n        if n % p == 0:\n            factors.add(p)\n            while n % p == 0:\n                n //= p\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef legendre_exponent(n, p):\n    \"\"\"Calculate the exponent of prime p in n! using Legendre's formula.\"\"\"\n    exp = 0\n    power_of_p = p\n    while power_of_p <= n:\n        exp += n // power_of_p\n        if power_of_p > n // p:  # Prevent overflow\n            break\n        power_of_p *= p\n    return exp\n\ndef mod_pow(base, exp, mod):\n    \"\"\"Compute (base^exp) % mod using fast exponentiation.\"\"\"\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef solve(x, n):\n    MOD = 1000000007\n    primes = prime_factors(x)\n    result = 1\n    \n    for p in primes:\n        exp = legendre_exponent(n, p)\n        term = mod_pow(p, exp, MOD)\n        result = (result * term) % MOD\n        \n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Solve and print result\nprint(solve(x, n))\n\n\n"], "responses": ["\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit using Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (limit + 1)\n    is_prime[0:2] = [False, False]\n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n    return [i for i, val in enumerate(is_prime) if val]\n\n# Precompute primes up to sqrt(10^9) ~= 31623\nPRIMES = sieve_of_eratosthenes(31623)\n\ndef prime_factors(n):\n    \"\"\"Return the set of prime factors of n.\"\"\"\n    factors = set()\n    for p in PRIMES:\n        if p * p > n:\n            break\n        if n % p == 0:\n            factors.add(p)\n            while n % p == 0:\n                n //= p\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef legendre_exponent(n, p):\n    \"\"\"Calculate the exponent of prime p in n! using Legendre's formula.\"\"\"\n    exp = 0\n    power_of_p = p\n    while power_of_p <= n:\n        exp += n // power_of_p\n        if power_of_p > n // p:  # Prevent overflow\n            break\n        power_of_p *= p\n    return exp\n\ndef mod_pow(base, exp, mod):\n    \"\"\"Compute (base^exp) % mod using fast exponentiation.\"\"\"\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef solve(x, n):\n    MOD = 1000000007\n    primes = prime_factors(x)\n    result = 1\n    \n    for p in primes:\n        exp = legendre_exponent(n, p)\n        term = mod_pow(p, exp, MOD)\n        result = (result * term) % MOD\n        \n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Solve and print result\nprint(solve(x, n))\n\n\n"], "prompt_tokens": [5875], "completion_tokens": [2075], "no_of_try": 1, "api_calls": 4, "is_solved": true, "language": "Python3", "task_id": "04610fbaa746c083dda30e21fa6e1a0c"}
{"description": "Anadi has a set of dominoes. Every domino has two parts, and each part contains some dots. For every $$$a$$$ and $$$b$$$ such that $$$1 \\leq a \\leq b \\leq 6$$$, there is exactly one domino with $$$a$$$ dots on one half and $$$b$$$ dots on the other half. The set contains exactly $$$21$$$ dominoes. Here is an exact illustration of his set:  Also, Anadi has an undirected graph without self-loops and multiple edges. He wants to choose some dominoes and place them on the edges of this graph. He can use at most one domino of each type. Each edge can fit at most one domino. It's not necessary to place a domino on each edge of the graph.When placing a domino on an edge, he also chooses its direction. In other words, one half of any placed domino must be directed toward one of the endpoints of the edge and the other half must be directed toward the other endpoint. There's a catch: if there are multiple halves of dominoes directed toward the same vertex, each of these halves must contain the same number of dots.How many dominoes at most can Anadi place on the edges of his graph?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 7$$$, $$$0 \\leq m \\leq \\frac{n\\cdot(n-1)}{2}$$$) \u2014 the number of vertices and the number of edges in the graph. The next $$$m$$$ lines contain two integers each. Integers in the $$$i$$$-th line are $$$a_i$$$ and $$$b_i$$$ ($$$1 \\leq a, b \\leq n$$$, $$$a \\neq b$$$) and denote that there is an edge which connects vertices $$$a_i$$$ and $$$b_i$$$. The graph might be disconnected. It's however guaranteed that the graph doesn't contain any self-loops, and that there is at most one edge between any pair of vertices.", "output_spec": "Output one integer which denotes the maximum number of dominoes which Anadi can place on the edges of the graph.", "notes": "NoteHere is an illustration of Anadi's graph from the first sample test:  And here is one of the ways to place a domino on each of its edges:  Note that each vertex is faced by the halves of dominoes with the same number of dots. For instance, all halves directed toward vertex $$$1$$$ have three dots.", "sample_inputs": ["4 4\n1 2\n2 3\n3 4\n4 1", "7 0", "3 1\n1 3", "7 21\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 3\n2 4\n2 5\n2 6\n2 7\n3 4\n3 5\n3 6\n3 7\n4 5\n4 6\n4 7\n5 6\n5 7\n6 7"], "sample_outputs": ["4", "0", "1", "16"], "tags": ["brute force", "graphs"], "src_uid": "11e6559cfb71b8f6ca88242094b17a2b", "difficulty": 1700, "source_codes": ["\nfrom itertools import permutations\n\ndef solve():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    \n    if m == 0:\n        return 0\n    \n    max_dominoes = 0\n    \n    # For n <= 6, we can assign distinct values 1-6\n    if n <= 6:\n        # Try all permutations of n values selected from {1,2,3,4,5,6}\n        for perm in permutations(range(1, 7), n):\n            labeling = {i+1: perm[i] for i in range(n)}\n            count = 0\n            used_dominoes = set()\n            \n            for a, b in edges:\n                val_a = labeling[a]\n                val_b = labeling[b]\n                # Create a normalized domino representation\n                domino = tuple(sorted([val_a, val_b]))\n                if domino not in used_dominoes:\n                    used_dominoes.add(domino)\n                    count += 1\n            \n            max_dominoes = max(max_dominoes, count)\n    else:\n        # For n = 7, we must repeat one value from 1-6\n        # Try all ways to choose which value to repeat\n        for repeated_value in range(1, 7):\n            # Create the multiset of values: 1,2,3,4,5,6 plus one repeated value\n            values = list(range(1, 7)) + [repeated_value]\n            \n            # Try all permutations of assigning these values to 7 vertices\n            for perm in permutations(values):\n                labeling = {i+1: perm[i] for i in range(7)}\n                count = 0\n                used_dominoes = set()\n                \n                for a, b in edges:\n                    val_a = labeling[a]\n                    val_b = labeling[b]\n                    # Create a normalized domino representation\n                    domino = tuple(sorted([val_a, val_b]))\n                    if domino not in used_dominoes:\n                        used_dominoes.add(domino)\n                        count += 1\n                \n                max_dominoes = max(max_dominoes, count)\n    \n    return max_dominoes\n\nprint(solve())\n\n\n"], "responses": ["\nfrom itertools import permutations\n\ndef solve():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    \n    if m == 0:\n        return 0\n    \n    max_dominoes = 0\n    \n    # For n <= 6, we can assign distinct values 1-6\n    if n <= 6:\n        # Try all permutations of n values selected from {1,2,3,4,5,6}\n        for perm in permutations(range(1, 7), n):\n            labeling = {i+1: perm[i] for i in range(n)}\n            count = 0\n            used_dominoes = set()\n            \n            for a, b in edges:\n                val_a = labeling[a]\n                val_b = labeling[b]\n                # Create a normalized domino representation\n                domino = tuple(sorted([val_a, val_b]))\n                if domino not in used_dominoes:\n                    used_dominoes.add(domino)\n                    count += 1\n            \n            max_dominoes = max(max_dominoes, count)\n    else:\n        # For n = 7, we must repeat one value from 1-6\n        # Try all ways to choose which value to repeat\n        for repeated_value in range(1, 7):\n            # Create the multiset of values: 1,2,3,4,5,6 plus one repeated value\n            values = list(range(1, 7)) + [repeated_value]\n            \n            # Try all permutations of assigning these values to 7 vertices\n            for perm in permutations(values):\n                labeling = {i+1: perm[i] for i in range(7)}\n                count = 0\n                used_dominoes = set()\n                \n                for a, b in edges:\n                    val_a = labeling[a]\n                    val_b = labeling[b]\n                    # Create a normalized domino representation\n                    domino = tuple(sorted([val_a, val_b]))\n                    if domino not in used_dominoes:\n                        used_dominoes.add(domino)\n                        count += 1\n                \n                max_dominoes = max(max_dominoes, count)\n    \n    return max_dominoes\n\nprint(solve())\n\n\n"], "prompt_tokens": [10300], "completion_tokens": [4279], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "11e6559cfb71b8f6ca88242094b17a2b"}
{"description": "Melody Pond was stolen from her parents as a newborn baby by Madame Kovarian, to become a weapon of the Silence in their crusade against the Doctor. Madame Kovarian changed Melody's name to River Song, giving her a new identity that allowed her to kill the Eleventh Doctor.Heidi figured out that Madame Kovarian uses a very complicated hashing function in order to change the names of the babies she steals. In order to prevent this from happening to future Doctors, Heidi decided to prepare herself by learning some basic hashing techniques.The first hashing function she designed is as follows.Given two positive integers $$$(x, y)$$$ she defines $$$H(x,y):=x^2+2xy+x+1$$$.Now, Heidi wonders if the function is reversible. That is, given a positive integer $$$r$$$, can you find a pair $$$(x, y)$$$ (of positive integers) such that $$$H(x, y) = r$$$?If multiple such pairs exist, output the one with smallest possible $$$x$$$. If there is no such pair, output \"NO\".", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first and only line contains an integer $$$r$$$ ($$$1 \\le r \\le 10^{12}$$$).", "output_spec": "Output integers $$$x, y$$$ such that $$$H(x,y) = r$$$ and $$$x$$$ is smallest possible, or \"NO\" if no such pair exists.", "notes": null, "sample_inputs": ["19", "16"], "sample_outputs": ["1 8", "NO"], "tags": ["brute force", "math", "number theory"], "src_uid": "3ff1c25a1026c90aeb14d148d7fb96ba", "difficulty": 1200, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "3ff1c25a1026c90aeb14d148d7fb96ba"}
{"description": "You are given a regular polygon with $$$n$$$ vertices labeled from $$$1$$$ to $$$n$$$ in counter-clockwise order. The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon, there is no pair of triangles such that their intersection has non-zero area, and the total area of all triangles is equal to the area of the given polygon. The weight of a triangulation is the sum of weigths of triangles it consists of, where the weight of a triagle is denoted as the product of labels of its vertices.Calculate the minimum weight among all triangulations of the polygon.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains single integer $$$n$$$ ($$$3 \\le n \\le 500$$$) \u2014 the number of vertices in the regular polygon.", "output_spec": "Print one integer \u2014 the minimum weight among all triangulations of the given polygon.", "notes": "NoteAccording to Wiki: polygon triangulation is the decomposition of a polygonal area (simple polygon) $$$P$$$ into a set of triangles, i.\u2009e., finding a set of triangles with pairwise non-intersecting interiors whose union is $$$P$$$.In the first example the polygon is a triangle, so we don't need to cut it further, so the answer is $$$1 \\cdot 2 \\cdot 3 = 6$$$.In the second example the polygon is a rectangle, so it should be divided into two triangles. It's optimal to cut it using diagonal $$$1-3$$$ so answer is $$$1 \\cdot 2 \\cdot 3 + 1 \\cdot 3 \\cdot 4 = 6 + 12 = 18$$$.", "sample_inputs": ["3", "4"], "sample_outputs": ["6", "18"], "tags": ["dp", "greedy", "math"], "src_uid": "1bd29d7a8793c22e81a1f6fd3991307a", "difficulty": 1200, "source_codes": ["\ndef minTriangulation(n):\n    # dp[i][j] represents the minimum weight triangulation for polygon vertices from i to j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table for all possible intervals\n    for length in range(3, n + 1):  # length of the sub-polygon\n        for i in range(1, n - length + 2):  # starting vertex\n            j = i + length - 1  # ending vertex\n            dp[i][j] = float('inf')\n            \n            # Try all possible third vertices k to form triangle (i, k, j)\n            for k in range(i + 1, j):\n                # Cost = triangulation of (i,k) + triangulation of (k,j) + triangle (i,k,j)\n                cost = dp[i][k] + dp[k][j] + i * k * j\n                dp[i][j] = min(dp[i][j], cost)\n    \n    return dp[1][n]\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(minTriangulation(n))\n\n\n"], "responses": ["\ndef minTriangulation(n):\n    # dp[i][j] represents the minimum weight triangulation for polygon vertices from i to j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table for all possible intervals\n    for length in range(3, n + 1):  # length of the sub-polygon\n        for i in range(1, n - length + 2):  # starting vertex\n            j = i + length - 1  # ending vertex\n            dp[i][j] = float('inf')\n            \n            # Try all possible third vertices k to form triangle (i, k, j)\n            for k in range(i + 1, j):\n                # Cost = triangulation of (i,k) + triangulation of (k,j) + triangle (i,k,j)\n                cost = dp[i][k] + dp[k][j] + i * k * j\n                dp[i][j] = min(dp[i][j], cost)\n    \n    return dp[1][n]\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(minTriangulation(n))\n\n\n"], "prompt_tokens": [3011], "completion_tokens": [1955], "no_of_try": 1, "api_calls": 4, "is_solved": true, "language": "Python3", "task_id": "1bd29d7a8793c22e81a1f6fd3991307a"}
