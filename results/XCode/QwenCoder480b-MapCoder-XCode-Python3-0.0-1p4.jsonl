{"description": "One day Petya was solving a very interesting problem. But although he used many optimization techniques, his solution still got Time limit exceeded verdict. Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of n positive integers was too slow. Desperate, Petya decided to use a somewhat unexpected optimization using parameter k, so now his function contains the following code:int fast_max(int n, int a[]) {     int ans = 0;    int offset = 0;    for (int i = 0; i &lt; n; ++i)        if (ans &lt; a[i]) {            ans = a[i];            offset = 0;        } else {            offset = offset + 1;            if (offset == k)                return ans;        }    return ans;}That way the function iteratively checks array elements, storing the intermediate maximum, and if after k consecutive iterations that maximum has not changed, it is returned as the answer.Now Petya is interested in fault rate of his function. He asked you to find the number of permutations of integers from 1 to n such that the return value of his function on those permutations is not equal to n. Since this number could be very big, output the answer modulo 109\u2009+\u20097.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009106), separated by a space\u00a0\u2014 the length of the permutations and the parameter k.", "output_spec": "Output the answer to the problem modulo 109\u2009+\u20097.", "notes": "NotePermutations from second example: [4,\u20091,\u20092,\u20093,\u20095], [4,\u20091,\u20093,\u20092,\u20095], [4,\u20092,\u20091,\u20093,\u20095], [4,\u20092,\u20093,\u20091,\u20095], [4,\u20093,\u20091,\u20092,\u20095], [4,\u20093,\u20092,\u20091,\u20095].", "sample_inputs": ["5 2", "5 3", "6 3"], "sample_outputs": ["22", "6", "84"], "tags": ["dp", "combinatorics", "math"], "src_uid": "0644605611a2cd10ab3a9f12f18d7ae4", "difficulty": 2400, "source_codes": [""], "responses": [""], "prompt_tokens": [3073], "completion_tokens": [1216], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "0644605611a2cd10ab3a9f12f18d7ae4"}
{"description": "Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0,\u20090). The robot can process commands. There are four types of commands it can perform:  U \u2014 move from the cell (x,\u2009y) to (x,\u2009y\u2009+\u20091);  D \u2014 move from (x,\u2009y) to (x,\u2009y\u2009-\u20091);  L \u2014 move from (x,\u2009y) to (x\u2009-\u20091,\u2009y);  R \u2014 move from (x,\u2009y) to (x\u2009+\u20091,\u2009y). Ivan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0,\u20090), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains one number n \u2014 the length of sequence of commands entered by Ivan (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains the sequence itself \u2014 a string consisting of n characters. Each character can be U, D, L or R.", "output_spec": "Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.", "notes": null, "sample_inputs": ["4\nLDUR", "5\nRRRUU", "6\nLLRRRR"], "sample_outputs": ["4", "0", "4"], "tags": ["greedy"], "src_uid": "b9fa2bb8001bd064ede531a5281cfd8a", "difficulty": 1000, "source_codes": ["\nn = int(input())\ncommands = input().strip()\n\n# Count each type of command\ncount_U = commands.count('U')\ncount_D = commands.count('D')\ncount_L = commands.count('L')\ncount_R = commands.count('R')\n\n# Calculate the maximum number of vertical moves that can be paired\nvertical_pairs = min(count_U, count_D) * 2\n\n# Calculate the maximum number of horizontal moves that can be paired\nhorizontal_pairs = min(count_L, count_R) * 2\n\n# Total commands that can be executed correctly\ntotal_correct_commands = vertical_pairs + horizontal_pairs\n\nprint(total_correct_commands)\n\n\n"], "responses": ["\nn = int(input())\ncommands = input().strip()\n\n# Count each type of command\ncount_U = commands.count('U')\ncount_D = commands.count('D')\ncount_L = commands.count('L')\ncount_R = commands.count('R')\n\n# Calculate the maximum number of vertical moves that can be paired\nvertical_pairs = min(count_U, count_D) * 2\n\n# Calculate the maximum number of horizontal moves that can be paired\nhorizontal_pairs = min(count_L, count_R) * 2\n\n# Total commands that can be executed correctly\ntotal_correct_commands = vertical_pairs + horizontal_pairs\n\nprint(total_correct_commands)\n\n\n"], "prompt_tokens": [3341], "completion_tokens": [981], "no_of_try": 1, "api_calls": 4, "is_solved": false, "language": "Python3", "task_id": "b9fa2bb8001bd064ede531a5281cfd8a"}
{"description": "You are given an array a consisting of n integers, and additionally an integer m. You have to choose some sequence of indices b1,\u2009b2,\u2009...,\u2009bk (1\u2009\u2264\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bk\u2009\u2264\u2009n) in such a way that the value of  is maximized. Chosen sequence can be empty.Print the maximum possible value of .", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200935, 1\u2009\u2264\u2009m\u2009\u2264\u2009109). The second line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109).", "output_spec": "Print the maximum possible value of .", "notes": "NoteIn the first example you can choose a sequence b\u2009=\u2009{1,\u20092}, so the sum  is equal to 7 (and that's 3 after taking it modulo 4).In the second example you can choose a sequence b\u2009=\u2009{3}.", "sample_inputs": ["4 4\n5 2 4 1", "3 20\n199 41 299"], "sample_outputs": ["3", "19"], "tags": ["bitmasks", "meet-in-the-middle", "divide and conquer"], "src_uid": "d3a8a3e69a55936ee33aedd66e5b7f4a", "difficulty": 1800, "source_codes": ["\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Split array into two halves\n    mid = n // 2\n    left_half = a[:mid]\n    right_half = a[mid:]\n    \n    # Function to generate all subset sums for a given array\n    def generate_subset_sums(arr):\n        subset_sums = set()\n        arr_len = len(arr)\n        for mask in range(1 << arr_len):\n            current_sum = 0\n            for i in range(arr_len):\n                if mask & (1 << i):\n                    current_sum += arr[i]\n            subset_sums.add(current_sum % m)\n        return sorted(list(subset_sums))\n    \n    # Generate subset sums for both halves\n    left_sums = generate_subset_sums(left_half)\n    right_sums = generate_subset_sums(right_half)\n    \n    max_value = 0\n    \n    # For each sum in left_sums, find the best matching sum in right_sums\n    for s1 in left_sums:\n        # We want to maximize (s1 + s2) % m\n        \n        # Case 1: Find the largest s2 such that s1 + s2 < m\n        # This means s2 < m - s1\n        import bisect\n        pos = bisect.bisect_left(right_sums, m - s1)\n        if pos > 0:\n            s2 = right_sums[pos - 1]\n            max_value = max(max_value, s1 + s2)\n        \n        # Case 2: Find the largest s2 (which will make s1 + s2 >= m)\n        # In this case, (s1 + s2) % m = s1 + s2 - m\n        if right_sums:\n            s2 = right_sums[-1]\n            max_value = max(max_value, (s1 + s2) % m)\n    \n    print(max_value)\n\nimport bisect\nsolve()\n\n\n"], "responses": ["\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Split array into two halves\n    mid = n // 2\n    left_half = a[:mid]\n    right_half = a[mid:]\n    \n    # Function to generate all subset sums for a given array\n    def generate_subset_sums(arr):\n        subset_sums = set()\n        arr_len = len(arr)\n        for mask in range(1 << arr_len):\n            current_sum = 0\n            for i in range(arr_len):\n                if mask & (1 << i):\n                    current_sum += arr[i]\n            subset_sums.add(current_sum % m)\n        return sorted(list(subset_sums))\n    \n    # Generate subset sums for both halves\n    left_sums = generate_subset_sums(left_half)\n    right_sums = generate_subset_sums(right_half)\n    \n    max_value = 0\n    \n    # For each sum in left_sums, find the best matching sum in right_sums\n    for s1 in left_sums:\n        # We want to maximize (s1 + s2) % m\n        \n        # Case 1: Find the largest s2 such that s1 + s2 < m\n        # This means s2 < m - s1\n        import bisect\n        pos = bisect.bisect_left(right_sums, m - s1)\n        if pos > 0:\n            s2 = right_sums[pos - 1]\n            max_value = max(max_value, s1 + s2)\n        \n        # Case 2: Find the largest s2 (which will make s1 + s2 >= m)\n        # In this case, (s1 + s2) % m = s1 + s2 - m\n        if right_sums:\n            s2 = right_sums[-1]\n            max_value = max(max_value, (s1 + s2) % m)\n    \n    print(max_value)\n\nimport bisect\nsolve()\n\n\n"], "prompt_tokens": [9324], "completion_tokens": [4016], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "d3a8a3e69a55936ee33aedd66e5b7f4a"}
{"description": "Amr loves Geometry. One day he came up with a very interesting problem.Amr has a circle of radius r and center in point (x,\u2009y). He wants the circle center to be in new position (x',\u2009y').In one step Amr can put a pin to the border of the circle in a certain point, then rotate the circle around that pin by any angle and finally remove the pin.Help Amr to achieve his goal in minimum number of steps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "Input consists of 5 space-separated integers r, x, y, x' y' (1\u2009\u2264\u2009r\u2009\u2264\u2009105, \u2009-\u2009105\u2009\u2264\u2009x,\u2009y,\u2009x',\u2009y'\u2009\u2264\u2009105), circle radius, coordinates of original center of the circle and coordinates of destination center of the circle respectively.", "output_spec": "Output a single integer \u2014 minimum number of steps required to move the center of the circle to the destination point.", "notes": "NoteIn the first sample test the optimal way is to put a pin at point (0,\u20092) and rotate the circle by 180 degrees counter-clockwise (or clockwise, no matter).", "sample_inputs": ["2 0 0 0 4", "1 1 1 4 4", "4 5 6 5 6"], "sample_outputs": ["1", "3", "0"], "tags": ["geometry", "math"], "src_uid": "698da80c7d24252b57cca4e4f0ca7031", "difficulty": 1400, "source_codes": ["\nimport math\n\ndef min_steps_to_move_circle(r, x, y, x_prime, y_prime):\n    # Calculate the Euclidean distance between current and target centers\n    d = math.sqrt((x_prime - x)**2 + (y_prime - y)**2)\n    \n    # If already at target, 0 steps needed\n    if d == 0:\n        return 0\n    \n    # Maximum distance that can be covered in one step is 2*r\n    max_step_distance = 2 * r\n    \n    # Calculate minimum steps using ceiling division\n    # Ceiling of (d / max_step_distance) is equivalent to floor((d + max_step_distance - 1) / max_step_distance)\n    steps = math.ceil(d / max_step_distance)\n    \n    return steps\n\n# Read input\nline = input().strip()\nr, x, y, x_prime, y_prime = map(int, line.split())\n\n# Calculate and print result\nresult = min_steps_to_move_circle(r, x, y, x_prime, y_prime)\nprint(result)\n\n\n"], "responses": ["\nimport math\n\ndef min_steps_to_move_circle(r, x, y, x_prime, y_prime):\n    # Calculate the Euclidean distance between current and target centers\n    d = math.sqrt((x_prime - x)**2 + (y_prime - y)**2)\n    \n    # If already at target, 0 steps needed\n    if d == 0:\n        return 0\n    \n    # Maximum distance that can be covered in one step is 2*r\n    max_step_distance = 2 * r\n    \n    # Calculate minimum steps using ceiling division\n    # Ceiling of (d / max_step_distance) is equivalent to floor((d + max_step_distance - 1) / max_step_distance)\n    steps = math.ceil(d / max_step_distance)\n    \n    return steps\n\n# Read input\nline = input().strip()\nr, x, y, x_prime, y_prime = map(int, line.split())\n\n# Calculate and print result\nresult = min_steps_to_move_circle(r, x, y, x_prime, y_prime)\nprint(result)\n\n\n"], "prompt_tokens": [3099], "completion_tokens": [1054], "no_of_try": 1, "api_calls": 4, "is_solved": true, "language": "Python3", "task_id": "698da80c7d24252b57cca4e4f0ca7031"}
{"description": "Drazil is playing a math game with Varda.Let's define  for positive integer x as a product of factorials of its digits. For example, .First, they choose a decimal number a consisting of n digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number x satisfying following two conditions:1. x doesn't contain neither digit 0 nor digit 1.2.  = .Help friends find such number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200915) \u2014 the number of digits in a. The second line contains n digits of a. There is at least one digit in a that is larger than 1. Number a may possibly contain leading zeroes.", "output_spec": "Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.", "notes": "NoteIn the first case, ", "sample_inputs": ["4\n1234", "3\n555"], "sample_outputs": ["33222", "555"], "tags": ["greedy", "math", "sortings", "dp", "implementation"], "src_uid": "60dbfc7a65702ae8bd4a587db1e06398", "difficulty": 1400, "source_codes": ["\nimport math\nfrom collections import Counter\n\ndef solve():\n    n = int(input())\n    digits = list(map(int, input().strip()))\n    \n    # Precompute factorials for digits 0-9\n    fact = [1] * 10\n    for i in range(1, 10):\n        fact[i] = fact[i-1] * i\n    \n    # Correct decomposition strategy: break down each factorial into prime factors\n    # then rebuild using largest possible digits first\n    \n    # Better approach: directly decompose n! into factorials of 2-9\n    # 4! = 24 = 3! * 2! * 2! \n    # 6! = 720 = 5! * 3! \n    # 8! = 40320 = 7! * 3! * 2! * 2! * 2!\n    # 9! = 362880 = 7! * 3! * 3! * 2!\n    \n    decomposition = {\n        2: [2],           # 2! = 2!\n        3: [3],           # 3! = 3!\n        4: [3, 2, 2],     # 4! = 24 = 3! * 2! * 2! \n        5: [5],           # 5! = 5!\n        6: [5, 3],        # 6! = 720 = 5! * 3!\n        7: [7],           # 7! = 7!\n        8: [7, 3, 2, 2],  # 8! = 40320 = 7! * 3! * 2! * 2!\n        9: [7, 3, 3, 2]   # 9! = 362880 = 7! * 3! * 3! * 2!\n    }\n    \n    # Convert each digit in input to its decomposition\n    result_digits = []\n    for digit in digits:\n        if digit <= 1:\n            continue  # Skip 0 and 1\n        result_digits.extend(decomposition[digit])\n    \n    # Sort in descending order to get maximum number\n    result_digits.sort(reverse=True)\n    \n    return ''.join(map(str, result_digits))\n\n# Read input and solve\nprint(solve())\n\n\n"], "responses": ["\nimport math\nfrom collections import Counter\n\ndef solve():\n    n = int(input())\n    digits = list(map(int, input().strip()))\n    \n    # Precompute factorials for digits 0-9\n    fact = [1] * 10\n    for i in range(1, 10):\n        fact[i] = fact[i-1] * i\n    \n    # Correct decomposition strategy: break down each factorial into prime factors\n    # then rebuild using largest possible digits first\n    \n    # Better approach: directly decompose n! into factorials of 2-9\n    # 4! = 24 = 3! * 2! * 2! \n    # 6! = 720 = 5! * 3! \n    # 8! = 40320 = 7! * 3! * 2! * 2! * 2!\n    # 9! = 362880 = 7! * 3! * 3! * 2!\n    \n    decomposition = {\n        2: [2],           # 2! = 2!\n        3: [3],           # 3! = 3!\n        4: [3, 2, 2],     # 4! = 24 = 3! * 2! * 2! \n        5: [5],           # 5! = 5!\n        6: [5, 3],        # 6! = 720 = 5! * 3!\n        7: [7],           # 7! = 7!\n        8: [7, 3, 2, 2],  # 8! = 40320 = 7! * 3! * 2! * 2!\n        9: [7, 3, 3, 2]   # 9! = 362880 = 7! * 3! * 3! * 2!\n    }\n    \n    # Convert each digit in input to its decomposition\n    result_digits = []\n    for digit in digits:\n        if digit <= 1:\n            continue  # Skip 0 and 1\n        result_digits.extend(decomposition[digit])\n    \n    # Sort in descending order to get maximum number\n    result_digits.sort(reverse=True)\n    \n    return ''.join(map(str, result_digits))\n\n# Read input and solve\nprint(solve())\n\n\n"], "prompt_tokens": [7772], "completion_tokens": [4582], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "60dbfc7a65702ae8bd4a587db1e06398"}
{"description": "Let's define the permutation of length n as an array p\u2009=\u2009[p1,\u2009p2,\u2009...,\u2009pn] consisting of n distinct integers from range from 1 to n. We say that this permutation maps value 1 into the value p1, value 2 into the value p2 and so on.Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of p as a collection of cycles forming p. For example, permutation p\u2009=\u2009[4,\u20091,\u20096,\u20092,\u20095,\u20093] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,\u20091,\u20096,\u20092,\u20095,\u20093] is (421)(5)(63).Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,\u20091,\u20096,\u20092,\u20095,\u20093] will become [4,\u20092,\u20091,\u20095,\u20096,\u20093].Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length n that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers n and k, print the permutation that was k-th on Kyoya's list.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line will contain two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950, 1\u2009\u2264\u2009k\u2009\u2264\u2009min{1018,\u2009l} where l is the length of the Kyoya's list).", "output_spec": "Print n space-separated integers, representing the permutation that is the answer for the question. ", "notes": "NoteThe standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1,\u20092,\u20093,\u20094], while the second permutation would be [1,\u20092,\u20094,\u20093].", "sample_inputs": ["4 3", "10 1"], "sample_outputs": ["1 3 2 4", "1 2 3 4 5 6 7 8 9 10"], "tags": ["greedy", "combinatorics", "binary search", "constructive algorithms", "math", "implementation"], "src_uid": "e03c6d3bb8cf9119530668765691a346", "difficulty": 1900, "source_codes": [""], "responses": [""], "prompt_tokens": [3967], "completion_tokens": [1918], "no_of_try": 1, "api_calls": 3, "is_solved": false, "language": "Python3", "task_id": "e03c6d3bb8cf9119530668765691a346"}
{"description": "You are given three sticks with positive integer lengths of a,\u2009b, and c centimeters. You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters. In particular, it is allowed not to increase the length of any stick.Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of centimeters in them.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains 4 integers a,\u2009b,\u2009c,\u2009l (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20093\u00b7105, 0\u2009\u2264\u2009l\u2009\u2264\u20093\u00b7105).", "output_spec": "Print a single integer \u2014 the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.", "notes": "NoteIn the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.", "sample_inputs": ["1 1 1 2", "1 2 3 1", "10 2 1 7"], "sample_outputs": ["4", "2", "0"], "tags": ["math", "combinatorics", "brute force", "dp", "implementation"], "src_uid": "185ff90a8b0ae0e2b75605f772589410", "difficulty": 2100, "source_codes": ["\ndef solve():\n    a, b, c, l = map(int, input().split())\n    \n    # Function to calculate C(n, k)\n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        result = 1\n        for i in range(min(k, n - k)):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Total number of ways to distribute 0 to l centimeters among 3 sticks\n    # This is sum of C(i+2, 2) for i from 0 to l = C(l+3, 3)\n    total = comb(l + 3, 3)\n    \n    # Count invalid configurations using inclusion-exclusion\n    invalid = 0\n    \n    # Case 1: a+x >= b+y + c+z => x >= (b+c-a) + y + z\n    # For a non-degenerate triangle, we need strict inequality\n    d1 = b + c - a + 1\n    if d1 > 0 and l - d1 + 3 >= 0:\n        invalid += comb(l - d1 + 3, 3)\n    \n    # Case 2: b+y >= a+x + c+z => y >= (a+c-b) + x + z  \n    d2 = a + c - b + 1\n    if d2 > 0 and l - d2 + 3 >= 0:\n        invalid += comb(l - d2 + 3, 3)\n    \n    # Case 3: c+z >= a+x + b+y => z >= (a+b-c) + x + y\n    d3 = a + b - c + 1\n    if d3 > 0 and l - d3 + 3 >= 0:\n        invalid += comb(l - d3 + 3, 3)\n    \n    # Apply inclusion-exclusion for double-counted cases\n    # Case 1 and 2: x >= d1 + y + z AND y >= d2 + x + z\n    # x >= d1 + y + z and y >= d2 + x + z\n    # Substituting: x >= d1 + (d2 + x + z) + z = d1 + d2 + x + 2z\n    # 0 >= d1 + d2 + 2z, which is impossible when d1,d2,z >= 0 and at least one is positive\n    # But we need to consider when both inequalities can be satisfied simultaneously\n    \n    # Actually, let's think differently. \n    # We're counting cases where:\n    # 1. x >= (b+c-a+1) + y + z  (which means a+x >= b+y + c+z + 1)\n    # 2. y >= (a+c-b+1) + x + z  (which means b+y >= a+x + c+z + 1)\n    \n    # For both to be true:\n    # x >= (b+c-a+1) + y + z  and  y >= (a+c-b+1) + x + z\n    # x >= (b+c-a+1) + [(a+c-b+1) + x + z] + z\n    # x >= (b+c-a+1) + (a+c-b+1) + x + 2z\n    # 0 >= 2c + 2 + 2z\n    # This is impossible since c > 0 and z >= 0\n    \n    # Similar logic applies to all pairwise intersections and the triple intersection\n    # So no need to subtract anything for overlaps\n    \n    result = total - invalid\n    print(result)\n\nsolve()\n\n\n"], "responses": ["\ndef solve():\n    a, b, c, l = map(int, input().split())\n    \n    # Function to calculate C(n, k)\n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        result = 1\n        for i in range(min(k, n - k)):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Total number of ways to distribute 0 to l centimeters among 3 sticks\n    # This is sum of C(i+2, 2) for i from 0 to l = C(l+3, 3)\n    total = comb(l + 3, 3)\n    \n    # Count invalid configurations using inclusion-exclusion\n    invalid = 0\n    \n    # Case 1: a+x >= b+y + c+z => x >= (b+c-a) + y + z\n    # For a non-degenerate triangle, we need strict inequality\n    d1 = b + c - a + 1\n    if d1 > 0 and l - d1 + 3 >= 0:\n        invalid += comb(l - d1 + 3, 3)\n    \n    # Case 2: b+y >= a+x + c+z => y >= (a+c-b) + x + z  \n    d2 = a + c - b + 1\n    if d2 > 0 and l - d2 + 3 >= 0:\n        invalid += comb(l - d2 + 3, 3)\n    \n    # Case 3: c+z >= a+x + b+y => z >= (a+b-c) + x + y\n    d3 = a + b - c + 1\n    if d3 > 0 and l - d3 + 3 >= 0:\n        invalid += comb(l - d3 + 3, 3)\n    \n    # Apply inclusion-exclusion for double-counted cases\n    # Case 1 and 2: x >= d1 + y + z AND y >= d2 + x + z\n    # x >= d1 + y + z and y >= d2 + x + z\n    # Substituting: x >= d1 + (d2 + x + z) + z = d1 + d2 + x + 2z\n    # 0 >= d1 + d2 + 2z, which is impossible when d1,d2,z >= 0 and at least one is positive\n    # But we need to consider when both inequalities can be satisfied simultaneously\n    \n    # Actually, let's think differently. \n    # We're counting cases where:\n    # 1. x >= (b+c-a+1) + y + z  (which means a+x >= b+y + c+z + 1)\n    # 2. y >= (a+c-b+1) + x + z  (which means b+y >= a+x + c+z + 1)\n    \n    # For both to be true:\n    # x >= (b+c-a+1) + y + z  and  y >= (a+c-b+1) + x + z\n    # x >= (b+c-a+1) + [(a+c-b+1) + x + z] + z\n    # x >= (b+c-a+1) + (a+c-b+1) + x + 2z\n    # 0 >= 2c + 2 + 2z\n    # This is impossible since c > 0 and z >= 0\n    \n    # Similar logic applies to all pairwise intersections and the triple intersection\n    # So no need to subtract anything for overlaps\n    \n    result = total - invalid\n    print(result)\n\nsolve()\n\n\n"], "prompt_tokens": [8851], "completion_tokens": [5438], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "185ff90a8b0ae0e2b75605f772589410"}
{"description": "One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.", "output_spec": "Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.", "notes": "NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.", "sample_inputs": ["3 1", "2 3", "7 3"], "sample_outputs": ["1 1", "2 0", "3 2"], "tags": ["math", "implementation"], "src_uid": "775766790e91e539c1cfaa5030e5b955", "difficulty": 800, "source_codes": ["\n# Read input\na, b = map(int, input().split())\n\n# Calculate maximum days with different socks (limited by the smaller count)\ndifferent_socks_days = min(a, b)\n\n# Calculate remaining socks after wearing different socks\nremaining_socks = abs(a - b)\n\n# Calculate days with same colored socks (each pair needs 2 socks)\nsame_socks_days = remaining_socks // 2\n\n# Output the result\nprint(different_socks_days, same_socks_days)\n\n\n"], "responses": ["\n# Read input\na, b = map(int, input().split())\n\n# Calculate maximum days with different socks (limited by the smaller count)\ndifferent_socks_days = min(a, b)\n\n# Calculate remaining socks after wearing different socks\nremaining_socks = abs(a - b)\n\n# Calculate days with same colored socks (each pair needs 2 socks)\nsame_socks_days = remaining_socks // 2\n\n# Output the result\nprint(different_socks_days, same_socks_days)\n\n\n"], "prompt_tokens": [3141], "completion_tokens": [851], "no_of_try": 1, "api_calls": 4, "is_solved": false, "language": "Python3", "task_id": "775766790e91e539c1cfaa5030e5b955"}
{"description": "A monster is attacking the Cyberland!Master Yang, a braver, is going to beat the monster. Yang and the monster each have 3 attributes: hitpoints (HP), offensive power (ATK) and defensive power (DEF).During the battle, every second the monster's HP decrease by max(0,\u2009ATKY\u2009-\u2009DEFM), while Yang's HP decreases by max(0,\u2009ATKM\u2009-\u2009DEFY), where index Y denotes Master Yang and index M denotes monster. Both decreases happen simultaneously Once monster's HP\u2009\u2264\u20090 and the same time Master Yang's HP\u2009&gt;\u20090, Master Yang wins.Master Yang can buy attributes from the magic shop of Cyberland: h bitcoins per HP, a bitcoins per ATK, and d bitcoins per DEF.Now Master Yang wants to know the minimum number of bitcoins he can spend in order to win.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains three integers HPY,\u2009ATKY,\u2009DEFY, separated by a space, denoting the initial HP, ATK and DEF of Master Yang. The second line contains three integers HPM,\u2009ATKM,\u2009DEFM, separated by a space, denoting the HP, ATK and DEF of the monster. The third line contains three integers h,\u2009a,\u2009d, separated by a space, denoting the price of 1\u00a0HP, 1\u00a0ATK and 1\u00a0DEF. All numbers in input are integer and lie between 1 and 100 inclusively.", "output_spec": "The only output line should contain an integer, denoting the minimum bitcoins Master Yang should spend in order to win.", "notes": "NoteFor the first sample, prices for ATK and DEF are extremely high. Master Yang can buy 99 HP, then he can beat the monster with 1 HP left.For the second sample, Master Yang is strong enough to beat the monster, so he doesn't need to buy anything.", "sample_inputs": ["1 2 1\n1 100 1\n1 100 100", "100 100 100\n1 1 1\n1 1 1"], "sample_outputs": ["99", "0"], "tags": ["brute force", "binary search", "implementation"], "src_uid": "bf8a133154745e64a547de6f31ddc884", "difficulty": 1800, "source_codes": ["\ndef min_bitcoins_to_win():\n    # Read input\n    HPY, ATKY, DEFY = map(int, input().split())\n    HPM, ATKM, DEFM = map(int, input().split())\n    h, a, d = map(int, input().split())\n    \n    # Function to simulate battle\n    def can_win(yang_hp, yang_atk, yang_def):\n        if yang_hp <= 0:\n            return False\n            \n        # Calculate damage per turn\n        yang_damage = max(0, ATKM - yang_def)\n        monster_damage = max(0, yang_atk - DEFM)\n        \n        # If Yang does no damage, he can't win\n        if monster_damage == 0:\n            return False\n            \n        # Calculate turns needed to kill monster\n        turns_to_kill_monster = (HPM + monster_damage - 1) // monster_damage\n        \n        # Calculate HP Yang loses in that time\n        hp_lost = turns_to_kill_monster * yang_damage\n        \n        # Yang wins if he survives\n        return yang_hp > hp_lost\n    \n    # Check if Yang already wins\n    if can_win(HPY, ATKY, DEFY):\n        return 0\n    \n    min_cost = float('inf')\n    \n    # Yang needs to be able to deal damage\n    min_new_atk = DEFM + 1\n    \n    # Try different combinations - limit search space reasonably\n    max_additional_stats = max(HPM, ATKM, DEFM) + 100\n    \n    for add_atk in range(max(0, min_new_atk - ATKY), max_additional_stats):\n        for add_def in range(0, max_additional_stats):\n            new_atk = ATKY + add_atk\n            new_def = DEFY + add_def\n            \n            # Must be able to deal damage\n            if new_atk <= DEFM:\n                continue\n                \n            # Calculate minimum turns to kill monster\n            monster_damage = new_atk - DEFM\n            turns_to_kill = (HPM + monster_damage - 1) // monster_damage\n            \n            # Calculate damage Yang takes per turn\n            yang_damage_per_turn = max(0, ATKM - new_def)\n            \n            # Calculate minimum HP needed\n            min_hp_needed = turns_to_kill * yang_damage_per_turn + 1\n            \n            # Calculate additional HP needed\n            add_hp = max(0, min_hp_needed - HPY)\n            \n            # Calculate cost\n            cost = add_hp * h + add_atk * a + add_def * d\n            if cost < min_cost:\n                new_hp = HPY + add_hp\n                if can_win(new_hp, new_atk, new_def):\n                    min_cost = cost\n    \n    return min_cost if min_cost != float('inf') else 0\n\n# Execute and print result\nprint(min_bitcoins_to_win())\n\n\n"], "responses": ["\ndef min_bitcoins_to_win():\n    # Read input\n    HPY, ATKY, DEFY = map(int, input().split())\n    HPM, ATKM, DEFM = map(int, input().split())\n    h, a, d = map(int, input().split())\n    \n    # Function to simulate battle\n    def can_win(yang_hp, yang_atk, yang_def):\n        if yang_hp <= 0:\n            return False\n            \n        # Calculate damage per turn\n        yang_damage = max(0, ATKM - yang_def)\n        monster_damage = max(0, yang_atk - DEFM)\n        \n        # If Yang does no damage, he can't win\n        if monster_damage == 0:\n            return False\n            \n        # Calculate turns needed to kill monster\n        turns_to_kill_monster = (HPM + monster_damage - 1) // monster_damage\n        \n        # Calculate HP Yang loses in that time\n        hp_lost = turns_to_kill_monster * yang_damage\n        \n        # Yang wins if he survives\n        return yang_hp > hp_lost\n    \n    # Check if Yang already wins\n    if can_win(HPY, ATKY, DEFY):\n        return 0\n    \n    min_cost = float('inf')\n    \n    # Yang needs to be able to deal damage\n    min_new_atk = DEFM + 1\n    \n    # Try different combinations - limit search space reasonably\n    max_additional_stats = max(HPM, ATKM, DEFM) + 100\n    \n    for add_atk in range(max(0, min_new_atk - ATKY), max_additional_stats):\n        for add_def in range(0, max_additional_stats):\n            new_atk = ATKY + add_atk\n            new_def = DEFY + add_def\n            \n            # Must be able to deal damage\n            if new_atk <= DEFM:\n                continue\n                \n            # Calculate minimum turns to kill monster\n            monster_damage = new_atk - DEFM\n            turns_to_kill = (HPM + monster_damage - 1) // monster_damage\n            \n            # Calculate damage Yang takes per turn\n            yang_damage_per_turn = max(0, ATKM - new_def)\n            \n            # Calculate minimum HP needed\n            min_hp_needed = turns_to_kill * yang_damage_per_turn + 1\n            \n            # Calculate additional HP needed\n            add_hp = max(0, min_hp_needed - HPY)\n            \n            # Calculate cost\n            cost = add_hp * h + add_atk * a + add_def * d\n            if cost < min_cost:\n                new_hp = HPY + add_hp\n                if can_win(new_hp, new_atk, new_def):\n                    min_cost = cost\n    \n    return min_cost if min_cost != float('inf') else 0\n\n# Execute and print result\nprint(min_bitcoins_to_win())\n\n\n"], "prompt_tokens": [8957], "completion_tokens": [4232], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "bf8a133154745e64a547de6f31ddc884"}
{"description": "Vasya decided to learn to play chess. Classic chess doesn't seem interesting to him, so he plays his own sort of chess.The queen is the piece that captures all squares on its vertical, horizontal and diagonal lines. If the cell is located on the same vertical, horizontal or diagonal line with queen, and the cell contains a piece of the enemy color, the queen is able to move to this square. After that the enemy's piece is removed from the board. The queen cannot move to a cell containing an enemy piece if there is some other piece between it and the queen. There is an n\u2009\u00d7\u2009n chessboard. We'll denote a cell on the intersection of the r-th row and c-th column as (r,\u2009c). The square (1,\u20091) contains the white queen and the square (1,\u2009n) contains the black queen. All other squares contain green pawns that don't belong to anyone.The players move in turns. The player that moves first plays for the white queen, his opponent plays for the black queen.On each move the player has to capture some piece with his queen (that is, move to a square that contains either a green pawn or the enemy queen). The player loses if either he cannot capture any piece during his move or the opponent took his queen during the previous move. Help Vasya determine who wins if both players play with an optimal strategy on the board n\u2009\u00d7\u2009n.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The input contains a single number n (2\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 the size of the board.", "output_spec": "On the first line print the answer to problem \u2014 string \"white\" or string \"black\", depending on who wins if the both players play optimally.  If the answer is \"white\", then you should also print two integers r and c representing the cell (r,\u2009c), where the first player should make his first move to win. If there are multiple such cells, print the one with the minimum r. If there are still multiple squares, print the one with the minimum c.", "notes": "NoteIn the first sample test the white queen can capture the black queen at the first move, so the white player wins.In the second test from the statement if the white queen captures the green pawn located on the central vertical line, then it will be captured by the black queen during the next move. So the only move for the white player is to capture the green pawn located at (2,\u20091). Similarly, the black queen doesn't have any other options but to capture the green pawn located at (2,\u20093), otherwise if it goes to the middle vertical line, it will be captured by the white queen.During the next move the same thing happens \u2014 neither the white, nor the black queen has other options rather than to capture green pawns situated above them. Thus, the white queen ends up on square (3,\u20091), and the black queen ends up on square (3,\u20093). In this situation the white queen has to capture any of the green pawns located on the middle vertical line, after that it will be captured by the black queen. Thus, the player who plays for the black queen wins.", "sample_inputs": ["2", "3"], "sample_outputs": ["white\n1 2", "black"], "tags": ["games", "math", "constructive algorithms"], "src_uid": "52e07d176aa1d370788f94ee2e61df93", "difficulty": 1700, "source_codes": ["\nn = int(input())\n\nif n == 2:\n    print(\"white\")\n    print(\"1 2\")\nelse:\n    total_pawns = n * n - 2\n    if total_pawns % 2 == 1:\n        print(\"black\")\n    else:\n        print(\"white\")\n        print(\"1 2\")\n\n\n"], "responses": ["\nn = int(input())\n\nif n == 2:\n    print(\"white\")\n    print(\"1 2\")\nelse:\n    total_pawns = n * n - 2\n    if total_pawns % 2 == 1:\n        print(\"black\")\n    else:\n        print(\"white\")\n        print(\"1 2\")\n\n\n"], "prompt_tokens": [5858], "completion_tokens": [2305], "no_of_try": 1, "api_calls": 5, "is_solved": true, "language": "Python3", "task_id": "52e07d176aa1d370788f94ee2e61df93"}
{"description": "It's tough to be a superhero. And it's twice as tough to resist the supervillain who is cool at math. Suppose that you're an ordinary Batman in an ordinary city of Gotham. Your enemy Joker mined the building of the city administration and you only have several minutes to neutralize the charge. To do that you should enter the cancel code on the bomb control panel.However, that mad man decided to give you a hint. This morning the mayor found a playing card under his pillow. There was a line written on the card:The bomb has a note saying \"J(x)\u2009=\u2009A\", where A is some positive integer. You suspect that the cancel code is some integer x that meets the equation J(x)\u2009=\u2009A. Now in order to decide whether you should neutralize the bomb or run for your life, you've got to count how many distinct positive integers x meet this equation.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The single line of the input contains a single integer A (1\u2009\u2264\u2009A\u2009\u2264\u20091012).", "output_spec": "Print the number of solutions of the equation J(x)\u2009=\u2009A.", "notes": "NoteRecord x|n means that number n divides number x. is defined as the largest positive integer that divides both a and b.In the first sample test the only suitable value of x is 2. Then J(2)\u2009=\u20091\u2009+\u20092.In the second sample test the following values of x match:  x\u2009=\u200914, J(14)\u2009=\u20091\u2009+\u20092\u2009+\u20097\u2009+\u200914\u2009=\u200924  x\u2009=\u200915, J(15)\u2009=\u20091\u2009+\u20093\u2009+\u20095\u2009+\u200915\u2009=\u200924  x\u2009=\u200923, J(23)\u2009=\u20091\u2009+\u200923\u2009=\u200924 ", "sample_inputs": ["3", "24"], "sample_outputs": ["1", "3"], "tags": ["math", "number theory", "hashing", "dp", "dfs and similar"], "src_uid": "1f68bd6f8b40e45a5bd360b03a264ef4", "difficulty": 2600, "source_codes": [""], "responses": [""], "prompt_tokens": [0], "completion_tokens": [0], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "1f68bd6f8b40e45a5bd360b03a264ef4"}
{"description": "Limak is a little polar bear. He has n balls, the i-th ball has size ti.Limak wants to give one ball to each of his three friends. Giving gifts isn't easy\u00a0\u2014 there are two rules Limak must obey to make friends happy:  No two friends can get balls of the same size.  No two friends can get balls of sizes that differ by more than 2. For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).Your task is to check whether Limak can choose three balls that satisfy conditions above.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains one integer n (3\u2009\u2264\u2009n\u2009\u2264\u200950)\u00a0\u2014 the number of balls Limak has. The second line contains n integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20091000) where ti denotes the size of the i-th ball.", "output_spec": "Print \"YES\" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print \"NO\" (without quotes).", "notes": "NoteIn the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.In the second sample, there is no way to give gifts to three friends without breaking the rules.In the third sample, there is even more than one way to choose balls:  Choose balls with sizes 3, 4 and 5.  Choose balls with sizes 972, 970, 971. ", "sample_inputs": ["4\n18 55 16 17", "6\n40 41 43 44 44 44", "8\n5 972 3 4 1 4 970 971"], "sample_outputs": ["YES", "NO", "YES"], "tags": ["brute force", "implementation", "sortings"], "src_uid": "d6c876a84c7b92141710be5d76536eab", "difficulty": 900, "source_codes": ["\nn = int(input())\nballs = list(map(int, input().split()))\n\n# Sort the balls to make it easier to check consecutive elements\nballs.sort()\n\nfound = False\n\n# Check every triplet of consecutive elements in the sorted array\nfor i in range(n - 2):\n    # Take three consecutive elements\n    a, b, c = balls[i], balls[i+1], balls[i+2]\n    \n    # Check if max difference is <= 2 (since array is sorted, c is max and a is min)\n    # Also check if all three are distinct\n    if a != b and b != c and a != c and c - a <= 2:\n        found = True\n        break\n\nif found:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n"], "responses": ["\nn = int(input())\nballs = list(map(int, input().split()))\n\n# Sort the balls to make it easier to check consecutive elements\nballs.sort()\n\nfound = False\n\n# Check every triplet of consecutive elements in the sorted array\nfor i in range(n - 2):\n    # Take three consecutive elements\n    a, b, c = balls[i], balls[i+1], balls[i+2]\n    \n    # Check if max difference is <= 2 (since array is sorted, c is max and a is min)\n    # Also check if all three are distinct\n    if a != b and b != c and a != c and c - a <= 2:\n        found = True\n        break\n\nif found:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n"], "prompt_tokens": [7740], "completion_tokens": [2154], "no_of_try": 1, "api_calls": 7, "is_solved": false, "language": "Python3", "task_id": "d6c876a84c7b92141710be5d76536eab"}
{"description": "Buses run between the cities A and B, the first one is at 05:00 AM and the last one departs not later than at 11:59 PM. A bus from the city A departs every a minutes and arrives to the city B in a ta minutes, and a bus from the city B departs every b minutes and arrives to the city A in a tb minutes.The driver Simion wants to make his job diverse, so he counts the buses going towards him. Simion doesn't count the buses he meet at the start and finish.You know the time when Simion departed from the city A to the city B. Calculate the number of buses Simion will meet to be sure in his counting.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers a,\u2009ta (1\u2009\u2264\u2009a,\u2009ta\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city A to the city B and the travel time. Both values are given in minutes. The second line contains two integers b,\u2009tb (1\u2009\u2264\u2009b,\u2009tb\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city B to the city A and the travel time. Both values are given in minutes. The last line contains the departure time of Simion from the city A in the format hh:mm. It is guaranteed that there are a bus from the city A at that time. Note that the hours and the minutes are given with exactly two digits.", "output_spec": "Print the only integer z \u2014 the number of buses Simion will meet on the way. Note that you should not count the encounters in cities A and B.", "notes": "NoteIn the first example Simion departs form the city A at 05:20 AM and arrives to the city B at 05:50 AM. He will meet the first 5 buses from the city B that departed in the period [05:00 AM - 05:40 AM]. Also Simion will meet a bus in the city B at 05:50 AM, but he will not count it.Also note that the first encounter will be between 05:26 AM and 05:27 AM (if we suggest that the buses are go with the sustained speed).", "sample_inputs": ["10 30\n10 35\n05:20", "60 120\n24 100\n13:00"], "sample_outputs": ["5", "9"], "tags": ["implementation"], "src_uid": "1c4cf1c3cb464a483511a8a61f8685a7", "difficulty": 1600, "source_codes": ["\ndef solve():\n    # Read input\n    a, ta = map(int, input().split())\n    b, tb = map(int, input().split())\n    departure_time = input().strip()\n    \n    # Convert Simion's departure time to minutes since 00:00\n    hh, mm = map(int, departure_time.split(':'))\n    sim_start = hh * 60 + mm\n    sim_end = sim_start + ta\n    \n    # Operational hours: 05:00 AM to 11:59 PM\n    # 05:00 AM = 5*60 = 300 minutes\n    # 11:59 PM = 23*60 + 59 = 1439 minutes\n    start_operational = 300\n    end_operational = 1439\n    \n    count = 0\n    \n    # Generate all departure times for buses from B to A\n    # A bus can depart at time t if t is in [300, 1439]\n    # But we also need to consider buses that might still be traveling during Simion's journey\n    \n    # The latest departure from B that could possibly meet Simion:\n    # This bus should depart early enough to reach A before Simion ends his journey\n    # So, departure_time + tb > sim_start\n    # departure_time > sim_start - tb\n    # We also need departure_time <= 1439\n    \n    # The earliest departure from B that could possibly meet Simion:\n    # This bus should depart when Simion is still traveling\n    # So, departure_time < sim_end\n    # We also need departure_time >= 300\n    \n    # Therefore, we check all buses departing from B in the range:\n    # max(300, sim_start - tb + 1) to min(1439, sim_end - 1)\n    \n    # However, let's think more carefully about the intersection:\n    # Simion travels from sim_start to sim_end\n    # A bus from B departs at time t and arrives at time t + tb\n    # They meet if their travel intervals overlap AND the meeting is not at the endpoints\n    \n    # For a bus departing from B at time t:\n    # Bus travels from t to t + tb\n    # Simion travels from sim_start to sim_end\n    # They meet if: max(t, sim_start) < min(t + tb, sim_end)\n    # And this meeting should not be at sim_start or sim_end\n    \n    # Let's enumerate all possible departure times from B\n    # Buses depart every b minutes starting from a time >= 300\n    # First bus from B departs at time: start_B = ((300 + b - 1) // b) * b if 300 % b != 0 else 300\n    # But actually, the problem states that buses run between 05:00 and 11:59, \n    # and they depart every b minutes during that period.\n    \n    # Let's find all departure times for B->A buses in the operational window\n    first_departure_B = ((300 + b - 1) // b) * b if 300 % b != 0 else 300\n    if first_departure_B < 300:\n        first_departure_B += b\n        \n    current_departure = first_departure_B\n    while current_departure <= end_operational:\n        # Bus from B departs at current_departure, arrives at current_departure + tb\n        bus_start = current_departure\n        bus_end = current_departure + tb\n        \n        # Check if intervals [sim_start, sim_end] and [bus_start, bus_end] intersect\n        # Intersection is [max(sim_start, bus_start), min(sim_end, bus_end)]\n        intersection_start = max(sim_start, bus_start)\n        intersection_end = min(sim_end, bus_end)\n        \n        # They meet if intersection_start < intersection_end\n        # AND the intersection is not just at the endpoints of Simion's journey\n        if intersection_start < intersection_end:\n            # Exclude the cases where intersection is exactly at sim_start or sim_end\n            if not (intersection_start == sim_end or intersection_end == sim_start):\n                count += 1\n                \n        current_departure += b\n        \n    print(count)\n\nsolve()\n\n\n"], "responses": ["\ndef solve():\n    # Read input\n    a, ta = map(int, input().split())\n    b, tb = map(int, input().split())\n    departure_time = input().strip()\n    \n    # Convert Simion's departure time to minutes since 00:00\n    hh, mm = map(int, departure_time.split(':'))\n    sim_start = hh * 60 + mm\n    sim_end = sim_start + ta\n    \n    # Operational hours: 05:00 AM to 11:59 PM\n    # 05:00 AM = 5*60 = 300 minutes\n    # 11:59 PM = 23*60 + 59 = 1439 minutes\n    start_operational = 300\n    end_operational = 1439\n    \n    count = 0\n    \n    # Generate all departure times for buses from B to A\n    # A bus can depart at time t if t is in [300, 1439]\n    # But we also need to consider buses that might still be traveling during Simion's journey\n    \n    # The latest departure from B that could possibly meet Simion:\n    # This bus should depart early enough to reach A before Simion ends his journey\n    # So, departure_time + tb > sim_start\n    # departure_time > sim_start - tb\n    # We also need departure_time <= 1439\n    \n    # The earliest departure from B that could possibly meet Simion:\n    # This bus should depart when Simion is still traveling\n    # So, departure_time < sim_end\n    # We also need departure_time >= 300\n    \n    # Therefore, we check all buses departing from B in the range:\n    # max(300, sim_start - tb + 1) to min(1439, sim_end - 1)\n    \n    # However, let's think more carefully about the intersection:\n    # Simion travels from sim_start to sim_end\n    # A bus from B departs at time t and arrives at time t + tb\n    # They meet if their travel intervals overlap AND the meeting is not at the endpoints\n    \n    # For a bus departing from B at time t:\n    # Bus travels from t to t + tb\n    # Simion travels from sim_start to sim_end\n    # They meet if: max(t, sim_start) < min(t + tb, sim_end)\n    # And this meeting should not be at sim_start or sim_end\n    \n    # Let's enumerate all possible departure times from B\n    # Buses depart every b minutes starting from a time >= 300\n    # First bus from B departs at time: start_B = ((300 + b - 1) // b) * b if 300 % b != 0 else 300\n    # But actually, the problem states that buses run between 05:00 and 11:59, \n    # and they depart every b minutes during that period.\n    \n    # Let's find all departure times for B->A buses in the operational window\n    first_departure_B = ((300 + b - 1) // b) * b if 300 % b != 0 else 300\n    if first_departure_B < 300:\n        first_departure_B += b\n        \n    current_departure = first_departure_B\n    while current_departure <= end_operational:\n        # Bus from B departs at current_departure, arrives at current_departure + tb\n        bus_start = current_departure\n        bus_end = current_departure + tb\n        \n        # Check if intervals [sim_start, sim_end] and [bus_start, bus_end] intersect\n        # Intersection is [max(sim_start, bus_start), min(sim_end, bus_end)]\n        intersection_start = max(sim_start, bus_start)\n        intersection_end = min(sim_end, bus_end)\n        \n        # They meet if intersection_start < intersection_end\n        # AND the intersection is not just at the endpoints of Simion's journey\n        if intersection_start < intersection_end:\n            # Exclude the cases where intersection is exactly at sim_start or sim_end\n            if not (intersection_start == sim_end or intersection_end == sim_start):\n                count += 1\n                \n        current_departure += b\n        \n    print(count)\n\nsolve()\n\n\n"], "prompt_tokens": [4514], "completion_tokens": [2434], "no_of_try": 1, "api_calls": 4, "is_solved": false, "language": "Python3", "task_id": "1c4cf1c3cb464a483511a8a61f8685a7"}
{"description": "There are three friend living on the straight line Ox in Lineland. The first friend lives at the point x1, the second friend lives at the point x2, and the third friend lives at the point x3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?It's guaranteed that the optimal answer is always integer.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains three distinct integers x1, x2 and x3 (1\u2009\u2264\u2009x1,\u2009x2,\u2009x3\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the houses of the first, the second and the third friends respectively. ", "output_spec": "Print one integer\u00a0\u2014 the minimum total distance the friends need to travel in order to meet together.", "notes": "NoteIn the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.", "sample_inputs": ["7 1 4", "30 20 10"], "sample_outputs": ["6", "20"], "tags": ["math", "implementation", "sortings"], "src_uid": "7bffa6e8d2d21bbb3b7f4aec109b3319", "difficulty": 800, "source_codes": ["\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort them\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The minimum total distance is the difference between max and min coordinates\n# When meeting at the median point, the total distance is simply max - min\nmin_distance = coordinates[2] - coordinates[0]\n\n# Output the result\nprint(min_distance)\n\n\n"], "responses": ["\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Store coordinates in a list and sort them\ncoordinates = [x1, x2, x3]\ncoordinates.sort()\n\n# The minimum total distance is the difference between max and min coordinates\n# When meeting at the median point, the total distance is simply max - min\nmin_distance = coordinates[2] - coordinates[0]\n\n# Output the result\nprint(min_distance)\n\n\n"], "prompt_tokens": [5641], "completion_tokens": [1288], "no_of_try": 1, "api_calls": 7, "is_solved": true, "language": "Python3", "task_id": "7bffa6e8d2d21bbb3b7f4aec109b3319"}
