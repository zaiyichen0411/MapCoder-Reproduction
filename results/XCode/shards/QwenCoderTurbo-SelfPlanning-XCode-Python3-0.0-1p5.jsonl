{"description": "A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.   \u00a0It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one\u00a0\u2014 in seat 'c'. Assume that all seats are occupied.Vasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of input contains a description of Vasya's seat in the format ns, where n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.", "output_spec": "Print one integer\u00a0\u2014 the number of seconds Vasya has to wait until he gets his lunch.", "notes": "NoteIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6\u2009+\u20091\u2009+\u20093\u2009=\u200910.", "sample_inputs": ["1f", "2d", "4a", "5e"], "sample_outputs": ["1", "10", "11", "18"], "tags": ["math", "implementation"], "src_uid": "069d0cb9b7c798a81007fb5b63fa0f45", "difficulty": 1200, "source_codes": ["\nimport math\n\ndef time_before_lunch(ns):\n    n = int(ns[:-1])\n    s = ns[-1]\n    seat_positions = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5}\n    seat_index = seat_positions[s]\n    full_rounds = n // 3\n    remaining_rows = n % 3\n    time_attendant1 = full_rounds * 3 + remaining_rows\n    time_attendant2 = (seat_index >= 3) * (full_rounds * 3 + remaining_rows)\n    return time_attendant1 + time_attendant2\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    ns = input()\n    result = time_before_lunch(ns)\n    results.append(result)\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\nimport math\n\ndef time_before_lunch(ns):\n    n = int(ns[:-1])\n    s = ns[-1]\n    seat_positions = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5}\n    seat_index = seat_positions[s]\n    full_rounds = n // 3\n    remaining_rows = n % 3\n    time_attendant1 = full_rounds * 3 + remaining_rows\n    time_attendant2 = (seat_index >= 3) * (full_rounds * 3 + remaining_rows)\n    return time_attendant1 + time_attendant2\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    ns = input()\n    result = time_before_lunch(ns)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [6385], "completion_tokens": [1229], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "069d0cb9b7c798a81007fb5b63fa0f45"}
{"description": "The year 2015 is almost over.Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system\u00a0\u2014 201510\u2009=\u2009111110111112. Note that he doesn't care about the number of zeros in the decimal representation.Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?Assume that all positive integers are always written without leading zeros.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains two integers a and b (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u20091018)\u00a0\u2014 the first year and the last year in Limak's interval respectively.", "output_spec": "Print one integer\u00a0\u2013 the number of years Limak will count in his chosen interval.", "notes": "NoteIn the first sample Limak's interval contains numbers 510\u2009=\u20091012, 610\u2009=\u20091102, 710\u2009=\u20091112, 810\u2009=\u200910002, 910\u2009=\u200910012 and 1010\u2009=\u200910102. Two of them (1012 and 1102) have the described property.", "sample_inputs": ["5 10", "2015 2015", "100 105", "72057594000000000 72057595000000000"], "sample_outputs": ["2", "1", "0", "26"], "tags": ["brute force", "bitmasks", "implementation"], "src_uid": "581f61b1f50313bf4c75833cefd4d022", "difficulty": 1300, "source_codes": ["\ndef count_years_with_one_zero(a, b):\n    def count_numbers_with_one_zero(x):\n        bin_x = bin(x)[2:]\n        return bin_x.count('0') == 1\n    \n    return sum(count_numbers_with_one_zero(i) for i in range(a, b + 1))\n\n# Reading input and processing each test case\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    results.append(count_years_with_one_zero(a, b))\n    index += 2\n\n# Printing results\nfor res in results:\n    print(res)\n\n\n"], "responses": ["```python\ndef count_years_with_one_zero(a, b):\n    def count_numbers_with_one_zero(x):\n        bin_x = bin(x)[2:]\n        return bin_x.count('0') == 1\n    \n    return sum(count_numbers_with_one_zero(i) for i in range(a, b + 1))\n\n# Reading input and processing each test case\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    results.append(count_years_with_one_zero(a, b))\n    index += 2\n\n# Printing results\nfor res in results:\n    print(res)\n```"], "prompt_tokens": [6368], "completion_tokens": [1671], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "581f61b1f50313bf4c75833cefd4d022"}
{"description": "Your friend recently gave you some slimes for your birthday. You have n slimes all initially with value 1.You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other n\u2009-\u20091 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value v, you combine them together to create a slime with value v\u2009+\u20091.You would like to see what the final state of the row is after you've added all n slimes. Please print the values of the slimes in the row from left to right.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input will contain a single integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000).", "output_spec": "Output a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.", "notes": "NoteIn the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.In the second sample, we perform the following steps:Initially we place a single slime in a row by itself. Thus, row is initially 1.Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.In the last sample, the steps look as follows:   1  2  2 1  3  3 1  3 2  3 2 1  4 ", "sample_inputs": ["1", "2", "3", "8"], "sample_outputs": ["1", "2", "2 1", "4"], "tags": ["implementation"], "src_uid": "757cd804aba01dc4bc108cb0722f68dc", "difficulty": 800, "source_codes": ["\ndef hat_game_schedule(t):\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        players = list(range(1, n + 1))\n        for _ in range(k):\n            group_size = n // m\n            extra = n % m\n            group_sizes = [group_size + 1] * extra + [group_size] * (m - extra)\n            for size in group_sizes:\n                group = []\n                for _ in range(size):\n                    group.append(players.pop(0))\n                print(f\"{size} {' '.join(map(str, group))}\")\n            players.extend(group)\n\ndef similar_permutations(t):\n    MOD = 10**9 + 7\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        r, k = 0, 1\n        for i, j in enumerate(sorted((a[i], i) for i in range(n))):\n            k, r, n = (k, k * (r - n - i + 1) % MOD)[n < j[1] < r], max(r, j[1] + 1), min(n, j[1])\n        print(k)\n\ndef cinema_seat_allocation(t):\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        ans = 0\n        colnum, colnumcnt, numcol = {}, {}, {}\n        for i, x in enumerate(a):\n            if x not in numcol:\n                numcol[x] = {i}\n            else:\n                numcol[x].add(i)\n            colnum[i] = x\n            colnumcnt[i] = len(numcol[x])\n        q = [[] for _ in range(n)]\n        for x in sorted(colnum, key=lambda x: a[x]):\n            temp = [j for j in numcol[x] if not q[j]]\n            for j in temp:\n                q[j].append(x)\n                ans += j\n                for y in range(j):\n                    if colnum[y] != x and colnumcnt[y] > 1:\n                        ans += 1\n                        colnumcnt[y] -= 1\n        print(ans)\n\ndef slime_combination(n):\n    slimes = [1]\n    for i in range(1, n):\n        slimes.append(slimes[-1] + 1)\n        if slimes[-2] == slimes[-1]:\n            slimes[-2] += 1\n    print(' '.join(map(str, slimes)))\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nt = int(data[index])\nindex += 1\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    k = int(data[index])\n    index += 1\n    hat_game_schedule(t)\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index+n]))\n    index += n\n    similar_permutations(t)\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index+n*m]))\n    index += n*m\n    cinema_seat_allocation(t)\n\nslime_combination(int(data[index]))\n\n\n"], "responses": ["```python\ndef hat_game_schedule(t):\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        players = list(range(1, n + 1))\n        for _ in range(k):\n            group_size = n // m\n            extra = n % m\n            group_sizes = [group_size + 1] * extra + [group_size] * (m - extra)\n            for size in group_sizes:\n                group = []\n                for _ in range(size):\n                    group.append(players.pop(0))\n                print(f\"{size} {' '.join(map(str, group))}\")\n            players.extend(group)\n\ndef similar_permutations(t):\n    MOD = 10**9 + 7\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        r, k = 0, 1\n        for i, j in enumerate(sorted((a[i], i) for i in range(n))):\n            k, r, n = (k, k * (r - n - i + 1) % MOD)[n < j[1] < r], max(r, j[1] + 1), min(n, j[1])\n        print(k)\n\ndef cinema_seat_allocation(t):\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        ans = 0\n        colnum, colnumcnt, numcol = {}, {}, {}\n        for i, x in enumerate(a):\n            if x not in numcol:\n                numcol[x] = {i}\n            else:\n                numcol[x].add(i)\n            colnum[i] = x\n            colnumcnt[i] = len(numcol[x])\n        q = [[] for _ in range(n)]\n        for x in sorted(colnum, key=lambda x: a[x]):\n            temp = [j for j in numcol[x] if not q[j]]\n            for j in temp:\n                q[j].append(x)\n                ans += j\n                for y in range(j):\n                    if colnum[y] != x and colnumcnt[y] > 1:\n                        ans += 1\n                        colnumcnt[y] -= 1\n        print(ans)\n\ndef slime_combination(n):\n    slimes = [1]\n    for i in range(1, n):\n        slimes.append(slimes[-1] + 1)\n        if slimes[-2] == slimes[-1]:\n            slimes[-2] += 1\n    print(' '.join(map(str, slimes)))\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nt = int(data[index])\nindex += 1\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    k = int(data[index])\n    index += 1\n    hat_game_schedule(t)\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index+n]))\n    index += n\n    similar_permutations(t)\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index+n*m]))\n    index += n*m\n    cinema_seat_allocation(t)\n\nslime_combination(int(data[index]))\n```"], "prompt_tokens": [6366], "completion_tokens": [2133], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "757cd804aba01dc4bc108cb0722f68dc"}
{"description": "You are given an alphabet consisting of n letters, your task is to make a string of the maximum possible length so that the following conditions are satisfied:   the i-th letter occurs in the string no more than ai times;  the number of occurrences of each letter in the string must be distinct for all the letters that occurred in the string at least once. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains a single integer n (2\u2009\u2009\u2264\u2009\u2009n\u2009\u2009\u2264\u2009\u200926)\u00a0\u2014 the number of letters in the alphabet. The next line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009109)\u00a0\u2014 i-th of these integers gives the limitation on the number of occurrences of the i-th character in the string.", "output_spec": "Print a single integer \u2014 the maximum length of the string that meets all the requirements.", "notes": "NoteFor convenience let's consider an alphabet consisting of three letters: \"a\", \"b\", \"c\". In the first sample, some of the optimal strings are: \"cccaabbccbb\", \"aabcbcbcbcb\". In the second sample some of the optimal strings are: \"acc\", \"cbc\".", "sample_inputs": ["3\n2 5 5", "3\n1 1 2"], "sample_outputs": ["11", "3"], "tags": ["greedy", "sortings"], "src_uid": "3c4b2d1c9440515bc3002eddd2b89f6f", "difficulty": 1100, "source_codes": ["\ndef max_string_length(n, a):\n    freq = [0] * (max(a) + 1)\n    for x in a:\n        freq[x] += 1\n    \n    unique_limits = []\n    for i in range(len(freq)):\n        if freq[i] > 0:\n            unique_limits.extend([i] * freq[i])\n    \n    if len(unique_limits) == 1:\n        return unique_limits[0]\n    \n    if len(unique_limits) < n:\n        return n\n    \n    unique_limits.sort(reverse=True)\n    return unique_limits[0] + unique_limits[1] - 1\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    result = max_string_length(n, a)\n    results.append(result)\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef max_string_length(n, a):\n    freq = [0] * (max(a) + 1)\n    for x in a:\n        freq[x] += 1\n    \n    unique_limits = []\n    for i in range(len(freq)):\n        if freq[i] > 0:\n            unique_limits.extend([i] * freq[i])\n    \n    if len(unique_limits) == 1:\n        return unique_limits[0]\n    \n    if len(unique_limits) < n:\n        return n\n    \n    unique_limits.sort(reverse=True)\n    return unique_limits[0] + unique_limits[1] - 1\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    result = max_string_length(n, a)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5142], "completion_tokens": [727], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "3c4b2d1c9440515bc3002eddd2b89f6f"}
{"description": "Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The only line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091018)\u00a0\u2014 the number of players to participate in the tournament.", "output_spec": "Print the maximum number of games in which the winner of the tournament can take part.", "notes": "NoteIn all samples we consider that player number 1 is the winner.In the first sample, there would be only one game so the answer is 1.In the second sample, player 1 can consequently beat players 2 and 3. In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1,\u20092) and (3,\u20094) and then clash the winners.", "sample_inputs": ["2", "3", "4", "10"], "sample_outputs": ["1", "2", "2", "4"], "tags": ["greedy", "combinatorics", "constructive algorithms", "dp", "math", "dfs and similar"], "src_uid": "3d3432b4f7c6a3b901161fa24b415b14", "difficulty": 1600, "source_codes": ["\ndef max_games_winner(n):\n    return bin(n).count('1')\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nt = int(data[0])\nresults = []\n\nfor i in range(t):\n    n = int(data[1 + 2 * i])\n    results.append(max_games_winner(n))\n\n# Output results\nprint('\\n'.join(map(str, results)))\n\n\n"], "responses": ["```python\ndef max_games_winner(n):\n    return bin(n).count('1')\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nt = int(data[0])\nresults = []\n\nfor i in range(t):\n    n = int(data[1 + 2 * i])\n    results.append(max_games_winner(n))\n\n# Output results\nprint('\\n'.join(map(str, results)))\n```"], "prompt_tokens": [5519], "completion_tokens": [711], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "3d3432b4f7c6a3b901161fa24b415b14"}
{"description": "Calvin the robot lies in an infinite rectangular grid. Calvin's source code contains a list of n commands, each either 'U', 'R', 'D', or 'L'\u00a0\u2014 instructions to move a single square up, right, down, or left, respectively. How many ways can Calvin execute a non-empty contiguous substrings of commands and return to the same square he starts in? Two substrings are considered different if they have different starting or ending indices.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains a single positive integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009200)\u00a0\u2014 the number of commands. The next line contains n characters, each either 'U', 'R', 'D', or 'L'\u00a0\u2014 Calvin's source code.", "output_spec": "Print a single integer\u00a0\u2014 the number of contiguous substrings that Calvin can execute and return to his starting square.", "notes": "NoteIn the first case, the entire source code works, as well as the \"RL\" substring in the second and third characters.Note that, in the third case, the substring \"LR\" appears three times, and is therefore counted three times to the total result.", "sample_inputs": ["6\nURLLDR", "4\nDLUU", "7\nRLRLRLR"], "sample_outputs": ["2", "0", "12"], "tags": ["brute force", "implementation"], "src_uid": "7bd5521531950e2de9a7b0904353184d", "difficulty": 1000, "source_codes": ["\ndef count_valid_substrings(n, commands):\n    prefix_sum_count = {(0, 0): 1}\n    current_sum = (0, 0)\n    valid_substrings = 0\n    \n    for command in commands:\n        if command == 'U':\n            current_sum = (current_sum[0], current_sum[1] + 1)\n        elif command == 'D':\n            current_sum = (current_sum[0], current_sum[1] - 1)\n        elif command == 'L':\n            current_sum = (current_sum[0] - 1, current_sum[1])\n        elif command == 'R':\n            current_sum = (current_sum[0] + 1, current_sum[1])\n        \n        valid_substrings += prefix_sum_count.get(current_sum, 0)\n        prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1\n    \n    return valid_substrings\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    commands = input().strip()\n    results.append(count_valid_substrings(n, commands))\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef count_valid_substrings(n, commands):\n    prefix_sum_count = {(0, 0): 1}\n    current_sum = (0, 0)\n    valid_substrings = 0\n    \n    for command in commands:\n        if command == 'U':\n            current_sum = (current_sum[0], current_sum[1] + 1)\n        elif command == 'D':\n            current_sum = (current_sum[0], current_sum[1] - 1)\n        elif command == 'L':\n            current_sum = (current_sum[0] - 1, current_sum[1])\n        elif command == 'R':\n            current_sum = (current_sum[0] + 1, current_sum[1])\n        \n        valid_substrings += prefix_sum_count.get(current_sum, 0)\n        prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1\n    \n    return valid_substrings\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n = int(input())\n    commands = input().strip()\n    results.append(count_valid_substrings(n, commands))\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5367], "completion_tokens": [1020], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "7bd5521531950e2de9a7b0904353184d"}
{"description": "Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a,\u2009b)?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains two integers s and x (2\u2009\u2264\u2009s\u2009\u2264\u20091012, 0\u2009\u2264\u2009x\u2009\u2264\u20091012), the sum and bitwise xor of the pair of positive integers, respectively.", "output_spec": "Print a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.", "notes": "NoteIn the first sample, we have the following solutions: (2,\u20097), (3,\u20096), (6,\u20093), (7,\u20092).In the second sample, the only solutions are (1,\u20092) and (2,\u20091).", "sample_inputs": ["9 5", "3 3", "5 2"], "sample_outputs": ["4", "2", "0"], "tags": ["math", "constructive algorithms", "dp", "implementation"], "src_uid": "18410980789b14c128dd6adfa501aea5", "difficulty": 1700, "source_codes": ["\ndef count_pairs(s, x):\n    a = s ^ x\n    b = (s ^ x) ^ s\n    if a > 0 and b > 0:\n        return 1\n    else:\n        return 0\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    s = int(data[index])\n    x = int(data[index + 1])\n    index += 2\n    results.append(count_pairs(s, x))\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef count_pairs(s, x):\n    a = s ^ x\n    b = (s ^ x) ^ s\n    if a > 0 and b > 0:\n        return 1\n    else:\n        return 0\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    s = int(data[index])\n    x = int(data[index + 1])\n    index += 2\n    results.append(count_pairs(s, x))\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5095], "completion_tokens": [755], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "18410980789b14c128dd6adfa501aea5"}
{"description": "For his computer science class, Jacob builds a model tree with sticks and balls containing n nodes in the shape of a tree. Jacob has spent ai minutes building the i-th ball in the tree.Jacob's teacher will evaluate his model and grade Jacob based on the effort he has put in. However, she does not have enough time to search his whole tree to determine this; Jacob knows that she will examine the first k nodes in a DFS-order traversal of the tree. She will then assign Jacob a grade equal to the minimum ai she finds among those k nodes.Though Jacob does not have enough time to rebuild his model, he can choose the root node that his teacher starts from. Furthermore, he can rearrange the list of neighbors of each node in any order he likes. Help Jacob find the best grade he can get on this assignment.A DFS-order traversal is an ordering of the nodes of a rooted tree, built by a recursive DFS-procedure initially called on the root of the tree. When called on a given node v, the procedure does the following:   Print v.  Traverse the list of neighbors of the node v in order and iteratively call DFS-procedure on each one. Do not call DFS-procedure on node u if you came to node v directly from u. ", "input_from": "standard input", "output_to": "standard output", "time_limit": "7 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line of the input contains two positive integers, n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000, 1\u2009\u2264\u2009k\u2009\u2264\u2009n)\u00a0\u2014 the number of balls in Jacob's tree and the number of balls the teacher will inspect. The second line contains n integers, ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091\u2009000\u2009000), the time Jacob used to build the i-th ball. Each of the next n\u2009-\u20091 lines contains two integers ui, vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n, ui\u2009\u2260\u2009vi) representing a connection in Jacob's tree between balls ui and vi.", "output_spec": "Print a single integer\u00a0\u2014 the maximum grade Jacob can get by picking the right root of the tree and rearranging the list of neighbors.", "notes": "NoteIn the first sample, Jacob can root the tree at node 2 and order 2's neighbors in the order 4, 1, 5 (all other nodes have at most two neighbors). The resulting preorder traversal is 2, 4, 1, 3, 5, and the minimum ai of the first 3 nodes is 3.In the second sample, it is clear that any preorder traversal will contain node 1 as either its first or second node, so Jacob cannot do better than a grade of 1.", "sample_inputs": ["5 3\n3 6 1 4 2\n1 2\n2 4\n2 5\n1 3", "4 2\n1 5 5 5\n1 2\n1 3\n1 4"], "sample_outputs": ["3", "1"], "tags": ["dfs and similar", "graphs", "greedy", "binary search"], "src_uid": "4fb83b890e472f86045981e1743ddaac", "difficulty": 2600, "source_codes": ["\ndef hat_game_schedule(n, m, k):\n    base = n // m\n    extra = n % m\n    result = []\n    players = list(range(1, n + 1))\n    \n    for _ in range(k):\n        table = []\n        for i in range(m):\n            if extra > 0:\n                table.append(base + 1)\n                extra -= 1\n            else:\n                table.append(base)\n        \n        for j in range(m):\n            if table[j] == base + 1:\n                if len(players) >= base + 1:\n                    table[j].extend(players[:base + 1])\n                    players = players[base + 1:]\n                else:\n                    table[j].extend(players)\n                    players = []\n            else:\n                if len(players) >= base:\n                    table[j].extend(players[:base])\n                    players = players[base:]\n                else:\n                    table[j].extend(players)\n                    players = []\n        \n        result.extend(table)\n    \n    return result\n\ndef similar_permutations(a):\n    MOD = 10**9 + 7\n    n = len(a)\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n    \n    def perm_count(arr):\n        cnt = [0] * (len(arr) + 1)\n        for x in arr:\n            cnt[x] += 1\n        ans = fact[len(arr)]\n        for c in cnt:\n            ans *= inv_fact[c]\n            ans %= MOD\n        return ans\n    \n    sorted_a = sorted(a)\n    ans = 0\n    for i in range(1, n + 1):\n        subarr = [sorted_a[j] for j in range(i - 1, n, i)]\n        ans += perm_count(subarr)\n        ans %= MOD\n    return ans\n\ndef minimize_inconvenience(n, m, a):\n    a.sort()\n    q = [[-1] * m for _ in range(n)]\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i in range(n * m):\n        colnum[a[i]] = i // m\n        colnumcnt[a[i]] = i // m\n        numcol[colnumcnt[a[i]]] = set()\n    \n    ans = 0\n    for x in a:\n        temp = numcol[colnumcnt[x]]\n        for r in temp:\n            q[r][colnumcnt[x]] = x\n            ans += colnumcnt[x]\n        if colnumcnt[x] < m:\n            colnumcnt[x] += 1\n        else:\n            del numcol[colnumcnt[x]]\n            numcol[colnumcnt[x] - 1].add(colnum[x])\n    \n    return ans\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nresults = []\n\nwhile index < len(data):\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index:index + 3])\n        index += 3\n        \n        if n == 1 and m == 1 and k == 1:\n            results.append(\"1\")\n            continue\n        \n        if n <= 10**5 and m <= 10**5 and k <= 10**5:\n            schedule = hat_game_schedule(n, m, k)\n            results.append(\"\\n\".join(\" \".join(map(str, row)) for row in schedule))\n        \n        elif n <= 10**5 and m <= 10**5 and k == 1:\n            a = list(map(int, data[index:index + n]))\n            index += n\n            results.append(similar_permutations(a))\n        \n        elif n <= 300 and m <= 300 and k == 1:\n            n, m = map(int, data[index:index + 2])\n            index += 2\n            a = list(map(int, data[index:index + n * m]))\n            index += n * m\n            results.append(minimize_inconvenience(n, m, a))\n    \n    print(\"\\n\".join(results))\n\n\n"], "responses": ["```python\ndef hat_game_schedule(n, m, k):\n    base = n // m\n    extra = n % m\n    result = []\n    players = list(range(1, n + 1))\n    \n    for _ in range(k):\n        table = []\n        for i in range(m):\n            if extra > 0:\n                table.append(base + 1)\n                extra -= 1\n            else:\n                table.append(base)\n        \n        for j in range(m):\n            if table[j] == base + 1:\n                if len(players) >= base + 1:\n                    table[j].extend(players[:base + 1])\n                    players = players[base + 1:]\n                else:\n                    table[j].extend(players)\n                    players = []\n            else:\n                if len(players) >= base:\n                    table[j].extend(players[:base])\n                    players = players[base:]\n                else:\n                    table[j].extend(players)\n                    players = []\n        \n        result.extend(table)\n    \n    return result\n\ndef similar_permutations(a):\n    MOD = 10**9 + 7\n    n = len(a)\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n    \n    def perm_count(arr):\n        cnt = [0] * (len(arr) + 1)\n        for x in arr:\n            cnt[x] += 1\n        ans = fact[len(arr)]\n        for c in cnt:\n            ans *= inv_fact[c]\n            ans %= MOD\n        return ans\n    \n    sorted_a = sorted(a)\n    ans = 0\n    for i in range(1, n + 1):\n        subarr = [sorted_a[j] for j in range(i - 1, n, i)]\n        ans += perm_count(subarr)\n        ans %= MOD\n    return ans\n\ndef minimize_inconvenience(n, m, a):\n    a.sort()\n    q = [[-1] * m for _ in range(n)]\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i in range(n * m):\n        colnum[a[i]] = i // m\n        colnumcnt[a[i]] = i // m\n        numcol[colnumcnt[a[i]]] = set()\n    \n    ans = 0\n    for x in a:\n        temp = numcol[colnumcnt[x]]\n        for r in temp:\n            q[r][colnumcnt[x]] = x\n            ans += colnumcnt[x]\n        if colnumcnt[x] < m:\n            colnumcnt[x] += 1\n        else:\n            del numcol[colnumcnt[x]]\n            numcol[colnumcnt[x] - 1].add(colnum[x])\n    \n    return ans\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nresults = []\n\nwhile index < len(data):\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index:index + 3])\n        index += 3\n        \n        if n == 1 and m == 1 and k == 1:\n            results.append(\"1\")\n            continue\n        \n        if n <= 10**5 and m <= 10**5 and k <= 10**5:\n            schedule = hat_game_schedule(n, m, k)\n            results.append(\"\\n\".join(\" \".join(map(str, row)) for row in schedule))\n        \n        elif n <= 10**5 and m <= 10**5 and k == 1:\n            a = list(map(int, data[index:index + n]))\n            index += n\n            results.append(similar_permutations(a))\n        \n        elif n <= 300 and m <= 300 and k == 1:\n            n, m = map(int, data[index:index + 2])\n            index += 2\n            a = list(map(int, data[index:index + n * m]))\n            index += n * m\n            results.append(minimize_inconvenience(n, m, a))\n    \n    print(\"\\n\".join(results))\n```"], "prompt_tokens": [6781], "completion_tokens": [2394], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "4fb83b890e472f86045981e1743ddaac"}
{"description": "The numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.Lucky number is a number that consists of digits 7 and 8 only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than n digits.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u200955) \u2014 the maximum length of a number that a door-plate can hold.", "output_spec": "Output one integer \u2014 the maximum number of offices, than can have unique lucky numbers not longer than n digits.", "notes": null, "sample_inputs": ["2"], "sample_outputs": ["6"], "tags": ["combinatorics", "math"], "src_uid": "f1b43baa14d4c262ba616d892525dfde", "difficulty": 1100, "source_codes": ["\ndef max_offices(n):\n    return 2 ** n\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(max_offices(n))\n\n\n"], "responses": ["```python\ndef max_offices(n):\n    return 2 ** n\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(max_offices(n))\n```"], "prompt_tokens": [4642], "completion_tokens": [348], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "f1b43baa14d4c262ba616d892525dfde"}
{"description": "Vasya started working in a machine vision company of IT City. Vasya's team creates software and hardware for identification of people by their face.One of the project's know-how is a camera rotating around its optical axis on shooting. People see an eye-catching gadget \u2014 a rotating camera \u2014 come up to it to see it better, look into it. And the camera takes their photo at that time. What could be better for high quality identification?But not everything is so simple. The pictures from camera appear rotated too (on clockwise camera rotation frame the content becomes rotated counter-clockwise). But the identification algorithm can work only with faces that are just slightly deviated from vertical.Vasya was entrusted to correct the situation \u2014 to rotate a captured image so that image would be minimally deviated from vertical. Requirements were severe. Firstly, the picture should be rotated only on angle divisible by 90 degrees to not lose a bit of information about the image. Secondly, the frames from the camera are so huge and FPS is so big that adequate rotation speed is provided by hardware FPGA solution only. And this solution can rotate only by 90 degrees clockwise. Of course, one can apply 90 degrees turn several times but for the sake of performance the number of turns should be minimized.Help Vasya implement the program that by the given rotation angle of the camera can determine the minimum number of 90 degrees clockwise turns necessary to get a picture in which up direction deviation from vertical is minimum.The next figure contains frames taken from an unrotated camera, then from rotated 90 degrees clockwise, then from rotated 90 degrees counter-clockwise. Arrows show direction to \"true up\".  The next figure shows 90 degrees clockwise turn by FPGA hardware.  ", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.5 seconds", "memory_limit": "64 megabytes", "input_spec": "The only line of the input contains one integer x (\u2009-\u20091018\u2009\u2264\u2009x\u2009\u2264\u20091018) \u2014 camera angle in degrees. Positive value denotes clockwise camera rotation, negative \u2014 counter-clockwise.", "output_spec": "Output one integer \u2014 the minimum required number of 90 degrees clockwise turns.", "notes": "NoteWhen the camera is rotated 60 degrees counter-clockwise (the second example), an image from it is rotated 60 degrees clockwise. One 90 degrees clockwise turn of the image result in 150 degrees clockwise total rotation and deviation from \"true up\" for one turn is 150 degrees. Two 90 degrees clockwise turns of the image result in 240 degrees clockwise total rotation and deviation from \"true up\" for two turns is 120 degrees because 240 degrees clockwise equal to 120 degrees counter-clockwise. Three 90 degrees clockwise turns of the image result in 330 degrees clockwise total rotation and deviation from \"true up\" for three turns is 30 degrees because 330 degrees clockwise equal to 30 degrees counter-clockwise.From 60, 150, 120 and 30 degrees deviations the smallest is 30, and it it achieved in three 90 degrees clockwise turns.", "sample_inputs": ["60", "-60"], "sample_outputs": ["1", "3"], "tags": ["geometry", "math"], "src_uid": "509db9cb6156b692557ba874a09f150e", "difficulty": 1800, "source_codes": ["\ndef min_turns(camera_angle):\n    normalized_angle = camera_angle % 360\n    if normalized_angle > 180:\n        normalized_angle -= 360\n    abs_angle = abs(normalized_angle)\n    if abs_angle <= 45:\n        return 0\n    elif abs_angle <= 135:\n        return 1\n    else:\n        return 2\n\n# Read input\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    x = int(input())\n    results.append(min_turns(x))\n\n# Print results\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef min_turns(camera_angle):\n    normalized_angle = camera_angle % 360\n    if normalized_angle > 180:\n        normalized_angle -= 360\n    abs_angle = abs(normalized_angle)\n    if abs_angle <= 45:\n        return 0\n    elif abs_angle <= 135:\n        return 1\n    else:\n        return 2\n\n# Read input\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    x = int(input())\n    results.append(min_turns(x))\n\n# Print results\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5940], "completion_tokens": [702], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "509db9cb6156b692557ba874a09f150e"}
{"description": "There are n people, sitting in a line at the table. For each person we know that he always tells either the truth or lies.Little Serge asked them: how many of you always tell the truth? Each of the people at the table knows everything (who is an honest person and who is a liar) about all the people at the table. The honest people are going to say the correct answer, the liars are going to say any integer from 1 to n, which is not the correct answer. Every liar chooses his answer, regardless of the other liars, so two distinct liars may give distinct answer.Serge does not know any information about the people besides their answers to his question. He took a piece of paper and wrote n integers a1,\u2009a2,\u2009...,\u2009an, where ai is the answer of the i-th person in the row. Given this sequence, Serge determined that exactly k people sitting at the table apparently lie.Serge wonders, how many variants of people's answers (sequences of answers a of length n) there are where one can say that exactly k people sitting at the table apparently lie. As there can be rather many described variants of answers, count the remainder of dividing the number of the variants by 777777777.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n, k, (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200928). It is guaranteed that n \u2014 is the power of number 2.", "output_spec": "Print a single integer \u2014 the answer to the problem modulo 777777777.", "notes": null, "sample_inputs": ["1 1", "2 1"], "sample_outputs": ["0", "2"], "tags": ["dp"], "src_uid": "cfe19131644e5925e32084a581e23286", "difficulty": 2700, "source_codes": ["\ndef binomial_coefficient(n, k, mod):\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = (C[j] + C[j - 1]) % mod\n    return C[k]\n\nt = int(input().strip())\nresults = []\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    mod = 777777777\n    result = binomial_coefficient(n, k, mod)\n    results.append(result)\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef binomial_coefficient(n, k, mod):\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = (C[j] + C[j - 1]) % mod\n    return C[k]\n\nt = int(input().strip())\nresults = []\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    mod = 777777777\n    result = binomial_coefficient(n, k, mod)\n    results.append(result)\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5522], "completion_tokens": [920], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "cfe19131644e5925e32084a581e23286"}
{"description": "There have recently been elections in the zoo. Overall there were 7 main political parties: one of them is the Little Elephant Political Party, 6 other parties have less catchy names.Political parties find their number in the ballot highly important. Overall there are m possible numbers: 1,\u20092,\u2009...,\u2009m. Each of these 7 parties is going to be assigned in some way to exactly one number, at that, two distinct parties cannot receive the same number.The Little Elephant Political Party members believe in the lucky digits 4 and 7. They want to evaluate their chances in the elections. For that, they need to find out, how many correct assignments are there, such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties. Help the Little Elephant Political Party, calculate this number. As the answer can be rather large, print the remainder from dividing it by 1000000007 (109\u2009+\u20097).", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "A single line contains a single positive integer m (7\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 the number of possible numbers in the ballot.", "output_spec": "In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["7", "8"], "sample_outputs": ["0", "1440"], "tags": ["brute force", "math", "combinatorics", "dp"], "src_uid": "656ed7b1b80de84d65a253e5d14d62a9", "difficulty": 1900, "source_codes": ["\nMOD = 10**9 + 7\n\ndef fair_schedule(n, m, k):\n    floor = n // m\n    ceil = n // m + (n % m != 0)\n    players = list(range(1, n + 1))\n    \n    for _ in range(k):\n        for i in range(m):\n            if i % 2 == 0:\n                group_size = floor\n                group_players = players[:group_size]\n                players = players[group_size:]\n            else:\n                group_size = ceil\n                group_players = players[:group_size]\n                players = players[group_size:]\n            \n            print(f\"{group_size}\", end=\" \")\n            for p in group_players:\n                print(p, end=\" \")\n            print()\n        \n        players.append(players.pop(0))\n\ndef min_inconvenience(n, m, a):\n    ans = 0\n    A = [(a[i], i) for i in range(n*m)]\n    A.sort()\n    \n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for a_i, i in A:\n        col = (i // m + 1) * m + i % m\n        if a_i not in colnum:\n            colnum[a_i] = set()\n            colnumcnt[a_i] = [0] * (m * n + 1)\n            numcol[col] = a_i\n        \n        r = (i // m + 1)\n        q = colnum[a_i]\n        \n        temp = []\n        for c in q:\n            if c in colnum[a_i]:\n                temp.append(c)\n                if colnumcnt[a_i][c] < r - 1:\n                    ans += (r - 1) - colnumcnt[a_i][c]\n                    colnumcnt[a_i][c] += 1\n        \n        if len(temp) > 1:\n            colnum[a_i].remove(temp[-2])\n            colnum[a_i].add(col)\n            if temp[-2] in numcol:\n                colnum[numcol[temp[-2]]].add(temp[-2])\n                colnum[numcol[temp[-2]]].discard(col)\n        \n        colnum[a_i].add(col)\n    \n    return ans % MOD\n\ndef minimal_inconvenience(n, m, a):\n    ans = 0\n    A = [(a[i], i) for i in range(n*m)]\n    A.sort()\n    \n    q = [[False] * m for _ in range(n)]\n    \n    for a_i, i in A:\n        r = (i // m + 1)\n        c = (i % m)\n        \n        if not q[r-1][c]:\n            q[r-1][c] = True\n            continue\n        \n        for cc in range(c):\n            if not q[r-1][cc]:\n                q[r-1][cc] = True\n                ans += 1\n                break\n    \n    return ans % MOD\n\ndef count_valid_assignments(m):\n    dp = [[0] * 10 for _ in range(10)]\n    dp[0][0] = 1\n    \n    for i in range(1, m):\n        for j in range(10):\n            dp[i][(j + 4) % 10] += dp[i-1][j]\n            dp[i][(j + 7) % 10] += dp[i-1][j]\n    \n    total = sum(dp[m-1])\n    little_elephant_count = dp[m-1][4] + dp[m-1][7]\n    \n    if little_elephant_count > total - little_elephant_count:\n        return total // 2\n    else:\n        return 0\n\n# Read input and call functions\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn, m, k = map(int, data[0].split())\nfair_schedule(n, m, k)\n\nfor i in range(2, len(data), 2):\n    n, m = map(int, data[i].split())\n    a = list(map(int, data[i+1].split()))\n    print(min_inconvenience(n, m, a))\n\nn, m = map(int, data[len(data)-2].split())\na = list(map(int, data[len(data)-1].split()))\nprint(minimal_inconvenience(n, m, a))\n\nm = int(data[len(data)+1])\nprint(count_valid_assignments(m))\n\n\n"], "responses": ["```python\nMOD = 10**9 + 7\n\ndef fair_schedule(n, m, k):\n    floor = n // m\n    ceil = n // m + (n % m != 0)\n    players = list(range(1, n + 1))\n    \n    for _ in range(k):\n        for i in range(m):\n            if i % 2 == 0:\n                group_size = floor\n                group_players = players[:group_size]\n                players = players[group_size:]\n            else:\n                group_size = ceil\n                group_players = players[:group_size]\n                players = players[group_size:]\n            \n            print(f\"{group_size}\", end=\" \")\n            for p in group_players:\n                print(p, end=\" \")\n            print()\n        \n        players.append(players.pop(0))\n\ndef min_inconvenience(n, m, a):\n    ans = 0\n    A = [(a[i], i) for i in range(n*m)]\n    A.sort()\n    \n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for a_i, i in A:\n        col = (i // m + 1) * m + i % m\n        if a_i not in colnum:\n            colnum[a_i] = set()\n            colnumcnt[a_i] = [0] * (m * n + 1)\n            numcol[col] = a_i\n        \n        r = (i // m + 1)\n        q = colnum[a_i]\n        \n        temp = []\n        for c in q:\n            if c in colnum[a_i]:\n                temp.append(c)\n                if colnumcnt[a_i][c] < r - 1:\n                    ans += (r - 1) - colnumcnt[a_i][c]\n                    colnumcnt[a_i][c] += 1\n        \n        if len(temp) > 1:\n            colnum[a_i].remove(temp[-2])\n            colnum[a_i].add(col)\n            if temp[-2] in numcol:\n                colnum[numcol[temp[-2]]].add(temp[-2])\n                colnum[numcol[temp[-2]]].discard(col)\n        \n        colnum[a_i].add(col)\n    \n    return ans % MOD\n\ndef minimal_inconvenience(n, m, a):\n    ans = 0\n    A = [(a[i], i) for i in range(n*m)]\n    A.sort()\n    \n    q = [[False] * m for _ in range(n)]\n    \n    for a_i, i in A:\n        r = (i // m + 1)\n        c = (i % m)\n        \n        if not q[r-1][c]:\n            q[r-1][c] = True\n            continue\n        \n        for cc in range(c):\n            if not q[r-1][cc]:\n                q[r-1][cc] = True\n                ans += 1\n                break\n    \n    return ans % MOD\n\ndef count_valid_assignments(m):\n    dp = [[0] * 10 for _ in range(10)]\n    dp[0][0] = 1\n    \n    for i in range(1, m):\n        for j in range(10):\n            dp[i][(j + 4) % 10] += dp[i-1][j]\n            dp[i][(j + 7) % 10] += dp[i-1][j]\n    \n    total = sum(dp[m-1])\n    little_elephant_count = dp[m-1][4] + dp[m-1][7]\n    \n    if little_elephant_count > total - little_elephant_count:\n        return total // 2\n    else:\n        return 0\n\n# Read input and call functions\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn, m, k = map(int, data[0].split())\nfair_schedule(n, m, k)\n\nfor i in range(2, len(data), 2):\n    n, m = map(int, data[i].split())\n    a = list(map(int, data[i+1].split()))\n    print(min_inconvenience(n, m, a))\n\nn, m = map(int, data[len(data)-2].split())\na = list(map(int, data[len(data)-1].split()))\nprint(minimal_inconvenience(n, m, a))\n\nm = int(data[len(data)+1])\nprint(count_valid_assignments(m))\n```"], "prompt_tokens": [6014], "completion_tokens": [2262], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "656ed7b1b80de84d65a253e5d14d62a9"}
{"description": "Dima and Anya love playing different games. Now Dima has imagined a new game that he wants to play with Anya.Dima writes n pairs of integers on a piece of paper (li,\u2009ri) (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009p). Then players take turns. On his turn the player can do the following actions:  choose the number of the pair i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), such that ri\u2009-\u2009li\u2009&gt;\u20092;  replace pair number i by pair  or by pair . Notation \u230ax\u230b means rounding down to the closest integer. The player who can't make a move loses.Of course, Dima wants Anya, who will move first, to win. That's why Dima should write out such n pairs of integers (li,\u2009ri) (1\u2009\u2264\u2009li\u2009&lt;\u2009ri\u2009\u2264\u2009p), that if both players play optimally well, the first one wins. Count the number of ways in which Dima can do it. Print the remainder after dividing the answer by number 1000000007\u00a0(109\u2009+\u20097).Two ways are considered distinct, if the ordered sequences of the written pairs are distinct.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n, p (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009p\u2009\u2264\u2009109). The numbers are separated by a single space.", "output_spec": "In a single line print the remainder after dividing the answer to the problem by number 1000000007\u00a0(109\u2009+\u20097).", "notes": null, "sample_inputs": ["2 2", "4 4", "100 1000"], "sample_outputs": ["0", "520", "269568947"], "tags": ["games", "dp"], "src_uid": "c03b6379e9d186874ac3d97c6968fbd0", "difficulty": 2600, "source_codes": ["\nMOD = 1000000007\n\ndef count_valid_pairs(p):\n    if p <= 2:\n        return 0\n    if p == 3:\n        return 1\n    dp = [0] * (p + 1)\n    dp[0], dp[1], dp[2], dp[3] = 0, 0, 0, 1\n    \n    for i in range(4, p + 1):\n        dp[i] = (dp[i - 1] + dp[i - 3]) % MOD\n    \n    return dp[p]\n\ndef count_ways(n, p):\n    total_pairs = count_valid_pairs(p)\n    result = pow(total_pairs, n, MOD)\n    return result\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, p = map(int, input().split())\n    results.append(count_ways(n, p))\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\nMOD = 1000000007\n\ndef count_valid_pairs(p):\n    if p <= 2:\n        return 0\n    if p == 3:\n        return 1\n    dp = [0] * (p + 1)\n    dp[0], dp[1], dp[2], dp[3] = 0, 0, 0, 1\n    \n    for i in range(4, p + 1):\n        dp[i] = (dp[i - 1] + dp[i - 3]) % MOD\n    \n    return dp[p]\n\ndef count_ways(n, p):\n    total_pairs = count_valid_pairs(p)\n    result = pow(total_pairs, n, MOD)\n    return result\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, p = map(int, input().split())\n    results.append(count_ways(n, p))\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5497], "completion_tokens": [794], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "c03b6379e9d186874ac3d97c6968fbd0"}
{"description": "Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.  The figure shows a 4-output splitter Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.", "input_from": "standard input", "output_to": "standard output", "time_limit": "0.4 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091018, 2\u2009\u2264\u2009k\u2009\u2264\u2009109). Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.", "output_spec": "Print a single integer \u2014 the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.", "notes": null, "sample_inputs": ["4 3", "5 5", "8 4"], "sample_outputs": ["2", "1", "-1"], "tags": ["math", "binary search"], "src_uid": "83bcfe32db302fbae18e8a95d89cf411", "difficulty": 1700, "source_codes": ["\ndef minSplitters(n, k):\n    if n == 1:\n        return 0\n    \n    remainingPipes = n - 1\n    totalPipes = 0\n    numSplitters = 0\n    \n    while remainingPipes > 0 and k >= 2:\n        pipesAdded = k - 1\n        if pipesAdded <= remainingPipes:\n            remainingPipes -= pipesAdded\n            totalPipes += pipesAdded\n            numSplitters += 1\n            k -= 1\n        else:\n            break\n    \n    while remainingPipes > 0:\n        if k == 2:\n            if remainingPipes % 2 == 0:\n                numSplitters += remainingPipes // 2\n                remainingPipes = 0\n            else:\n                if totalPipes + 1 >= n:\n                    numSplitters += remainingPipes // 2\n                    remainingPipes = 1\n                else:\n                    return -1\n        else:\n            return -1\n    \n    return numSplitters\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(minSplitters(n, k))\n    \n    for result in results:\n        print(result)\n\n\n"], "responses": ["```python\ndef minSplitters(n, k):\n    if n == 1:\n        return 0\n    \n    remainingPipes = n - 1\n    totalPipes = 0\n    numSplitters = 0\n    \n    while remainingPipes > 0 and k >= 2:\n        pipesAdded = k - 1\n        if pipesAdded <= remainingPipes:\n            remainingPipes -= pipesAdded\n            totalPipes += pipesAdded\n            numSplitters += 1\n            k -= 1\n        else:\n            break\n    \n    while remainingPipes > 0:\n        if k == 2:\n            if remainingPipes % 2 == 0:\n                numSplitters += remainingPipes // 2\n                remainingPipes = 0\n            else:\n                if totalPipes + 1 >= n:\n                    numSplitters += remainingPipes // 2\n                    remainingPipes = 1\n                else:\n                    return -1\n        else:\n            return -1\n    \n    return numSplitters\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(minSplitters(n, k))\n    \n    for result in results:\n        print(result)\n```"], "prompt_tokens": [5805], "completion_tokens": [1257], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "83bcfe32db302fbae18e8a95d89cf411"}
