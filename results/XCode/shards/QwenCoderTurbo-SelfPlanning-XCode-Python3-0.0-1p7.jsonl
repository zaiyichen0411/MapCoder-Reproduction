{"description": "Iahub is training for the IOI. What is a better way to train than playing a Zuma-like game? There are n balls put in a row. Each ball is colored in one of k colors. Initially the row doesn't contain three or more contiguous balls with the same color. Iahub has a single ball of color x. He can insert his ball at any position in the row (probably, between two other balls). If at any moment there are three or more contiguous balls of the same color in the row, they are destroyed immediately. This rule is applied multiple times, until there are no more sets of 3 or more contiguous balls of the same color. For example, if Iahub has the row of balls [black, black, white, white, black, black] and a white ball, he can insert the ball between two white balls. Thus three white balls are destroyed, and then four black balls become contiguous, so all four balls are destroyed. The row will not contain any ball in the end, so Iahub can destroy all 6 balls.Iahub wants to destroy as many balls as possible. You are given the description of the row of balls, and the color of Iahub's ball. Help Iahub train for the IOI by telling him the maximum number of balls from the row he can destroy.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line of input contains three integers: n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), k (1\u2009\u2264\u2009k\u2009\u2264\u2009100) and x (1\u2009\u2264\u2009x\u2009\u2264\u2009k). The next line contains n space-separated integers c1,\u2009c2,\u2009...,\u2009cn (1\u2009\u2264\u2009ci\u2009\u2264\u2009k). Number ci means that the i-th ball in the row has color ci. It is guaranteed that the initial row of balls will never contain three or more contiguous balls of the same color. ", "output_spec": "Print a single integer \u2014 the maximum number of balls Iahub can destroy.", "notes": null, "sample_inputs": ["6 2 2\n1 1 2 2 1 1", "1 1 1\n1"], "sample_outputs": ["6", "0"], "tags": ["brute force", "two pointers"], "src_uid": "d73d9610e3800817a3109314b1e6f88c", "difficulty": 1400, "source_codes": ["\ndef generate_hat_game_schedule(n, m, k):\n    small_group_size = n // m\n    large_group_size = n // m + (n % m > 0)\n    groups = [large_group_size] * (n % m) + [small_group_size] * (m - n % m)\n    players = list(range(1, n + 1))\n    \n    schedule = []\n    for _ in range(k):\n        game_schedule = []\n        for group in groups:\n            game_schedule.append(f\"{group} {' '.join(map(str, players[:group]))}\")\n            players = players[group:] + players[:group]\n        schedule.extend(game_schedule)\n    \n    return schedule\n\ndef count_similar_permutations(n, a):\n    MOD = 10**9 + 7\n    r, k = 0, 1\n    mn = n\n    \n    for i, j in enumerate(sorted((x, i) for i, x in enumerate(a))):\n        if mn < j < r:\n            k = (k * (r - n - i + 1)) % MOD\n        mn = min(mn, j)\n        r = max(r, j)\n    \n    return k\n\ndef minimize_total_inconvenience(n, m, A):\n    MOD = 10**9 + 7\n    ans = 0\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i, x in enumerate(A):\n        if x not in numcol:\n            numcol[x] = set()\n            colnum[i] = len(numcol)\n            colnumcnt[colnum[i]] = 0\n        \n        numcol[x].add(colnum[i])\n        colnumcnt[colnum[i]] += 1\n        \n        if len(numcol[x]) == 2 and abs(list(numcol[x])[0] - list(numcol[x])[1]) != 1:\n            q[list(numcol[x])[0]].append(x)\n        \n        if len(numcol[x]) == 1 and colnumcnt[colnum[i]] == m:\n            q[colnum[i]].extend(A[(colnum[i] * m):((colnum[i] + 1) * m)])\n    \n    for x in A:\n        temp = [y for y in numcol[x]]\n        for y in temp:\n            if len(q[y]) >= 2 and abs(q[y][-1] - q[y][0]) <= 1:\n                continue\n            \n            last = q[y][-1]\n            for z in range(last + 1, q[y][-1] + len(q[y])):\n                if z in numcol:\n                    break\n                \n                q[y].append(z)\n                colnum[z] = y\n                colnumcnt[y] += 1\n                break\n        \n            ans += len(q[y]) - 2\n    \n    return ans\n\ndef max_balls_destroyed(n, k, x, c):\n    def destroy(start, end, color):\n        count = 0\n        while start < end and c[start] == color:\n            start += 1\n            count += 1\n        return count\n    \n    max_destroy = 0\n    for i in range(n):\n        left = i\n        right = i\n        count = 0\n        \n        while left >= 0 and right < n:\n            if c[left] == c[right]:\n                count += destroy(left, right + 1, c[left])\n                left -= 1\n                right += 1\n            else:\n                break\n        \n        max_destroy = max(max_destroy, count)\n    \n    return max_destroy\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        m = int(data[idx + 1])\n        k = int(data[idx + 2])\n        idx += 3\n        schedule = generate_hat_game_schedule(n, m, k)\n        results.extend(schedule)\n        results.append(\"\")\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        idx += 2\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        result = count_similar_permutations(n, a)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        m = int(data[idx + 1])\n        idx += 2\n        A = list(map(int, data[idx:idx + n * m]))\n        idx += n * m\n        \n        result = minimize_total_inconvenience(n, m, A)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        x = int(data[idx + 2])\n        idx += 3\n        c = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        result = max_balls_destroyed(n, k, x, c)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\n\n"], "responses": ["```python\ndef generate_hat_game_schedule(n, m, k):\n    small_group_size = n // m\n    large_group_size = n // m + (n % m > 0)\n    groups = [large_group_size] * (n % m) + [small_group_size] * (m - n % m)\n    players = list(range(1, n + 1))\n    \n    schedule = []\n    for _ in range(k):\n        game_schedule = []\n        for group in groups:\n            game_schedule.append(f\"{group} {' '.join(map(str, players[:group]))}\")\n            players = players[group:] + players[:group]\n        schedule.extend(game_schedule)\n    \n    return schedule\n\ndef count_similar_permutations(n, a):\n    MOD = 10**9 + 7\n    r, k = 0, 1\n    mn = n\n    \n    for i, j in enumerate(sorted((x, i) for i, x in enumerate(a))):\n        if mn < j < r:\n            k = (k * (r - n - i + 1)) % MOD\n        mn = min(mn, j)\n        r = max(r, j)\n    \n    return k\n\ndef minimize_total_inconvenience(n, m, A):\n    MOD = 10**9 + 7\n    ans = 0\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i, x in enumerate(A):\n        if x not in numcol:\n            numcol[x] = set()\n            colnum[i] = len(numcol)\n            colnumcnt[colnum[i]] = 0\n        \n        numcol[x].add(colnum[i])\n        colnumcnt[colnum[i]] += 1\n        \n        if len(numcol[x]) == 2 and abs(list(numcol[x])[0] - list(numcol[x])[1]) != 1:\n            q[list(numcol[x])[0]].append(x)\n        \n        if len(numcol[x]) == 1 and colnumcnt[colnum[i]] == m:\n            q[colnum[i]].extend(A[(colnum[i] * m):((colnum[i] + 1) * m)])\n    \n    for x in A:\n        temp = [y for y in numcol[x]]\n        for y in temp:\n            if len(q[y]) >= 2 and abs(q[y][-1] - q[y][0]) <= 1:\n                continue\n            \n            last = q[y][-1]\n            for z in range(last + 1, q[y][-1] + len(q[y])):\n                if z in numcol:\n                    break\n                \n                q[y].append(z)\n                colnum[z] = y\n                colnumcnt[y] += 1\n                break\n        \n            ans += len(q[y]) - 2\n    \n    return ans\n\ndef max_balls_destroyed(n, k, x, c):\n    def destroy(start, end, color):\n        count = 0\n        while start < end and c[start] == color:\n            start += 1\n            count += 1\n        return count\n    \n    max_destroy = 0\n    for i in range(n):\n        left = i\n        right = i\n        count = 0\n        \n        while left >= 0 and right < n:\n            if c[left] == c[right]:\n                count += destroy(left, right + 1, c[left])\n                left -= 1\n                right += 1\n            else:\n                break\n        \n        max_destroy = max(max_destroy, count)\n    \n    return max_destroy\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        m = int(data[idx + 1])\n        k = int(data[idx + 2])\n        idx += 3\n        schedule = generate_hat_game_schedule(n, m, k)\n        results.extend(schedule)\n        results.append(\"\")\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        idx += 2\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        result = count_similar_permutations(n, a)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        m = int(data[idx + 1])\n        idx += 2\n        A = list(map(int, data[idx:idx + n * m]))\n        idx += n * m\n        \n        result = minimize_total_inconvenience(n, m, A)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    idx = 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        x = int(data[idx + 2])\n        idx += 3\n        c = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        result = max_balls_destroyed(n, k, x, c)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n```"], "prompt_tokens": [6758], "completion_tokens": [3019], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "d73d9610e3800817a3109314b1e6f88c"}
{"description": "Ann has recently started commuting by subway. We know that a one ride subway ticket costs a rubles. Besides, Ann found out that she can buy a special ticket for m rides (she can buy it several times). It costs b rubles. Ann did the math; she will need to use subway n times. Help Ann, tell her what is the minimum sum of money she will have to spend to make n rides?", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains four space-separated integers n, m, a, b (1\u2009\u2264\u2009n,\u2009m,\u2009a,\u2009b\u2009\u2264\u20091000) \u2014 the number of rides Ann has planned, the number of rides covered by the m ride ticket, the price of a one ride ticket and the price of an m ride ticket. ", "output_spec": "Print a single integer \u2014 the minimum sum in rubles that Ann will need to spend.", "notes": "NoteIn the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three m ride tickets.", "sample_inputs": ["6 2 1 2", "5 2 2 3"], "sample_outputs": ["6", "8"], "tags": ["implementation"], "src_uid": "faa343ad6028c5a069857a38fa19bb24", "difficulty": 1200, "source_codes": ["\ndef min_subway_cost(n, m, a, b):\n    cost_only_one_ride = n * a\n    cost_only_m_ride = (n + m - 1) // m * b\n    min_cost = float('inf')\n    \n    for x in range((n + m - 1) // m + 1):\n        y = n - x * m\n        cost = x * b + y * a\n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nresults = []\nindex = 0\nfor _ in range(int(data[index])):\n    index += 1\n    n = int(data[index])\n    m = int(data[index + 1])\n    a = int(data[index + 2])\n    b = int(data[index + 3])\n    results.append(str(min_subway_cost(n, m, a, b)))\n\nprint('\\n'.join(results))\n\n\n"], "responses": ["```python\ndef min_subway_cost(n, m, a, b):\n    cost_only_one_ride = n * a\n    cost_only_m_ride = (n + m - 1) // m * b\n    min_cost = float('inf')\n    \n    for x in range((n + m - 1) // m + 1):\n        y = n - x * m\n        cost = x * b + y * a\n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nresults = []\nindex = 0\nfor _ in range(int(data[index])):\n    index += 1\n    n = int(data[index])\n    m = int(data[index + 1])\n    a = int(data[index + 2])\n    b = int(data[index + 3])\n    results.append(str(min_subway_cost(n, m, a, b)))\n\nprint('\\n'.join(results))\n```"], "prompt_tokens": [5231], "completion_tokens": [895], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "faa343ad6028c5a069857a38fa19bb24"}
{"description": "Pasha has a positive integer a without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.Help Pasha count the maximum number he can get if he has the time to make at most k swaps.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The single line contains two integers a and k (1\u2009\u2264\u2009a\u2009\u2264\u20091018;\u00a00\u2009\u2264\u2009k\u2009\u2264\u2009100).", "output_spec": "Print the maximum number that Pasha can get if he makes at most k swaps.", "notes": null, "sample_inputs": ["1990 1", "300 0", "1034 2", "9090000078001234 6"], "sample_outputs": ["9190", "300", "3104", "9907000008001234"], "tags": ["greedy"], "src_uid": "e56f6c343167745821f0b18dcf0d0cde", "difficulty": 1400, "source_codes": ["\nfrom heapq import heappop, heappush\n\ndef max_number_with_swaps(a, k):\n    digits = [int(d) for d in str(a)]\n    n = len(digits)\n    pq = []\n    \n    for i in range(n):\n        for j in range(i + 1, min(n, i + k + 1)):\n            if digits[i] < digits[j]:\n                heappush(pq, (-digits[j], i, j))\n    \n    for _ in range(k):\n        if pq:\n            _, i, j = heappop(pq)\n            digits[i], digits[j] = digits[j], digits[i]\n        else:\n            break\n    \n    result = int(''.join(map(str, digits)))\n    return result\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a, k = map(int, input().split())\n    results.append(max_number_with_swaps(a, k))\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\nfrom heapq import heappop, heappush\n\ndef max_number_with_swaps(a, k):\n    digits = [int(d) for d in str(a)]\n    n = len(digits)\n    pq = []\n    \n    for i in range(n):\n        for j in range(i + 1, min(n, i + k + 1)):\n            if digits[i] < digits[j]:\n                heappush(pq, (-digits[j], i, j))\n    \n    for _ in range(k):\n        if pq:\n            _, i, j = heappop(pq)\n            digits[i], digits[j] = digits[j], digits[i]\n        else:\n            break\n    \n    result = int(''.join(map(str, digits)))\n    return result\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a, k = map(int, input().split())\n    results.append(max_number_with_swaps(a, k))\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5150], "completion_tokens": [884], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "e56f6c343167745821f0b18dcf0d0cde"}
{"description": "This winter is so cold in Nvodsk! A group of n friends decided to buy k bottles of a soft drink called \"Take-It-Light\" to warm up a bit. Each bottle has l milliliters of the drink. Also they bought c limes and cut each of them into d slices. After that they found p grams of salt.To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first and only line contains positive integers n, k, l, c, d, p, nl, np, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.", "output_spec": "Print a single integer \u2014 the number of toasts each friend can make.", "notes": "NoteA comment to the first sample: Overall the friends have 4\u2009*\u20095\u2009=\u200920 milliliters of the drink, it is enough to make 20\u2009/\u20093\u2009=\u20096 toasts. The limes are enough for 10\u2009*\u20098\u2009=\u200980 toasts and the salt is enough for 100\u2009/\u20091\u2009=\u2009100 toasts. However, there are 3 friends in the group, so the answer is min(6,\u200980,\u2009100)\u2009/\u20093\u2009=\u20092.", "sample_inputs": ["3 4 5 10 8 100 3 1", "5 100 10 1 19 90 4 3", "10 1000 1000 25 23 1 50 1"], "sample_outputs": ["2", "3", "0"], "tags": ["math", "implementation"], "src_uid": "67410b7d36b9d2e6a97ca5c7cff317c1", "difficulty": 800, "source_codes": ["\ndef max_toasts(n, k, l, c, d, p, nl, np):\n    total_drink = k * l\n    total_lime_slices = c * d\n    total_salt = p\n    toasts_with_drink = total_drink // (n * nl)\n    toasts_with_lime = total_lime_slices // n\n    toasts_with_salt = total_salt // (n * np)\n    return min(toasts_with_drink, toasts_with_lime, toasts_with_salt)\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n    results.append(max_toasts(n, k, l, c, d, p, nl, np))\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef max_toasts(n, k, l, c, d, p, nl, np):\n    total_drink = k * l\n    total_lime_slices = c * d\n    total_salt = p\n    toasts_with_drink = total_drink // (n * nl)\n    toasts_with_lime = total_lime_slices // n\n    toasts_with_salt = total_salt // (n * np)\n    return min(toasts_with_drink, toasts_with_lime, toasts_with_salt)\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n    results.append(max_toasts(n, k, l, c, d, p, nl, np))\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5627], "completion_tokens": [916], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "67410b7d36b9d2e6a97ca5c7cff317c1"}
{"description": "Lavrenty, a baker, is going to make several buns with stuffings and sell them.Lavrenty has n grams of dough as well as m different stuffing types. The stuffing types are numerated from 1 to m. Lavrenty knows that he has ai grams left of the i-th stuffing. It takes exactly bi grams of stuffing i and ci grams of dough to cook a bun with the i-th stuffing. Such bun can be sold for di tugriks.Also he can make buns without stuffings. Each of such buns requires c0 grams of dough and it can be sold for d0 tugriks. So Lavrenty can cook any number of buns with different stuffings or without it unless he runs out of dough and the stuffings. Lavrenty throws away all excess material left after baking.Find the maximum number of tugriks Lavrenty can earn.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains 4 integers n, m, c0 and d0 (1\u2009\u2264\u2009n\u2009\u2264\u20091000, 1\u2009\u2264\u2009m\u2009\u2264\u200910, 1\u2009\u2264\u2009c0,\u2009d0\u2009\u2264\u2009100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1\u2009\u2264\u2009ai,\u2009bi,\u2009ci,\u2009di\u2009\u2264\u2009100).", "output_spec": "Print the only number \u2014 the maximum number of tugriks Lavrenty can earn.", "notes": "NoteTo get the maximum number of tugriks in the first sample, you need to cook 2 buns with stuffing 1, 4 buns with stuffing 2 and a bun without any stuffing.In the second sample Lavrenty should cook 4 buns without stuffings.", "sample_inputs": ["10 2 2 1\n7 3 2 100\n12 3 1 10", "100 1 25 50\n15 5 20 10"], "sample_outputs": ["241", "200"], "tags": ["dp"], "src_uid": "4e166b8b44427b1227e0f811161d3a6f", "difficulty": 1700, "source_codes": ["\ndef fair_schedule():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        \n        ceil_val = (n + m - 1) // m\n        floor_val = n // m\n        z = 0\n        \n        if n % m != 0:\n            for i in range(m):\n                if z == n % m:\n                    ceil_val -= 1\n                else:\n                    floor_val += 1\n                z += 1\n        \n        smaller_group_size = floor_val\n        larger_group_size = ceil_val\n        \n        players = list(range(1, n + 1))\n        \n        for _ in range(k):\n            schedule = []\n            for _ in range(m):\n                if len(players) > larger_group_size:\n                    schedule.append(f\"{larger_group_size} \" + \" \".join(map(str, players[:larger_group_size])))\n                    players = players[larger_group_size:]\n                elif len(players) > 0:\n                    schedule.append(f\"{smaller_group_size} \" + \" \".join(map(str, players[:smaller_group_size])))\n                    players = players[smaller_group_size:]\n            \n            results.extend(schedule)\n            players = players[::-1]\n    \n    for result in results:\n        print(result)\n\n\ndef count_similar_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        r = max(a)\n        k = 1\n        \n        for i, j in enumerate(sorted((x, y) for x, y in enumerate(a))):\n            k = (k * (r - n - i + 1)) % (10**9 + 7) if n < j[0] < r else k\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n\n\ndef minimize_inconvenience():\n    import heapq\n\n    def minimize_inconvenience():\n        import sys\n        input = sys.stdin.read\n        data = input().split()\n        \n        index = 0\n        t = int(data[index])\n        index += 1\n        \n        results = []\n        \n        for _ in range(t):\n            n = int(data[index])\n            m = int(data[index + 1])\n            index += 2\n            a = list(map(int, data[index:index+n*m]))\n            index += n*m\n            \n            q = []\n            for i in range(n):\n                for j in range(m):\n                    heapq.heappush(q, (a[i*m+j], i, j))\n            \n            ans = 0\n            colnum = [0]*m\n            colnumcnt = [0]*m\n            numcol = {}\n            for i in range(n):\n                numcol[i] = set()\n            \n            while q:\n                _, r, c = heapq.heappop(q)\n                if colnum[c] >= min(r, n-r):\n                    continue\n                ans += (min(r, n-r) - colnum[c])\n                colnum[c] += 1\n                colnumcnt[c] += 1\n                if colnumcnt[c] == 2:\n                    del numcol[r]\n                    del numcol[n-r]\n                    colnumcnt[c] = 0\n            \n            results.append(ans)\n        \n        for result in results:\n            print(result)\n\n\ndef maximize_bun_earnings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m, c0, d0 = map(int, data[index:index+4])\n        index += 4\n        stuffings = []\n        for _ in range(m):\n            ai, bi, ci, di = map(int, data[index:index+4])\n            stuffings.append((ai, bi, ci, di))\n            index += 4\n        \n        dp = [0] * (n + 1)\n        \n        for ai, bi, ci, di in stuffings:\n            for j in range(n, bi - 1, -1):\n                dp[j] = max(dp[j], dp[j - bi] + di * (j // bi) + c0 * (j % bi))\n        \n        results.append(max(dp))\n    \n    for result in results:\n        print(result)\n\n\n# Call the functions\nfair_schedule()\ncount_similar_permutations()\nminimize_inconvenience()\nmaximize_bun_earnings()\n\n\n"], "responses": ["```python\ndef fair_schedule():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        \n        ceil_val = (n + m - 1) // m\n        floor_val = n // m\n        z = 0\n        \n        if n % m != 0:\n            for i in range(m):\n                if z == n % m:\n                    ceil_val -= 1\n                else:\n                    floor_val += 1\n                z += 1\n        \n        smaller_group_size = floor_val\n        larger_group_size = ceil_val\n        \n        players = list(range(1, n + 1))\n        \n        for _ in range(k):\n            schedule = []\n            for _ in range(m):\n                if len(players) > larger_group_size:\n                    schedule.append(f\"{larger_group_size} \" + \" \".join(map(str, players[:larger_group_size])))\n                    players = players[larger_group_size:]\n                elif len(players) > 0:\n                    schedule.append(f\"{smaller_group_size} \" + \" \".join(map(str, players[:smaller_group_size])))\n                    players = players[smaller_group_size:]\n            \n            results.extend(schedule)\n            players = players[::-1]\n    \n    for result in results:\n        print(result)\n\n\ndef count_similar_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        r = max(a)\n        k = 1\n        \n        for i, j in enumerate(sorted((x, y) for x, y in enumerate(a))):\n            k = (k * (r - n - i + 1)) % (10**9 + 7) if n < j[0] < r else k\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n\n\ndef minimize_inconvenience():\n    import heapq\n\n    def minimize_inconvenience():\n        import sys\n        input = sys.stdin.read\n        data = input().split()\n        \n        index = 0\n        t = int(data[index])\n        index += 1\n        \n        results = []\n        \n        for _ in range(t):\n            n = int(data[index])\n            m = int(data[index + 1])\n            index += 2\n            a = list(map(int, data[index:index+n*m]))\n            index += n*m\n            \n            q = []\n            for i in range(n):\n                for j in range(m):\n                    heapq.heappush(q, (a[i*m+j], i, j))\n            \n            ans = 0\n            colnum = [0]*m\n            colnumcnt = [0]*m\n            numcol = {}\n            for i in range(n):\n                numcol[i] = set()\n            \n            while q:\n                _, r, c = heapq.heappop(q)\n                if colnum[c] >= min(r, n-r):\n                    continue\n                ans += (min(r, n-r) - colnum[c])\n                colnum[c] += 1\n                colnumcnt[c] += 1\n                if colnumcnt[c] == 2:\n                    del numcol[r]\n                    del numcol[n-r]\n                    colnumcnt[c] = 0\n            \n            results.append(ans)\n        \n        for result in results:\n            print(result)\n\n\ndef maximize_bun_earnings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m, c0, d0 = map(int, data[index:index+4])\n        index += 4\n        stuffings = []\n        for _ in range(m):\n            ai, bi, ci, di = map(int, data[index:index+4])\n            stuffings.append((ai, bi, ci, di))\n            index += 4\n        \n        dp = [0] * (n + 1)\n        \n        for ai, bi, ci, di in stuffings:\n            for j in range(n, bi - 1, -1):\n                dp[j] = max(dp[j], dp[j - bi] + di * (j // bi) + c0 * (j % bi))\n        \n        results.append(max(dp))\n    \n    for result in results:\n        print(result)\n\n\n# Call the functions\nfair_schedule()\ncount_similar_permutations()\nminimize_inconvenience()\nmaximize_bun_earnings()\n```"], "prompt_tokens": [6642], "completion_tokens": [2739], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "4e166b8b44427b1227e0f811161d3a6f"}
{"description": "Little Petya loves training spiders. Petya has a board n\u2009\u00d7\u2009m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200940,\u2009n\u00b7m\u2009\u2264\u200940) \u2014 the board sizes.", "output_spec": "In the first line print the maximum number of cells without spiders.", "notes": "NoteIn the first sample the only possible answer is:sIn the second sample one of the possible solutions is: rdlruls denotes command \"stay idle\", l, r, d, u denote commands \"crawl left\", \"crawl right\", \"crawl down\", \"crawl up\", correspondingly.", "sample_inputs": ["1 1", "2 3"], "sample_outputs": ["0", "4"], "tags": ["bitmasks", "dp", "dsu"], "src_uid": "097674b4dd696b30e102938f71dd39b9", "difficulty": 2100, "source_codes": ["\ndef max_empty_cells(n, m):\n    board = [[True] * m for _ in range(n)]\n    occupied = set()\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m:\n                    occupied.add((ni, nj))\n    \n    total_cells = n * m\n    num_occupied = len(occupied)\n    num_empty = total_cells - num_occupied\n    \n    return num_empty\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    results.append(max_empty_cells(n, m))\n\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef max_empty_cells(n, m):\n    board = [[True] * m for _ in range(n)]\n    occupied = set()\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m:\n                    occupied.add((ni, nj))\n    \n    total_cells = n * m\n    num_occupied = len(occupied)\n    num_empty = total_cells - num_occupied\n    \n    return num_empty\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    results.append(max_empty_cells(n, m))\n\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5451], "completion_tokens": [982], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "097674b4dd696b30e102938f71dd39b9"}
{"description": "Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya dreamt of a lexicographically k-th permutation of integers from 1 to n. Determine how many lucky numbers in the permutation are located on the positions whose indexes are also lucky numbers.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009109) \u2014 the number of elements in the permutation and the lexicographical number of the permutation.", "output_spec": "If the k-th permutation of numbers from 1 to n does not exist, print the single number \"-1\" (without the quotes). Otherwise, print the answer to the problem: the number of such indexes i, that i and ai are both lucky numbers.", "notes": "NoteA permutation is an ordered set of n elements, where each integer from 1 to n occurs exactly once. The element of permutation in position with index i is denoted as ai (1\u2009\u2264\u2009i\u2009\u2264\u2009n). Permutation a is lexicographically smaller that permutation b if there is such a i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), that ai\u2009&lt;\u2009bi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) aj\u2009=\u2009bj. Let's make a list of all possible permutations of n elements and sort it in the order of lexicographical increasing. Then the lexicographically k-th permutation is the k-th element of this list of permutations.In the first sample the permutation looks like that:1 2 3 4 6 7 5The only suitable position is 4.In the second sample the permutation looks like that:2 1 3 4The only suitable position is 4.", "sample_inputs": ["7 4", "4 7"], "sample_outputs": ["1", "1"], "tags": ["brute force", "combinatorics", "number theory"], "src_uid": "cb2aa02772f95fefd1856960b6ceac4c", "difficulty": 1900, "source_codes": ["\ndef generate_lucky_numbers(limit):\n    lucky_numbers = []\n    queue = ['4', '7']\n    while len(lucky_numbers) < limit:\n        num = queue.pop(0)\n        lucky_numbers.append(int(num))\n        queue.append(num + '4')\n        queue.append(num + '7')\n    return lucky_numbers\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef kth_permutation(n, k):\n    k -= 1\n    permutation = []\n    remaining = list(range(1, n + 1))\n    fact = factorial(n - 1)\n    \n    for i in range(n, 0, -1):\n        index = k // fact\n        permutation.append(remaining[index])\n        remaining.remove(remaining[index])\n        k %= fact\n        if i > 1:\n            fact //= (i - 1)\n    \n    return permutation\n\ndef count_lucky_positions(n, k):\n    lucky_numbers = generate_lucky_numbers(n)\n    lucky_set = set(lucky_numbers)\n    permutation = kth_permutation(n, k)\n    count = 0\n    \n    for i, value in enumerate(permutation, start=1):\n        if i in lucky_set and value in lucky_set:\n            count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    t = int(data[index])\n    index += 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        result = count_lucky_positions(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n\n"], "responses": ["```python\ndef generate_lucky_numbers(limit):\n    lucky_numbers = []\n    queue = ['4', '7']\n    while len(lucky_numbers) < limit:\n        num = queue.pop(0)\n        lucky_numbers.append(int(num))\n        queue.append(num + '4')\n        queue.append(num + '7')\n    return lucky_numbers\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef kth_permutation(n, k):\n    k -= 1\n    permutation = []\n    remaining = list(range(1, n + 1))\n    fact = factorial(n - 1)\n    \n    for i in range(n, 0, -1):\n        index = k // fact\n        permutation.append(remaining[index])\n        remaining.remove(remaining[index])\n        k %= fact\n        if i > 1:\n            fact //= (i - 1)\n    \n    return permutation\n\ndef count_lucky_positions(n, k):\n    lucky_numbers = generate_lucky_numbers(n)\n    lucky_set = set(lucky_numbers)\n    permutation = kth_permutation(n, k)\n    count = 0\n    \n    for i, value in enumerate(permutation, start=1):\n        if i in lucky_set and value in lucky_set:\n            count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    t = int(data[index])\n    index += 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        result = count_lucky_positions(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n```"], "prompt_tokens": [5835], "completion_tokens": [1312], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "cb2aa02772f95fefd1856960b6ceac4c"}
{"description": "Little Petya very much likes strings. Recently he has received a voucher to purchase a string as a gift from his mother. The string can be bought in the local shop. One can consider that the shop has all sorts of strings over the alphabet of fixed size. The size of the alphabet is equal to k. However, the voucher has a string type limitation: specifically, the voucher can be used to purchase string s if the length of string's longest substring that is also its weak subsequence (see the definition given below) equals w.String a with the length of n is considered the weak subsequence of the string s with the length of m, if there exists such a set of indexes 1\u2009\u2264\u2009i1\u2009&lt;\u2009i2\u2009&lt;\u2009...\u2009&lt;\u2009in\u2009\u2264\u2009m, that has the following two properties:   ak\u2009=\u2009sik for all k from 1 to n;  there exists at least one such k (1\u2009\u2264\u2009k\u2009&lt;\u2009n), for which ik\u2009+\u20091\u2009\u2013\u2009ik\u2009&gt;\u20091. Petya got interested how many different strings are available for him to purchase in the shop. As the number of strings can be very large, please find it modulo 1000000007 (109\u2009+\u20097). If there are infinitely many such strings, print \"-1\".", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers k (1\u2009\u2264\u2009k\u2009\u2264\u2009106) and w (2\u2009\u2264\u2009w\u2009\u2264\u2009109) \u2014 the alphabet size and the required length of the maximum substring that also is the weak subsequence, correspondingly.", "output_spec": "Print a single number \u2014 the number of strings Petya can buy using the voucher, modulo 1000000007 (109\u2009+\u20097). If there are infinitely many such strings, print \"-1\" (without the quotes).", "notes": "NoteIn the first sample Petya can buy the following strings: aaa, aab, abab, abb, abba, baa, baab, baba, bba, bbb.", "sample_inputs": ["2 2", "3 5", "2 139"], "sample_outputs": ["10", "1593", "717248223"], "tags": ["combinatorics"], "src_uid": "b715f0fdc83ec539eb3ae2b0371ee130", "difficulty": 3000, "source_codes": ["\n# Problem 1: Fair Game Schedule\ndef fair_game_schedule(n, m, k):\n    import math\n    \n    def distribute_players(n, m):\n        floor = n // m\n        ceil = n // m + (n % m != 0)\n        \n        # Create initial groups\n        groups = [floor] * m\n        remaining = n - floor * m\n        \n        # Distribute extra players\n        for _ in range(remaining):\n            groups[_] += 1\n        \n        return groups\n    \n    def rotate(lst, steps):\n        return lst[-steps:] + lst[:-steps]\n    \n    groups = distribute_players(n, m)\n    players = list(range(1, n + 1))\n    result = []\n    \n    for _ in range(k):\n        result.append(' '.join(map(str, groups)))\n        players = rotate(players, 1)\n        for i in range(m):\n            if groups[i] > floor:\n                groups[i] -= 1\n            else:\n                groups[i] += 1\n    \n    return '\\n'.join(result)\n\n# Problem 2: Counting Similar Permutations\ndef count_similar_permutations(a):\n    MOD = 10**9 + 7\n    from collections import defaultdict\n    \n    n = len(a)\n    indices = sorted(range(n), key=a.__getitem__)\n    dp = defaultdict(int)\n    dp[(indices[0],)] = 1\n    \n    for i in range(1, n):\n        new_dp = defaultdict(int)\n        for perm, cnt in dp.items():\n            last = perm[-1]\n            for j in range(last + 1, n):\n                new_dp[perm + (j,)] = (new_dp[perm + (j,)] + cnt) % MOD\n        dp = new_dp\n    \n    return sum(dp.values()) % MOD\n\n# Problem 3: Minimizing Total Inconvenience\ndef min_inconvenience(n, m, a):\n    MOD = 10**9 + 7\n    a.sort()\n    q = [0] * (n * m)\n    ans = 0\n    \n    for x in a:\n        temp = set()\n        for i in range(n):\n            if i * m <= x < (i + 1) * m:\n                temp.add(i)\n                break\n        \n        for i in temp:\n            occupied = 0\n            for j in range(q[i * m], q[i * m + m]):\n                if j >= x:\n                    break\n                occupied += 1\n            \n            ans = (ans + occupied) % MOD\n        \n        q[x] = x\n    \n    return ans\n\n# Problem 4: String Constraints\ndef count_valid_strings(k, w):\n    MOD = 10**9 + 7\n    \n    if w == 1:\n        return pow(k, k, MOD)\n    \n    if k == 1:\n        if w > 1:\n            return -1\n        return 1\n    \n    return pow(k, w, MOD)\n\n# Input handling\nfor line in ['5 2 2\\n2 0 3 2 1', '4 0 3 2 1', '0', '1 2 3', '1 3 7 2 5 0 6 4', '2 2', '3 5', '2 139']:\n    parts = line.split('\\n')\n    command = parts[0].split()\n    n, m, k = int(command[0]), int(command[1]), int(command[2])\n    if len(parts) > 1:\n        a = list(map(int, parts[1].split()))\n        if len(a) == n:\n            print(eval(command[0])(*command[1:], a))\n        else:\n            print(eval(command[0])(*command[1:]))\n    else:\n        print(eval(command[0])(*command[1:]))\n\n\n"], "responses": ["```python\n# Problem 1: Fair Game Schedule\ndef fair_game_schedule(n, m, k):\n    import math\n    \n    def distribute_players(n, m):\n        floor = n // m\n        ceil = n // m + (n % m != 0)\n        \n        # Create initial groups\n        groups = [floor] * m\n        remaining = n - floor * m\n        \n        # Distribute extra players\n        for _ in range(remaining):\n            groups[_] += 1\n        \n        return groups\n    \n    def rotate(lst, steps):\n        return lst[-steps:] + lst[:-steps]\n    \n    groups = distribute_players(n, m)\n    players = list(range(1, n + 1))\n    result = []\n    \n    for _ in range(k):\n        result.append(' '.join(map(str, groups)))\n        players = rotate(players, 1)\n        for i in range(m):\n            if groups[i] > floor:\n                groups[i] -= 1\n            else:\n                groups[i] += 1\n    \n    return '\\n'.join(result)\n\n# Problem 2: Counting Similar Permutations\ndef count_similar_permutations(a):\n    MOD = 10**9 + 7\n    from collections import defaultdict\n    \n    n = len(a)\n    indices = sorted(range(n), key=a.__getitem__)\n    dp = defaultdict(int)\n    dp[(indices[0],)] = 1\n    \n    for i in range(1, n):\n        new_dp = defaultdict(int)\n        for perm, cnt in dp.items():\n            last = perm[-1]\n            for j in range(last + 1, n):\n                new_dp[perm + (j,)] = (new_dp[perm + (j,)] + cnt) % MOD\n        dp = new_dp\n    \n    return sum(dp.values()) % MOD\n\n# Problem 3: Minimizing Total Inconvenience\ndef min_inconvenience(n, m, a):\n    MOD = 10**9 + 7\n    a.sort()\n    q = [0] * (n * m)\n    ans = 0\n    \n    for x in a:\n        temp = set()\n        for i in range(n):\n            if i * m <= x < (i + 1) * m:\n                temp.add(i)\n                break\n        \n        for i in temp:\n            occupied = 0\n            for j in range(q[i * m], q[i * m + m]):\n                if j >= x:\n                    break\n                occupied += 1\n            \n            ans = (ans + occupied) % MOD\n        \n        q[x] = x\n    \n    return ans\n\n# Problem 4: String Constraints\ndef count_valid_strings(k, w):\n    MOD = 10**9 + 7\n    \n    if w == 1:\n        return pow(k, k, MOD)\n    \n    if k == 1:\n        if w > 1:\n            return -1\n        return 1\n    \n    return pow(k, w, MOD)\n\n# Input handling\nfor line in ['5 2 2\\n2 0 3 2 1', '4 0 3 2 1', '0', '1 2 3', '1 3 7 2 5 0 6 4', '2 2', '3 5', '2 139']:\n    parts = line.split('\\n')\n    command = parts[0].split()\n    n, m, k = int(command[0]), int(command[1]), int(command[2])\n    if len(parts) > 1:\n        a = list(map(int, parts[1].split()))\n        if len(a) == n:\n            print(eval(command[0])(*command[1:], a))\n        else:\n            print(eval(command[0])(*command[1:]))\n    else:\n        print(eval(command[0])(*command[1:]))\n```"], "prompt_tokens": [6391], "completion_tokens": [2117], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "b715f0fdc83ec539eb3ae2b0371ee130"}
{"description": "Life is not easy for the perfectly common variable named Vasya. Wherever it goes, it is either assigned a value, or simply ignored, or is being used!Vasya's life goes in states of a program. In each state, Vasya can either be used (for example, to calculate the value of another variable), or be assigned a value, or ignored. Between some states are directed (oriented) transitions.A path is a sequence of states v1,\u2009v2,\u2009...,\u2009vx, where for any 1\u2009\u2264\u2009i\u2009&lt;\u2009x exists a transition from vi to vi\u2009+\u20091.Vasya's value in state v is interesting to the world, if exists path p1,\u2009p2,\u2009...,\u2009pk such, that pi\u2009=\u2009v for some i (1\u2009\u2264\u2009i\u2009\u2264\u2009k), in state p1 Vasya gets assigned a value, in state pk Vasya is used and there is no state pi (except for p1) where Vasya gets assigned a value.Help Vasya, find the states in which Vasya's value is interesting to the world.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains two space-separated integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009105) \u2014 the numbers of states and transitions, correspondingly. The second line contains space-separated n integers f1,\u2009f2,\u2009...,\u2009fn (0\u2009\u2264\u2009fi\u2009\u2264\u20092), fi described actions performed upon Vasya in state i: 0 represents ignoring, 1 \u2014 assigning a value, 2 \u2014 using. Next m lines contain space-separated pairs of integers ai,\u2009bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u2009n, ai\u2009\u2260\u2009bi), each pair represents the transition from the state number ai to the state number bi. Between two states can be any number of transitions.", "output_spec": "Print n integers r1,\u2009r2,\u2009...,\u2009rn, separated by spaces or new lines. Number ri should equal 1, if Vasya's value in state i is interesting to the world and otherwise, it should equal 0. The states are numbered from 1 to n in the order, in which they are described in the input.", "notes": "NoteIn the first sample the program states can be used to make the only path in which the value of Vasya interests the world, 1  2  3  4; it includes all the states, so in all of them Vasya's value is interesting to the world.The second sample the only path in which Vasya's value is interesting to the world is , \u2014 1  3; state 2 is not included there.In the third sample we cannot make from the states any path in which the value of Vasya would be interesting to the world, so the value of Vasya is never interesting to the world.", "sample_inputs": ["4 3\n1 0 0 2\n1 2\n2 3\n3 4", "3 1\n1 0 2\n1 3", "3 1\n2 0 1\n1 3"], "sample_outputs": ["1\n1\n1\n1", "1\n0\n1", "0\n0\n0"], "tags": ["graphs"], "src_uid": "87d869a0fd4a510c5e7e310886b86a57", "difficulty": 1700, "source_codes": ["\nfrom collections import defaultdict, deque\n\ndef find_interesting_states(n, m, actions, transitions):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in transitions:\n        graph[u].append(v)\n    \n    # List to store interesting states\n    interesting_states = [0] * (n + 1)\n    \n    # Function to perform BFS and mark interesting states\n    def bfs(start_state):\n        queue = deque([start_state])\n        visited = set()\n        visited.add(start_state)\n        \n        while queue:\n            current = queue.popleft()\n            \n            # Mark the current state as interesting\n            interesting_states[current] = 1\n            \n            # Traverse all neighbors\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n    \n    # Identify states where Vasya is assigned a value\n    for i in range(1, n + 1):\n        if actions[i - 1] == 1:\n            bfs(i)\n    \n    return interesting_states[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nresults = []\nwhile index < len(data):\n    t = int(data[index])\n    index += 1\n    \n    results.extend([])\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        actions = list(map(int, data[index + 2:index + 2 + n]))\n        transitions = [(int(data[index + 2 + n + 2*i]), int(data[index + 2 + n + 2*i + 1])) for i in range(m)]\n        \n        index += 2 + n + 2 * m\n        \n        result = find_interesting_states(n, m, actions, transitions)\n        results.extend(result)\n\n# Print results\nprint('\\n'.join(map(str, results)))\n\n\n"], "responses": ["```python\nfrom collections import defaultdict, deque\n\ndef find_interesting_states(n, m, actions, transitions):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in transitions:\n        graph[u].append(v)\n    \n    # List to store interesting states\n    interesting_states = [0] * (n + 1)\n    \n    # Function to perform BFS and mark interesting states\n    def bfs(start_state):\n        queue = deque([start_state])\n        visited = set()\n        visited.add(start_state)\n        \n        while queue:\n            current = queue.popleft()\n            \n            # Mark the current state as interesting\n            interesting_states[current] = 1\n            \n            # Traverse all neighbors\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n    \n    # Identify states where Vasya is assigned a value\n    for i in range(1, n + 1):\n        if actions[i - 1] == 1:\n            bfs(i)\n    \n    return interesting_states[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nresults = []\nwhile index < len(data):\n    t = int(data[index])\n    index += 1\n    \n    results.extend([])\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        actions = list(map(int, data[index + 2:index + 2 + n]))\n        transitions = [(int(data[index + 2 + n + 2*i]), int(data[index + 2 + n + 2*i + 1])) for i in range(m)]\n        \n        index += 2 + n + 2 * m\n        \n        result = find_interesting_states(n, m, actions, transitions)\n        results.extend(result)\n\n# Print results\nprint('\\n'.join(map(str, results)))\n```"], "prompt_tokens": [6439], "completion_tokens": [1339], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "87d869a0fd4a510c5e7e310886b86a57"}
{"description": "To get money for a new aeonic blaster, ranger Qwerty decided to engage in trade for a while. He wants to buy some number of items (or probably not to buy anything at all) on one of the planets, and then sell the bought items on another planet. Note that this operation is not repeated, that is, the buying and the selling are made only once. To carry out his plan, Qwerty is going to take a bank loan that covers all expenses and to return the loaned money at the end of the operation (the money is returned without the interest). At the same time, Querty wants to get as much profit as possible.The system has n planets in total. On each of them Qwerty can buy or sell items of m types (such as food, medicine, weapons, alcohol, and so on). For each planet i and each type of items j Qwerty knows the following: aij \u2014 the cost of buying an item;  bij \u2014 the cost of selling an item;  cij \u2014 the number of remaining items.It is not allowed to buy more than cij items of type j on planet i, but it is allowed to sell any number of items of any kind.Knowing that the hold of Qwerty's ship has room for no more than k items, determine the maximum profit which Qwerty can get.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains three space-separated integers n, m and k (2\u2009\u2264\u2009n\u2009\u2264\u200910, 1\u2009\u2264\u2009m,\u2009k\u2009\u2264\u2009100) \u2014 the number of planets, the number of question types and the capacity of Qwerty's ship hold, correspondingly. Then follow n blocks describing each planet. The first line of the i-th block has the planet's name as a string with length from 1 to 10 Latin letters. The first letter of the name is uppercase, the rest are lowercase. Then in the i-th block follow m lines, the j-th of them contains three integers aij, bij and cij (1\u2009\u2264\u2009bij\u2009&lt;\u2009aij\u2009\u2264\u20091000, 0\u2009\u2264\u2009cij\u2009\u2264\u2009100) \u2014 the numbers that describe money operations with the j-th item on the i-th planet. The numbers in the lines are separated by spaces. It is guaranteed that the names of all planets are different.", "output_spec": "Print a single number \u2014 the maximum profit Qwerty can get.", "notes": "NoteIn the first test case you should fly to planet Venus, take a loan on 74 units of money and buy three items of the first type and 7 items of the third type (3\u00b76\u2009+\u20097\u00b78\u2009=\u200974). Then the ranger should fly to planet Earth and sell there all the items he has bought. He gets 3\u00b79\u2009+\u20097\u00b79\u2009=\u200990 units of money for the items, he should give 74 of them for the loan. The resulting profit equals 16 units of money. We cannot get more profit in this case.", "sample_inputs": ["3 3 10\nVenus\n6 5 3\n7 6 5\n8 6 10\nEarth\n10 9 0\n8 6 4\n10 9 3\nMars\n4 3 0\n8 4 12\n7 2 5"], "sample_outputs": ["16"], "tags": ["games", "graph matchings", "greedy"], "src_uid": "7419c4268a9815282fadca6581f28ec1", "difficulty": 1200, "source_codes": ["\nimport math\nMOD = 10**9 + 7\n\ndef generate_hat_schedule(t):\n    results = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ceil_group_size = math.ceil(n / m)\n        floor_group_size = math.floor(n / m)\n        players = list(range(1, n + 1))\n        for _ in range(k):\n            group_indices = [i // floor_group_size for i in range(n)]\n            count = [group_indices.count(i) for i in range(m)]\n            extra_count = len(players) - sum(count)\n            for i in range(extra_count):\n                count[i % m] += 1\n            schedule = []\n            for i in range(m):\n                start = sum(count[:i])\n                end = start + count[i]\n                schedule.append((count[i], *players[start:end]))\n            results.extend(schedule)\n        for line in results:\n            print(line[0], *line[1:])\n        results.clear()\n        print()\n\ndef count_similar_permutations(t):\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        idx = sorted(range(n), key=lambda x: a[x])\n        k = 1\n        r = max(idx) + 1\n        for i, j in zip(idx, idx[1:]):\n            if n < j < r:\n                k = k * (r - n - i + 1) % MOD\n            n = min(n, i)\n            r = max(r, j)\n        print(k)\n\ndef minimize_inconvenience(t):\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        ans = 0\n        A = [(a[i], i) for i in range(n*m)]\n        A.sort()\n        colnum = {}\n        colnumcnt = {}\n        numcol = {}\n        q = [[] for _ in range(n)]\n        for _, i in A:\n            row = i // m\n            col = i % m\n            if col not in colnum:\n                colnum[col] = q[row].index(min(q[row])) + 1\n                colnumcnt[col] = 0\n                numcol[colnum[col]] = col\n            else:\n                colnumcnt[col] += 1\n                colnum[col] += colnumcnt[col]\n            q[row][col] = 1\n            ans += colnum[col]\n        print(ans)\n\ndef maximize_profit():\n    def dp_buy(n, m, k):\n        dp = [[[-1] * (k + 1) for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j][0] = 0\n                else:\n                    for l in range(k + 1):\n                        if l > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1] - ai[j][0])\n                        if i > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j][l] - ci[i - 1][j][0])\n                        if j > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j - 1][l] - bi[j - 1][0])\n        return dp[n - 1][m - 1][k]\n\n    def dp_sell(n, m, k):\n        dp = [[[-1] * (k + 1) for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j][0] = 0\n                else:\n                    for l in range(k + 1):\n                        if l > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1] + bi[j][0])\n                        if i > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j][l] + ci[i - 1][j][0])\n                        if j > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j - 1][l] + ai[j - 1][0])\n        return dp[n - 1][m - 1][k]\n\n    t = int(input())\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ai = []\n        bi = []\n        ci = []\n        for _ in range(n):\n            name = input().strip()\n            temp_ai = []\n            temp_bi = []\n            temp_ci = []\n            for _ in range(m):\n                aij, bij, cij = map(int, input().split())\n                temp_ai.append(aij)\n                temp_bi.append(bij)\n                temp_ci.append(cij)\n            ai.append(temp_ai)\n            bi.append(temp_bi)\n            ci.append(temp_ci)\n        profit = dp_buy(n, m, k) + dp_sell(n, m, k)\n        print(profit)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ai = []\n        bi = []\n        ci = []\n        for _ in range(n):\n            name = input().strip()\n            temp_ai = []\n            temp_bi = []\n            temp_ci = []\n            for _ in range(m):\n                aij, bij, cij = map(int, input().split())\n                temp_ai.append(aij)\n                temp_bi.append(bij)\n                temp_ci.append(cij)\n            ai.append(temp_ai)\n            bi.append(temp_bi)\n            ci.append(temp_ci)\n        profit = dp_buy(n, m, k) + dp_sell(n, m, k)\n        print(profit)\n\n\n"], "responses": ["```python\nimport math\nMOD = 10**9 + 7\n\ndef generate_hat_schedule(t):\n    results = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ceil_group_size = math.ceil(n / m)\n        floor_group_size = math.floor(n / m)\n        players = list(range(1, n + 1))\n        for _ in range(k):\n            group_indices = [i // floor_group_size for i in range(n)]\n            count = [group_indices.count(i) for i in range(m)]\n            extra_count = len(players) - sum(count)\n            for i in range(extra_count):\n                count[i % m] += 1\n            schedule = []\n            for i in range(m):\n                start = sum(count[:i])\n                end = start + count[i]\n                schedule.append((count[i], *players[start:end]))\n            results.extend(schedule)\n        for line in results:\n            print(line[0], *line[1:])\n        results.clear()\n        print()\n\ndef count_similar_permutations(t):\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        idx = sorted(range(n), key=lambda x: a[x])\n        k = 1\n        r = max(idx) + 1\n        for i, j in zip(idx, idx[1:]):\n            if n < j < r:\n                k = k * (r - n - i + 1) % MOD\n            n = min(n, i)\n            r = max(r, j)\n        print(k)\n\ndef minimize_inconvenience(t):\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        ans = 0\n        A = [(a[i], i) for i in range(n*m)]\n        A.sort()\n        colnum = {}\n        colnumcnt = {}\n        numcol = {}\n        q = [[] for _ in range(n)]\n        for _, i in A:\n            row = i // m\n            col = i % m\n            if col not in colnum:\n                colnum[col] = q[row].index(min(q[row])) + 1\n                colnumcnt[col] = 0\n                numcol[colnum[col]] = col\n            else:\n                colnumcnt[col] += 1\n                colnum[col] += colnumcnt[col]\n            q[row][col] = 1\n            ans += colnum[col]\n        print(ans)\n\ndef maximize_profit():\n    def dp_buy(n, m, k):\n        dp = [[[-1] * (k + 1) for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j][0] = 0\n                else:\n                    for l in range(k + 1):\n                        if l > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1] - ai[j][0])\n                        if i > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j][l] - ci[i - 1][j][0])\n                        if j > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j - 1][l] - bi[j - 1][0])\n        return dp[n - 1][m - 1][k]\n\n    def dp_sell(n, m, k):\n        dp = [[[-1] * (k + 1) for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j][0] = 0\n                else:\n                    for l in range(k + 1):\n                        if l > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1] + bi[j][0])\n                        if i > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j][l] + ci[i - 1][j][0])\n                        if j > 0:\n                            dp[i][j][l] = max(dp[i][j][l], dp[i][j - 1][l] + ai[j - 1][0])\n        return dp[n - 1][m - 1][k]\n\n    t = int(input())\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ai = []\n        bi = []\n        ci = []\n        for _ in range(n):\n            name = input().strip()\n            temp_ai = []\n            temp_bi = []\n            temp_ci = []\n            for _ in range(m):\n                aij, bij, cij = map(int, input().split())\n                temp_ai.append(aij)\n                temp_bi.append(bij)\n                temp_ci.append(cij)\n            ai.append(temp_ai)\n            bi.append(temp_bi)\n            ci.append(temp_ci)\n        profit = dp_buy(n, m, k) + dp_sell(n, m, k)\n        print(profit)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        ai = []\n        bi = []\n        ci = []\n        for _ in range(n):\n            name = input().strip()\n            temp_ai = []\n            temp_bi = []\n            temp_ci = []\n            for _ in range(m):\n                aij, bij, cij = map(int, input().split())\n                temp_ai.append(aij)\n                temp_bi.append(bij)\n                temp_ci.append(cij)\n            ai.append(temp_ai)\n            bi.append(temp_bi)\n            ci.append(temp_ci)\n        profit = dp_buy(n, m, k) + dp_sell(n, m, k)\n        print(profit)\n```"], "prompt_tokens": [7171], "completion_tokens": [2948], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "7419c4268a9815282fadca6581f28ec1"}
{"description": "Several ages ago Berland was a kingdom. The King of Berland adored math. That's why, when he first visited one of his many palaces, he first of all paid attention to the floor in one hall. The floor was tiled with hexagonal tiles.The hall also turned out hexagonal in its shape. The King walked along the perimeter of the hall and concluded that each of the six sides has a, b, c, a, b and c adjacent tiles, correspondingly.To better visualize the situation, look at the picture showing a similar hexagon for a\u2009=\u20092, b\u2009=\u20093 and c\u2009=\u20094.  According to the legend, as the King of Berland obtained the values a, b and c, he almost immediately calculated the total number of tiles on the hall floor. Can you do the same?", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains three integers: a, b and c (2\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20091000).", "output_spec": "Print a single number \u2014 the total number of tiles on the hall floor.", "notes": null, "sample_inputs": ["2 3 4"], "sample_outputs": ["18"], "tags": ["math", "implementation"], "src_uid": "8ab25ed4955d978fe20f6872cb94b0da", "difficulty": 1200, "source_codes": ["\ndef count_tiles(a, b, c):\n    return 2 * (a + b + c)\n\n# Reading input\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    results.append(count_tiles(a, b, c))\n\n# Printing results\nfor result in results:\n    print(result)\n\n\n"], "responses": ["```python\ndef count_tiles(a, b, c):\n    return 2 * (a + b + c)\n\n# Reading input\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    results.append(count_tiles(a, b, c))\n\n# Printing results\nfor result in results:\n    print(result)\n```"], "prompt_tokens": [5075], "completion_tokens": [609], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "8ab25ed4955d978fe20f6872cb94b0da"}
{"description": "Polycarpus is an amateur businessman. Recently he was surprised to find out that the market for paper scissors is completely free! Without further ado, Polycarpus decided to start producing and selling such scissors.Polycaprus calculated that the optimal celling price for such scissors would be p bourles. However, he read somewhere that customers are attracted by prices that say something like \"Special Offer! Super price 999 bourles!\". So Polycarpus decided to lower the price a little if it leads to the desired effect.Polycarpus agrees to lower the price by no more than d bourles so that the number of nines at the end of the resulting price is maximum. If there are several ways to do it, he chooses the maximum possible price.Note, Polycarpus counts only the trailing nines in a price.", "input_from": "standard input", "output_to": "standard output", "time_limit": "1 second", "memory_limit": "256 megabytes", "input_spec": "The first line contains two integers p and d (1\u2009\u2264\u2009p\u2009\u2264\u20091018; 0\u2009\u2264\u2009d\u2009&lt;\u2009p) \u2014 the initial price of scissors and the maximum possible price reduction. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.", "output_spec": "Print the required price \u2014 the maximum price that ends with the largest number of nines and that is less than p by no more than d. The required number shouldn't have leading zeroes.", "notes": null, "sample_inputs": ["1029 102", "27191 17"], "sample_outputs": ["999", "27189"], "tags": ["implementation"], "src_uid": "c706cfcd4c37fbc1b1631aeeb2c02b6a", "difficulty": 1400, "source_codes": ["\ndef fair_schedule(n, m, k):\n    base_size = n // m\n    extra_players = n % m\n    schedule = []\n    players = list(range(1, n + 1))\n    for _ in range(k):\n        current_table = []\n        for i in range(m):\n            if extra_players > 0:\n                current_table.append(base_size + 1)\n                extra_players -= 1\n            else:\n                current_table.append(base_size)\n        for player in players:\n            current_table.append(player)\n        import random\n        random.shuffle(current_table)\n        schedule.extend(current_table)\n    return schedule\n\ndef count_similar_permutations(a):\n    from itertools import combinations\n    from collections import Counter\n    n = len(a)\n    MOD = 10**9 + 7\n    def mex(subarr):\n        seen = set(subarr)\n        x = 0\n        while x in seen:\n            x += 1\n        return x\n    mex_counts = [Counter() for _ in range(n)]\n    for l in range(n):\n        current_mex = 0\n        for r in range(l, n):\n            current_mex |= (1 << a[r])\n            mex_counts[r].update({current_mex: 1})\n    result = 1\n    for v in mex_counts[-1].values():\n        result *= v\n        result %= MOD\n    return result\n\ndef minimize_inconvenience(n, m, A):\n    MOD = 10**9 + 7\n    A.sort()\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    for i, a in enumerate(A):\n        if a not in colnum:\n            colnum[a] = []\n            colnumcnt[a] = 0\n            numcol[i] = a\n    for i, a in enumerate(A):\n        colnum[a].append(i)\n    q = [set() for _ in range(m)]\n    ans = 0\n    for a in A:\n        temp = [i for i in colnum[a]]\n        for i in temp:\n            while q[i]:\n                ans += len(q[i])\n            colnumcnt[a] += 1\n            colnum[a].remove(i)\n            q[i].add(colnumcnt[a])\n    return ans\n\ndef maximize_trailing_nines(p, d):\n    p_str = str(p)\n    d = int(d)\n    while d > 0 and p_str[-1] == '9':\n        p_str = str(int(p_str) - 1)\n        d -= 1\n    return int(p_str)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        if n == m:\n            schedule = [list(range(1, n + 1)) for _ in range(k)]\n        else:\n            schedule = fair_schedule(n, m, k)\n        if n == 1:\n            similar_permutations = 1\n        else:\n            similar_permutations = count_similar_permutations([i for i in range(n)])\n        inconvenience = minimize_inconvenience(n, m, [int(data[index + i]) for i in range(n * m)])\n        index += n * m\n        max_nines_price = maximize_trailing_nines(int(data[index]), int(data[index + 1]))\n        index += 2\n        results.append(schedule)\n        results.append(similar_permutations)\n        results.append(inconvenience)\n        results.append(max_nines_price)\n    for result in results:\n        if isinstance(result, list):\n            print(\" \".join(map(str, result)))\n        else:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n\n"], "responses": ["```python\ndef fair_schedule(n, m, k):\n    base_size = n // m\n    extra_players = n % m\n    schedule = []\n    players = list(range(1, n + 1))\n    for _ in range(k):\n        current_table = []\n        for i in range(m):\n            if extra_players > 0:\n                current_table.append(base_size + 1)\n                extra_players -= 1\n            else:\n                current_table.append(base_size)\n        for player in players:\n            current_table.append(player)\n        import random\n        random.shuffle(current_table)\n        schedule.extend(current_table)\n    return schedule\n\ndef count_similar_permutations(a):\n    from itertools import combinations\n    from collections import Counter\n    n = len(a)\n    MOD = 10**9 + 7\n    def mex(subarr):\n        seen = set(subarr)\n        x = 0\n        while x in seen:\n            x += 1\n        return x\n    mex_counts = [Counter() for _ in range(n)]\n    for l in range(n):\n        current_mex = 0\n        for r in range(l, n):\n            current_mex |= (1 << a[r])\n            mex_counts[r].update({current_mex: 1})\n    result = 1\n    for v in mex_counts[-1].values():\n        result *= v\n        result %= MOD\n    return result\n\ndef minimize_inconvenience(n, m, A):\n    MOD = 10**9 + 7\n    A.sort()\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    for i, a in enumerate(A):\n        if a not in colnum:\n            colnum[a] = []\n            colnumcnt[a] = 0\n            numcol[i] = a\n    for i, a in enumerate(A):\n        colnum[a].append(i)\n    q = [set() for _ in range(m)]\n    ans = 0\n    for a in A:\n        temp = [i for i in colnum[a]]\n        for i in temp:\n            while q[i]:\n                ans += len(q[i])\n            colnumcnt[a] += 1\n            colnum[a].remove(i)\n            q[i].add(colnumcnt[a])\n    return ans\n\ndef maximize_trailing_nines(p, d):\n    p_str = str(p)\n    d = int(d)\n    while d > 0 and p_str[-1] == '9':\n        p_str = str(int(p_str) - 1)\n        d -= 1\n    return int(p_str)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        if n == m:\n            schedule = [list(range(1, n + 1)) for _ in range(k)]\n        else:\n            schedule = fair_schedule(n, m, k)\n        if n == 1:\n            similar_permutations = 1\n        else:\n            similar_permutations = count_similar_permutations([i for i in range(n)])\n        inconvenience = minimize_inconvenience(n, m, [int(data[index + i]) for i in range(n * m)])\n        index += n * m\n        max_nines_price = maximize_trailing_nines(int(data[index]), int(data[index + 1]))\n        index += 2\n        results.append(schedule)\n        results.append(similar_permutations)\n        results.append(inconvenience)\n        results.append(max_nines_price)\n    for result in results:\n        if isinstance(result, list):\n            print(\" \".join(map(str, result)))\n        else:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"], "prompt_tokens": [6281], "completion_tokens": [2379], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "c706cfcd4c37fbc1b1631aeeb2c02b6a"}
{"description": "The Little Elephant is playing with the Cartesian coordinates' system. Most of all he likes playing with integer points. The Little Elephant defines an integer point as a pair of integers (x;\u00a0y), such that 0\u2009\u2264\u2009x\u2009\u2264\u2009w and 0\u2009\u2264\u2009y\u2009\u2264\u2009h. Thus, the Little Elephant knows only (w\u2009+\u20091)\u00b7(h\u2009+\u20091) distinct integer points.The Little Elephant wants to paint a triangle with vertexes at integer points, the triangle's area must be a positive integer. For that, he needs to find the number of groups of three points that form such triangle. At that, the order of points in a group matters, that is, the group of three points (0;0), (0;2), (2;2) isn't equal to the group (0;2), (0;0), (2;2).Help the Little Elephant to find the number of groups of three integer points that form a nondegenerate triangle with integer area.", "input_from": "standard input", "output_to": "standard output", "time_limit": "3 seconds", "memory_limit": "256 megabytes", "input_spec": "A single line contains two integers w and h (1\u2009\u2264\u2009w,\u2009h\u2009\u2264\u20094000).", "output_spec": "In a single output line print an integer \u2014 the remainder of dividing the answer to the problem by 1000000007 (109\u2009+\u20097).", "notes": null, "sample_inputs": ["2 1", "2 2"], "sample_outputs": ["36", "240"], "tags": ["geometry", "math"], "src_uid": "984788e4b4925c15c9c6f31e42f2f8fa", "difficulty": 2500, "source_codes": ["\nMOD = 1000000007\n\ndef count_non_degenerate_triangles(w, h):\n    n = (w + 1) * (h + 1)\n    total_combinations = (n * (n - 1) * (n - 2)) // 6\n    valid_triangles = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                x1, y1 = divmod(i, w + 1)\n                x2, y2 = divmod(j, w + 1)\n                x3, y3 = divmod(k, w + 1)\n                \n                det = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n                if det % 2 == 0:\n                    valid_triangles += 1\n    \n    return (valid_triangles * 6) % MOD\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        result = count_non_degenerate_triangles(w, h)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n\n"], "responses": ["```python\nMOD = 1000000007\n\ndef count_non_degenerate_triangles(w, h):\n    n = (w + 1) * (h + 1)\n    total_combinations = (n * (n - 1) * (n - 2)) // 6\n    valid_triangles = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                x1, y1 = divmod(i, w + 1)\n                x2, y2 = divmod(j, w + 1)\n                x3, y3 = divmod(k, w + 1)\n                \n                det = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n                if det % 2 == 0:\n                    valid_triangles += 1\n    \n    return (valid_triangles * 6) % MOD\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        result = count_non_degenerate_triangles(w, h)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n```"], "prompt_tokens": [5660], "completion_tokens": [1296], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "984788e4b4925c15c9c6f31e42f2f8fa"}
{"description": "Polycarpus loves lucky numbers. Everybody knows that lucky numbers are positive integers, whose decimal representation (without leading zeroes) contain only the lucky digits x and y. For example, if x\u2009=\u20094, and y\u2009=\u20097, then numbers 47, 744, 4 are lucky.Let's call a positive integer a undoubtedly lucky, if there are such digits x and y (0\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20099), that the decimal representation of number a (without leading zeroes) contains only digits x and y.Polycarpus has integer n. He wants to know how many positive integers that do not exceed n, are undoubtedly lucky. Help him, count this number.", "input_from": "standard input", "output_to": "standard output", "time_limit": "2 seconds", "memory_limit": "256 megabytes", "input_spec": "The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 Polycarpus's number.", "output_spec": "Print a single integer that says, how many positive integers that do not exceed n are undoubtedly lucky.", "notes": "NoteIn the first test sample all numbers that do not exceed 10 are undoubtedly lucky.In the second sample numbers 102, 103, 104, 105, 106, 107, 108, 109, 120, 123 are not undoubtedly lucky.", "sample_inputs": ["10", "123"], "sample_outputs": ["10", "113"], "tags": ["brute force", "bitmasks", "dfs and similar"], "src_uid": "0f7f10557602c8c2f2eb80762709ffc4", "difficulty": 1600, "source_codes": ["\n# Problem 1: Hat Game Schedule\ndef hat_game_schedule(n, m, k):\n    g = n // m\n    h = g + 1\n    players = list(range(1, n + 1))\n    result = []\n    z = 0\n    \n    while len(players) > 0:\n        for _ in range(k):\n            group = []\n            if len(players) >= h:\n                group.extend(players[:h])\n                players = players[h:]\n            else:\n                group.extend(players)\n                players = []\n            result.append(group)\n    \n    return result\n\n# Problem 2: Count Similar Permutations\nMOD = 10**9 + 7\ndef count_similar_permutations(n, a):\n    a.sort()\n    k = 1\n    r = 0\n    n_min = n_max = a[0]\n    \n    for i in range(1, n):\n        if n < a[i] < r:\n            k = (k * (r - n - i + 1)) % MOD\n        n_min = min(n_min, a[i])\n        r = max(r, a[i])\n    \n    return k\n\n# Problem 3: Minimize Total Inconvenience\ndef minimize_inconvenience(n, m, A):\n    ans = 0\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i in range(len(A)):\n        colnum[i] = (A[i], (i // m) + 1)\n        colnumcnt[A[i]] = colnumcnt.get(A[i], 0) + 1\n        numcol.setdefault((i // m) + 1, set()).add(A[i])\n    \n    q = [[] for _ in range(m)]\n    \n    for v in sorted(colnum.keys()):\n        temp = numcol[colnum[v][1]]\n        for i in range(n):\n            if colnum[i][0] == v:\n                while q[(i // m)].count(v):\n                    q[(i // m)].remove(v)\n                q[(i // m)].append(v)\n                if q[(i // m)].count(v):\n                    ans += len(q[(i // m)]) - q[(i // m)].index(v) - 1\n                break\n    \n    return ans\n\n# Problem 4: Count Unquestionably Lucky Numbers\ndef count_unquestionably_lucky_numbers(n, x, y):\n    dp = [[0] * 2 for _ in range(10)]\n    dp[0][0] = 1\n    \n    for digit in str(n):\n        ndp = [[0] * 2 for _ in range(10)]\n        for d in range(10):\n            if d == int(digit):\n                for i in range(2):\n                    ndp[d][i] = (ndp[d][i] + dp[d][i]) % MOD\n                    ndp[x][i] = (ndp[x][i] + dp[d][i]) % MOD\n            elif d == x:\n                for i in range(2):\n                    ndp[x][i] = (ndp[x][i] + dp[d][i]) % MOD\n                    ndp[y][i] = (ndp[y][i] + dp[d][i]) % MOD\n            elif d == y:\n                for i in range(2):\n                    ndp[y][i] = (ndp[y][i] + dp[d][i]) % MOD\n        \n        dp = ndp\n    \n    return (dp[0][0] + dp[x][0] + dp[y][0]) % MOD\n\n# Reading Input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    if n <= 2 * m:\n        results.append(hat_game_schedule(n, m, k))\n    elif n <= 2 * m:\n        results.append(count_similar_permutations(n, data[index:index + n]))\n        index += n\n    elif n <= 2 * m:\n        results.append(minimize_inconvenience(n, m, list(map(int, data[index:index + n * m]))))\n        index += n * m\n    elif n <= 2 * m:\n        x = int(data[index])\n        y = int(data[index + 1])\n        results.append(count_unquestionably_lucky_numbers(n, x, y))\n        index += 2\n\n# Printing Results\nfor result in results:\n    if isinstance(result, list):\n        for game in result:\n            print(\" \".join(map(str, game)))\n        print()\n    else:\n        print(result)\n\n\n"], "responses": ["```python\n# Problem 1: Hat Game Schedule\ndef hat_game_schedule(n, m, k):\n    g = n // m\n    h = g + 1\n    players = list(range(1, n + 1))\n    result = []\n    z = 0\n    \n    while len(players) > 0:\n        for _ in range(k):\n            group = []\n            if len(players) >= h:\n                group.extend(players[:h])\n                players = players[h:]\n            else:\n                group.extend(players)\n                players = []\n            result.append(group)\n    \n    return result\n\n# Problem 2: Count Similar Permutations\nMOD = 10**9 + 7\ndef count_similar_permutations(n, a):\n    a.sort()\n    k = 1\n    r = 0\n    n_min = n_max = a[0]\n    \n    for i in range(1, n):\n        if n < a[i] < r:\n            k = (k * (r - n - i + 1)) % MOD\n        n_min = min(n_min, a[i])\n        r = max(r, a[i])\n    \n    return k\n\n# Problem 3: Minimize Total Inconvenience\ndef minimize_inconvenience(n, m, A):\n    ans = 0\n    colnum = {}\n    colnumcnt = {}\n    numcol = {}\n    \n    for i in range(len(A)):\n        colnum[i] = (A[i], (i // m) + 1)\n        colnumcnt[A[i]] = colnumcnt.get(A[i], 0) + 1\n        numcol.setdefault((i // m) + 1, set()).add(A[i])\n    \n    q = [[] for _ in range(m)]\n    \n    for v in sorted(colnum.keys()):\n        temp = numcol[colnum[v][1]]\n        for i in range(n):\n            if colnum[i][0] == v:\n                while q[(i // m)].count(v):\n                    q[(i // m)].remove(v)\n                q[(i // m)].append(v)\n                if q[(i // m)].count(v):\n                    ans += len(q[(i // m)]) - q[(i // m)].index(v) - 1\n                break\n    \n    return ans\n\n# Problem 4: Count Unquestionably Lucky Numbers\ndef count_unquestionably_lucky_numbers(n, x, y):\n    dp = [[0] * 2 for _ in range(10)]\n    dp[0][0] = 1\n    \n    for digit in str(n):\n        ndp = [[0] * 2 for _ in range(10)]\n        for d in range(10):\n            if d == int(digit):\n                for i in range(2):\n                    ndp[d][i] = (ndp[d][i] + dp[d][i]) % MOD\n                    ndp[x][i] = (ndp[x][i] + dp[d][i]) % MOD\n            elif d == x:\n                for i in range(2):\n                    ndp[x][i] = (ndp[x][i] + dp[d][i]) % MOD\n                    ndp[y][i] = (ndp[y][i] + dp[d][i]) % MOD\n            elif d == y:\n                for i in range(2):\n                    ndp[y][i] = (ndp[y][i] + dp[d][i]) % MOD\n        \n        dp = ndp\n    \n    return (dp[0][0] + dp[x][0] + dp[y][0]) % MOD\n\n# Reading Input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    if n <= 2 * m:\n        results.append(hat_game_schedule(n, m, k))\n    elif n <= 2 * m:\n        results.append(count_similar_permutations(n, data[index:index + n]))\n        index += n\n    elif n <= 2 * m:\n        results.append(minimize_inconvenience(n, m, list(map(int, data[index:index + n * m]))))\n        index += n * m\n    elif n <= 2 * m:\n        x = int(data[index])\n        y = int(data[index + 1])\n        results.append(count_unquestionably_lucky_numbers(n, x, y))\n        index += 2\n\n# Printing Results\nfor result in results:\n    if isinstance(result, list):\n        for game in result:\n            print(\" \".join(map(str, game)))\n        print()\n    else:\n        print(result)\n```"], "prompt_tokens": [6377], "completion_tokens": [2728], "no_of_try": 1, "is_solved": false, "language": "Python3", "task_id": "0f7f10557602c8c2f2eb80762709ffc4"}
